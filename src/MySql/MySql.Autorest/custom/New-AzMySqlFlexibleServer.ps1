
# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Code generated by Microsoft (R) AutoRest Code Generator.Changes may cause incorrect behavior and will be lost if the code
# is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Creates a new server or updates an existing server.
The update action will overwrite the existing server.
.Description
Creates a new server or updates an existing server.
The update action will overwrite the existing server.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.MySql.Models.IMySqlIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.MySql.Models.IServerAutoGenerated
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IMySqlIdentity>: Identity Parameter
  [AdvancedThreatProtectionName <String>]: The name of the Advanced Threat Protection state.
  [BackupName <String>]: The name of the backup.
  [ConfigurationName <String>]: The name of the server configuration.
  [DatabaseName <String>]: The name of the database.
  [FirewallRuleName <String>]: The name of the server firewall rule.
  [Id <String>]: Resource identity path
  [LocationName <String>]: The name of the location.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SecurityAlertPolicyName <String>]: The name of the security alert policy.
  [ServerName <String>]: The name of the server.
  [SubscriptionId <String>]: The ID of the target subscription.
  [VirtualNetworkRuleName <String>]: The name of the virtual network rule.
.Link
https://learn.microsoft.com/powershell/module/az.mysql/new-azmysqlflexibleserver
#>

$DEFAULT_DB_NAME = 'flexibleserverdb'
$DELEGATION_SERVICE_NAME = "Microsoft.DBforMySQL/flexibleServers"
$DEFAULT_VNET_PREFIX = '10.0.0.0/16'
$DEFAULT_SUBNET_PREFIX = '10.0.0.0/24'
$AZURE_ARMNAME = '^[^<>%&:\\?/]{1,260}$'

function New-AzMySqlFlexibleServer {
    [OutputType([Microsoft.Azure.PowerShell.Cmdlets.MySql.Models.IServerAutoGenerated])]
    [CmdletBinding(DefaultParameterSetName = 'CreateExpanded', PositionalBinding = $false, SupportsShouldProcess, ConfirmImpact = 'Medium')]
    param(
        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaJsonFilePath')]
        [Parameter(ParameterSetName = 'CreateViaJsonString')]
        [Alias('ServerName')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Path')]
        [System.String]
        # The name of the server.
        ${Name},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaJsonFilePath')]
        [Parameter(ParameterSetName = 'CreateViaJsonString')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Path')]
        [System.String]
        # The name of the resource group.
        # The name is case insensitive.
        ${ResourceGroupName},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaJsonFilePath')]
        [Parameter(ParameterSetName = 'CreateViaJsonString')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Runtime.DefaultInfo(Script = '(Get-AzContext).Subscription.Id')]
        [System.String]
        # The ID of the target subscription.
        ${SubscriptionId},

        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded', ValueFromPipeline)]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Models.IMySqlIdentity]
        # Identity Parameter
        ${InputObject},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # The geo-location where the resource lives
        ${Location},

        [Parameter(ParameterSetName = 'CreateExpanded', HelpMessage = 'Administrator username for the server. Once set, it cannot be changed.')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded', HelpMessage = 'Administrator username for the server. Once set, it cannot be changed.')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # The administrator's login name of a server.
        # Can only be specified when the server is being created (and is required for creation).
        ${AdministratorUserName},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.Security.SecureString]
        # The password of the administrator login (required for server creation).
        ${AdministratorLoginPassword},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # availability Zone information of the server.
        ${Zone},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.PSArgumentCompleterAttribute("Enabled", "Disabled")]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # Whether or not geo redundant backup is enabled.
        ${BackupGeoRedundantBackup},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.Int32]
        # Backup retention days for the server.
        ${BackupRetentionDay},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.PSArgumentCompleterAttribute("Default", "PointInTimeRestore", "GeoRestore", "Replica")]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # The mode to create a new MySQL server.
        ${CreateMode},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # Geo backup key uri as key vault can't cross region, need cmk in same region as geo backup
        ${DataEncryptionGeoBackupKeyUri},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # Geo backup user identity resource id as identity can't cross region, need identity in same region as geo backup
        ${DataEncryptionGeoBackupUserAssignedIdentityId},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # Primary key uri
        ${DataEncryptionPrimaryKeyUri},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # Primary user identity resource id
        ${DataEncryptionPrimaryUserAssignedIdentityId},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.PSArgumentCompleterAttribute("AzureKeyVault", "SystemManaged")]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # The key type, AzureKeyVault for enable cmk, SystemManaged for disable cmk.
        ${DataEncryptionType},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.PSArgumentCompleterAttribute("UserAssigned")]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # Type of managed service identity.
        ${IdentityType},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.PSArgumentCompleterAttribute("None", "Source", "Replica")]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # The replication role.
        ${ReplicationRole},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.DateTime]
        # Restore point creation time (ISO8601 format), specifying the time to restore from.
        ${RestorePointInTime},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # The name of the sku, e.g.
        # Standard_D32s_v3.
        ${Sku},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.PSArgumentCompleterAttribute("Basic", "GeneralPurpose", "MemoryOptimized", "Burstable")]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # The tier of the particular SKU, e.g.
        # GeneralPurpose.
        ${SkuTier},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # The source MySQL server id.
        ${SourceServerResourceId},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.PSArgumentCompleterAttribute("Enabled", "Disabled")]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # Enable Storage Auto Grow or not.
        ${StorageAutoGrow},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.Int32]
        # Storage IOPS for a server.
        ${Iops},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.Int32]
        # Max storage size allowed for a server.
        ${StorageInMb},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Runtime.Info(PossibleTypes = ([Microsoft.Azure.PowerShell.Cmdlets.MySql.Models.ITrackedResourceTags]))]
        [System.Collections.Hashtable]
        # Resource tags.
        ${Tag},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [AllowEmptyCollection()]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String[]]
        # The array of user assigned identities associated with the resource.
        # The elements in array will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.'
        ${UserAssignedIdentity},

        [Parameter(ParameterSetName = 'CreateExpanded')]
        [Parameter(ParameterSetName = 'CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.PSArgumentCompleterAttribute("5.6", "5.7", "8.0", "8.0.21")]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # Server version.
        ${Version},

        [Parameter(ParameterSetName = 'CreateViaJsonFilePath')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # Path of Json file supplied to the Create operation
        ${JsonFilePath},

        [Parameter(ParameterSetName = 'CreateViaJsonString')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Body')]
        [System.String]
        # Json string supplied to the Create operation
        ${JsonString},

        [Parameter(HelpMessage = 'The subnet IP address prefix to use when creating a new vnet in CIDR format. Default value is 10.0.0.0/24.')]
        [System.String]
        ${SubnetPrefix},
    
        [Parameter(HelpMessage = 'The Name or Id of an existing Subnet or name of a new one to create. Use resource ID if you want to use a subnet from different resource group. Please note that the subnet will be delegated to Microsoft.DBforMySQL/flexibleServers. After delegation, this subnet cannot be used for any other type of Azure resources.')]
        [System.String]
        ${Subnet},
    
        [Parameter(HelpMessage = 'The IP address prefix to use when creating a new vnet in CIDR format. Default value is 10.0.0.0/16.')]
        [System.String]
        ${VnetPrefix},
    
        [Parameter(HelpMessage = 'The Name or Id of an existing virtual network or name of a new one to create. The name must be between 2 to 64 characters. The name must begin with a letter or number, end with a letter, number or underscore, and may contain only letters, numbers, underscores, periods, or hyphens.')]
        [System.String]
        ${Vnet},
    
        [Parameter(HelpMessage = 'The id of an existing private dns zone. The suffix of dns zone has to be same as that of fully qualified domain of the server.')]
        [System.String]
        ${PrivateDnsZone},
    
        [Parameter(HelpMessage = "Determines the public access. Allowed values: All, None, IP address range (e.g., 1.1.1.1-1.1.1.5, 1.1.1.1) Specifying 0.0.0.0 allows public access from any resources deployed within Azure to access your server. Specifying no IP address sets the server in public access mode but does not create a firewall rule.")]
        [System.String]
        ${PublicAccess},
    
        [Parameter(HelpMessage = "Enable or disable high availability feature. Allowed values are 'ZoneRedundant', 'SameZone', and 'Disabled'. Default value is Disabled.")]
        [Validateset('ZoneRedundant', 'SameZone', 'Disabled')]
        [Alias('HaEnabled')]
        [System.String]
        ${HighAvailability},

        [Parameter()]
        [Alias('AzureRMContext', 'AzureCredential')]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Azure')]
        [System.Management.Automation.PSObject]
        # The DefaultProfile parameter is not functional.
        # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
        ${DefaultProfile},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Run the command as a job
        ${AsJob},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Wait for .NET debugger to attach
        ${Break},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be appended to the front of the pipeline
        ${HttpPipelineAppend},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be prepended to the front of the pipeline
        ${HttpPipelinePrepend},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Run the command asynchronously
        ${NoWait},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Runtime')]
        [System.Uri]
        # The URI for the proxy server to use
        ${Proxy},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Runtime')]
        [System.Management.Automation.PSCredential]
        # Credentials for a proxy server to use for the remote call
        ${ProxyCredential},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.MySql.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Use the default credentials for the proxy
        ${ProxyUseDefaultCredentials}
    )

    process {
        try {
            if (!$PSBoundParameters.ContainsKey('Location')) {
                $PSBoundParameters.Location = 'westus2'
            }

            if (!$PSBoundParameters.ContainsKey('AdministratorLoginPassword')) {
                $Password = Get-GeneratePassword
                $PSBoundParameters.AdministratorLoginPassword = $Password | ConvertTo-SecureString -AsPlainText -Force
            }

            Import-Module -Name Az.Resources

            if (!$PSBoundParameters.ContainsKey('ResourceGroupName')) {
                $PSBoundParameters.ResourceGroupName = Get-RandomNumbers -Prefix 'group' -Length 10
                $Msg = "Creating Resource Group {0}..." -f $PSBoundParameters.ResourceGroupName
                Write-Host $Msg
                if ($PSCmdlet.ShouldProcess($PSBoundParameters.ResourceGroupName)) {
                    $null = New-AzResourceGroup -Name $PSBoundParameters.ResourceGroupName -Location $PSBoundParameters.Location -Force
                }
            }
            else {
                $Msg = 'Checking the existence of the resource group {0} ...' -f $PSBoundParameters.ResourceGroupName
                Write-Host $Msg
                try {
                    $null = Get-AzResourceGroup -Name $PSBoundParameters.ResourceGroupName -ErrorAction Stop
                    $Msg = 'Resource group {0} exists ? : True' -f $PSBoundParameters.ResourceGroupName
                    Write-Host $Msg
                }
                catch {
                    $Msg = 'Resource group {0} exists ? : False' -f $PSBoundParameters.ResourceGroupName
                    Write-Host $Msg
                    $Msg = "Creating Resource Group {0}..." -f $PSBoundParameters.ResourceGroupName
                    Write-Host $Msg
                    if ($PSCmdlet.ShouldProcess($PSBoundParameters.ResourceGroupName)) {
                        $null = New-AzResourceGroup -Name $PSBoundParameters.ResourceGroupName -Location $PSBoundParameters.Location -Force
                    }

                }
            }

            if (!$PSBoundParameters.ContainsKey('Name')) {
                $PSBoundParameters.Name = Get-RandomNumbers -Prefix 'server' -Length 10
            }

            if (!$PSBoundParameters.ContainsKey('SkuTier')) {
                $PSBoundParameters.SkuTier = 'Burstable'
            }

            if (!$PSBoundParameters.ContainsKey('Sku')) {
                $PSBoundParameters.Sku = 'Standard_B1ms'
            }

            if (!$PSBoundParameters.ContainsKey('BackupRetentionDay')) {
                $PSBoundParameters.BackupRetentionDay = 7
            }

            if ($PSBoundParameters.ContainsKey('StorageInMb')) {
                $PSBoundParameters.StorageSizeGb = [Math]::floor($PSBoundParameters['StorageInMb'] / 1024)
                $null = $PSBoundParameters.Remove('StorageInMb')
            }
            else {
                $PSBoundParameters.StorageSizeGb = 32
            }

            if ($PSBoundParameters.ContainsKey('StorageAutoGrow') -And $PSBoundParameters['StorageAutoGrow'] -eq 'Enabled') {
                $PSBoundParameters.StorageAutoGrow = "Enabled"
            }
            else {
                $PSBoundParameters.StorageAutoGrow = "Disabled"
            }

            if ($PSBoundParameters.ContainsKey('HighAvailability')) {
                if ($PSBoundParameters['HighAvailability'].ToLower() -eq 'disabled') {
                    $PSBoundParameters["HighAvailabilityMode"] = "Disabled"
                }
                elseif ($PSBoundParameters['HighAvailability'].ToLower() -eq 'zoneredundant') {
                    if ($PSBoundParameters.SkuTier -eq 'Burstable') {
                        throw "Zone redundant high availability cannot be enabled for Burstable tier."
                    }
                    $PSBoundParameters["HighAvailabilityMode"] = "ZoneRedundant"
                    $PSBoundParameters.StorageAutoGrow = "Enabled"
                }
                elseif ($PSBoundParameters['HighAvailability'].ToLower() -eq 'samezone') {
                    $PSBoundParameters.HighAvailabilityMode = "SameZone"
                    $PSBoundParameters.StorageAutoGrow = "Enabled"
                }
                $null = $PSBoundParameters.Remove('HighAvailability')
            }

            if (!$PSBoundParameters.ContainsKey('Version')) {
                $PSBoundParameters.Version = '5.7'
            }

            if ($PSBoundParameters.ContainsKey('AdministratorUserName')) {
                $PSBoundParameters.AdministratorLogin = $PSBoundParameters['AdministratorUserName']
                $null = $PSBoundParameters.Remove('AdministratorUserName')
            }
            else {
                $PSBoundParameters.AdministratorLogin = Get-RandomName
            }

            $PSBoundParameters.CreateMode = "Default"

            # Handling Vnet & Subnet
            $NetworkKeys = 'PublicAccess', 'Subnet', 'Vnet', 'SubnetPrefix', 'VnetPrefix', 'PrivateDnsZone'
            $NetworkParameters = @{}
            foreach ($Key in $NetworkKeys) {
                if ($PSBoundParameters.ContainsKey($Key)) { 
                    $NetworkParameters[$Key] = $PSBoundParameters[$Key]
                    $null = $PSBoundParameters.Remove($Key)
                }
            }
            $RequiredKeys = 'SubscriptionId', 'ResourceGroupName', 'Name', 'Location'
            foreach ($Key in $RequiredKeys) { $NetworkParameters[$Key] = $PSBoundParameters[$Key] }

            if ($NetworkParameters.ContainsKey('Vnet') -Or $NetworkParameters.ContainsKey('Subnet')) {
                $VnetSubnetParameters = CreateNetworkResource $NetworkParameters
                $SubnetId = GetSubnetId $VnetSubnetParameters.ResourceGroupName $VnetSubnetParameters.VnetName $VnetSubnetParameters.SubnetName
                $VnetId = [string]::Join("/", $SubnetId.split("/")[0..8])
                $PSBoundParameters.NetworkDelegatedSubnetResourceId = $SubnetId
                if ([string]::IsNullOrEmpty($PSBoundParameters.NetworkDelegatedSubnetResourceId)) {
                    $null = $PSBoundParameters.Remove('NetworkDelegatedSubnetResourceId')
                }
                if ($NetworkParameters.ContainsKey('PrivateDnsZone')) {
                    if (!(Get-Module -ListAvailable -Name Az.PrivateDns)) {
                        throw 'Please install Az.Network module by entering "Install-Module -Name Az.PrivateDns"'
                    }
                    else {
                        Import-Module -Name Az.PrivateDns
                    }
                    $ZoneName = $NetworkParameters["PrivateDnsZone"].split("/")[-1]
                    $DnsResourceGroup = $NetworkParameters["PrivateDnsZone"].split("/")[4]
                    $Links = Get-AzPrivateDnsVirtualNetworkLink -ZoneName $ZoneName -ResourceGroupName $DnsResourceGroup
                    $LinkedFlag = $false
                    foreach ($Link in $Links) {
                        if ($Link.VirtualNetworkId -eq $VnetId) {
                            $LinkedFlag = $true
                            break
                        }
                    }
                    if (!$LinkedFlag) {
                        Write-Host "Adding virtual network link to the DNS zone..."
                        New-AzPrivateDnsVirtualNetworkLink -ZoneName $ZoneName -ResourceGroupName $DnsResourceGroup -Name $PSBoundParameters["Name"] -VirtualNetworkId $VnetId
                    }
                    $PSBoundParameters.NetworkPrivateDnsZoneResourceId = $NetworkParameters["PrivateDnsZone"]
                    $null = $PSBoundParameters.Remove('PrivateDnsZone')
                }
                else {
                    throw "To provision a server with private access, you need to provide private DNS zone."
                }
            }
            else {
                $RuleName, $StartIp, $EndIp = ParseFirewallRule $NetworkParameters.PublicAccess
            }

            $Msg = 'Creating MySQL server {0} in group {1}...' -f $PSBoundParameters.Name, $PSBoundParameters.resourceGroupName
            Write-Host $Msg
            $Msg = 'Your server {0} is using sku {1} (Paid Tier). Please refer to https://aka.ms/mysql-pricing for pricing details' -f $PSBoundParameters.Name, $PSBoundParameters.Sku
            Write-Host $Msg
            $Server = Az.MySql.internal\New-AzMySqlFlexibleServer @PSBoundParameters

            # # Create Database
            $DatabaseParameter = [Microsoft.Azure.PowerShell.Cmdlets.MySql.Models.Database]::new()
            $DatabaseParameter.Charset = "utf8"
            $DatabaseParameter.Collation = "utf8_general_ci"
            $Msg = 'Creating database {0}...' -f $DEFAULT_DB_NAME
            Write-Host $Msg
            $null = New-AzMySqlFlexibleServerDatabase -Name $DEFAULT_DB_NAME -ResourceGroupName $PSBoundParameters.ResourceGroupName -ServerName $PSBoundParameters.Name -Parameter $DatabaseParameter
        
            # Create Firewallrules
            if (![string]::IsNullOrEmpty($RuleName)) {
                $FirewallRuleName = CreateFirewallRule $RuleName $StartIp $EndIp $PSBoundParameters.ResourceGroupName $PSBoundParameters.Name
                $Server.FirewallRuleName = $FirewallRuleName
            }
            $Server.DatabaseName = $DEFAULT_DB_NAME
            $Server.SecuredPassword = $PSBoundParameters.AdministratorLoginPassword

            return $Server

        }
        catch {
            throw
        }
    }
}
function CreateNetworkResource($NetworkParameters) {
    [OutputType([hashtable])]
    $WarningPreference = 'silentlycontinue'
    
    if (!(Get-Module -ListAvailable -Name Az.Network)) {
        throw 'Please install Az.Network module by entering "Install-Module -Name Az.Network"'
    }
    else {
        Import-Module -Name Az.Network
    }

    # 1. Error Handling
    # Raise error when user passes values for both parameters
    if ($NetworkParameters.Containskey('Subnet') -And $NetworkParameters.ContainsKey('PublicAccess')) {
        throw "Incorrect usage : A combination of the parameters -Subnet and -PublicAccess is invalid. Use either one of them."
    }

    # # When address space parameters are passed, the only valid combination is : -Vnet -Subnet -VnetPrefix -SubnetPrefix
    if ($NetworkParameters.ContainsKey('Vnet') -Or $NetworkParameters.ContainsKey('Subnet')) {
        if (($NetworkParameters.ContainsKey('VnetPrefix') -And !$NetworkParameters.ContainsKey('SubnetPrefix')) -Or
            (!$NetworkParameters.ContainsKey('VnetPrefix') -And $NetworkParameters.ContainsKey('SubnetPrefix')) -Or 
            ($NetworkParameters.ContainsKey('VnetPrefix') -And $NetworkParameters.ContainsKey('SubnetPrefix') -And (!$NetworkParameters.ContainsKey('Vnet') -Or !$NetworkParameters.ContainsKey('Subnet')))) {
            throw "Incorrect usage : -Vnet -Subnet -VnetPrefix -SubnetPrefix must be supplied together."
        }
    }
    
    #Handle Vnet, Subnet scenario
    # Only the Subnet ID provided.. 
    if (!$NetworkParameters.ContainsKey('Vnet') -And $NetworkParameters.ContainsKey('Subnet')) {
        if (IsValidSubnetId $NetworkParameters.Subnet) {
            Write-Host "You have supplied a subnet Id. Verifying its existence..."
            $ParsedResult = ParseResourceId $NetworkParameters.Subnet 
            $NetworkParameters.VnetName = $ParsedResult.VnetName
            $NetworkParameters.SubnetName = $ParsedResult.SubnetName
            $NetworkParameters.ResourceGroupName = $ParsedResult.ResourceGroupName
            $SubnetFlag = $true
            try {
                # Valid Subnet ID is provided
                $Subnet = Get-AzVirtualNetworkSubnetConfig -ResourceId $NetworkParameters.Subnet -ErrorAction Stop
            }
            catch {
                # Invalid subnet ID is provided, creating a new one.
                $SubnetFlag = $false
                Write-Host "The subnet doesn't exist. Creating the subnet"
                $Subnet = CreateVnetSubnet $NetworkParameters
            }

            if ($SubnetFlag) {
                $Delegations = Get-AzDelegation -Subnet $Subnet
                if ($null -ne $Delegations) {
                    # Valid but incorrect delegation
                    $Delegations | ForEach-Object { if ($PSItem.ServiceName -ne $DELEGATION_SERVICE_NAME) {
                            $Msg = "Can not use subnet with existing delegations other than {0}" -f $DELEGATION_SERVICE_NAME
                            throw $Msg
                        } }
                }
                else {
                    # Valid but no delegation
                    $Vnet = Get-AzVirtualNetwork -ResourceGroupName $NetworkParameters.ResourceGroupName -Name $NetworkParameters.VnetName
                    $Subnet = Get-AzVirtualNetworkSubnetConfig -Name $NetworkParameters.SubnetName -VirtualNetwork $Vnet
                    $Subnet = Add-AzDelegation -Name $DELEGATION_SERVICE_NAME -ServiceName $DELEGATION_SERVICE_NAME -Subnet $Subnet
                    $Vnet | Set-AzVirtualNetwork
                }
            }
        }
        else {
            throw "The Subnet ID is not a valid form of resource id."
        }
    }
    elseif ($NetworkParameters.ContainsKey('Vnet') -And !$NetworkParameters.ContainsKey('Subnet')) {
        if (IsValidVnetId $NetworkParameters.Vnet) {
            Write-Host "You have supplied a vnet Id. Verifying its existence..."
            IsValidRgLocation $NetworkParameters.Vnet $NetworkParameters
            $ParsedResult = ParseResourceId $NetworkParameters.Vnet 
            $NetworkParameters.VnetName = $ParsedResult.VnetName
            $NetworkParameters.SubnetName = 'Subnet' + $NetworkParameters.Name
            $Subnet = CreateVnetSubnet $NetworkParameters
        }
        elseif ($NetworkParameters.Vnet -Match $AZURE_ARMNAME) {
            Write-Host "You have supplied a vnet Name. Verifying its existence..."
            $NetworkParameters.VnetName = $NetworkParameters.Vnet
            $NetworkParameters.SubnetName = 'Subnet' + $NetworkParameters.Name
            $Subnet = CreateVnetSubnet $NetworkParameters
            IsValidRgLocation $Subnet.Id $NetworkParameters 
        }
        else {
            throw "Incorrectly formed Vnet id or Vnet name"
        }
    }
    else {
        # Both Vnet and Subnet provided
        if ($NetworkParameters.Vnet -Match $AZURE_ARMNAME -And $NetworkParameters.Subnet -Match $AZURE_ARMNAME) {
            $NetworkParameters.VnetName = $NetworkParameters.Vnet
            $NetworkParameters.SubnetName = $NetworkParameters.Subnet
            $Subnet = CreateVnetSubnet $NetworkParameters
        }
        else {
            if ($NetworkParameters.ContainsKey('SubnetPrefix') -And $NetworkParameters.ContainsKey('VnetPrefix')) {
                $Msg = "If you pass an address prefix, please consider passing a name (instead of Id) for a subnet or vnet."
            }
            else { $Msg = "If you pass both --vnet and --subnet, consider passing names instead of ids." }
            throw $Msg
        }
    }

    return $NetworkParameters
}

function GetSubnetId($ResourceGroupName, $VnetName, $SubnetName) {
    if (!($ResourceGroupName -is [String])) { $ResourceGroupName = $ResourceGroupName[0] }
    $Vnet = Get-AzVirtualNetwork -Name $VnetName -ResourceGroupName $ResourceGroupName
    $Subnet = Get-AzVirtualNetworkSubnetConfig -Name $SubnetName -VirtualNetwork $Vnet
    return $Subnet.Id 
}

function CreateVnetSubnet($Parameters) {
    if (!$Parameters.ContainsKey('SubnetPrefix')) { $Parameters.SubnetPrefix = $DEFAULT_SUBNET_PREFIX }
    if (!$Parameters.ContainsKey('VnetPrefix')) { $Parameters.VnetPrefix = $DEFAULT_VNET_PREFIX }

    try {
        $Vnet = Get-AzVirtualNetwork -Name $Parameters.VnetName -ResourceGroupName $Parameters.ResourceGroupName -ErrorAction Stop
        $prefixes = $Vnet.AddressSpace.AddressPrefixes
        if (!($prefixes -Contains $Parameters.VnetPrefix)) {
            $prefixes.Add($Parameters.VnetPrefix)
            $Vnet.AddressSpace.AddressPrefixes = $prefixes
            $Vnet | Set-AzVirtualNetwork
        }
    }
    catch {
        $Msg = "Creating new vnet {0} in resource group {1}" -f $Parameters.VnetName, $Parameters.ResourceGroupName
        Write-Host $Msg
        if ($PSCmdlet.ShouldProcess($Parameters.VnetName)) {
            New-AzVirtualNetwork -Name $Parameters.VnetName -ResourceGroupName $Parameters.ResourceGroupName -Location $Parameters.Location -AddressPrefix $Parameters.VnetPrefix -Force
        }
    }

    $Subnet = CreateAndDelegateSubnet $Parameters
    
    return $Subnet
}
function CreateAndDelegateSubnet($Parameters) {
    $SubnetFlag = $true
    $Vnet = Get-AzVirtualNetwork -Name $Parameters.VnetName -ResourceGroupName $Parameters.ResourceGroupName -ErrorAction Stop
    try {
        $Subnet = Get-AzVirtualNetworkSubnetConfig -VirtualNetwork $Vnet -Name $Parameters.SubnetName -ErrorAction Stop
    }
    catch {
        $SubnetFlag = $false
        $Msg = 'Creating new subnet {0} in resource group {1} and delegating it to {2}' -f $Parameters.SubnetName, $Parameters.ResourceGroupName, $DELEGATION_SERVICE_NAME
        Write-Host $Msg
    }

    if (!$SubnetFlag) {
        $Delegation = New-AzDelegation -Name $DELEGATION_SERVICE_NAME -ServiceName $DELEGATION_SERVICE_NAME
        Add-AzVirtualNetworkSubnetConfig -Name $Parameters.SubnetName -VirtualNetwork $Vnet -AddressPrefix $Parameters.SubnetPrefix -Delegation $Delegation | Set-AzVirtualNetwork
    }
    else {
        # check if existing subnet is delegated
        $Delegations = Get-AzDelegation -Subnet $Subnet
        if ($null -ne $Delegations) {
            $Delegations | ForEach-Object { If ($PSItem.ServiceName -ne $DELEGATION_SERVICE_NAME) {
                    $Msg = "Can not use subnet with existing delegations other than {0}" -f $DELEGATION_SERVICE_NAME
                    throw $Msg
                } }
        }
        else {
            # Valid but no delegation
            $Subnet = Add-AzDelegation -Name $DELEGATION_SERVICE_NAME -ServiceName $DELEGATION_SERVICE_NAME -Subnet $Subnet
            $Vnet | Set-AzVirtualNetwork
        }
    }

    return $Subnet
}
function CreateFirewallRule($RuleName, $StartIp, $EndIp, $ResourceGroupName, $ServerName) {
    $FirewallRule = New-AzMySqlFlexibleServerFirewallRule -Name $RuleName -ResourceGroupName $ResourceGroupName -ServerName $ServerName -EndIPAddress $EndIp -StartIPAddress $StartIp
    return $FirewallRule.Name 
}

function ParseFirewallRule($PublicAccess) {
    $PublicAccess = [string]$PublicAccess
    if ([string]::IsNullOrEmpty($PublicAccess)) {
        $PublicAccess = 'none'
    }
    if ($PublicAccess.ToLower() -ne 'none') {
        $Date = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
        if ($PublicAccess.ToLower() -eq 'all') {
            $StartIp = '0.0.0.0' 
            $EndIp = '255.255.255.255'
            $RuleName = "AllowAll_" + $Date 
        }
        else {
            $Parsed = $PublicAccess -split "-"
            if ($Parsed.length -eq 1) {
                $StartIp = $Parsed[0]
                $EndIp = $Parsed[0]
            }
            elseif ($Parsed.length -eq 2) {
                $StartIp = $Parsed[0]
                $EndIp = $Parsed[1]
            }
            else { throw "Incorrect usage: --public-access. Acceptable values are \'all\', \'none\',\'<startIP>\' and \'<startIP>-<destinationIP>\' where startIP and destinationIP ranges from 0.0.0.0 to 255.255.255.255" }
            if ($StartIp -eq '0.0.0.0' -And $EndIp -eq '0.0.0.0') {
                $RuleName = "AllowAllAzureServicesAndResourcesWithinAzureIps_" + $Date
                $Msg = 'Configuring server firewall rule to accept connections from all Azure resources...'
            }
            elseif ($StartIP -eq $EndIP) {
                $Msg = 'Configuring server firewall rule to accept connections from ' + $StartIP 
                $RuleName = "FirewallIPAddress_" + $Date
            } 
            else {
                $Msg = 'Configuring server firewall rule to accept connections from {0} to {1}' -f $StartIP, $EndIp
                $RuleName = "FirewallIPAddress_" + $Date
            }
            Write-Host $Msg
        }
    }
    else {
        $StartIp = $null
        $EndIp = $null
        $RuleName = $null
    }
    return $RuleName, $StartIp, $EndIp
}
function IsValidVnetId($Rid) {
    $VnetFormat = "\/subscriptions\/[0-9A-Fa-f]{8}-([0-9A-Fa-f]{4}-){3}[0-9A-Fa-f]{12}\/resourceGroups\/[-\w\._\(\)]+\/providers\/Microsoft.Network\/virtualNetworks\/[^<>%&:\\?/]{1,260}$"
    if ( $Rid -match $VnetFormat ) {
        return $True
    }
    return $False
}
function IsValidSubnetId($Rid) {
    $SubnetFormat = "\/subscriptions\/[0-9A-Fa-f]{8}-([0-9A-Fa-f]{4}-){3}[0-9A-Fa-f]{12}\/resourceGroups/[-\w\._\(\)]+\/providers\/Microsoft.Network\/virtualNetworks\/[^<>%&:\\?/]{1,260}\/subnets\/[^<>%&:\\?/]{1,260}$"
    if ( $Rid -match $SubnetFormat ) {
        return $True
    }
    return $False
}
function ParseResourceId($Rid) {
    $Splits = $Rid -split "/"
    $ParsedResults = @{}
    if ($Splits.length -gt 1) {
        $ParsedResults["SubscriptionId"] = $Splits[2]
        $ParsedResults["ResourceGroupName"] = $Splits[4]
        $ParsedResults["VnetName"] = $Splits[8]
        if ($Splits.length -eq 11) {
            $ParsedResults["SubnetName"] = $Splits[10]
        }
    }
    return $ParsedResults
}
function IsValidRgLocation($ResourceId, $Parameters) {
    $ParsedResults = ParseResourceId $ResourceId
    $Group = Get-AzResourceGroup -Name $ParsedResults["ResourceGroupName"]
    $ParsedResults["Location"] = $Group.Location

    if ($Parameters.SubscriptionId -eq $ParsedResults.SubscriptionId -And $Parameters.Location -eq $ParsedResults.Location) {
        return $True
    }
    throw "Incorrect Usage : The location and subscription of the server, Vnet and Subnet should be same."
}

function Get-RandomNumbers($Prefix, $Length) {
    $Generated = ""
    for ($i = 0; $i -lt $Length; $i++) { $Generated += Get-Random -Maximum 10 }
    return $Prefix + $Generated
}

function Get-RandomName() {
    $Noun = Get-Content -Path (Join-Path $PSScriptRoot ".\nouns.txt") | Get-Random
    $Adjective = Get-Content -Path (Join-Path $PSScriptRoot ".\adjectives.txt") | Get-Random
    $Number = Get-Random -Maximum 10
    $RandomName = $Adjective + $Noun + $Number
    return $RandomName

}

function Get-GeneratePassword() {
    $Password = ''
    $Chars = 'abcdefghiklmnoprstuvwxyzABCDEFGHKLMNOPRSTUVWXYZ1234567890'
    for ($i = 0; $i -lt 16; $i++ ) { $Password += $Chars[(Get-Random -Minimum 0 -Maximum $Chars.Length)] }
    $Password = ($Password -split '' | Sort-Object { Get-Random }) -join ''
    return $Password
}
