<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AvailabilitySetRemovalCaption" xml:space="preserve">
    <value>Availability set removal operation</value>
  </data>
  <data name="AvailabilitySetRemovalConfirmation" xml:space="preserve">
    <value>This cmdlet will remove the specified availability set. Do you want to continue?</value>
  </data>
  <data name="BothWindowsAndLinuxConfigurationsSpecified" xml:space="preserve">
    <value>Cannot specify both Windows and Linux configurations.</value>
  </data>
  <data name="CustomScriptExtensionTryToUseTheFirstSpecifiedFileAsRunScript" xml:space="preserve">
    <value>No Run File has been assigned, and the Custom Script extension will try to use the first specified File Name as the Run File.</value>
  </data>
  <data name="VirtualMachineExtensionRemovalCaption" xml:space="preserve">
    <value>Virtual machine extension removal operation</value>
  </data>
  <data name="VirtualMachineExtensionRemovalConfirmation" xml:space="preserve">
    <value>This cmdlet will remove the specified virtual machine extension. Do you want to continue?</value>
  </data>
  <data name="VirtualMachineNotAssociatedWithPublicIPOrPublicLoadBalancer" xml:space="preserve">
    <value>The RDP file cannot be generated because the network interface of the virtual machine does not reference a PublicIP or an InboundNatRule of a public load balancer. </value>
  </data>
  <data name="VirtualMachineNotAssociatedWithPublicLoadBalancer" xml:space="preserve">
    <value>The RDP file cannot be generated because the network interface of the virtual machine does not reference an InboundNatRule of a public load balancer.</value>
  </data>
  <data name="VirtualMachineReferencesInternalNetworkInterface" xml:space="preserve">
    <value>The RDP file cannot be generated because the network interface of the virtual machine does not reference a PublicIP or an InboungNatRule of the load balancer.</value>
  </data>
  <data name="VirtualMachineRemovalCaption" xml:space="preserve">
    <value>Virtual machine removal operation</value>
  </data>
  <data name="VirtualMachineRemovalConfirmation" xml:space="preserve">
    <value>This cmdlet will remove the specified virtual machine. Do you want to continue?</value>
  </data>
  <data name="VirtualMachineStoppingCaption" xml:space="preserve">
    <value>Virtual machine stopping operation</value>
  </data>
  <data name="VirtualMachineStoppingConfirmation" xml:space="preserve">
    <value>This cmdlet will stop the specified virtual machine. Do you want to continue?</value>
  </data>
  <data name="AzureVMDscCannotFindConfigurationDataFile" xml:space="preserve">
    <value>Cannot find configuration data file: {0}</value>
  </data>
  <data name="AzureVMDscConfigurationDataFileShouldNotIncludePath" xml:space="preserve">
    <value>The -ConfigurationArchive parameter must no include a path</value>
  </data>
  <data name="AzureVMDscInvalidConfigurationDataFile" xml:space="preserve">
    <value>The configuration data must be a .psd1 file</value>
  </data>
  <data name="AzureVMDscExtensionInvalidVersion" xml:space="preserve">
    <value>Please enter a valid DSC Extension version. Allowed format: N.N where N = [1..9]</value>
  </data>
  <data name="PublishVMDscExtensionConfigFileNotFound" xml:space="preserve">
    <value>Cannot find configuration file: {0}.</value>
    <comment>0 = path to the configuration file</comment>
  </data>
  <data name="PublishVMDscExtensionUploadArchiveConfigFileInvalidExtension" xml:space="preserve">
    <value>Invalid configuration file: {0}.
The file needs to be a PowerShell script (.ps1 or .psm1) or a ZIP archive (.zip).</value>
    <comment>0 = path to the configuration file</comment>
  </data>
  <data name="PublishVMDscExtensionUploadArchiveConfigFileNotExist" xml:space="preserve">
    <value>Configuration file '{0}' not found.</value>
    <comment>0 = path to the configuration file</comment>
  </data>
  <data name="PublishVMDscExtensionGetDscResourceFailed" xml:space="preserve">
    <value>Cannot get module for DscResource '{0}'. Possible solutions:
1) Specify -ModuleName for Import-DscResource in your configuration.
2) Unblock module that contains resource.
3) Move Import-DscResource inside Node block.
</value>
    <comment>0 = name of DscResource</comment>
  </data>
  <data name="PublishVMDscExtensionStorageParserErrors" xml:space="preserve">
    <value>Configuration script '{0}' contained parse errors:
{1}</value>
    <comment>0 = path to the configuration script, 1 = parser errors</comment>
  </data>
  <data name="AzureVMDscStorageContextMustIncludeAccountName" xml:space="preserve">
    <value>The storage context must include an storage account.</value>
  </data>
  <data name="AzureVMDscApplyConfigurationAction" xml:space="preserve">
    <value>Apply configuration '{0}'</value>
    <comment>{0} is the name of a PowerShell DSC Configuration function</comment>
  </data>
  <data name="AzureVMDscParsingConfiguration" xml:space="preserve">
    <value>Parsing configuration script: {0}</value>
    <comment>{0} is the path to a script file</comment>
  </data>
  <data name="AzureVMDscStorageBlobAlreadyExists" xml:space="preserve">
    <value>Storage Blob '{0}' already exists. Use the -Force parameter to overwrite it.</value>
    <comment>{0} is the name of an storage blob</comment>
  </data>
  <data name="AzureVMDscUploadToBlobStorageAction" xml:space="preserve">
    <value>Upload '{0}'</value>
    <comment>{0} is the name of an storage blob</comment>
  </data>
  <data name="PublishVMDscExtensionCreateArchiveConfigFileInvalidExtension" xml:space="preserve">
    <value>Invalid configuration file: {0}.
The file needs to be a PowerShell script (.ps1 or .psm1).</value>
    <comment>0 = path to the configuration file</comment>
  </data>
  <data name="AzureVMDscNullArchiveNoConfiguragionParameters" xml:space="preserve">
    <value>If the ConfigurationArchive argument is null, then the ConfigurationName, ConfigurationArgument, and ConfigurationDataPath parameters must not be specified </value>
  </data>
  <data name="AzureVMDscNullArchiveNoStorageParameters" xml:space="preserve">
    <value>If the ConfigurationArchive argument is null, then the StorageContext, ArchiveContainerName, and ArchiveStorageEndpointSuffix parameters must not be specified</value>
  </data>
  <data name="AzureVMDscCreateArchiveAction" xml:space="preserve">
    <value>Create Archive</value>
  </data>
  <data name="AzureVMDscArchiveAlreadyExists" xml:space="preserve">
    <value>File '{0}' already exists. Use the -Force parameter to overwrite it.</value>
    <comment>{0} is the path to a file</comment>
  </data>
  <data name="PublishVMDscExtensionRequiredPsVersion" xml:space="preserve">
    <value>Your current PowerShell version {1} is less then required by this cmdlet {0}. Consider download and install latest PowerShell version.</value>
    <comment>{0} = minimal required PS version, {1} = current PS version</comment>
  </data>
  <data name="AzureVMDscDefaultStorageCredentialsNotFound" xml:space="preserve">
    <value>Can not find your azure storage credential. Please specify an storage context using the -StorageContext parameter, or set the current storage account using "Set-AzureSubscription", or set the "AZURE_STORAGE_CONNECTION_STRING" environment variable.</value>
  </data>
  <data name="PublishVMDscExtensionRequiredModulesVerbose" xml:space="preserve">
    <value>List of required modules: [{0}].</value>
    <comment>{0} = list of modules</comment>
  </data>
  <data name="PublishVMDscExtensionTempFolderVerbose" xml:space="preserve">
    <value>Temp folder '{0}' created.</value>
    <comment>{0} = temp folder path</comment>
  </data>
  <data name="PublishVMDscExtensionCopyFileVerbose" xml:space="preserve">
    <value>Copy '{0}' to '{1}'.</value>
    <comment>{0} = source, {1} = destination</comment>
  </data>
  <data name="PublishVMDscExtensionCopyModuleVerbose" xml:space="preserve">
    <value>Copy the module '{0}' to '{1}'.</value>
    <comment>{0} = source, {1} = destination</comment>
  </data>
  <data name="PublishVMDscExtensionCreateZipVerbose" xml:space="preserve">
    <value>Create a zip file '{0}' from directory '{1}'.</value>
    <comment>{0} = target zip, {1} = source</comment>
  </data>
  <data name="PublishVMDscExtensionDeletedFileMessage" xml:space="preserve">
    <value>Deleted '{0}'</value>
    <comment>{0} is the path of a file</comment>
  </data>
  <data name="PublishVMDscExtensionDeleteErrorMessage" xml:space="preserve">
    <value>Cannot delete '{0}': {1}</value>
    <comment>{0} is the path of a file, {1} is an error message</comment>
  </data>
  <data name="AzureVMDscWrongSettingsFormat" xml:space="preserve">
    <value>Cannot deserialize settings string from DSC extension. Updating your Azure PowerShell SDK to the latest version may solve this problem. Settings string:
{0}</value>
    <comment>{0} settings json string</comment>
  </data>
  <data name="PublishVMDscExtensionArchiveUploadedMessage" xml:space="preserve">
    <value>Configuration published to {0}</value>
    <comment>{0} is an URI</comment>
  </data>
  <data name="DscExtensionRemovalCaption" xml:space="preserve">
    <value>Remove Extension</value>
  </data>
  <data name="DscExtensionRemovalConfirmation" xml:space="preserve">
    <value>{0}</value>
  </data>
</root>