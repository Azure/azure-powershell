<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AvailabilitySetRemovalCaption" xml:space="preserve">
    <value>Availability set removal operation</value>
  </data>
  <data name="AvailabilitySetRemovalConfirmation" xml:space="preserve">
    <value>This cmdlet will remove the specified availability set. Do you want to continue?</value>
  </data>
  <data name="BothWindowsAndLinuxConfigurationsSpecified" xml:space="preserve">
    <value>Cannot specify both Windows and Linux configurations.</value>
  </data>
  <data name="CustomScriptExtensionTryToUseTheFirstSpecifiedFileAsRunScript" xml:space="preserve">
    <value>No Run File has been assigned, and the Custom Script extension will try to use the first specified File Name as the Run File.</value>
  </data>
  <data name="VirtualMachineExtensionRemovalCaption" xml:space="preserve">
    <value>Virtual machine extension removal operation</value>
  </data>
  <data name="VirtualMachineExtensionRemovalConfirmation" xml:space="preserve">
    <value>This cmdlet will remove the specified virtual machine extension. Do you want to continue?</value>
  </data>
  <data name="VirtualMachineNotAssociatedWithPublicIPOrPublicLoadBalancer" xml:space="preserve">
    <value>The RDP file cannot be generated because the network interface of the virtual machine does not reference a PublicIP or an InboundNatRule of a public load balancer. </value>
  </data>
  <data name="VirtualMachineNotAssociatedWithPublicLoadBalancer" xml:space="preserve">
    <value>The RDP file cannot be generated because the network interface of the virtual machine does not reference an InboundNatRule of a public load balancer.</value>
  </data>
  <data name="VirtualMachineReferencesInternalNetworkInterface" xml:space="preserve">
    <value>The RDP file cannot be generated because the network interface of the virtual machine does not reference a PublicIP or an InboungNatRule of the load balancer.</value>
  </data>
  <data name="VirtualMachineRemovalCaption" xml:space="preserve">
    <value>Virtual machine removal operation</value>
  </data>
  <data name="VirtualMachineRemovalConfirmation" xml:space="preserve">
    <value>This cmdlet will remove the specified virtual machine. Do you want to continue?</value>
  </data>
  <data name="VirtualMachineStoppingCaption" xml:space="preserve">
    <value>Virtual machine stopping operation</value>
  </data>
  <data name="VirtualMachineStoppingConfirmation" xml:space="preserve">
    <value>This cmdlet will stop the specified virtual machine. Do you want to continue?</value>
  </data>
  <data name="AzureVMDscCannotFindConfigurationDataFile" xml:space="preserve">
    <value>Cannot find configuration data file: {0}</value>
  </data>
  <data name="AzureVMDscConfigurationDataFileShouldNotIncludePath" xml:space="preserve">
    <value>The -ConfigurationArchive parameter must no include a path</value>
  </data>
  <data name="AzureVMDscInvalidConfigurationDataFile" xml:space="preserve">
    <value>The configuration data must be a .psd1 file</value>
  </data>
  <data name="AzureVMDscExtensionInvalidVersion" xml:space="preserve">
    <value>Please enter a valid DSC Extension version. Allowed format: N.N where N = [1..9]</value>
  </data>
  <data name="PublishVMDscExtensionConfigFileNotFound" xml:space="preserve">
    <value>Cannot find configuration file: {0}.</value>
    <comment>0 = path to the configuration file</comment>
  </data>
  <data name="PublishVMDscExtensionUploadArchiveConfigFileInvalidExtension" xml:space="preserve">
    <value>Invalid configuration file: {0}.
The file needs to be a PowerShell script (.ps1 or .psm1) or a ZIP archive (.zip).</value>
    <comment>0 = path to the configuration file</comment>
  </data>
  <data name="PublishVMDscExtensionUploadArchiveConfigFileNotExist" xml:space="preserve">
    <value>Configuration file '{0}' not found.</value>
    <comment>0 = path to the configuration file</comment>
  </data>
  <data name="PublishVMDscExtensionGetDscResourceFailed" xml:space="preserve">
    <value>Cannot get module for DscResource '{0}'. Possible solutions:
1) Specify -ModuleName for Import-DscResource in your configuration.
2) Unblock module that contains resource.
3) Move Import-DscResource inside Node block.
</value>
    <comment>0 = name of DscResource</comment>
  </data>
  <data name="PublishVMDscExtensionStorageParserErrors" xml:space="preserve">
    <value>Configuration script '{0}' contained parse errors:
{1}</value>
    <comment>0 = path to the configuration script, 1 = parser errors</comment>
  </data>
  <data name="AzureVMDscStorageContextMustIncludeAccountName" xml:space="preserve">
    <value>The storage context must include an storage account.</value>
  </data>
  <data name="AzureVMDscApplyConfigurationAction" xml:space="preserve">
    <value>Apply configuration '{0}'</value>
    <comment>{0} is the name of a PowerShell DSC Configuration function</comment>
  </data>
  <data name="AzureVMDscParsingConfiguration" xml:space="preserve">
    <value>Parsing configuration script: {0}</value>
    <comment>{0} is the path to a script file</comment>
  </data>
  <data name="AzureVMDscStorageBlobAlreadyExists" xml:space="preserve">
    <value>Storage Blob '{0}' already exists. Use the -Force parameter to overwrite it.</value>
    <comment>{0} is the name of an storage blob</comment>
  </data>
  <data name="AzureVMDscUploadToBlobStorageAction" xml:space="preserve">
    <value>Upload '{0}'</value>
    <comment>{0} is the name of an storage blob</comment>
  </data>
  <data name="PublishVMDscExtensionCreateArchiveConfigFileInvalidExtension" xml:space="preserve">
    <value>Invalid configuration file: {0}.
The file needs to be a PowerShell script (.ps1 or .psm1).</value>
    <comment>0 = path to the configuration file</comment>
  </data>
  <data name="AzureVMDscNullArchiveNoConfiguragionParameters" xml:space="preserve">
    <value>If the ConfigurationArchive argument is null, then the ConfigurationName, ConfigurationArgument, and ConfigurationDataPath parameters must not be specified </value>
  </data>
  <data name="AzureVMDscNullArchiveNoStorageParameters" xml:space="preserve">
    <value>If the ConfigurationArchive argument is null, then the StorageContext, ArchiveContainerName, and ArchiveStorageEndpointSuffix parameters must not be specified</value>
  </data>
  <data name="AzureVMDscCreateArchiveAction" xml:space="preserve">
    <value>Create Archive</value>
  </data>
  <data name="AzureVMDscArchiveAlreadyExists" xml:space="preserve">
    <value>File '{0}' already exists. Use the -Force parameter to overwrite it.</value>
    <comment>{0} is the path to a file</comment>
  </data>
  <data name="PublishVMDscExtensionRequiredPsVersion" xml:space="preserve">
    <value>Your current PowerShell version {1} is less then required by this cmdlet {0}. Consider download and install latest PowerShell version.</value>
    <comment>{0} = minimal required PS version, {1} = current PS version</comment>
  </data>
  <data name="AzureVMDscDefaultStorageCredentialsNotFound" xml:space="preserve">
    <value>Can not find your azure storage credential. Please specify an storage context using the -StorageContext parameter, or set the current storage account using "Set-AzureRmSubscription", or set the "AZURE_STORAGE_CONNECTION_STRING" environment variable.</value>
  </data>
  <data name="PublishVMDscExtensionRequiredModulesVerbose" xml:space="preserve">
    <value>List of required modules: [{0}].</value>
    <comment>{0} = list of modules</comment>
  </data>
  <data name="PublishVMDscExtensionTempFolderVerbose" xml:space="preserve">
    <value>Temp folder '{0}' created.</value>
    <comment>{0} = temp folder path</comment>
  </data>
  <data name="PublishVMDscExtensionCopyFileVerbose" xml:space="preserve">
    <value>Copy '{0}' to '{1}'.</value>
    <comment>{0} = source, {1} = destination</comment>
  </data>
  <data name="PublishVMDscExtensionCopyModuleVerbose" xml:space="preserve">
    <value>Copy the module '{0}' to '{1}'.</value>
    <comment>{0} = source, {1} = destination</comment>
  </data>
  <data name="PublishVMDscExtensionCreateZipVerbose" xml:space="preserve">
    <value>Create a zip file '{0}' from directory '{1}'.</value>
    <comment>{0} = target zip, {1} = source</comment>
  </data>
  <data name="PublishVMDscExtensionDeletedFileMessage" xml:space="preserve">
    <value>Deleted '{0}'</value>
    <comment>{0} is the path of a file</comment>
  </data>
  <data name="PublishVMDscExtensionDeleteErrorMessage" xml:space="preserve">
    <value>Cannot delete '{0}': {1}</value>
    <comment>{0} is the path of a file, {1} is an error message</comment>
  </data>
  <data name="AzureVMDscWrongSettingsFormat" xml:space="preserve">
    <value>Cannot deserialize settings string from DSC extension. Updating your Azure PowerShell SDK to the latest version may solve this problem. Settings string:
{0}</value>
    <comment>{0} settings json string</comment>
  </data>
  <data name="PublishVMDscExtensionArchiveUploadedMessage" xml:space="preserve">
    <value>Configuration published to {0}</value>
    <comment>{0} is an URI</comment>
  </data>
  <data name="DscExtensionRemovalCaption" xml:space="preserve">
    <value>Remove Extension</value>
  </data>
  <data name="DscExtensionRemovalConfirmation" xml:space="preserve">
    <value>{0}</value>
  </data>
  <data name="AddAzureVhdCommandSASUriNotSupportedInPatchMode" xml:space="preserve">
    <value>SAS Uri for the destination blob is not supported in patch mode:{0}</value>
  </data>
  <data name="PSSyncOutputEventsCalculatingMD5Hash" xml:space="preserve">
    <value>Calculating MD5 Hash</value>
  </data>
  <data name="PSSyncOutputEventsCalculatingMD5HashForFile" xml:space="preserve">
    <value>MD5 hash is being calculated for the file '{0}'.</value>
  </data>
  <data name="PSSyncOutputEventsCopying" xml:space="preserve">
    <value>Copying</value>
  </data>
  <data name="PSSyncOutputEventsCreatingNewPageBlob" xml:space="preserve">
    <value>Creating new page blob of size {0}...</value>
  </data>
  <data name="PSSyncOutputEventsDetectingActualDataBlocks" xml:space="preserve">
    <value>Detecting the empty data blocks in the local file.</value>
  </data>
  <data name="PSSyncOutputEventsDetectingActualDataBlocksCompleted" xml:space="preserve">
    <value>Detecting the empty data blocks completed.</value>
  </data>
  <data name="PSSyncOutputEventsDownloading" xml:space="preserve">
    <value>Downloading</value>
  </data>
  <data name="PSSyncOutputEventsElapsedTimeForCopy" xml:space="preserve">
    <value>Elapsed time for copy: {0}</value>
  </data>
  <data name="PSSyncOutputEventsElapsedTimeForDownload" xml:space="preserve">
    <value>Elapsed time for download: {0}</value>
  </data>
  <data name="PSSyncOutputEventsElapsedTimeForOperation" xml:space="preserve">
    <value>Elapsed time for the operation: {0}</value>
  </data>
  <data name="PSSyncOutputEventsElapsedTimeForUpload" xml:space="preserve">
    <value>Elapsed time for upload: {0}</value>
  </data>
  <data name="PSSyncOutputEventsEmptyBlockDetected" xml:space="preserve">
    <value>Empty block detected: {0}</value>
  </data>
  <data name="PSSyncOutputEventsEmptyBlockDetectionCompleted" xml:space="preserve">
    <value>Completed</value>
  </data>
  <data name="PSSyncOutputEventsEmptyBlockDetectionDetecting" xml:space="preserve">
    <value>Detecting empty blocks</value>
  </data>
  <data name="PSSyncOutputEventsFormatDuration" xml:space="preserve">
    <value>{0} days {1:00}:{2:00}:{3:00}</value>
  </data>
  <data name="PSSyncOutputEventsLogProgress" xml:space="preserve">
    <value>{0:0.0}% complete; Remaining Time: {1}; Throughput: {2:0.0}Mbps</value>
  </data>
  <data name="PSSyncOutputEventsLogProgressCompleteCompleted" xml:space="preserve">
    <value>Completed</value>
  </data>
  <data name="PSSyncOutputEventsMD5HashCalculationFinished" xml:space="preserve">
    <value>MD5 hash calculation is completed.</value>
  </data>
  <data name="PSSyncOutputEventsPrintBlockRange" xml:space="preserve">
    <value>Range of the block is {0}, Length: {1}</value>
  </data>
  <data name="PSSyncOutputEventsProgressEmptyBlockDetection" xml:space="preserve">
    <value>Empty Block Detection</value>
  </data>
  <data name="PSSyncOutputEventsResumingUpload" xml:space="preserve">
    <value>Found existing page blob. Resuming upload...</value>
  </data>
  <data name="PSSyncOutputEventsRetryingAfterANetworkDisruption" xml:space="preserve">
    <value>Network disruption occured, retrying.</value>
  </data>
  <data name="PSSyncOutputEventsUploadFailedWithException" xml:space="preserve">
    <value>Upload failed with exceptions:</value>
  </data>
  <data name="PSSyncOutputEventsUploading" xml:space="preserve">
    <value>Uploading</value>
  </data>
  <data name="StorageCredentialsFactoryCurrentSubscriptionNotSet" xml:space="preserve">
    <value>No current subscription has been designated. Use Select-AzureRmSubscription -Current &lt;subscriptionName&gt; to set the current subscription.</value>
  </data>
  <data name="DataDiskNotAssignedForVM" xml:space="preserve">
    <value>A data disk, {0}, is not currently assigned for this VM. Use Add-AzureRmVMDataDisk to add it.</value>
  </data>
  <data name="AzureVMSqlServerWrongSettingsFormat" xml:space="preserve">
    <value>Cannot deserialize settings string from Sql Server extension. Updating your Azure PowerShell SDK to the latest version may solve this problem. Settings string:
{0}</value>
    <comment>{0} settings json string</comment>
  </data>
  <data name="PublishVMDscExtensionAdditionalContentPathNotExist" xml:space="preserve">
    <value>Path '{0}' not found.</value>
    <comment>0 = path to the additional content file/directory</comment>
  </data>
  <data name="PublishVMDscExtensionArchiveUploadedMessage1" xml:space="preserve">
    <value>Configuration published to {0}</value>
    <comment>{0} is an URI</comment>
  </data>
  <data name="PublishVMDscExtensionCopyFileVerbose1" xml:space="preserve">
    <value>Copy '{0}' to '{1}'.</value>
    <comment>{0} = source, {1} = destination</comment>
  </data>
  <data name="PublishVMDscExtensionCopyModuleVerbose1" xml:space="preserve">
    <value>Copy the module '{0}' to '{1}'.</value>
    <comment>{0} = source, {1} = destination</comment>
  </data>
  <data name="PublishVMDscExtensionCreateArchiveConfigFileInvalidExtension1" xml:space="preserve">
    <value>Invalid configuration file: {0}.
The file needs to be a PowerShell script (.ps1 or .psm1).</value>
    <comment>0 = path to the configuration file</comment>
  </data>
  <data name="PublishVMDscExtensionDeletedFileMessage1" xml:space="preserve">
    <value>Deleted '{0}'</value>
    <comment>{0} is the path of a file</comment>
  </data>
  <data name="PublishVMDscExtensionDeleteErrorMessage1" xml:space="preserve">
    <value>Cannot delete '{0}': {1}</value>
    <comment>{0} is the path of a file, {1} is an error message</comment>
  </data>
  <data name="PublishVMDscExtensionDirectoryNotExist" xml:space="preserve">
    <value>Path '{0}' not found.</value>
    <comment>0 = path to the additional content file/directory</comment>
  </data>
  <data name="PublishVMDscExtensionGetDscResourceFailed1" xml:space="preserve">
    <value>Cannot get module for DscResource '{0}'. Possible solutions:
1) Specify -ModuleName for Import-DscResource in your configuration.
2) Unblock module that contains resource.
3) Move Import-DscResource inside Node block.
</value>
    <comment>0 = name of DscResource</comment>
  </data>
  <data name="PublishVMDscExtensionRequiredModulesVerbose1" xml:space="preserve">
    <value>List of required modules: [{0}].</value>
    <comment>{0} = list of modules</comment>
  </data>
  <data name="PublishVMDscExtensionRequiredPsVersion1" xml:space="preserve">
    <value>Your current PowerShell version {1} is less then required by this cmdlet {0}. Consider download and install latest PowerShell version.</value>
    <comment>{0} = minimal required PS version, {1} = current PS version</comment>
  </data>
  <data name="PublishVMDscExtensionStorageParserErrors1" xml:space="preserve">
    <value>Configuration script '{0}' contained parse errors:
{1}</value>
    <comment>0 = path to the configuration script, 1 = parser errors</comment>
  </data>
  <data name="PublishVMDscExtensionTempFolderVerbose1" xml:space="preserve">
    <value>Temp folder '{0}' created.</value>
    <comment>{0} = temp folder path</comment>
  </data>
  <data name="PublishVMDscExtensionUploadArchiveConfigFileInvalidExtension1" xml:space="preserve">
    <value>Invalid configuration file: {0}.
The file needs to be a PowerShell script (.ps1 or .psm1) or a ZIP archive (.zip).</value>
    <comment>0 = path to the configuration file</comment>
  </data>
  <data name="PublishVMDscExtensionUploadArchiveConfigFileNotExist1" xml:space="preserve">
    <value>Configuration file '{0}' not found.</value>
    <comment>0 = path to the configuration file</comment>
  </data>
  <data name="PremiumStorageAccountForBootDiagnostics" xml:space="preserve">
    <value>Storage account, {0}, is a premium account.  You cannot specify a premium storage account for boot diagnostics</value>
  </data>
  <data name="BootDiagnosticsNoStorageAccountError" xml:space="preserve">
    <value>Storage account name for boot diagnostics is not given.</value>
  </data>
  <data name="CreatingStorageAccountForBootDiagnostics" xml:space="preserve">
    <value>Since the VM is created using premium storage, new standard storage account, {0}, is created for boot diagnostics.</value>
    <comment>{0} = new standard storage account name</comment>
  </data>
  <data name="ErrorDuringCreatingStorageAccountForBootDiagnostics" xml:space="preserve">
    <value>Error occurred when creating storage account for boot diagnostics.  Keep creating a VM with disabling boot diagnostics.  : {0}</value>
    <comment>{0} = exception</comment>
  </data>
  <data name="UsingExistingStorageAccountForBootDiagnostics" xml:space="preserve">
    <value>Since the VM is created using premium storage, existing standard storage account, {0}, is used for boot diagnostics.</value>
    <comment>{0} = existing standard storage account name</comment>
  </data>
  <data name="EnableAzureDiskEncryptionCaption" xml:space="preserve">
    <value>Enable AzureDiskEncryption on the VM</value>
  </data>
  <data name="EnableAzureDiskEncryptionConfirmation" xml:space="preserve">
    <value>This cmdlet prepares the VM and enables encryption which may reboot the machine and takes 10-15 minutes to finish. Please save your work on the VM before confirming. Do you want to continue?</value>
  </data>
  <data name="ErrorDuringGettingStorageAccountForBootDiagnostics" xml:space="preserve">
    <value>Error occurred when getting storage account, {0}, for boot diagnostics: {1}</value>
    <comment>{0} = storage account name, {1} = error message</comment>
  </data>
  <data name="StorageAccountNotFoundForBootDiagnostics" xml:space="preserve">
    <value>Storage account, {0}, is not found.  The OS disk may be in a different subscription.</value>
    <comment>{0} = storage account name</comment>
  </data>
  <data name="VMOSDiskDiskEncryptionBothKekVaultIdAndKekUrlRequired" xml:space="preserve">
    <value>You have to specify either both of KeyEncryptionKeyVaultId and KeyEncryptionKeyUrl or none of them.</value>
  </data>
  <data name="DiagnosticsExtensionNotFound" xml:space="preserve">
    <value>No diagnostics extension found under resource group '{0}', virtual machine '{1}'.</value>
    <comment>{0} = resource group name, {1} = virtual machine name</comment>
  </data>
  <data name="DiagnosticsExtensionNullStorageAccountKey" xml:space="preserve">
    <value>Storage account key is not specified or can not be retrieved automatically.</value>
  </data>
  <data name="DiagnosticsExtensionNullStorageAccountName" xml:space="preserve">
    <value>Storage account name is not defined.</value>
  </data>
  <data name="DiagnosticsExtensionNullStorageAccountEndpoint" xml:space="preserve">
    <value>Storage account endpoint is not defined or can not be retrieved automatically.</value>
  </data>
  <data name="DiagnosticsExtensionIaaSConfigElementNotDefinedInJson" xml:space="preserve">
    <value>No WadCfg, WadCfgBlob or xmlCfg element defined in the json configuration file.</value>
  </data>
  <data name="DiagnosticsExtensionInvalidConfigFileFormat" xml:space="preserve">
    <value>Invalid diagnostics configuration file. It should be in xml or json format.</value>
  </data>
  <data name="DiagnosticsExtensionDiagnosticMonitorConfigurationElementNotDefined" xml:space="preserve">
    <value>No DiagnosticMonitorConfiguration element defined in the configuration file.</value>
  </data>
  <data name="DiagnosticsExtensionMetricsResourceIdNotMatch" xml:space="preserve">
    <value>The resourceId defined in the config file does not match the actual resource's id.</value>
  </data>
  <data name="DiagnosticsExtensionIaaSConfigElementNotDefinedInXml" xml:space="preserve">
    <value>No WadCfg or WadCfgBlob element defined in the xml configuration file.</value>
  </data>
  <data name="AEMExtensionNotFound" xml:space="preserve">
    <value>No Azure Enhanced Monitoring extension found under resource group '{0}', virtual machine '{1}'.</value>
    <comment>{0} = resource group name, {1} = virtual machine name</comment>
  </data>
  <data name="DisableAzureDiskEncryptionCaption" xml:space="preserve">
    <value>Disable AzureDiskEncryption on the VM</value>
  </data>
  <data name="DisableAzureDiskEncryptionConfirmation" xml:space="preserve">
    <value>This cmdlet disables encryption on the VM which may reboot the machine. Please save your work on the VM before confirming. Do you want to continue?</value>
  </data>
  <data name="ErrorDuringChoosingStandardStorageAccount" xml:space="preserve">
    <value>Error occurred when choosing existing standard storage account for boot diagnostics: {0}</value>
    <comment>{0} = an error message</comment>
  </data>
  <data name="DisableDiskEncryptionAction" xml:space="preserve">
    <value>Disable disk encryption</value>
  </data>
  <data name="EnableDiskEncryptionAction" xml:space="preserve">
    <value>Enable disk encryption</value>
  </data>
  <data name="RemoveAccessExtensionAction" xml:space="preserve">
    <value>Remove VM access extension</value>
  </data>
  <data name="RemoveDiskEncryptionAction" xml:space="preserve">
    <value>Remove disk encryption</value>
  </data>
  <data name="RemoveExtensionAction" xml:space="preserve">
    <value>Remove '{0}' extension</value>
  </data>
  <data name="RemoveScriptExtensionAction" xml:space="preserve">
    <value>Remove custom script extension</value>
  </data>
  <data name="ChefExtensionNotFound" xml:space="preserve">
    <value>No chef extension found under resource group '{0}', virtual machine '{1}'.</value>
    <comment>{0} = resource group name, {1} = virtual machine name</comment>
  </data>
</root>