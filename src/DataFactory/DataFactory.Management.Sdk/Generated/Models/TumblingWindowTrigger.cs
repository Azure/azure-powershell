// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.Management.DataFactory.Models
{
    using System.Linq;

    /// <summary>
    /// Trigger that schedules pipeline runs for all fixed time interval windows
    /// from a start time without gaps and also supports backfill scenarios (when
    /// start time is in the past).
    /// </summary>
    [Newtonsoft.Json.JsonObject("TumblingWindowTrigger")]
    [Microsoft.Rest.Serialization.JsonTransformation]
    public partial class TumblingWindowTrigger : Trigger
    {
        /// <summary>
        /// Initializes a new instance of the TumblingWindowTrigger class.
        /// </summary>
        public TumblingWindowTrigger()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the TumblingWindowTrigger class.
        /// </summary>

        /// <param name="additionalProperties">Azure data factory nested object which contains information about creating
        /// pipeline run
        /// </param>

        /// <param name="description">Trigger description.
        /// </param>

        /// <param name="runtimeState">Indicates if trigger is running or not. Updated when Start/Stop APIs are
        /// called on the Trigger.
        /// Possible values include: &#39;Started&#39;, &#39;Stopped&#39;, &#39;Disabled&#39;</param>

        /// <param name="annotations">List of tags that can be used for describing the trigger.
        /// </param>

        /// <param name="pipeline">Pipeline for which runs are created when an event is fired for trigger
        /// window that is ready.
        /// </param>

        /// <param name="retryPolicy">Retry policy that will be applied for failed pipeline runs.
        /// </param>

        /// <param name="frequency">The frequency of the time windows.
        /// Possible values include: &#39;Minute&#39;, &#39;Hour&#39;, &#39;Month&#39;</param>

        /// <param name="interval">The interval of the time windows. The minimum interval allowed is 15
        /// Minutes.
        /// </param>

        /// <param name="startTime">The start time for the time period for the trigger during which events are
        /// fired for windows that are ready. Only UTC time is currently supported.
        /// </param>

        /// <param name="endTime">The end time for the time period for the trigger during which events are
        /// fired for windows that are ready. Only UTC time is currently supported.
        /// </param>

        /// <param name="delay">Specifies how long the trigger waits past due time before triggering new
        /// run. It doesn&#39;t alter window start and end time. The default is 0. Type:
        /// string (or Expression with resultType string), pattern:
        /// ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        /// </param>

        /// <param name="maxConcurrency">The max number of parallel time windows (ready for execution) for which a
        /// new run is triggered.
        /// </param>

        /// <param name="dependsOn">Triggers that this trigger depends on. Only tumbling window triggers are
        /// supported.
        /// </param>
        public TumblingWindowTrigger(TriggerPipelineReference pipeline, string frequency, int interval, System.DateTime startTime, int maxConcurrency, System.Collections.Generic.IDictionary<string, object> additionalProperties = default(System.Collections.Generic.IDictionary<string, object>), string description = default(string), string runtimeState = default(string), System.Collections.Generic.IList<object> annotations = default(System.Collections.Generic.IList<object>), RetryPolicy retryPolicy = default(RetryPolicy), System.DateTime? endTime = default(System.DateTime?), object delay = default(object), System.Collections.Generic.IList<DependencyReference> dependsOn = default(System.Collections.Generic.IList<DependencyReference>))

        : base(additionalProperties, description, runtimeState, annotations)
        {
            this.Pipeline = pipeline;
            this.RetryPolicy = retryPolicy;
            this.Frequency = frequency;
            this.Interval = interval;
            this.StartTime = startTime;
            this.EndTime = endTime;
            this.Delay = delay;
            this.MaxConcurrency = maxConcurrency;
            this.DependsOn = dependsOn;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();


        /// <summary>
        /// Gets or sets pipeline for which runs are created when an event is fired for
        /// trigger window that is ready.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "pipeline")]
        public TriggerPipelineReference Pipeline {get; set; }

        /// <summary>
        /// Gets or sets retry policy that will be applied for failed pipeline runs.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "typeProperties.retryPolicy")]
        public RetryPolicy RetryPolicy {get; set; }

        /// <summary>
        /// Gets or sets the frequency of the time windows. Possible values include: &#39;Minute&#39;, &#39;Hour&#39;, &#39;Month&#39;
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "typeProperties.frequency")]
        public string Frequency {get; set; }

        /// <summary>
        /// Gets or sets the interval of the time windows. The minimum interval allowed
        /// is 15 Minutes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "typeProperties.interval")]
        public int Interval {get; set; }

        /// <summary>
        /// Gets or sets the start time for the time period for the trigger during
        /// which events are fired for windows that are ready. Only UTC time is
        /// currently supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "typeProperties.startTime")]
        public System.DateTime StartTime {get; set; }

        /// <summary>
        /// Gets or sets the end time for the time period for the trigger during which
        /// events are fired for windows that are ready. Only UTC time is currently
        /// supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "typeProperties.endTime")]
        public System.DateTime? EndTime {get; set; }

        /// <summary>
        /// Gets or sets specifies how long the trigger waits past due time before
        /// triggering new run. It doesn&#39;t alter window start and end time. The default
        /// is 0. Type: string (or Expression with resultType string), pattern:
        /// ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "typeProperties.delay")]
        public object Delay {get; set; }

        /// <summary>
        /// Gets or sets the max number of parallel time windows (ready for execution)
        /// for which a new run is triggered.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "typeProperties.maxConcurrency")]
        public int MaxConcurrency {get; set; }

        /// <summary>
        /// Gets or sets triggers that this trigger depends on. Only tumbling window
        /// triggers are supported.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "typeProperties.dependsOn")]
        public System.Collections.Generic.IList<DependencyReference> DependsOn {get; set; }
        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="Microsoft.Rest.ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (this.Pipeline == null)
            {
                throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.CannotBeNull, "Pipeline");
            }
            if (this.Frequency == null)
            {
                throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.CannotBeNull, "Frequency");
            }
            if (this.Pipeline != null)
            {
                this.Pipeline.Validate();
            }
            if (this.RetryPolicy != null)
            {
                this.RetryPolicy.Validate();
            }


            if (this.MaxConcurrency > 50)
            {
                throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.InclusiveMaximum, "MaxConcurrency", 50);
            }
            if (this.MaxConcurrency < 1)
            {
                throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.InclusiveMinimum, "MaxConcurrency", 1);
            }

        }
    }
}