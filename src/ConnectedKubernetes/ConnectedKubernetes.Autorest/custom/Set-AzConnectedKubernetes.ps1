
# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Code generated by Microsoft (R) AutoRest Code Generator.Changes may cause incorrect behavior and will be lost if the code
# is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to set properties of the connected cluster resource
.Description
API to set properties of the connected cluster resource
.Example
Set-AzConnectedKubernetes -ClusterName azps_test_cluster -ResourceGroupName azps_test_group -Location eastus
.Example
Set-AzConnectedKubernetes -ClusterName azps_test_cluster1 -ResourceGroupName azps_test_group -Location eastus -KubeConfig $HOME\.kube\config -KubeContext azps_aks_t01

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Models.Api20240701Preview.IConnectedCluster
.Link
https://learn.microsoft.com/powershell/module/az.connectedkubernetes/new-azconnectedkubernetes
#>

[System.Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseSingularNouns', '',
    Justification='Kubernetes is a recognised term', Scope='Function', Target='New-AzConnectedKubernetes')]
param()

function Set-AzConnectedKubernetes {
    [OutputType([Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Models.Api20240701Preview.IConnectedCluster])]
    [CmdletBinding(DefaultParameterSetName='SetExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingConvertToSecureStringWithPlainText', '',
        Justification='Code published before this issue was identified')]
    param(
        [Parameter(ParameterSetName='SetExpanded', Mandatory)]
        [Alias('Name')]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [System.String]
        # The name of the Kubernetes cluster on which get is called.
        ${ClusterName},

        [Parameter(ParameterSetName='SetExpanded', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [System.String]
        # The name of the resource group.
        # The name is case insensitive.
        ${ResourceGroupName},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
        [System.String]
        # The ID of the target subscription.
        ${SubscriptionId},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [System.Uri]
        # The http URI of the proxy server for the kubernetes cluster to use
        ${HttpProxy},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [System.Uri]
        # The https URI of the proxy server for the kubernetes cluster to use
        ${HttpsProxy},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [System.String]
        # The comma-separated list of hostnames that should be excluded from the proxy server for the kubernetes cluster to use
        ${NoProxy},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [System.String]
        # The path to the certificate file for proxy or custom Certificate Authority.
        ${ProxyCert},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [System.Management.Automation.SwitchParameter]
        # Flag to disable auto upgrade of arc agents.
        ${DisableAutoUpgrade},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [System.String]
        # Override the default container log path to enable fluent-bit logging.
        ${ContainerLogPath},

        [Parameter(HelpMessage="Path to the kube config file")]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.String]
        # Path to the kube config file
        ${KubeConfig},

        [Parameter(HelpMessage="Kubconfig context from current machine")]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.String]
        # Kubconfig context from current machine
        ${KubeContext},

        [Parameter(Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.String]
        # The geo-location where the resource lives
        ${Location},

        [Parameter()]
        [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Support.AzureHybridBenefit])]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Support.AzureHybridBenefit]
        # Indicates whether Azure Hybrid Benefit is opted in
        ${AzureHybridBenefit},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.String]
        # The Kubernetes distribution running on this connected cluster.
        ${Distribution},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.String]
        # The Kubernetes distribution version on this connected cluster.
        ${DistributionVersion},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.String]
        # The infrastructure on which the Kubernetes cluster represented by this connected cluster is running on.
        ${Infrastructure},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.String]
        # The resource id of the private link scope this connected cluster is assigned to, if any.
        ${PrivateLinkScopeResourceId},

        [Parameter()]
        [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Support.PrivateLinkState])]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Support.PrivateLinkState]
        # Property which describes the state of private link on a connected cluster resource.
        ${PrivateLinkState},

        [Parameter()]
        [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Support.ProvisioningState])]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Support.ProvisioningState]
        # Provisioning state of the connected cluster resource.
        ${ProvisioningState},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Models.Api20.ITrackedResourceTags]))]
        [System.Collections.Hashtable]
        # Resource tags.
        ${Tag},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.String]
        # OID of 'custom-locations' app.
        ${CustomLocationsOid},

        [Parameter()]
        [System.Management.Automation.SwitchParameter]
        # Accept EULA of ConnectedKubernetes, legal term will pop up without this parameter provided
        ${AcceptEULA},

        [Parameter()]
        [Alias('AzureRMContext', 'AzureCredential')]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Azure')]
        [System.Management.Automation.PSObject]
        # The credentials, account, tenant, and subscription used for communication with Azure.
        ${DefaultProfile},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Run the command as a job
        ${AsJob},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Wait for .NET debugger to attach
        ${Break},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be appended to the front of the pipeline
        ${HttpPipelineAppend},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be prepended to the front of the pipeline
        ${HttpPipelinePrepend},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [System.Uri]
        # The URI of the proxy server for host os to use
        ${Proxy},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [System.Management.Automation.PSCredential]
        # The credential of the proxy server for host os to use
        ${ProxyCredential},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Use the default credentials for the proxy
        ${ProxyUseDefaultCredentials},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.Collections.Hashtable]
        # Arc Agentry System Configuration
        ${ConfigurationSetting},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.Collections.Hashtable]
        # Arc Agentry System Protected Configuration
        ${ConfigurationProtectedSetting},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('body')]
        [System.Management.Automation.SwitchParameter]
        ${EnableGateway},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('body')]
        [System.Management.Automation.SwitchParameter]
        ${DisableGateway},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('body')]
        [System.String]
        # Arc Gateway resource Id
        ${GatewayResourceId},
        
        [Parameter(ParameterSetName='Set', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Models.Api20240701Preview.IConnectedCluster]
        ${InputObject}
    )

    process {
        . "$PSScriptRoot/helpers/HelmHelper.ps1"
        . "$PSScriptRoot/helpers/ConfigDPHelper.ps1"
        . "$PSScriptRoot/helpers/AZCloudMetadataHelper.ps1"
        $parameterSet = $PSCmdlet.ParameterSetName

        if($AzureHybridBenefit){
            if(!$AcceptEULA){
                $legalTermPath = Join-Path $PSScriptRoot -ChildPath "LegalTerm.txt"
                try {
                    $legalTerm = (Get-Content -Path $legalTermPath) -join "`r`n"
                } catch {
                    Write-Error "Get legal term failed."
                    throw
                }
                $confirmation = Read-Host $legalTerm"`n[Y] Yes  [N] No  (default is `"N`")"
                if($confirmation -ine "Y"){
                    Return
                }
            }
        }
        $null = $PSBoundParameters.Remove('AcceptEULA')

        if ($PSBoundParameters.ContainsKey("KubeConfig")) {
            $Null = $PSBoundParameters.Remove('KubeConfig')
        } elseif (Test-Path Env:KUBECONFIG) {
            $KubeConfig = Get-ChildItem -Path Env:KUBECONFIG
        } elseif (Test-Path Env:Home) {
            $KubeConfig = Join-Path -Path $Env:Home -ChildPath '.kube' | Join-Path -ChildPath 'config'
        } else {
            $KubeConfig = Join-Path -Path $Home -ChildPath '.kube' | Join-Path -ChildPath 'config'
        }
        if (-not (Test-Path $KubeConfig)) {
            Write-Error 'Cannot find the kube-config. Please make sure that you have the kube-config on your machine.'
            return
        }
        if ($PSBoundParameters.ContainsKey('KubeContext')) {
            $Null = $PSBoundParameters.Remove('KubeContext')
        }
        if (($null -eq $KubeContext) -or ($KubeContext -eq '')) {
            $KubeContext = kubectl config current-context
        }

        # XW TODO: unit test this?
        # If EnableGateway is provided then set the gateway as enabled.
        if ($EnableGateway -and $DisableGateway) {
            Write-Error "You cannot enable and disable gateway at the same time."
            return
        }
        if ($EnableGateway) {
            $Null = $PSBoundParameters.Remove('EnableGateway')
            $PSBoundParameters.Add('GatewayEnabled', $true)
        }
        # If DisableGateway is provided then set the gateway as disabled and remove gateway resourceId from parameters
        if ($DisableGateway) {
            $Null = $PSBoundParameters.Remove('DisableGateway')
            $PSBoundParameters.Add('GatewayEnabled', $false)
        }
        
        
        $CommonPSBoundParameters = @{}
        if ($PSBoundParameters.ContainsKey('HttpPipelineAppend')) {
            $CommonPSBoundParameters['HttpPipelineAppend'] = $HttpPipelineAppend
        }
        if ($PSBoundParameters.ContainsKey('HttpPipelinePrepend')) {
            $CommonPSBoundParameters['HttpPipelinePrepend'] = $HttpPipelinePrepend
        }
        if ($PSBoundParameters.ContainsKey('SubscriptionId')) {
            $CommonPSBoundParameters['SubscriptionId'] = $SubscriptionId
        }
        if ($PSBoundParameters.ContainsKey('PrivateLinkState') -and ($null -ne $CustomLocationsOid) -and ($CustomLocationsOid -ne '')) {
            Write-Warning "The features 'cluster-connect' and 'custom-locations' cannot be enabled for a private link enabled connected cluster."
            $CustomLocationsOid = $null
        }
        if ($PSBoundParameters.ContainsKey('CustomLocationsOid')) {
            $Null = $PSBoundParameters.Remove('CustomLocationsOid')
        }
        $IdentityType = [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Support.ResourceIdentityType]::SystemAssigned
        $PSBoundParameters.Add('IdentityType', $IdentityType)
        
        # Region Deal with settings and protected settings
        # If a new Kubernetes feature is added then code may need to be added here
        # to suport protected settings as the Config DP is unable to process these
        # themselves.  Add a check here to see if there are any that we currently
        # do not suport.
        $supportedFeatures = @("proxy")
        if ($arcAgentrySettings) {
            foreach ($key in $arcAgentrySettings.Keys) {
                if (-not $supportedFeatures.Contains($key.ToLower())) {
                    Write-Warning "Arc Agentry feature '${key}' is not supported for Connected Kubernetes"
                }
            }
        }
        if ($arcAgentryProtectedSettings) {
            foreach ($key in $arcAgentryProtectedSettings.Keys) {
                if (-not $supportedFeatures.Contains($key.ToLower())) {
                    Write-Warning "ArcAgentry feature '${key}' is not supported for Connected Kubernetes"
                }
            }
        }
        #Endregion

        # XW TODO: helm install can be extracted as common function to be used by both Set and New
        #Region check helm install
        try {
            Set-HelmClientLocation
            $HelmVersion = helm version --template='{{.Version}}' --kubeconfig $KubeConfig
            if ($HelmVersion.Contains("v2")) {
                Write-Error "Helm version 3+ is required (not ${HelmVersion}). Learn more at https://aka.ms/arc/k8s/onboarding-helm-install"
                return
            }
            $HelmVersion = helm version --short --kubeconfig $KubeConfig

            # Compare the helm version to 3.8 in a symantic versioning valid way
            # Strip the leading "v" from the helm version and discard any metadata
            $HelmVersion = $HelmVersion.Substring(1)
            $HelmVersion = $HelmVersion.Split('+')[0]
            $helmV380 = [System.Version]::Parse("3.8.0")
            $helmThisVersion = [System.Version]::Parse($HelmVersion)
            if ($helmThisVersion -lt $helmV380) {
                Write-Error "Helm version of at least 3.8 is required for latest OCI handling."
                Return
            }
        }
        catch {
            throw "Failed to install Helm version 3+ ($_). Learn more at https://aka.ms/arc/k8s/onboarding-helm-install"
        }
        #EndRegion
        $helmClientLocation = 'helm'

        # XW TODO: can be extracted as common function to be used by both Set and New
        #Region get release namespace
        $ReleaseInstallNamespace = Get-ReleaseInstallNamespace
        $ReleaseNamespace = $null
        try {
            # !!PDS: Seems like this showing "Error: Release: Not found" is not an error but a warning that implies there just is not a release.  Can we quench this?
            $ReleaseNamespace = (helm status azure-arc -o json --kubeconfig $KubeConfig --kube-context $KubeContext -n $ReleaseInstallNamespace 2> $null | ConvertFrom-Json).namespace
        }
        catch {
            Write-Error "Fail to find the namespace for azure-arc."
        }
        #Endregion

        # XW: different with New command
        #Region validate release namespace
        if ($null -ne $ReleaseNamespace) {
            $Configmap = kubectl get configmap --namespace azure-arc azure-clusterconfig -o json --kubeconfig $KubeConfig | ConvertFrom-Json
            $ConfigmapRgName = $Configmap.data.AZURE_RESOURCE_GROUP
            $ConfigmapClusterName = $Configmap.data.AZURE_RESOURCE_NAME
            try {
                $ExistConnectedKubernetes = Get-AzConnectedKubernetes `
                    -ResourceGroupName $ConfigmapRgName `
                    -ClusterName $ConfigmapClusterName `
                    @CommonPSBoundParameters `
                    -ErrorAction 'silentlycontinue'
                $PSBoundParameters.Add('AgentPublicKeyCertificate', $ExistConnectedKubernetes.AgentPublicKeyCertificate)

                if ("Set" -contains $parameterSet) {
                    $ResourceGroupName = $InputObject.ResourceGroupName
                    $ClusterName = $InputObject.Name
                }

                if (($ResourceGroupName.ToLower() -ne $ConfigmapRgName.ToLower()) -or ($ClusterName.ToLower() -ne $ConfigmapClusterName.ToLower())) {
                    Write-Error "The provided cluster name and rg correspond to different cluster"
                    return
                }
            }
            catch {
                Write-Error "The corresponding connected cluster resource does not exist"
                return
            }
        } else {
            Write-Error "The azure-arc release namespace couldn't be retrieved, which implies that the kubernetes cluster has not been onboarded to azure-arc."
            return
        }
        #Endregion

        # TODO XW: can be extracted as common function to be used by both Set and New
        # Adding Helm repo
        if ((Test-Path Env:HELMREPONAME) -and (Test-Path Env:HELMREPOURL)) {
            $HelmRepoName = Get-ChildItem -Path Env:HELMREPONAME
            $HelmRepoUrl = Get-ChildItem -Path Env:HELMREPOURL
            helm repo add $HelmRepoName $HelmRepoUrl --kubeconfig $KubeConfig --kube-context $KubeContext
        }

        $resources = Get-Module Az.Resources -ListAvailable
        if ($null -eq $resources) {
            Write-Error "Missing required module(s): Az.Resources. Please run 'Install-Module Az.Resources -Repository PSGallery' to install Az.Resources."
            return
        }
        if (Test-Path Env:HELMREGISTRY) {
            $RegistryPath = Get-ChildItem -Path Env:HELMREGISTRY
        } else {
            $ReleaseTrain = ''
            if ((Test-Path Env:RELEASETRAIN) -and (Test-Path Env:RELEASETRAIN)) {
                $ReleaseTrain = Get-ChildItem -Path Env:RELEASETRAIN
            } else {
                $ReleaseTrain = 'stable'
            }
            $AzLocation = Get-AzLocation | Where-Object { ($_.DisplayName -ieq $Location) -or ($_.Location -ieq $Location)}
            $Region = $AzLocation.Location
            if ($null -eq $Region) {
                Write-Error "Invalid location: $Location"
                return
            } else {
                $Location = $Region
            }
            $ChartLocationUrl = "https://${Location}.dp.kubernetesconfiguration.azure.com/azure-arc-k8sagents/GetLatestHelmPackagePath?api-version=2019-11-01-preview&releaseTrain=${ReleaseTrain}"

            $Uri = [System.Uri]::New($ChartLocationUrl)
            $Account = [Microsoft.Azure.Commands.Common.Authentication.Abstractions.AzureRmProfileProvider]::Instance.Profile.DefaultContext.Account
            $Env = [Microsoft.Azure.Commands.Common.Authentication.Abstractions.AzureEnvironment]::PublicEnvironments[[Microsoft.Azure.Commands.Common.Authentication.Abstractions.EnvironmentName]::AzureCloud]
            $TenantId = [Microsoft.Azure.Commands.Common.Authentication.Abstractions.AzureRmProfileProvider]::Instance.Profile.DefaultContext.Tenant.Id
            $PromptBehavior = [Microsoft.Azure.Commands.Common.Authentication.ShowDialog]::Never
            $Token = [Microsoft.Azure.Commands.Common.Authentication.AzureSession]::Instance.AuthenticationFactory.Authenticate($account, $env, $tenantId, $null, $promptBehavior, $null)
            $AccessToken = $Token.AccessToken

            $HeaderParameter = @{
                "Authorization" = "Bearer $AccessToken"
            }

            $Response = Invoke-WebRequest -Uri $Uri -Headers $HeaderParameter -Method Post -UseBasicParsing
            if ($Response.StatusCode -eq 200) {
                $RegistryPath = ($Response.Content | ConvertFrom-Json).repositoryPath
            } else {
                Write-Error "Error while fetching helm chart registry path: ${$Response.RawContent}"
                return
            }
        }
        Set-Item -Path Env:HELM_EXPERIMENTAL_OCI -Value 1

        # $HelmChartPath = Join-Path -Path $ChartExportPath -ChildPath 'azure-arc-k8sagents'
        # if (Test-Path Env:HELMCHART) {
        #     $ChartPath = Get-ChildItem -Path Env:HELMCHART
        # } else {
        #     $ChartPath = $HelmChartPath
        # }

        # XW TODO: can be extracted as common function
        #Region helm options
        # !!PDS: The az cli also sets the "proxy" fields in the settings and
        #        passes these to Azure.  Do we need to do this as well?

        $options = ""
        $proxyEnableState = $false

        if ($null -eq $ConfigurationSetting) { 
            $ConfigurationSetting = @{}
        }
        if ($null -eq $ConfigurationProtectedSetting) {
            $ConfigurationProtectedSetting = @{}
        }

        # XW: Read settings out from InputObject
        if ("Set" -contains $parameterSet) {
            foreach ($arcAgentConfig in $InputObject.ArcAgentryConfiguration) {
                $ConfigurationSetting[$arcAgentConfig.feature] = $arcAgentConfig.settings
                $ConfigurationProtectedSetting[$arcAgentConfig.feature] = $arcAgentConfig.protectedSettings
            }
        }
        
        if (![string]::IsNullOrEmpty($HttpProxy) -or ![string]::IsNullOrEmpty($HttpsProxy) -or ![string]::IsNullOrEmpty($NoProxy) -or ![string]::IsNullOrEmpty($HttpProxy) ) {
            if (-not $ConfigurationSetting.ContainsKey("proxy")) {
                $ConfigurationSetting["proxy"] = @{}
            }
            if (-not $ConfigurationProtectedSetting.ContainsKey("proxy")) {
                $ConfigurationProtectedSetting["proxy"] = @{}
            }
        }

        if (-not ([string]::IsNullOrEmpty($HttpProxy))) {
            $HttpProxyStr = $HttpProxy.ToString()
            $HttpProxyStr = $HttpProxyStr -replace ',', '\,'
            $HttpProxyStr = $HttpProxyStr -replace '/', '\/'
            $options += " --set global.httpProxy=$HttpProxyStr"
            $proxyEnableState = $true
            $ConfigurationSetting["proxy"]["http_proxy"] = $HttpProxyStr
            $ConfigurationProtectedSetting["proxy"]["http_proxy"] = $HttpProxyStr
            # Note how we are removing k8s parameters from the list of parameters
            # to pass to the internal (creates ARM object) command.
            $Null = $PSBoundParameters.Remove('HttpProxy')
        }
        if (-not ([string]::IsNullOrEmpty($HttpsProxy))) {
            $HttpsProxyStr = $HttpsProxy.ToString()
            $HttpsProxyStr = $HttpsProxyStr -replace ',', '\,'
            $HttpsProxyStr = $HttpsProxyStr -replace '/', '\/'
            $options += " --set global.httpsProxy=$HttpsProxyStr"
            $proxyEnableState = $true
            $ConfigurationSetting["proxy"]["https_proxy"] = $HttpsProxyStr
            $ConfigurationProtectedSetting["proxy"]["https_proxy"] = $HttpsProxyStr
            $Null = $PSBoundParameters.Remove('HttpsProxy')
        }
        if (-not ([string]::IsNullOrEmpty($NoProxy))) {
            $NoProxy = $NoProxy -replace ',', '\,'
            $NoProxy = $NoProxy -replace '/', '\/'
            $options += " --set global.noProxy=$NoProxy"
            $proxyEnableState = $true
            $ConfigurationSetting["proxy"]["no_proxy"] = $NoProxy
            $ConfigurationProtectedSetting["proxy"]["no_proxy"] = $NoProxy
            $Null = $PSBoundParameters.Remove('NoProxy')
        }
        if ($proxyEnableState) {
            $options += " --set global.isProxyEnabled=true"
        }
        try {
            if ((-not ([string]::IsNullOrEmpty($ProxyCert))) -and (Test-Path $ProxyCert)) {
                $options += " --set-file global.proxyCert=$ProxyCert"
                $options += " --set global.isCustomCert=true"
                $ConfigurationSetting["proxy"]["proxy_cert"] = $ProxyCert
                $ConfigurationProtectedSetting["proxy"]["proxy_cert"] = $ProxyCert
            }
        }
        catch {
            throw "Unable to find ProxyCert from file path"
        }
        if ($DisableAutoUpgrade) {
            $options += " --set systemDefaultValues.azureArcAgents.autoUpdate=false"
            $Null = $PSBoundParameters.Remove('DisableAutoUpgrade')
        }
        if (-not ([string]::IsNullOrEmpty($ContainerLogPath))) {
            $options += " --set systemDefaultValues.fluent-bit.containerLogPath=$ContainerLogPath"
            $Null = $PSBoundParameters.Remove('ContainerLogPath')
        }
        if (-not ([string]::IsNullOrEmpty($KubeConfig))) {
            $options += " --kubeconfig $KubeConfig"
        }
        if (-not ([string]::IsNullOrEmpty($KubeContext))) {
            $options += " --kube-context $KubeContext"
        }
        if (-not ([string]::IsNullOrEmpty($CustomLocationsOid))) {
            $options += " --set systemDefaultValues.customLocations.oid=$CustomLocationsOid"
            $options += " --set systemDefaultValues.customLocations.enabled=true"
        }

        if ((-not ([string]::IsNullOrEmpty($Proxy))) -and (-not $PSBoundParameters.ContainsKey('ProxyCredential'))) {
            if (-not ([string]::IsNullOrEmpty($Proxy.UserInfo))) {
                try {
                    $userInfo = $Proxy.UserInfo -Split ':'
                    $pass = ConvertTo-SecureString $userInfo[1] -AsPlainText -Force
                    $ProxyCredential = New-Object System.Management.Automation.PSCredential ($userInfo[0] , $pass)
                    $PSBoundParameters.Add('ProxyCredential', $ProxyCredential)
                }
                catch {
                    throw "Please set ProxyCredential or provide username and password in the Proxy parameter"
                }
            }
            else {
                Write-Warning "If the proxy is a private proxy, pass ProxyCredential parameter or provide username and password in the Proxy parameter"
            }
        }
        #Endregion

        # Process the Arc agentry settings and protected settings
        # Create any empty array of IArcAgentryConfigurations.
        # shortened name to avoid class with type name.
        #
        # **NOTE** The Swagger naming does NOT match the names that will be used
        #          in the final helm values file.  Instead there needs to be an
        #          explicit mapping which is done in TWO places:
        #          1. The ConfigDP is able to map the (unprotected) settings but
        #             does not have access to the protected settings so...
        #          2. This Powershell script has to perform the mapping for
        #             protected settings.
        #
        #          This DOES mean that code changes are required both in the
        #          Config DP annd this Powershell script if a new Kubernetes 
        #          feature is added.
        
        # XW TODO: this can ve extracted as common function to be used by both Set and New
        $arcAgentryConfigs = @(
        )

        # !!PDS: The name "Setting" below is SINGULAR but in the Swagger it is PLURAL - why is this?
        if ($ConfigurationSetting) {
            foreach ($key in $ConfigurationSetting.Keys) {
                $ArcAgentryConfiguration = [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Models.Api20240701Preview.ArcAgentryConfigurations]@{
                    Feature = $key
                    Setting = $ConfigurationSetting[$key]
                }
                if ($ConfigurationProtectedSetting -and $ConfigurationProtectedSetting[$key]) {
                    $ArcAgentryConfiguration.ProtectedSetting = $ConfigurationProtectedSetting[$key]

                    # Remove this key from ConfigurationProtectedSetting.
                    $Null = $ConfigurationProtectedSetting.Remove($key)
                }
                $arcAgentryConfigs += $ArcAgentryConfiguration
            }
            $PSBoundParameters.Remove('ConfigurationSetting')
        }

        # Add the remaining (protected only) settings.
        if ($ConfigurationProtectedSetting) {
            foreach ($key in $ConfigurationProtectedSetting.Keys) {
                $ArcAgentryConfiguration = [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Models.Api20240701Preview.ArcAgentryConfigurations]@{
                    Feature = $key
                    ProtectedSetting = $ArcAgentryprotectedSettings[$key]
                }
                $argAgentryConfigs += $ArcAgentryConfiguration
            }
            $PSBoundParameters.Remove('ConfigurationProtectedSetting')
        }

        $PSBoundParameters.Add('ArcAgentryConfiguration', $arcAgentryConfigs)
        
        # A lot of what follows relies on knowing the cloud we are using and the
        # various endpoints so get that information now.
        $cloudMetadata = Get-AzCloudMetadata

        # Perform DP health check

        # !!PDS: There is no dogfood so not required?
        # $valuesFile = Get-HelmValuesFile

        $configDpinfo = Get-ConfigDPEndpoint -location ("Set" -contains $parameterSet ? $InputObject.Location : $Location) -Cloud $cloudMetadata
        $configDPEndpoint = $configDpInfo.configDPEndpoint
        $adResourceId = $configDpInfo.adResourceId

        # If the health check fails (not 200 response), an exception is thrown
        # so we can ignore the output.
        $null = Invoke-ConfigDPHealthCheck -configDPEndpoint $configDPEndpoint -Resource $adResourceId

        # This call does the "pure ARM" update of the ARM objects.
        Write-Debug "Writing Connected Kubernetes ARM objects."

        # XW TODO If we cannot generate internal Set command, use New
        # Re-put here
        $Response = Az.ConnectedKubernetes.internal\New-AzConnectedKubernetes @PSBoundParameters

        # XW TODO: remove this block if we cannot use internal Set command
        #Region Set with inputObject
        # if ('Set' -contains $parameterSet){
        #     $connectedCluster = $InputObject
        # }

        # if ('SetExpanded' -contains $parameterSet) {
        #     $connectedCluster = $ExistConnectedKubernetes
        # }
 
        # $Response = Az.ConnectedKubernetes.internal\Set-AzConnectedKubernetes ---InputObject $connectedCluster @PSBoundParameters
        #Enendregion

        # Retrieving Helm chart OCI (Open Container Initiative) Artifact location
        Write-Debug "Retrieving Helm chart OCI (Open Container Initiative) Artifact location."
        Write-Debug "PUT response: $Response"
        $ResponseStr = "$Response"
        $helmValuesDp = Get-HelmValues `
            -configDPEndpoint $configDPEndpoint `
            -releaseTrain $ReleaseTrain `
            -requestBody $ResponseStr `
            -Verbose:($PSCmdlet.MyInvocation.BoundParameters["Verbose"].IsPresent -eq $true) `
            -Debug:($PSCmdlet.MyInvocation.BoundParameters["Debug"].IsPresent -eq $true)

        Write-Debug "helmValuesDp: $helmValuesDp"
        Write-Debug "OCI Artifact location: ${helmValuesDp.repositoryPath}."

        # Allow a custom OCI registry to be set via environment variables.
        # !!PDS: Where are these variables documented?  Should they be?
        #
        # AZURE_ACCESS_TOKEN
        # HELMCHART
        # HELMREGISTRY
        # HELMVALUESPATH
        # RELEASETRAIN
        # USERPROFILE
        #
        $registryPath = if ($env:HELMREGISTRY) { $env:HELMREGISTRY } else { $helmValuesDp.repositoryPath }
        Write-Debug "RegistryPath: ${registryPath}."

        $helmValuesContent = $helmValuesDp.helmValuesContent
        Write-Debug "Helm values: ${helmValuesContent}."

        foreach ($field in $helmValuesContent.PSObject.Properties) {
            if ($field.Name -in @("global.httpsProxy", "global.httpProxy", "global.noProxy", "global.proxyCert")) {
                continue
            }
            $options += " --set $($field.Name)=$($field.Value)"
        }
        
        # Set agent version in registry path
        if ($ExistConnectedKubernetes.AgentVersion) {
            $repositoryPath = $repositoryPath -replace "(?<=:).*", $ExistConnectedKubernetes.AgentVersion
        }

        # Get helm chart path (within the OCI registry).
        $chartPath = Get-HelmChartPath -registryPath $registryPath -kubeConfig $KubeConfig -kubeContext $KubeContext -helmClientLocation $HelmClientLocation
        if (Test-Path Env:HELMCHART) {
            $ChartPath = Get-ChildItem -Path Env:HELMCHART
        }

        # Get curren helm values
        try {
            $userValuesLocation = Join-Path $env:USERPROFILE ".azure\userValues.txt"

            helm get values azure-arc `
            --debug `
            --namespace $ReleaseInstallNamespace `
            --kubeconfig $KubeConfig `
            --kube-context $KubeContext > $userValuesLocation

        } catch {
            throw "Unable to get helm values"
        }

        try {
            helm upgrade `
            --debug `
            azure-arc `
            $ChartPath `
            --namespace $ReleaseInstallNamespace `
            -f $userValuesLocation `
            --wait (-split $options)
        } catch {
            throw "Unable to install helm release"
        }
        Return $Response
    }
}

