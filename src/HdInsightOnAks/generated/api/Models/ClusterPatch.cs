// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models
{
    using static Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Extensions;

    /// <summary>The patch for a cluster.</summary>
    public partial class ClusterPatch :
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatch,
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchInternal,
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.IValidates
    {
        /// <summary>
        /// Backing field for Inherited model <see cref= "Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResource"
        /// />
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResource __trackedResource = new Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.TrackedResource();

        /// <summary>True if stderror is enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? ApplicationLogStdErrorEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ApplicationLogStdErrorEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ApplicationLogStdErrorEnabled = value ?? default(bool); }

        /// <summary>True if stdout is enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? ApplicationLogStdOutEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ApplicationLogStdOutEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ApplicationLogStdOutEnabled = value ?? default(bool); }

        /// <summary>AAD group Ids authorized for data plane access.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> AuthorizationProfileGroupId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).AuthorizationProfileGroupId; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).AuthorizationProfileGroupId = value ?? null /* arrayOf */; }

        /// <summary>AAD user Ids authorized for data plane access.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> AuthorizationProfileUserId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).AuthorizationProfileUserId; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).AuthorizationProfileUserId = value ?? null /* arrayOf */; }

        /// <summary>
        /// User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string AutoscaleProfileAutoscaleType { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).AutoscaleProfileAutoscaleType; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).AutoscaleProfileAutoscaleType = value ?? null; }

        /// <summary>This indicates whether auto scale is enabled on HDInsight on AKS cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? AutoscaleProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).AutoscaleProfileEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).AutoscaleProfileEnabled = value ?? default(bool); }

        /// <summary>
        /// This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes
        /// place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING
        /// node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? AutoscaleProfileGracefulDecommissionTimeout { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).AutoscaleProfileGracefulDecommissionTimeout; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).AutoscaleProfileGracefulDecommissionTimeout = value ?? default(int); }

        /// <summary>The script action profile list.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScriptActionProfile> ClusterProfileScriptActionProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ClusterProfileScriptActionProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ClusterProfileScriptActionProfile = value ?? null /* arrayOf */; }

        /// <summary>The service configs profiles.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterServiceConfigsProfile> ClusterProfileServiceConfigsProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ClusterProfileServiceConfigsProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ClusterProfileServiceConfigsProfile = value ?? null /* arrayOf */; }

        /// <summary>
        /// Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public string Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Id; }

        /// <summary>
        /// This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between
        /// a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers
        /// it. The default value is 300 seconds.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? LoadBasedConfigCooldownPeriod { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).LoadBasedConfigCooldownPeriod; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).LoadBasedConfigCooldownPeriod = value ?? default(int); }

        /// <summary>
        /// User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? LoadBasedConfigMaxNode { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).LoadBasedConfigMaxNode; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).LoadBasedConfigMaxNode = value ?? default(int); }

        /// <summary>
        /// User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? LoadBasedConfigMinNode { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).LoadBasedConfigMinNode; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).LoadBasedConfigMinNode = value ?? default(int); }

        /// <summary>
        /// User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering
        /// a scaling operation.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? LoadBasedConfigPollInterval { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).LoadBasedConfigPollInterval; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).LoadBasedConfigPollInterval = value ?? default(int); }

        /// <summary>The scaling rules.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScalingRule> LoadBasedConfigScalingRule { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).LoadBasedConfigScalingRule; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).LoadBasedConfigScalingRule = value ?? null /* arrayOf */; }

        /// <summary>The geo-location where the resource lives</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public string Location { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResourceInternal)__trackedResource).Location; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResourceInternal)__trackedResource).Location = value ; }

        /// <summary>True if log analytics is enabled for the cluster, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? LogAnalyticProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).LogAnalyticProfileEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).LogAnalyticProfileEnabled = value ?? default(bool); }

        /// <summary>True if metrics are enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? LogAnalyticProfileMetricsEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).LogAnalyticProfileMetricsEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).LogAnalyticProfileMetricsEnabled = value ?? default(bool); }

        /// <summary>Internal Acessors for AutoscaleProfileLoadBasedConfig</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ILoadBasedConfig Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchInternal.AutoscaleProfileLoadBasedConfig { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).AutoscaleProfileLoadBasedConfig; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).AutoscaleProfileLoadBasedConfig = value; }

        /// <summary>Internal Acessors for AutoscaleProfileScheduleBasedConfig</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScheduleBasedConfig Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchInternal.AutoscaleProfileScheduleBasedConfig { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).AutoscaleProfileScheduleBasedConfig; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).AutoscaleProfileScheduleBasedConfig = value; }

        /// <summary>Internal Acessors for ClusterProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchInternal.ClusterProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ClusterProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ClusterProfile = value; }

        /// <summary>Internal Acessors for ClusterProfileAuthorizationProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IAuthorizationProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchInternal.ClusterProfileAuthorizationProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ClusterProfileAuthorizationProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ClusterProfileAuthorizationProfile = value; }

        /// <summary>Internal Acessors for ClusterProfileAutoscaleProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IAutoscaleProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchInternal.ClusterProfileAutoscaleProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ClusterProfileAutoscaleProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ClusterProfileAutoscaleProfile = value; }

        /// <summary>Internal Acessors for ClusterProfileLogAnalyticsProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterLogAnalyticsProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchInternal.ClusterProfileLogAnalyticsProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ClusterProfileLogAnalyticsProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ClusterProfileLogAnalyticsProfile = value; }

        /// <summary>Internal Acessors for ClusterProfilePrometheusProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPrometheusProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchInternal.ClusterProfilePrometheusProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ClusterProfilePrometheusProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ClusterProfilePrometheusProfile = value; }

        /// <summary>Internal Acessors for ClusterProfileSshProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISshProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchInternal.ClusterProfileSshProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ClusterProfileSshProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ClusterProfileSshProfile = value; }

        /// <summary>Internal Acessors for LogAnalyticProfileApplicationLog</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterLogAnalyticsApplicationLogs Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchInternal.LogAnalyticProfileApplicationLog { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).LogAnalyticProfileApplicationLog; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).LogAnalyticProfileApplicationLog = value; }

        /// <summary>Internal Acessors for Property</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchProperties Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchInternal.Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ClusterPatchProperties()); set { {_property = value;} } }

        /// <summary>Internal Acessors for SshProfilePodPrefix</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchInternal.SshProfilePodPrefix { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).SshProfilePodPrefix; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).SshProfilePodPrefix = value; }

        /// <summary>Internal Acessors for Id</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal.Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Id = value; }

        /// <summary>Internal Acessors for Name</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal.Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Name = value; }

        /// <summary>Internal Acessors for SystemData</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISystemData Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal.SystemData { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemData; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemData = value; }

        /// <summary>Internal Acessors for Type</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal.Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Type = value; }

        /// <summary>The name of the resource</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public string Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Name; }

        /// <summary>Enable Prometheus for cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? PrometheuProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).PrometheuProfileEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).PrometheuProfileEnabled = value ?? default(bool); }

        /// <summary>Backing field for <see cref="Property" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchProperties _property;

        /// <summary>Define cluster patch specific properties.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchProperties Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ClusterPatchProperties()); set => this._property = value; }

        /// <summary>
        /// Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are
        /// default when an specified scaling operation is executed (scale up/scale down)
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? ScheduleBasedConfigDefaultCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ScheduleBasedConfigDefaultCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ScheduleBasedConfigDefaultCount = value ?? default(int); }

        /// <summary>
        /// This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules
        /// within the schedule across days and times (start/end).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISchedule> ScheduleBasedConfigSchedule { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ScheduleBasedConfigSchedule; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ScheduleBasedConfigSchedule = value ?? null /* arrayOf */; }

        /// <summary>
        /// User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string ScheduleBasedConfigTimeZone { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ScheduleBasedConfigTimeZone; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).ScheduleBasedConfigTimeZone = value ?? null; }

        /// <summary>Number of ssh pods per cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? SshProfileCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).SshProfileCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).SshProfileCount = value ?? default(int); }

        /// <summary>
        /// Prefix of the pod names. Pod number will be appended to the prefix. The ingress URLs for the pods will be available at
        /// <clusterFqdn>/<sshBasePath>/<prefix>-<number>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string SshProfilePodPrefix { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal)Property).SshProfilePodPrefix; }

        /// <summary>
        /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        internal Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISystemData SystemData { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemData; }

        /// <summary>The timestamp of resource creation (UTC).</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public global::System.DateTime? SystemDataCreatedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataCreatedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataCreatedAt = value ?? default(global::System.DateTime); }

        /// <summary>The identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public string SystemDataCreatedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataCreatedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataCreatedBy = value ?? null; }

        /// <summary>The type of identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public string SystemDataCreatedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataCreatedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataCreatedByType = value ?? null; }

        /// <summary>The timestamp of resource last modification (UTC)</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public global::System.DateTime? SystemDataLastModifiedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedAt = value ?? default(global::System.DateTime); }

        /// <summary>The identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public string SystemDataLastModifiedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedBy = value ?? null; }

        /// <summary>The type of identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public string SystemDataLastModifiedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedByType = value ?? null; }

        /// <summary>Resource tags.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResourceTags Tag { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResourceInternal)__trackedResource).Tag; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResourceInternal)__trackedResource).Tag = value ?? null /* model class */; }

        /// <summary>
        /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public string Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Type; }

        /// <summary>Creates an new <see cref="ClusterPatch" /> instance.</summary>
        public ClusterPatch()
        {

        }

        /// <summary>Validates that this object meets the validation criteria.</summary>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.IEventListener" /> instance that will receive validation
        /// events.</param>
        /// <returns>
        /// A <see cref = "global::System.Threading.Tasks.Task" /> that will be complete when validation is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task Validate(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.IEventListener eventListener)
        {
            await eventListener.AssertNotNull(nameof(__trackedResource), __trackedResource);
            await eventListener.AssertObjectIsValid(nameof(__trackedResource), __trackedResource);
        }
    }
    /// The patch for a cluster.
    public partial interface IClusterPatch :
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.IJsonSerializable,
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResource
    {
        /// <summary>True if stderror is enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if stderror is enabled, otherwise false.",
        SerializedName = @"stdErrorEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ApplicationLogStdErrorEnabled { get; set; }
        /// <summary>True if stdout is enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if stdout is enabled, otherwise false.",
        SerializedName = @"stdOutEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ApplicationLogStdOutEnabled { get; set; }
        /// <summary>AAD group Ids authorized for data plane access.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"AAD group Ids authorized for data plane access.",
        SerializedName = @"groupIds",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> AuthorizationProfileGroupId { get; set; }
        /// <summary>AAD user Ids authorized for data plane access.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"AAD user Ids authorized for data plane access.",
        SerializedName = @"userIds",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> AuthorizationProfileUserId { get; set; }
        /// <summary>
        /// User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.",
        SerializedName = @"autoscaleType",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("ScheduleBased", "LoadBased")]
        string AutoscaleProfileAutoscaleType { get; set; }
        /// <summary>This indicates whether auto scale is enabled on HDInsight on AKS cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This indicates whether auto scale is enabled on HDInsight on AKS cluster.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AutoscaleProfileEnabled { get; set; }
        /// <summary>
        /// This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes
        /// place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING
        /// node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.",
        SerializedName = @"gracefulDecommissionTimeout",
        PossibleTypes = new [] { typeof(int) })]
        int? AutoscaleProfileGracefulDecommissionTimeout { get; set; }
        /// <summary>The script action profile list.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The script action profile list.",
        SerializedName = @"scriptActionProfiles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScriptActionProfile) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScriptActionProfile> ClusterProfileScriptActionProfile { get; set; }
        /// <summary>The service configs profiles.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The service configs profiles.",
        SerializedName = @"serviceConfigsProfiles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterServiceConfigsProfile) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterServiceConfigsProfile> ClusterProfileServiceConfigsProfile { get; set; }
        /// <summary>
        /// This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between
        /// a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers
        /// it. The default value is 300 seconds.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers it. The default value is 300 seconds.",
        SerializedName = @"cooldownPeriod",
        PossibleTypes = new [] { typeof(int) })]
        int? LoadBasedConfigCooldownPeriod { get; set; }
        /// <summary>
        /// User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.",
        SerializedName = @"maxNodes",
        PossibleTypes = new [] { typeof(int) })]
        int? LoadBasedConfigMaxNode { get; set; }
        /// <summary>
        /// User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.",
        SerializedName = @"minNodes",
        PossibleTypes = new [] { typeof(int) })]
        int? LoadBasedConfigMinNode { get; set; }
        /// <summary>
        /// User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering
        /// a scaling operation.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering a scaling operation.",
        SerializedName = @"pollInterval",
        PossibleTypes = new [] { typeof(int) })]
        int? LoadBasedConfigPollInterval { get; set; }
        /// <summary>The scaling rules.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The scaling rules.",
        SerializedName = @"scalingRules",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScalingRule) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScalingRule> LoadBasedConfigScalingRule { get; set; }
        /// <summary>True if log analytics is enabled for the cluster, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if log analytics is enabled for the cluster, otherwise false.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? LogAnalyticProfileEnabled { get; set; }
        /// <summary>True if metrics are enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if metrics are enabled, otherwise false.",
        SerializedName = @"metricsEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? LogAnalyticProfileMetricsEnabled { get; set; }
        /// <summary>Enable Prometheus for cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Enable Prometheus for cluster or not.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? PrometheuProfileEnabled { get; set; }
        /// <summary>
        /// Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are
        /// default when an specified scaling operation is executed (scale up/scale down)
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are default when an specified scaling operation is executed (scale up/scale down)",
        SerializedName = @"defaultCount",
        PossibleTypes = new [] { typeof(int) })]
        int? ScheduleBasedConfigDefaultCount { get; set; }
        /// <summary>
        /// This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules
        /// within the schedule across days and times (start/end).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules within the schedule across days and times (start/end).",
        SerializedName = @"schedules",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISchedule) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISchedule> ScheduleBasedConfigSchedule { get; set; }
        /// <summary>
        /// User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.",
        SerializedName = @"timeZone",
        PossibleTypes = new [] { typeof(string) })]
        string ScheduleBasedConfigTimeZone { get; set; }
        /// <summary>Number of ssh pods per cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Number of ssh pods per cluster.",
        SerializedName = @"count",
        PossibleTypes = new [] { typeof(int) })]
        int? SshProfileCount { get; set; }
        /// <summary>
        /// Prefix of the pod names. Pod number will be appended to the prefix. The ingress URLs for the pods will be available at
        /// <clusterFqdn>/<sshBasePath>/<prefix>-<number>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Prefix of the pod names. Pod number will be appended to the prefix. The ingress URLs for the pods will be available at <clusterFqdn>/<sshBasePath>/<prefix>-<number>",
        SerializedName = @"podPrefix",
        PossibleTypes = new [] { typeof(string) })]
        string SshProfilePodPrefix { get;  }

    }
    /// The patch for a cluster.
    internal partial interface IClusterPatchInternal :
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResourceInternal
    {
        /// <summary>True if stderror is enabled, otherwise false.</summary>
        bool? ApplicationLogStdErrorEnabled { get; set; }
        /// <summary>True if stdout is enabled, otherwise false.</summary>
        bool? ApplicationLogStdOutEnabled { get; set; }
        /// <summary>AAD group Ids authorized for data plane access.</summary>
        System.Collections.Generic.List<string> AuthorizationProfileGroupId { get; set; }
        /// <summary>AAD user Ids authorized for data plane access.</summary>
        System.Collections.Generic.List<string> AuthorizationProfileUserId { get; set; }
        /// <summary>
        /// User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("ScheduleBased", "LoadBased")]
        string AutoscaleProfileAutoscaleType { get; set; }
        /// <summary>This indicates whether auto scale is enabled on HDInsight on AKS cluster.</summary>
        bool? AutoscaleProfileEnabled { get; set; }
        /// <summary>
        /// This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes
        /// place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING
        /// node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        /// </summary>
        int? AutoscaleProfileGracefulDecommissionTimeout { get; set; }
        /// <summary>Profiles of load based Autoscale.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ILoadBasedConfig AutoscaleProfileLoadBasedConfig { get; set; }
        /// <summary>Profiles of schedule based Autoscale.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScheduleBasedConfig AutoscaleProfileScheduleBasedConfig { get; set; }
        /// <summary>Cluster resource patch properties.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfile ClusterProfile { get; set; }
        /// <summary>
        /// Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IAuthorizationProfile ClusterProfileAuthorizationProfile { get; set; }
        /// <summary>
        /// This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IAutoscaleProfile ClusterProfileAutoscaleProfile { get; set; }
        /// <summary>Cluster log analytics profile to enable or disable OMS agent for cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterLogAnalyticsProfile ClusterProfileLogAnalyticsProfile { get; set; }
        /// <summary>Cluster Prometheus profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPrometheusProfile ClusterProfilePrometheusProfile { get; set; }
        /// <summary>The script action profile list.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScriptActionProfile> ClusterProfileScriptActionProfile { get; set; }
        /// <summary>The service configs profiles.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterServiceConfigsProfile> ClusterProfileServiceConfigsProfile { get; set; }
        /// <summary>Ssh profile for the cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISshProfile ClusterProfileSshProfile { get; set; }
        /// <summary>
        /// This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between
        /// a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers
        /// it. The default value is 300 seconds.
        /// </summary>
        int? LoadBasedConfigCooldownPeriod { get; set; }
        /// <summary>
        /// User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        int? LoadBasedConfigMaxNode { get; set; }
        /// <summary>
        /// User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        int? LoadBasedConfigMinNode { get; set; }
        /// <summary>
        /// User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering
        /// a scaling operation.
        /// </summary>
        int? LoadBasedConfigPollInterval { get; set; }
        /// <summary>The scaling rules.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScalingRule> LoadBasedConfigScalingRule { get; set; }
        /// <summary>Collection of logs to be enabled or disabled for log analytics.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterLogAnalyticsApplicationLogs LogAnalyticProfileApplicationLog { get; set; }
        /// <summary>True if log analytics is enabled for the cluster, otherwise false.</summary>
        bool? LogAnalyticProfileEnabled { get; set; }
        /// <summary>True if metrics are enabled, otherwise false.</summary>
        bool? LogAnalyticProfileMetricsEnabled { get; set; }
        /// <summary>Enable Prometheus for cluster or not.</summary>
        bool? PrometheuProfileEnabled { get; set; }
        /// <summary>Define cluster patch specific properties.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchProperties Property { get; set; }
        /// <summary>
        /// Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are
        /// default when an specified scaling operation is executed (scale up/scale down)
        /// </summary>
        int? ScheduleBasedConfigDefaultCount { get; set; }
        /// <summary>
        /// This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules
        /// within the schedule across days and times (start/end).
        /// </summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISchedule> ScheduleBasedConfigSchedule { get; set; }
        /// <summary>
        /// User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        /// </summary>
        string ScheduleBasedConfigTimeZone { get; set; }
        /// <summary>Number of ssh pods per cluster.</summary>
        int? SshProfileCount { get; set; }
        /// <summary>
        /// Prefix of the pod names. Pod number will be appended to the prefix. The ingress URLs for the pods will be available at
        /// <clusterFqdn>/<sshBasePath>/<prefix>-<number>
        /// </summary>
        string SshProfilePodPrefix { get; set; }

    }
}