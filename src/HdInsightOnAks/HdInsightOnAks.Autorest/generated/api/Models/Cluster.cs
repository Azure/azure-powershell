// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models
{
    using static Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Extensions;

    /// <summary>The cluster.</summary>
    [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.DoNotFormat]
    public partial class Cluster :
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ICluster,
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal,
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.IValidates
    {
        /// <summary>
        /// Backing field for Inherited model <see cref= "Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResource"
        /// />
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResource __trackedResource = new Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.TrackedResource();

        /// <summary>
        /// Whether to create cluster using private IP instead of public IP. This property must be set at create time.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? AccessProfileEnableInternalIngress { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterAccessProfileEnableInternalIngress; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterAccessProfileEnableInternalIngress = value ?? default(bool); }

        /// <summary>
        /// Private link service resource ID. Only when enableInternalIngress is true, this property will be returned.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string AccessProfilePrivateLinkServiceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterAccessProfilePrivateLinkServiceId; }

        /// <summary>True if stderror is enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? ApplicationLogStdErrorEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ApplicationLogStdErrorEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ApplicationLogStdErrorEnabled = value ?? default(bool); }

        /// <summary>True if stdout is enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? ApplicationLogStdOutEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ApplicationLogStdOutEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ApplicationLogStdOutEnabled = value ?? default(bool); }

        /// <summary>AAD group Ids authorized for data plane access.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> AuthorizationProfileGroupId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).AuthorizationProfileGroupId; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).AuthorizationProfileGroupId = value ?? null /* arrayOf */; }

        /// <summary>AAD user Ids authorized for data plane access.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> AuthorizationProfileUserId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).AuthorizationProfileUserId; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).AuthorizationProfileUserId = value ?? null /* arrayOf */; }

        /// <summary>
        /// User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string AutoscaleProfileAutoscaleType { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).AutoscaleProfileAutoscaleType; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).AutoscaleProfileAutoscaleType = value ?? null; }

        /// <summary>This indicates whether auto scale is enabled on HDInsight on AKS cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? AutoscaleProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).AutoscaleProfileEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).AutoscaleProfileEnabled = value ?? default(bool); }

        /// <summary>
        /// This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes
        /// place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING
        /// node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? AutoscaleProfileGracefulDecommissionTimeout { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).AutoscaleProfileGracefulDecommissionTimeout; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).AutoscaleProfileGracefulDecommissionTimeout = value ?? default(int); }

        /// <summary>The type of cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string ClusterType { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterType; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterType = value ?? null; }

        /// <summary>The nodes definitions.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.INodeProfile> ComputeProfileNode { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ComputeProfileNode; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ComputeProfileNode = value ?? null /* arrayOf */; }

        /// <summary>bootstrap server connectivity endpoint.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string ConnectivityEndpointBootstrapServerEndpoint { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ConnectivityEndpointBootstrapServerEndpoint; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ConnectivityEndpointBootstrapServerEndpoint = value ?? null; }

        /// <summary>Kafka broker endpoint list.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> ConnectivityEndpointBrokerEndpoint { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ConnectivityEndpointBrokerEndpoint; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ConnectivityEndpointBrokerEndpoint = value ?? null /* arrayOf */; }

        /// <summary>List of SSH connectivity endpoints.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISshConnectivityEndpoint> ConnectivityProfileSsh { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ConnectivityProfileSsh; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ConnectivityProfileSsh = value ?? null /* arrayOf */; }

        /// <summary>The flag that if enable debug or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? CoordinatorDebugEnable { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).CoordinatorDebugEnable; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).CoordinatorDebugEnable = value ?? default(bool); }

        /// <summary>The debug port.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? CoordinatorDebugPort { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).CoordinatorDebugPort; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).CoordinatorDebugPort = value ?? default(int); }

        /// <summary>The flag that if suspend debug or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? CoordinatorDebugSuspend { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).CoordinatorDebugSuspend; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).CoordinatorDebugSuspend = value ?? default(bool); }

        /// <summary>
        /// The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node.
        /// Default: true.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? CoordinatorHighAvailabilityEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).CoordinatorHighAvailabilityEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).CoordinatorHighAvailabilityEnabled = value ?? default(bool); }

        /// <summary>The database URL</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string DatabaseHost { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).DatabaseHost; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).DatabaseHost = value ?? null; }

        /// <summary>The database name</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string DatabaseName { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).DatabaseName; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).DatabaseName = value ?? null; }

        /// <summary>Reference for the database password</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string DatabasePasswordSecretRef { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).DatabasePasswordSecretRef; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).DatabasePasswordSecretRef = value ?? null; }

        /// <summary>The name of the database user</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string DatabaseUsername { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).DatabaseUsername; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).DatabaseUsername = value ?? null; }

        /// <summary>A unique id generated by the RP to identify the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string DeploymentId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).DeploymentId; }

        /// <summary>
        /// Managed Disk size in GB. The maximum supported disk size for Standard and Premium HDD/SSD is 32TB, except for Premium
        /// SSD v2, which supports up to 64TB.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? DiskStorageDataDiskSize { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).DiskStorageDataDiskSize; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).DiskStorageDataDiskSize = value ?? default(int); }

        /// <summary>Managed Disk Type.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string DiskStorageDataDiskType { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).DiskStorageDataDiskType; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).DiskStorageDataDiskType = value ?? null; }

        /// <summary>
        /// A string property that indicates the deployment mode of Flink cluster. It can have one of the following enum values =>
        /// Application, Session. Default value is Session
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string FlinkProfileDeploymentMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileDeploymentMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileDeploymentMode = value ?? null; }

        /// <summary>The number of task managers.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? FlinkProfileNumReplica { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileNumReplica; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileNumReplica = value ?? default(int); }

        /// <summary>The required CPU.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public float? HistoryServerCpu { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).HistoryServerCpu; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).HistoryServerCpu = value ?? default(float); }

        /// <summary>The required memory in MB, Container memory will be 110 percentile</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public long? HistoryServerMemory { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).HistoryServerMemory; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).HistoryServerMemory = value ?? default(long); }

        /// <summary>
        /// The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string HiveMetastoreDbConnectionAuthenticationMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).HiveMetastoreDbConnectionAuthenticationMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).HiveMetastoreDbConnectionAuthenticationMode = value ?? null; }

        /// <summary>
        /// Secret reference name from secretsProfile.secrets containing password for database connection.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string HiveMetastoreDbConnectionPasswordSecret { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).HiveMetastoreDbConnectionPasswordSecret; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).HiveMetastoreDbConnectionPasswordSecret = value ?? null; }

        /// <summary>Connection string for hive metastore database.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string HiveMetastoreDbConnectionUrl { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).HiveMetastoreDbConnectionUrl; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).HiveMetastoreDbConnectionUrl = value ?? null; }

        /// <summary>User name for database connection.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string HiveMetastoreDbConnectionUserName { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).HiveMetastoreDbConnectionUserName; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).HiveMetastoreDbConnectionUserName = value ?? null; }

        /// <summary>
        /// Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public string Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Id; }

        /// <summary>ClientId of the MSI.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string IdentityMsiClientId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterIdentityMsiClientId; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterIdentityMsiClientId = value ?? null; }

        /// <summary>ObjectId of the MSI.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string IdentityMsiObjectId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterIdentityMsiObjectId; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterIdentityMsiObjectId = value ?? null; }

        /// <summary>ResourceId of the MSI.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string IdentityMsiResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterIdentityMsiResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterIdentityMsiResourceId = value ?? null; }

        /// <summary>ClientId of the MSI.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string IdentityProfileMsiClientId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).IdentityProfileMsiClientId; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).IdentityProfileMsiClientId = value ?? null; }

        /// <summary>ObjectId of the MSI.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string IdentityProfileMsiObjectId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).IdentityProfileMsiObjectId; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).IdentityProfileMsiObjectId = value ?? null; }

        /// <summary>ResourceId of the MSI.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string IdentityProfileMsiResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).IdentityProfileMsiResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).IdentityProfileMsiResourceId = value ?? null; }

        /// <summary>The required CPU.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public float? JobManagerCpu { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).JobManagerCpu; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).JobManagerCpu = value ?? default(float); }

        /// <summary>The required memory in MB, Container memory will be 110 percentile</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public long? JobManagerMemory { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).JobManagerMemory; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).JobManagerMemory = value ?? default(long); }

        /// <summary>
        /// A string property representing additional JVM arguments for the Flink job. It should be space separated value.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string JobSpecArg { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).JobSpecArg; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).JobSpecArg = value ?? null; }

        /// <summary>
        /// A string property that specifies the entry class for the Flink job. If not specified, the entry point is auto-detected
        /// from the flink job jar package.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string JobSpecEntryClass { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).JobSpecEntryClass; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).JobSpecEntryClass = value ?? null; }

        /// <summary>A string property that represents the name of the job JAR.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string JobSpecJarName { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).JobSpecJarName; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).JobSpecJarName = value ?? null; }

        /// <summary>A string property that specifies the directory where the job JAR is located.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string JobSpecJobJarDirectory { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).JobSpecJobJarDirectory; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).JobSpecJobJarDirectory = value ?? null; }

        /// <summary>A string property that represents the name of the savepoint for the Flink job</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string JobSpecSavePointName { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).JobSpecSavePointName; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).JobSpecSavePointName = value ?? null; }

        /// <summary>
        /// A string property that indicates the upgrade mode to be performed on the Flink job. It can have one of the following enum
        /// values => STATELESS_UPDATE, UPDATE, LAST_STATE_UPDATE.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string JobSpecUpgradeMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).JobSpecUpgradeMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).JobSpecUpgradeMode = value ?? null; }

        /// <summary>Expose Kafka cluster in KRaft mode.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? KafkaProfileEnableKRaft { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).KafkaProfileEnableKRaft; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).KafkaProfileEnableKRaft = value ?? default(bool); }

        /// <summary>Expose worker nodes as public endpoints.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? KafkaProfileEnablePublicEndpoint { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).KafkaProfileEnablePublicEndpoint; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).KafkaProfileEnablePublicEndpoint = value ?? default(bool); }

        /// <summary>Fully qualified path of Azure Storage container used for Tiered Storage.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string KafkaProfileRemoteStorageUri { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).KafkaProfileRemoteStorageUri; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).KafkaProfileRemoteStorageUri = value ?? null; }

        /// <summary>
        /// This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between
        /// a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers
        /// it. The default value is 300 seconds.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? LoadBasedConfigCooldownPeriod { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).LoadBasedConfigCooldownPeriod; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).LoadBasedConfigCooldownPeriod = value ?? default(int); }

        /// <summary>
        /// User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? LoadBasedConfigMaxNode { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).LoadBasedConfigMaxNode; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).LoadBasedConfigMaxNode = value ?? default(int); }

        /// <summary>
        /// User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? LoadBasedConfigMinNode { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).LoadBasedConfigMinNode; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).LoadBasedConfigMinNode = value ?? default(int); }

        /// <summary>
        /// User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering
        /// a scaling operation.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? LoadBasedConfigPollInterval { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).LoadBasedConfigPollInterval; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).LoadBasedConfigPollInterval = value ?? default(int); }

        /// <summary>The scaling rules.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScalingRule> LoadBasedConfigScalingRule { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).LoadBasedConfigScalingRule; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).LoadBasedConfigScalingRule = value ?? null /* arrayOf */; }

        /// <summary>The geo-location where the resource lives</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public string Location { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResourceInternal)__trackedResource).Location; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResourceInternal)__trackedResource).Location = value ; }

        /// <summary>True if log analytics is enabled for the cluster, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? LogAnalyticProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).LogAnalyticProfileEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).LogAnalyticProfileEnabled = value ?? default(bool); }

        /// <summary>True if metrics are enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? LogAnalyticProfileMetricsEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).LogAnalyticProfileMetricsEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).LogAnalyticProfileMetricsEnabled = value ?? default(bool); }

        /// <summary>
        /// The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string MetastoreSpecDbConnectionAuthenticationMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).MetastoreSpecDbConnectionAuthenticationMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).MetastoreSpecDbConnectionAuthenticationMode = value ?? null; }

        /// <summary>The database name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string MetastoreSpecDbName { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).MetastoreSpecDbName; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).MetastoreSpecDbName = value ?? null; }

        /// <summary>The secret name which contains the database user password.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string MetastoreSpecDbPasswordSecretName { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).MetastoreSpecDbPasswordSecretName; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).MetastoreSpecDbPasswordSecretName = value ?? null; }

        /// <summary>The database server host.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string MetastoreSpecDbServerHost { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).MetastoreSpecDbServerHost; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).MetastoreSpecDbServerHost = value ?? null; }

        /// <summary>The database user name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string MetastoreSpecDbUserName { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).MetastoreSpecDbUserName; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).MetastoreSpecDbUserName = value ?? null; }

        /// <summary>The key vault resource id.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string MetastoreSpecKeyVaultId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).MetastoreSpecKeyVaultId; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).MetastoreSpecKeyVaultId = value ?? null; }

        /// <summary>The thrift url.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string MetastoreSpecThriftUrl { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).MetastoreSpecThriftUrl; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).MetastoreSpecThriftUrl = value ?? null; }

        /// <summary>Internal Acessors for AccessProfilePrivateLinkServiceId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.AccessProfilePrivateLinkServiceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterAccessProfilePrivateLinkServiceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterAccessProfilePrivateLinkServiceId = value; }

        /// <summary>Internal Acessors for AutoscaleProfileLoadBasedConfig</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ILoadBasedConfig Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.AutoscaleProfileLoadBasedConfig { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).AutoscaleProfileLoadBasedConfig; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).AutoscaleProfileLoadBasedConfig = value; }

        /// <summary>Internal Acessors for AutoscaleProfileScheduleBasedConfig</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScheduleBasedConfig Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.AutoscaleProfileScheduleBasedConfig { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).AutoscaleProfileScheduleBasedConfig; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).AutoscaleProfileScheduleBasedConfig = value; }

        /// <summary>Internal Acessors for ComputeProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IComputeProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ComputeProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ComputeProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ComputeProfile = value; }

        /// <summary>Internal Acessors for ConnectivityProfileWeb</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IConnectivityProfileWeb Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ConnectivityProfileWeb { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ConnectivityProfileWeb; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ConnectivityProfileWeb = value; }

        /// <summary>Internal Acessors for CoordinatorDebug</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoDebugConfig Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.CoordinatorDebug { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).CoordinatorDebug; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).CoordinatorDebug = value; }

        /// <summary>Internal Acessors for DeploymentId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.DeploymentId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).DeploymentId; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).DeploymentId = value; }

        /// <summary>Internal Acessors for FlinkProfileCatalogOption</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IFlinkCatalogOptions Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.FlinkProfileCatalogOption { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileCatalogOption; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileCatalogOption = value; }

        /// <summary>Internal Acessors for FlinkProfileCatalogOptionsHive</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IFlinkHiveCatalogOption Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.FlinkProfileCatalogOptionsHive { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileCatalogOptionsHive; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileCatalogOptionsHive = value; }

        /// <summary>Internal Acessors for FlinkProfileHistoryServer</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IComputeResourceDefinition Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.FlinkProfileHistoryServer { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileHistoryServer; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileHistoryServer = value; }

        /// <summary>Internal Acessors for FlinkProfileJobManager</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IComputeResourceDefinition Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.FlinkProfileJobManager { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileJobManager; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileJobManager = value; }

        /// <summary>Internal Acessors for FlinkProfileJobSpec</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IFlinkJobProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.FlinkProfileJobSpec { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileJobSpec; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileJobSpec = value; }

        /// <summary>Internal Acessors for FlinkProfileStorage</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IFlinkStorageProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.FlinkProfileStorage { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileStorage; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileStorage = value; }

        /// <summary>Internal Acessors for FlinkProfileTaskManager</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IComputeResourceDefinition Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.FlinkProfileTaskManager { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileTaskManager; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).FlinkProfileTaskManager = value; }

        /// <summary>Internal Acessors for KafkaProfileClusterIdentity</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IIdentityProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.KafkaProfileClusterIdentity { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).KafkaProfileClusterIdentity; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).KafkaProfileClusterIdentity = value; }

        /// <summary>Internal Acessors for KafkaProfileConnectivityEndpoint</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IKafkaConnectivityEndpoints Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.KafkaProfileConnectivityEndpoint { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).KafkaProfileConnectivityEndpoint; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).KafkaProfileConnectivityEndpoint = value; }

        /// <summary>Internal Acessors for KafkaProfileDiskStorage</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IDiskStorageProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.KafkaProfileDiskStorage { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).KafkaProfileDiskStorage; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).KafkaProfileDiskStorage = value; }

        /// <summary>Internal Acessors for LogAnalyticProfileApplicationLog</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterLogAnalyticsApplicationLogs Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.LogAnalyticProfileApplicationLog { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).LogAnalyticProfileApplicationLog; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).LogAnalyticProfileApplicationLog = value; }

        /// <summary>Internal Acessors for Profile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.Profile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfile = value; }

        /// <summary>Internal Acessors for ProfileAuthorizationProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IAuthorizationProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ProfileAuthorizationProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileAuthorizationProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileAuthorizationProfile = value; }

        /// <summary>Internal Acessors for ProfileAutoscaleProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IAutoscaleProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ProfileAutoscaleProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileAutoscaleProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileAutoscaleProfile = value; }

        /// <summary>Internal Acessors for ProfileClusterAccessProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterAccessProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ProfileClusterAccessProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileClusterAccessProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileClusterAccessProfile = value; }

        /// <summary>Internal Acessors for ProfileComponent</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterComponentsItem> Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ProfileComponent { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileComponent; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileComponent = value; }

        /// <summary>Internal Acessors for ProfileConnectivityProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IConnectivityProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ProfileConnectivityProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileConnectivityProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileConnectivityProfile = value; }

        /// <summary>Internal Acessors for ProfileFlinkProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IFlinkProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ProfileFlinkProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileFlinkProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileFlinkProfile = value; }

        /// <summary>Internal Acessors for ProfileIdentityProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IIdentityProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ProfileIdentityProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileIdentityProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileIdentityProfile = value; }

        /// <summary>Internal Acessors for ProfileKafkaProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IKafkaProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ProfileKafkaProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileKafkaProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileKafkaProfile = value; }

        /// <summary>Internal Acessors for ProfileLogAnalyticsProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterLogAnalyticsProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ProfileLogAnalyticsProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileLogAnalyticsProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileLogAnalyticsProfile = value; }

        /// <summary>Internal Acessors for ProfilePrometheusProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPrometheusProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ProfilePrometheusProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfilePrometheusProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfilePrometheusProfile = value; }

        /// <summary>Internal Acessors for ProfileRangerPluginProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterRangerPluginProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ProfileRangerPluginProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileRangerPluginProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileRangerPluginProfile = value; }

        /// <summary>Internal Acessors for ProfileRangerProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ProfileRangerProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileRangerProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileRangerProfile = value; }

        /// <summary>Internal Acessors for ProfileSecretsProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISecretsProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ProfileSecretsProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileSecretsProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileSecretsProfile = value; }

        /// <summary>Internal Acessors for ProfileSparkProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISparkProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ProfileSparkProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileSparkProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileSparkProfile = value; }

        /// <summary>Internal Acessors for ProfileSshProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISshProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ProfileSshProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileSshProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileSshProfile = value; }

        /// <summary>Internal Acessors for ProfileTrinoProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ProfileTrinoProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileTrinoProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileTrinoProfile = value; }

        /// <summary>Internal Acessors for Property</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourceProperties Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ClusterResourceProperties()); set { {_property = value;} } }

        /// <summary>Internal Acessors for ProvisioningState</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.ProvisioningState { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ProvisioningState; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ProvisioningState = value; }

        /// <summary>Internal Acessors for RangerAdminDatabase</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerAdminSpecDatabase Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.RangerAdminDatabase { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerAdminDatabase; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerAdminDatabase = value; }

        /// <summary>Internal Acessors for RangerProfileRangerAdmin</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerAdminSpec Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.RangerProfileRangerAdmin { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerProfileRangerAdmin; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerProfileRangerAdmin = value; }

        /// <summary>Internal Acessors for RangerProfileRangerAudit</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerAuditSpec Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.RangerProfileRangerAudit { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerProfileRangerAudit; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerProfileRangerAudit = value; }

        /// <summary>Internal Acessors for RangerProfileRangerUsersync</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerUsersyncSpec Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.RangerProfileRangerUsersync { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerProfileRangerUsersync; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerProfileRangerUsersync = value; }

        /// <summary>Internal Acessors for SparkProfileMetastoreSpec</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISparkMetastoreSpec Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.SparkProfileMetastoreSpec { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).SparkProfileMetastoreSpec; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).SparkProfileMetastoreSpec = value; }

        /// <summary>Internal Acessors for SparkProfileUserPluginsSpec</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISparkUserPlugins Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.SparkProfileUserPluginsSpec { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).SparkProfileUserPluginsSpec; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).SparkProfileUserPluginsSpec = value; }

        /// <summary>Internal Acessors for SshProfilePodPrefix</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.SshProfilePodPrefix { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).SshProfilePodPrefix; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).SshProfilePodPrefix = value; }

        /// <summary>Internal Acessors for Status</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.Status { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).Status; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).Status = value; }

        /// <summary>Internal Acessors for TrinoProfileCatalogOption</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ICatalogOptions Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.TrinoProfileCatalogOption { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TrinoProfileCatalogOption; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TrinoProfileCatalogOption = value; }

        /// <summary>Internal Acessors for TrinoProfileCoordinator</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoCoordinator Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.TrinoProfileCoordinator { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TrinoProfileCoordinator; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TrinoProfileCoordinator = value; }

        /// <summary>Internal Acessors for TrinoProfileUserPluginsSpec</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoUserPlugins Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.TrinoProfileUserPluginsSpec { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TrinoProfileUserPluginsSpec; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TrinoProfileUserPluginsSpec = value; }

        /// <summary>Internal Acessors for TrinoProfileUserTelemetrySpec</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoUserTelemetry Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.TrinoProfileUserTelemetrySpec { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TrinoProfileUserTelemetrySpec; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TrinoProfileUserTelemetrySpec = value; }

        /// <summary>Internal Acessors for TrinoProfileWorker</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoWorker Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.TrinoProfileWorker { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TrinoProfileWorker; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TrinoProfileWorker = value; }

        /// <summary>Internal Acessors for UserTelemetrySpecStorage</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoTelemetryConfig Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.UserTelemetrySpecStorage { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).UserTelemetrySpecStorage; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).UserTelemetrySpecStorage = value; }

        /// <summary>Internal Acessors for WorkerDebug</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoDebugConfig Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterInternal.WorkerDebug { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).WorkerDebug; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).WorkerDebug = value; }

        /// <summary>Internal Acessors for Id</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal.Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Id = value; }

        /// <summary>Internal Acessors for Name</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal.Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Name = value; }

        /// <summary>Internal Acessors for SystemData</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISystemData Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal.SystemData { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemData; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemData = value; }

        /// <summary>Internal Acessors for Type</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal.Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Type = value; }

        /// <summary>The name of the resource</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public string Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Name; }

        /// <summary>Version with 3/4 part.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string ProfileClusterVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileClusterVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileClusterVersion = value ?? null; }

        /// <summary>Component list of this cluster type and version.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterComponentsItem> ProfileComponent { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileComponent; }

        /// <summary>LLAP cluster profile.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterProfileLlapProfile ProfileLlapProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileLlapProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileLlapProfile = value ?? null /* model class */; }

        /// <summary>Version with three part.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string ProfileOssVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileOssVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileOssVersion = value ?? null; }

        /// <summary>The script action profile list.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScriptActionProfile> ProfileScriptActionProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileScriptActionProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileScriptActionProfile = value ?? null /* arrayOf */; }

        /// <summary>The service configs profiles.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterServiceConfigsProfile> ProfileServiceConfigsProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileServiceConfigsProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileServiceConfigsProfile = value ?? null /* arrayOf */; }

        /// <summary>Stub cluster profile.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterProfileStubProfile ProfileStubProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileStubProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ClusterProfileStubProfile = value ?? null /* model class */; }

        /// <summary>Enable Prometheus for cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? PrometheuProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).PrometheuProfileEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).PrometheuProfileEnabled = value ?? default(bool); }

        /// <summary>Backing field for <see cref="Property" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourceProperties _property;

        /// <summary>Gets or sets the properties. Define cluster specific properties.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourceProperties Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ClusterResourceProperties()); set => this._property = value; }

        /// <summary>Provisioning state of the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string ProvisioningState { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ProvisioningState; }

        /// <summary>
        /// List of usernames that should be marked as ranger admins. These usernames should match the user principal name (UPN) of
        /// the respective AAD users.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> RangerAdmin { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerAdmin; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerAdmin = value ?? null /* arrayOf */; }

        /// <summary>
        /// Azure storage location of the blobs. MSI should have read/write access to this Storage account.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string RangerAuditStorageAccount { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerAuditStorageAccount; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerAuditStorageAccount = value ?? null; }

        /// <summary>Enable Ranger for cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? RangerPluginProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerPluginProfileEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerPluginProfileEnabled = value ?? default(bool); }

        /// <summary>Denotes whether usersync service should be enabled</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? RangerUsersyncEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerUsersyncEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerUsersyncEnabled = value ?? default(bool); }

        /// <summary>
        /// List of groups that should be synced. These group names should match the object id of the respective AAD groups.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> RangerUsersyncGroup { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerUsersyncGroup; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerUsersyncGroup = value ?? null /* arrayOf */; }

        /// <summary>
        /// User & groups can be synced automatically or via a static list that's refreshed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string RangerUsersyncMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerUsersyncMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerUsersyncMode = value ?? null; }

        /// <summary>
        /// List of user names that should be synced. These usernames should match the User principal name of the respective AAD users.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> RangerUsersyncUser { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerUsersyncUser; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerUsersyncUser = value ?? null /* arrayOf */; }

        /// <summary>Azure storage location of a mapping file that lists user & group associations.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string RangerUsersyncUserMappingLocation { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerUsersyncUserMappingLocation; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).RangerUsersyncUserMappingLocation = value ?? null; }

        /// <summary>Gets the resource group name</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Owned)]
        public string ResourceGroupName { get => (new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(this.Id).Success ? new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(this.Id).Groups["resourceGroupName"].Value : null); }

        /// <summary>
        /// Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are
        /// default when an specified scaling operation is executed (scale up/scale down)
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? ScheduleBasedConfigDefaultCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ScheduleBasedConfigDefaultCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ScheduleBasedConfigDefaultCount = value ?? default(int); }

        /// <summary>
        /// This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules
        /// within the schedule across days and times (start/end).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISchedule> ScheduleBasedConfigSchedule { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ScheduleBasedConfigSchedule; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ScheduleBasedConfigSchedule = value ?? null /* arrayOf */; }

        /// <summary>
        /// User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string ScheduleBasedConfigTimeZone { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ScheduleBasedConfigTimeZone; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).ScheduleBasedConfigTimeZone = value ?? null; }

        /// <summary>
        /// Name of the user Key Vault where all the cluster specific user secrets are stored.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string SecretProfileKeyVaultResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).SecretProfileKeyVaultResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).SecretProfileKeyVaultResourceId = value ?? null; }

        /// <summary>Properties of Key Vault secret.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISecretReference> SecretProfileSecret { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).SecretProfileSecret; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).SecretProfileSecret = value ?? null /* arrayOf */; }

        /// <summary>The default storage URL.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string SparkProfileDefaultStorageUrl { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).SparkProfileDefaultStorageUrl; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).SparkProfileDefaultStorageUrl = value ?? null; }

        /// <summary>Spark user plugins.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISparkUserPlugin> SparkProfileUserPluginsSpecPlugin { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).SparkProfileUserPluginsSpecPlugin; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).SparkProfileUserPluginsSpecPlugin = value ?? null /* arrayOf */; }

        /// <summary>Number of ssh pods per cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? SshProfileCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).SshProfileCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).SshProfileCount = value ?? default(int); }

        /// <summary>
        /// Prefix of the pod names. Pod number will be appended to the prefix. The ingress URLs for the pods will be available at
        /// <clusterFqdn>/<sshBasePath>/<prefix>-<number>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string SshProfilePodPrefix { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).SshProfilePodPrefix; }

        /// <summary>Business status of the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string Status { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).Status; }

        /// <summary>
        /// Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string StorageHivecatalogName { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).StorageHivecatalogName; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).StorageHivecatalogName = value ?? null; }

        /// <summary>
        /// Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under
        /// schema trinologs.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string StorageHivecatalogSchema { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).StorageHivecatalogSchema; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).StorageHivecatalogSchema = value ?? null; }

        /// <summary>
        /// Retention period for query log table partitions, this doesn't have any affect on actual data.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? StoragePartitionRetentionInDay { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).StoragePartitionRetentionInDay; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).StoragePartitionRetentionInDay = value ?? default(int); }

        /// <summary>Azure storage location of the blobs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string StoragePath { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).StoragePath; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).StoragePath = value ?? null; }

        /// <summary>Storage key is only required for wasb(s) storage.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string StorageStoragekey { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).StorageStoragekey; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).StorageStoragekey = value ?? null; }

        /// <summary>Storage account uri which is used for savepoint and checkpoint state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string StorageUri { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).StorageUri; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).StorageUri = value ?? null; }

        /// <summary>
        /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        internal Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISystemData SystemData { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemData; }

        /// <summary>The timestamp of resource creation (UTC).</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public global::System.DateTime? SystemDataCreatedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataCreatedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataCreatedAt = value ?? default(global::System.DateTime); }

        /// <summary>The identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public string SystemDataCreatedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataCreatedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataCreatedBy = value ?? null; }

        /// <summary>The type of identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public string SystemDataCreatedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataCreatedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataCreatedByType = value ?? null; }

        /// <summary>The timestamp of resource last modification (UTC)</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public global::System.DateTime? SystemDataLastModifiedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedAt = value ?? default(global::System.DateTime); }

        /// <summary>The identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public string SystemDataLastModifiedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedBy = value ?? null; }

        /// <summary>The type of identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public string SystemDataLastModifiedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedByType = value ?? null; }

        /// <summary>Resource tags.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResourceTags Tag { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResourceInternal)__trackedResource).Tag; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResourceInternal)__trackedResource).Tag = value ?? null /* model class */; }

        /// <summary>The required CPU.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public float? TaskManagerCpu { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TaskManagerCpu; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TaskManagerCpu = value ?? default(float); }

        /// <summary>The required memory in MB, Container memory will be 110 percentile</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public long? TaskManagerMemory { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TaskManagerMemory; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TaskManagerMemory = value ?? default(long); }

        /// <summary>hive catalog options.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IHiveCatalogOption> TrinoProfileCatalogOptionsHive { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TrinoProfileCatalogOptionsHive; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TrinoProfileCatalogOptionsHive = value ?? null /* arrayOf */; }

        /// <summary>Trino user plugins.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoUserPlugin> TrinoProfileUserPluginsSpecPlugin { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TrinoProfileUserPluginsSpecPlugin; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).TrinoProfileUserPluginsSpecPlugin = value ?? null /* arrayOf */; }

        /// <summary>
        /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inherited)]
        public string Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IResourceInternal)__trackedResource).Type; }

        /// <summary>Web connectivity endpoint.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string WebFqdn { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).WebFqdn; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).WebFqdn = value ?? null; }

        /// <summary>
        /// Private web connectivity endpoint. This property will only be returned when enableInternalIngress is true.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string WebPrivateFqdn { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).WebPrivateFqdn; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).WebPrivateFqdn = value ?? null; }

        /// <summary>The flag that if enable debug or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? WorkerDebugEnable { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).WorkerDebugEnable; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).WorkerDebugEnable = value ?? default(bool); }

        /// <summary>The debug port.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? WorkerDebugPort { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).WorkerDebugPort; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).WorkerDebugPort = value ?? default(int); }

        /// <summary>The flag that if suspend debug or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? WorkerDebugSuspend { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).WorkerDebugSuspend; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourcePropertiesInternal)Property).WorkerDebugSuspend = value ?? default(bool); }

        /// <summary>Creates an new <see cref="Cluster" /> instance.</summary>
        public Cluster()
        {

        }

        /// <summary>Validates that this object meets the validation criteria.</summary>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.IEventListener" /> instance that will receive validation
        /// events.</param>
        /// <returns>
        /// A <see cref = "global::System.Threading.Tasks.Task" /> that will be complete when validation is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task Validate(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.IEventListener eventListener)
        {
            await eventListener.AssertNotNull(nameof(__trackedResource), __trackedResource);
            await eventListener.AssertObjectIsValid(nameof(__trackedResource), __trackedResource);
        }
    }
    /// The cluster.
    public partial interface ICluster :
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.IJsonSerializable,
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResource
    {
        /// <summary>
        /// Whether to create cluster using private IP instead of public IP. This property must be set at create time.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = false,
        Description = @"Whether to create cluster using private IP instead of public IP. This property must be set at create time.",
        SerializedName = @"enableInternalIngress",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AccessProfileEnableInternalIngress { get; set; }
        /// <summary>
        /// Private link service resource ID. Only when enableInternalIngress is true, this property will be returned.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Private link service resource ID. Only when enableInternalIngress is true, this property will be returned.",
        SerializedName = @"privateLinkServiceId",
        PossibleTypes = new [] { typeof(string) })]
        string AccessProfilePrivateLinkServiceId { get;  }
        /// <summary>True if stderror is enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if stderror is enabled, otherwise false.",
        SerializedName = @"stdErrorEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ApplicationLogStdErrorEnabled { get; set; }
        /// <summary>True if stdout is enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if stdout is enabled, otherwise false.",
        SerializedName = @"stdOutEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ApplicationLogStdOutEnabled { get; set; }
        /// <summary>AAD group Ids authorized for data plane access.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"AAD group Ids authorized for data plane access.",
        SerializedName = @"groupIds",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> AuthorizationProfileGroupId { get; set; }
        /// <summary>AAD user Ids authorized for data plane access.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"AAD user Ids authorized for data plane access.",
        SerializedName = @"userIds",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> AuthorizationProfileUserId { get; set; }
        /// <summary>
        /// User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.",
        SerializedName = @"autoscaleType",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("ScheduleBased", "LoadBased")]
        string AutoscaleProfileAutoscaleType { get; set; }
        /// <summary>This indicates whether auto scale is enabled on HDInsight on AKS cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This indicates whether auto scale is enabled on HDInsight on AKS cluster.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AutoscaleProfileEnabled { get; set; }
        /// <summary>
        /// This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes
        /// place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING
        /// node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.",
        SerializedName = @"gracefulDecommissionTimeout",
        PossibleTypes = new [] { typeof(int) })]
        int? AutoscaleProfileGracefulDecommissionTimeout { get; set; }
        /// <summary>The type of cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = false,
        Description = @"The type of cluster.",
        SerializedName = @"clusterType",
        PossibleTypes = new [] { typeof(string) })]
        string ClusterType { get; set; }
        /// <summary>The nodes definitions.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The nodes definitions.",
        SerializedName = @"nodes",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.INodeProfile) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.INodeProfile> ComputeProfileNode { get; set; }
        /// <summary>bootstrap server connectivity endpoint.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"bootstrap server connectivity endpoint.",
        SerializedName = @"bootstrapServerEndpoint",
        PossibleTypes = new [] { typeof(string) })]
        string ConnectivityEndpointBootstrapServerEndpoint { get;  }
        /// <summary>Kafka broker endpoint list.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Kafka broker endpoint list.",
        SerializedName = @"brokerEndpoints",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> ConnectivityEndpointBrokerEndpoint { get;  }
        /// <summary>List of SSH connectivity endpoints.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"List of SSH connectivity endpoints.",
        SerializedName = @"ssh",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISshConnectivityEndpoint) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISshConnectivityEndpoint> ConnectivityProfileSsh { get;  }
        /// <summary>The flag that if enable debug or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The flag that if enable debug or not.",
        SerializedName = @"enable",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CoordinatorDebugEnable { get; set; }
        /// <summary>The debug port.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The debug port.",
        SerializedName = @"port",
        PossibleTypes = new [] { typeof(int) })]
        int? CoordinatorDebugPort { get; set; }
        /// <summary>The flag that if suspend debug or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The flag that if suspend debug or not.",
        SerializedName = @"suspend",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CoordinatorDebugSuspend { get; set; }
        /// <summary>
        /// The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node.
        /// Default: true.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node. Default: true.",
        SerializedName = @"highAvailabilityEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CoordinatorHighAvailabilityEnabled { get; set; }
        /// <summary>The database URL</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The database URL",
        SerializedName = @"host",
        PossibleTypes = new [] { typeof(string) })]
        string DatabaseHost { get; set; }
        /// <summary>The database name</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The database name",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string DatabaseName { get; set; }
        /// <summary>Reference for the database password</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Reference for the database password",
        SerializedName = @"passwordSecretRef",
        PossibleTypes = new [] { typeof(string) })]
        string DatabasePasswordSecretRef { get; set; }
        /// <summary>The name of the database user</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The name of the database user",
        SerializedName = @"username",
        PossibleTypes = new [] { typeof(string) })]
        string DatabaseUsername { get; set; }
        /// <summary>A unique id generated by the RP to identify the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"A unique id generated by the RP to identify the resource.",
        SerializedName = @"deploymentId",
        PossibleTypes = new [] { typeof(string) })]
        string DeploymentId { get;  }
        /// <summary>
        /// Managed Disk size in GB. The maximum supported disk size for Standard and Premium HDD/SSD is 32TB, except for Premium
        /// SSD v2, which supports up to 64TB.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Managed Disk size in GB. The maximum supported disk size for Standard and Premium HDD/SSD is 32TB, except for Premium SSD v2, which supports up to 64TB.",
        SerializedName = @"dataDiskSize",
        PossibleTypes = new [] { typeof(int) })]
        int? DiskStorageDataDiskSize { get; set; }
        /// <summary>Managed Disk Type.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Managed Disk Type.",
        SerializedName = @"dataDiskType",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("Standard_HDD_LRS", "Standard_SSD_LRS", "Standard_SSD_ZRS", "Premium_SSD_LRS", "Premium_SSD_ZRS", "Premium_SSD_v2_LRS")]
        string DiskStorageDataDiskType { get; set; }
        /// <summary>
        /// A string property that indicates the deployment mode of Flink cluster. It can have one of the following enum values =>
        /// Application, Session. Default value is Session
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"A string property that indicates the deployment mode of Flink cluster. It can have one of the following enum values => Application, Session. Default value is Session",
        SerializedName = @"deploymentMode",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("Application", "Session")]
        string FlinkProfileDeploymentMode { get; set; }
        /// <summary>The number of task managers.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The number of task managers.",
        SerializedName = @"numReplicas",
        PossibleTypes = new [] { typeof(int) })]
        int? FlinkProfileNumReplica { get; set; }
        /// <summary>The required CPU.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The required CPU.",
        SerializedName = @"cpu",
        PossibleTypes = new [] { typeof(float) })]
        float? HistoryServerCpu { get; set; }
        /// <summary>The required memory in MB, Container memory will be 110 percentile</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The required memory in MB, Container memory will be 110 percentile",
        SerializedName = @"memory",
        PossibleTypes = new [] { typeof(long) })]
        long? HistoryServerMemory { get; set; }
        /// <summary>
        /// The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization",
        SerializedName = @"metastoreDbConnectionAuthenticationMode",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("SqlAuth", "IdentityAuth")]
        string HiveMetastoreDbConnectionAuthenticationMode { get; set; }
        /// <summary>
        /// Secret reference name from secretsProfile.secrets containing password for database connection.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Secret reference name from secretsProfile.secrets containing password for database connection.",
        SerializedName = @"metastoreDbConnectionPasswordSecret",
        PossibleTypes = new [] { typeof(string) })]
        string HiveMetastoreDbConnectionPasswordSecret { get; set; }
        /// <summary>Connection string for hive metastore database.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Connection string for hive metastore database.",
        SerializedName = @"metastoreDbConnectionURL",
        PossibleTypes = new [] { typeof(string) })]
        string HiveMetastoreDbConnectionUrl { get; set; }
        /// <summary>User name for database connection.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User name for database connection.",
        SerializedName = @"metastoreDbConnectionUserName",
        PossibleTypes = new [] { typeof(string) })]
        string HiveMetastoreDbConnectionUserName { get; set; }
        /// <summary>ClientId of the MSI.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"ClientId of the MSI.",
        SerializedName = @"msiClientId",
        PossibleTypes = new [] { typeof(string) })]
        string IdentityMsiClientId { get;  }
        /// <summary>ObjectId of the MSI.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"ObjectId of the MSI.",
        SerializedName = @"msiObjectId",
        PossibleTypes = new [] { typeof(string) })]
        string IdentityMsiObjectId { get;  }
        /// <summary>ResourceId of the MSI.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"ResourceId of the MSI.",
        SerializedName = @"msiResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string IdentityMsiResourceId { get;  }
        /// <summary>ClientId of the MSI.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"ClientId of the MSI.",
        SerializedName = @"msiClientId",
        PossibleTypes = new [] { typeof(string) })]
        string IdentityProfileMsiClientId { get; set; }
        /// <summary>ObjectId of the MSI.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"ObjectId of the MSI.",
        SerializedName = @"msiObjectId",
        PossibleTypes = new [] { typeof(string) })]
        string IdentityProfileMsiObjectId { get; set; }
        /// <summary>ResourceId of the MSI.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"ResourceId of the MSI.",
        SerializedName = @"msiResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string IdentityProfileMsiResourceId { get; set; }
        /// <summary>The required CPU.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The required CPU.",
        SerializedName = @"cpu",
        PossibleTypes = new [] { typeof(float) })]
        float? JobManagerCpu { get; set; }
        /// <summary>The required memory in MB, Container memory will be 110 percentile</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The required memory in MB, Container memory will be 110 percentile",
        SerializedName = @"memory",
        PossibleTypes = new [] { typeof(long) })]
        long? JobManagerMemory { get; set; }
        /// <summary>
        /// A string property representing additional JVM arguments for the Flink job. It should be space separated value.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"A string property representing additional JVM arguments for the Flink job. It should be space separated value.",
        SerializedName = @"args",
        PossibleTypes = new [] { typeof(string) })]
        string JobSpecArg { get; set; }
        /// <summary>
        /// A string property that specifies the entry class for the Flink job. If not specified, the entry point is auto-detected
        /// from the flink job jar package.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"A string property that specifies the entry class for the Flink job. If not specified, the entry point is auto-detected from the flink job jar package.",
        SerializedName = @"entryClass",
        PossibleTypes = new [] { typeof(string) })]
        string JobSpecEntryClass { get; set; }
        /// <summary>A string property that represents the name of the job JAR.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"A string property that represents the name of the job JAR.",
        SerializedName = @"jarName",
        PossibleTypes = new [] { typeof(string) })]
        string JobSpecJarName { get; set; }
        /// <summary>A string property that specifies the directory where the job JAR is located.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"A string property that specifies the directory where the job JAR is located.",
        SerializedName = @"jobJarDirectory",
        PossibleTypes = new [] { typeof(string) })]
        string JobSpecJobJarDirectory { get; set; }
        /// <summary>A string property that represents the name of the savepoint for the Flink job</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"A string property that represents the name of the savepoint for the Flink job",
        SerializedName = @"savePointName",
        PossibleTypes = new [] { typeof(string) })]
        string JobSpecSavePointName { get; set; }
        /// <summary>
        /// A string property that indicates the upgrade mode to be performed on the Flink job. It can have one of the following enum
        /// values => STATELESS_UPDATE, UPDATE, LAST_STATE_UPDATE.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"A string property that indicates the upgrade mode to be performed on the Flink job. It can have one of the following enum values => STATELESS_UPDATE, UPDATE, LAST_STATE_UPDATE.",
        SerializedName = @"upgradeMode",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("STATELESS_UPDATE", "UPDATE", "LAST_STATE_UPDATE")]
        string JobSpecUpgradeMode { get; set; }
        /// <summary>Expose Kafka cluster in KRaft mode.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Expose Kafka cluster in KRaft mode.",
        SerializedName = @"enableKRaft",
        PossibleTypes = new [] { typeof(bool) })]
        bool? KafkaProfileEnableKRaft { get; set; }
        /// <summary>Expose worker nodes as public endpoints.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Expose worker nodes as public endpoints.",
        SerializedName = @"enablePublicEndpoints",
        PossibleTypes = new [] { typeof(bool) })]
        bool? KafkaProfileEnablePublicEndpoint { get; set; }
        /// <summary>Fully qualified path of Azure Storage container used for Tiered Storage.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Fully qualified path of Azure Storage container used for Tiered Storage.",
        SerializedName = @"remoteStorageUri",
        PossibleTypes = new [] { typeof(string) })]
        string KafkaProfileRemoteStorageUri { get; set; }
        /// <summary>
        /// This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between
        /// a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers
        /// it. The default value is 300 seconds.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers it. The default value is 300 seconds.",
        SerializedName = @"cooldownPeriod",
        PossibleTypes = new [] { typeof(int) })]
        int? LoadBasedConfigCooldownPeriod { get; set; }
        /// <summary>
        /// User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.",
        SerializedName = @"maxNodes",
        PossibleTypes = new [] { typeof(int) })]
        int? LoadBasedConfigMaxNode { get; set; }
        /// <summary>
        /// User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.",
        SerializedName = @"minNodes",
        PossibleTypes = new [] { typeof(int) })]
        int? LoadBasedConfigMinNode { get; set; }
        /// <summary>
        /// User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering
        /// a scaling operation.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering a scaling operation.",
        SerializedName = @"pollInterval",
        PossibleTypes = new [] { typeof(int) })]
        int? LoadBasedConfigPollInterval { get; set; }
        /// <summary>The scaling rules.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The scaling rules.",
        SerializedName = @"scalingRules",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScalingRule) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScalingRule> LoadBasedConfigScalingRule { get; set; }
        /// <summary>True if log analytics is enabled for the cluster, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if log analytics is enabled for the cluster, otherwise false.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? LogAnalyticProfileEnabled { get; set; }
        /// <summary>True if metrics are enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if metrics are enabled, otherwise false.",
        SerializedName = @"metricsEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? LogAnalyticProfileMetricsEnabled { get; set; }
        /// <summary>
        /// The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization",
        SerializedName = @"dbConnectionAuthenticationMode",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("SqlAuth", "IdentityAuth")]
        string MetastoreSpecDbConnectionAuthenticationMode { get; set; }
        /// <summary>The database name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The database name.",
        SerializedName = @"dbName",
        PossibleTypes = new [] { typeof(string) })]
        string MetastoreSpecDbName { get; set; }
        /// <summary>The secret name which contains the database user password.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The secret name which contains the database user password.",
        SerializedName = @"dbPasswordSecretName",
        PossibleTypes = new [] { typeof(string) })]
        string MetastoreSpecDbPasswordSecretName { get; set; }
        /// <summary>The database server host.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The database server host.",
        SerializedName = @"dbServerHost",
        PossibleTypes = new [] { typeof(string) })]
        string MetastoreSpecDbServerHost { get; set; }
        /// <summary>The database user name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The database user name.",
        SerializedName = @"dbUserName",
        PossibleTypes = new [] { typeof(string) })]
        string MetastoreSpecDbUserName { get; set; }
        /// <summary>The key vault resource id.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The key vault resource id.",
        SerializedName = @"keyVaultId",
        PossibleTypes = new [] { typeof(string) })]
        string MetastoreSpecKeyVaultId { get; set; }
        /// <summary>The thrift url.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The thrift url.",
        SerializedName = @"thriftUrl",
        PossibleTypes = new [] { typeof(string) })]
        string MetastoreSpecThriftUrl { get; set; }
        /// <summary>Version with 3/4 part.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Version with 3/4 part.",
        SerializedName = @"clusterVersion",
        PossibleTypes = new [] { typeof(string) })]
        string ProfileClusterVersion { get; set; }
        /// <summary>Component list of this cluster type and version.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Component list of this cluster type and version.",
        SerializedName = @"components",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterComponentsItem) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterComponentsItem> ProfileComponent { get;  }
        /// <summary>LLAP cluster profile.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"LLAP cluster profile.",
        SerializedName = @"llapProfile",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterProfileLlapProfile) })]
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterProfileLlapProfile ProfileLlapProfile { get; set; }
        /// <summary>Version with three part.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Version with three part.",
        SerializedName = @"ossVersion",
        PossibleTypes = new [] { typeof(string) })]
        string ProfileOssVersion { get; set; }
        /// <summary>The script action profile list.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The script action profile list.",
        SerializedName = @"scriptActionProfiles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScriptActionProfile) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScriptActionProfile> ProfileScriptActionProfile { get; set; }
        /// <summary>The service configs profiles.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The service configs profiles.",
        SerializedName = @"serviceConfigsProfiles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterServiceConfigsProfile) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterServiceConfigsProfile> ProfileServiceConfigsProfile { get; set; }
        /// <summary>Stub cluster profile.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Stub cluster profile.",
        SerializedName = @"stubProfile",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterProfileStubProfile) })]
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterProfileStubProfile ProfileStubProfile { get; set; }
        /// <summary>Enable Prometheus for cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Enable Prometheus for cluster or not.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? PrometheuProfileEnabled { get; set; }
        /// <summary>Provisioning state of the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Provisioning state of the resource.",
        SerializedName = @"provisioningState",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("Accepted", "Succeeded", "Canceled", "Failed")]
        string ProvisioningState { get;  }
        /// <summary>
        /// List of usernames that should be marked as ranger admins. These usernames should match the user principal name (UPN) of
        /// the respective AAD users.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"List of usernames that should be marked as ranger admins. These usernames should match the user principal name (UPN) of the respective AAD users.",
        SerializedName = @"admins",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> RangerAdmin { get; set; }
        /// <summary>
        /// Azure storage location of the blobs. MSI should have read/write access to this Storage account.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Azure storage location of the blobs. MSI should have read/write access to this Storage account.",
        SerializedName = @"storageAccount",
        PossibleTypes = new [] { typeof(string) })]
        string RangerAuditStorageAccount { get; set; }
        /// <summary>Enable Ranger for cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Enable Ranger for cluster or not.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? RangerPluginProfileEnabled { get; set; }
        /// <summary>Denotes whether usersync service should be enabled</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Denotes whether usersync service should be enabled",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? RangerUsersyncEnabled { get; set; }
        /// <summary>
        /// List of groups that should be synced. These group names should match the object id of the respective AAD groups.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"List of groups that should be synced. These group names should match the object id of the respective AAD groups.",
        SerializedName = @"groups",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> RangerUsersyncGroup { get; set; }
        /// <summary>
        /// User & groups can be synced automatically or via a static list that's refreshed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User & groups can be synced automatically or via a static list that's refreshed.",
        SerializedName = @"mode",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("static", "automatic")]
        string RangerUsersyncMode { get; set; }
        /// <summary>
        /// List of user names that should be synced. These usernames should match the User principal name of the respective AAD users.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"List of user names that should be synced. These usernames should match the User principal name of the respective AAD users.",
        SerializedName = @"users",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> RangerUsersyncUser { get; set; }
        /// <summary>Azure storage location of a mapping file that lists user & group associations.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Azure storage location of a mapping file that lists user & group associations.",
        SerializedName = @"userMappingLocation",
        PossibleTypes = new [] { typeof(string) })]
        string RangerUsersyncUserMappingLocation { get; set; }
        /// <summary>
        /// Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are
        /// default when an specified scaling operation is executed (scale up/scale down)
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are default when an specified scaling operation is executed (scale up/scale down)",
        SerializedName = @"defaultCount",
        PossibleTypes = new [] { typeof(int) })]
        int? ScheduleBasedConfigDefaultCount { get; set; }
        /// <summary>
        /// This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules
        /// within the schedule across days and times (start/end).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules within the schedule across days and times (start/end).",
        SerializedName = @"schedules",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISchedule) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISchedule> ScheduleBasedConfigSchedule { get; set; }
        /// <summary>
        /// User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.",
        SerializedName = @"timeZone",
        PossibleTypes = new [] { typeof(string) })]
        string ScheduleBasedConfigTimeZone { get; set; }
        /// <summary>
        /// Name of the user Key Vault where all the cluster specific user secrets are stored.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Name of the user Key Vault where all the cluster specific user secrets are stored.",
        SerializedName = @"keyVaultResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string SecretProfileKeyVaultResourceId { get; set; }
        /// <summary>Properties of Key Vault secret.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Properties of Key Vault secret.",
        SerializedName = @"secrets",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISecretReference) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISecretReference> SecretProfileSecret { get; set; }
        /// <summary>The default storage URL.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The default storage URL.",
        SerializedName = @"defaultStorageUrl",
        PossibleTypes = new [] { typeof(string) })]
        string SparkProfileDefaultStorageUrl { get; set; }
        /// <summary>Spark user plugins.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Spark user plugins.",
        SerializedName = @"plugins",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISparkUserPlugin) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISparkUserPlugin> SparkProfileUserPluginsSpecPlugin { get; set; }
        /// <summary>Number of ssh pods per cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Number of ssh pods per cluster.",
        SerializedName = @"count",
        PossibleTypes = new [] { typeof(int) })]
        int? SshProfileCount { get; set; }
        /// <summary>
        /// Prefix of the pod names. Pod number will be appended to the prefix. The ingress URLs for the pods will be available at
        /// <clusterFqdn>/<sshBasePath>/<prefix>-<number>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Prefix of the pod names. Pod number will be appended to the prefix. The ingress URLs for the pods will be available at <clusterFqdn>/<sshBasePath>/<prefix>-<number>",
        SerializedName = @"podPrefix",
        PossibleTypes = new [] { typeof(string) })]
        string SshProfilePodPrefix { get;  }
        /// <summary>Business status of the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Business status of the resource.",
        SerializedName = @"status",
        PossibleTypes = new [] { typeof(string) })]
        string Status { get;  }
        /// <summary>
        /// Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.",
        SerializedName = @"hivecatalogName",
        PossibleTypes = new [] { typeof(string) })]
        string StorageHivecatalogName { get; set; }
        /// <summary>
        /// Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under
        /// schema trinologs.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under schema trinologs.",
        SerializedName = @"hivecatalogSchema",
        PossibleTypes = new [] { typeof(string) })]
        string StorageHivecatalogSchema { get; set; }
        /// <summary>
        /// Retention period for query log table partitions, this doesn't have any affect on actual data.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Retention period for query log table partitions, this doesn't have any affect on actual data.",
        SerializedName = @"partitionRetentionInDays",
        PossibleTypes = new [] { typeof(int) })]
        int? StoragePartitionRetentionInDay { get; set; }
        /// <summary>Azure storage location of the blobs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Azure storage location of the blobs.",
        SerializedName = @"path",
        PossibleTypes = new [] { typeof(string) })]
        string StoragePath { get; set; }
        /// <summary>Storage key is only required for wasb(s) storage.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Storage key is only required for wasb(s) storage.",
        SerializedName = @"storagekey",
        PossibleTypes = new [] { typeof(string) })]
        string StorageStoragekey { get; set; }
        /// <summary>Storage account uri which is used for savepoint and checkpoint state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Storage account uri which is used for savepoint and checkpoint state.",
        SerializedName = @"storageUri",
        PossibleTypes = new [] { typeof(string) })]
        string StorageUri { get; set; }
        /// <summary>The required CPU.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The required CPU.",
        SerializedName = @"cpu",
        PossibleTypes = new [] { typeof(float) })]
        float? TaskManagerCpu { get; set; }
        /// <summary>The required memory in MB, Container memory will be 110 percentile</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The required memory in MB, Container memory will be 110 percentile",
        SerializedName = @"memory",
        PossibleTypes = new [] { typeof(long) })]
        long? TaskManagerMemory { get; set; }
        /// <summary>hive catalog options.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"hive catalog options.",
        SerializedName = @"hive",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IHiveCatalogOption) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IHiveCatalogOption> TrinoProfileCatalogOptionsHive { get; set; }
        /// <summary>Trino user plugins.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Trino user plugins.",
        SerializedName = @"plugins",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoUserPlugin) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoUserPlugin> TrinoProfileUserPluginsSpecPlugin { get; set; }
        /// <summary>Web connectivity endpoint.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Web connectivity endpoint.",
        SerializedName = @"fqdn",
        PossibleTypes = new [] { typeof(string) })]
        string WebFqdn { get;  }
        /// <summary>
        /// Private web connectivity endpoint. This property will only be returned when enableInternalIngress is true.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Private web connectivity endpoint. This property will only be returned when enableInternalIngress is true.",
        SerializedName = @"privateFqdn",
        PossibleTypes = new [] { typeof(string) })]
        string WebPrivateFqdn { get;  }
        /// <summary>The flag that if enable debug or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The flag that if enable debug or not.",
        SerializedName = @"enable",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WorkerDebugEnable { get; set; }
        /// <summary>The debug port.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The debug port.",
        SerializedName = @"port",
        PossibleTypes = new [] { typeof(int) })]
        int? WorkerDebugPort { get; set; }
        /// <summary>The flag that if suspend debug or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The flag that if suspend debug or not.",
        SerializedName = @"suspend",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WorkerDebugSuspend { get; set; }

    }
    /// The cluster.
    internal partial interface IClusterInternal :
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrackedResourceInternal
    {
        /// <summary>
        /// Whether to create cluster using private IP instead of public IP. This property must be set at create time.
        /// </summary>
        bool? AccessProfileEnableInternalIngress { get; set; }
        /// <summary>
        /// Private link service resource ID. Only when enableInternalIngress is true, this property will be returned.
        /// </summary>
        string AccessProfilePrivateLinkServiceId { get; set; }
        /// <summary>True if stderror is enabled, otherwise false.</summary>
        bool? ApplicationLogStdErrorEnabled { get; set; }
        /// <summary>True if stdout is enabled, otherwise false.</summary>
        bool? ApplicationLogStdOutEnabled { get; set; }
        /// <summary>AAD group Ids authorized for data plane access.</summary>
        System.Collections.Generic.List<string> AuthorizationProfileGroupId { get; set; }
        /// <summary>AAD user Ids authorized for data plane access.</summary>
        System.Collections.Generic.List<string> AuthorizationProfileUserId { get; set; }
        /// <summary>
        /// User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("ScheduleBased", "LoadBased")]
        string AutoscaleProfileAutoscaleType { get; set; }
        /// <summary>This indicates whether auto scale is enabled on HDInsight on AKS cluster.</summary>
        bool? AutoscaleProfileEnabled { get; set; }
        /// <summary>
        /// This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes
        /// place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING
        /// node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        /// </summary>
        int? AutoscaleProfileGracefulDecommissionTimeout { get; set; }
        /// <summary>Profiles of load based Autoscale.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ILoadBasedConfig AutoscaleProfileLoadBasedConfig { get; set; }
        /// <summary>Profiles of schedule based Autoscale.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScheduleBasedConfig AutoscaleProfileScheduleBasedConfig { get; set; }
        /// <summary>The type of cluster.</summary>
        string ClusterType { get; set; }
        /// <summary>The compute profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IComputeProfile ComputeProfile { get; set; }
        /// <summary>The nodes definitions.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.INodeProfile> ComputeProfileNode { get; set; }
        /// <summary>bootstrap server connectivity endpoint.</summary>
        string ConnectivityEndpointBootstrapServerEndpoint { get; set; }
        /// <summary>Kafka broker endpoint list.</summary>
        System.Collections.Generic.List<string> ConnectivityEndpointBrokerEndpoint { get; set; }
        /// <summary>List of SSH connectivity endpoints.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISshConnectivityEndpoint> ConnectivityProfileSsh { get; set; }
        /// <summary>Web connectivity endpoint details.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IConnectivityProfileWeb ConnectivityProfileWeb { get; set; }
        /// <summary>Trino debug configuration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoDebugConfig CoordinatorDebug { get; set; }
        /// <summary>The flag that if enable debug or not.</summary>
        bool? CoordinatorDebugEnable { get; set; }
        /// <summary>The debug port.</summary>
        int? CoordinatorDebugPort { get; set; }
        /// <summary>The flag that if suspend debug or not.</summary>
        bool? CoordinatorDebugSuspend { get; set; }
        /// <summary>
        /// The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node.
        /// Default: true.
        /// </summary>
        bool? CoordinatorHighAvailabilityEnabled { get; set; }
        /// <summary>The database URL</summary>
        string DatabaseHost { get; set; }
        /// <summary>The database name</summary>
        string DatabaseName { get; set; }
        /// <summary>Reference for the database password</summary>
        string DatabasePasswordSecretRef { get; set; }
        /// <summary>The name of the database user</summary>
        string DatabaseUsername { get; set; }
        /// <summary>A unique id generated by the RP to identify the resource.</summary>
        string DeploymentId { get; set; }
        /// <summary>
        /// Managed Disk size in GB. The maximum supported disk size for Standard and Premium HDD/SSD is 32TB, except for Premium
        /// SSD v2, which supports up to 64TB.
        /// </summary>
        int? DiskStorageDataDiskSize { get; set; }
        /// <summary>Managed Disk Type.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("Standard_HDD_LRS", "Standard_SSD_LRS", "Standard_SSD_ZRS", "Premium_SSD_LRS", "Premium_SSD_ZRS", "Premium_SSD_v2_LRS")]
        string DiskStorageDataDiskType { get; set; }
        /// <summary>Flink cluster catalog options.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IFlinkCatalogOptions FlinkProfileCatalogOption { get; set; }
        /// <summary>Hive Catalog Option for Flink cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IFlinkHiveCatalogOption FlinkProfileCatalogOptionsHive { get; set; }
        /// <summary>
        /// A string property that indicates the deployment mode of Flink cluster. It can have one of the following enum values =>
        /// Application, Session. Default value is Session
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("Application", "Session")]
        string FlinkProfileDeploymentMode { get; set; }
        /// <summary>History Server container/ process CPU and memory requirements</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IComputeResourceDefinition FlinkProfileHistoryServer { get; set; }
        /// <summary>Job Manager container/ process CPU and memory requirements</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IComputeResourceDefinition FlinkProfileJobManager { get; set; }
        /// <summary>
        /// Job specifications for flink clusters in application deployment mode. The specification is immutable even if job properties
        /// are changed by calling the RunJob API, please use the ListJob API to get the latest job information.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IFlinkJobProfile FlinkProfileJobSpec { get; set; }
        /// <summary>The number of task managers.</summary>
        int? FlinkProfileNumReplica { get; set; }
        /// <summary>The storage profile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IFlinkStorageProfile FlinkProfileStorage { get; set; }
        /// <summary>Task Manager container/ process CPU and memory requirements</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IComputeResourceDefinition FlinkProfileTaskManager { get; set; }
        /// <summary>The required CPU.</summary>
        float? HistoryServerCpu { get; set; }
        /// <summary>The required memory in MB, Container memory will be 110 percentile</summary>
        long? HistoryServerMemory { get; set; }
        /// <summary>
        /// The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("SqlAuth", "IdentityAuth")]
        string HiveMetastoreDbConnectionAuthenticationMode { get; set; }
        /// <summary>
        /// Secret reference name from secretsProfile.secrets containing password for database connection.
        /// </summary>
        string HiveMetastoreDbConnectionPasswordSecret { get; set; }
        /// <summary>Connection string for hive metastore database.</summary>
        string HiveMetastoreDbConnectionUrl { get; set; }
        /// <summary>User name for database connection.</summary>
        string HiveMetastoreDbConnectionUserName { get; set; }
        /// <summary>ClientId of the MSI.</summary>
        string IdentityMsiClientId { get; set; }
        /// <summary>ObjectId of the MSI.</summary>
        string IdentityMsiObjectId { get; set; }
        /// <summary>ResourceId of the MSI.</summary>
        string IdentityMsiResourceId { get; set; }
        /// <summary>ClientId of the MSI.</summary>
        string IdentityProfileMsiClientId { get; set; }
        /// <summary>ObjectId of the MSI.</summary>
        string IdentityProfileMsiObjectId { get; set; }
        /// <summary>ResourceId of the MSI.</summary>
        string IdentityProfileMsiResourceId { get; set; }
        /// <summary>The required CPU.</summary>
        float? JobManagerCpu { get; set; }
        /// <summary>The required memory in MB, Container memory will be 110 percentile</summary>
        long? JobManagerMemory { get; set; }
        /// <summary>
        /// A string property representing additional JVM arguments for the Flink job. It should be space separated value.
        /// </summary>
        string JobSpecArg { get; set; }
        /// <summary>
        /// A string property that specifies the entry class for the Flink job. If not specified, the entry point is auto-detected
        /// from the flink job jar package.
        /// </summary>
        string JobSpecEntryClass { get; set; }
        /// <summary>A string property that represents the name of the job JAR.</summary>
        string JobSpecJarName { get; set; }
        /// <summary>A string property that specifies the directory where the job JAR is located.</summary>
        string JobSpecJobJarDirectory { get; set; }
        /// <summary>A string property that represents the name of the savepoint for the Flink job</summary>
        string JobSpecSavePointName { get; set; }
        /// <summary>
        /// A string property that indicates the upgrade mode to be performed on the Flink job. It can have one of the following enum
        /// values => STATELESS_UPDATE, UPDATE, LAST_STATE_UPDATE.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("STATELESS_UPDATE", "UPDATE", "LAST_STATE_UPDATE")]
        string JobSpecUpgradeMode { get; set; }
        /// <summary>Identity of the internal service components inside the Kafka cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IIdentityProfile KafkaProfileClusterIdentity { get; set; }
        /// <summary>Kafka bootstrap server and brokers related connectivity endpoints.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IKafkaConnectivityEndpoints KafkaProfileConnectivityEndpoint { get; set; }
        /// <summary>Kafka disk storage profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IDiskStorageProfile KafkaProfileDiskStorage { get; set; }
        /// <summary>Expose Kafka cluster in KRaft mode.</summary>
        bool? KafkaProfileEnableKRaft { get; set; }
        /// <summary>Expose worker nodes as public endpoints.</summary>
        bool? KafkaProfileEnablePublicEndpoint { get; set; }
        /// <summary>Fully qualified path of Azure Storage container used for Tiered Storage.</summary>
        string KafkaProfileRemoteStorageUri { get; set; }
        /// <summary>
        /// This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between
        /// a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers
        /// it. The default value is 300 seconds.
        /// </summary>
        int? LoadBasedConfigCooldownPeriod { get; set; }
        /// <summary>
        /// User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        int? LoadBasedConfigMaxNode { get; set; }
        /// <summary>
        /// User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        int? LoadBasedConfigMinNode { get; set; }
        /// <summary>
        /// User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering
        /// a scaling operation.
        /// </summary>
        int? LoadBasedConfigPollInterval { get; set; }
        /// <summary>The scaling rules.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScalingRule> LoadBasedConfigScalingRule { get; set; }
        /// <summary>Collection of logs to be enabled or disabled for log analytics.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterLogAnalyticsApplicationLogs LogAnalyticProfileApplicationLog { get; set; }
        /// <summary>True if log analytics is enabled for the cluster, otherwise false.</summary>
        bool? LogAnalyticProfileEnabled { get; set; }
        /// <summary>True if metrics are enabled, otherwise false.</summary>
        bool? LogAnalyticProfileMetricsEnabled { get; set; }
        /// <summary>
        /// The authentication mode to connect to your Hive metastore database. More details: https://learn.microsoft.com/en-us/azure/azure-sql/database/logins-create-manage?view=azuresql#authentication-and-authorization
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("SqlAuth", "IdentityAuth")]
        string MetastoreSpecDbConnectionAuthenticationMode { get; set; }
        /// <summary>The database name.</summary>
        string MetastoreSpecDbName { get; set; }
        /// <summary>The secret name which contains the database user password.</summary>
        string MetastoreSpecDbPasswordSecretName { get; set; }
        /// <summary>The database server host.</summary>
        string MetastoreSpecDbServerHost { get; set; }
        /// <summary>The database user name.</summary>
        string MetastoreSpecDbUserName { get; set; }
        /// <summary>The key vault resource id.</summary>
        string MetastoreSpecKeyVaultId { get; set; }
        /// <summary>The thrift url.</summary>
        string MetastoreSpecThriftUrl { get; set; }
        /// <summary>Cluster profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterProfile Profile { get; set; }
        /// <summary>
        /// Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IAuthorizationProfile ProfileAuthorizationProfile { get; set; }
        /// <summary>
        /// This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IAutoscaleProfile ProfileAutoscaleProfile { get; set; }
        /// <summary>Cluster access profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterAccessProfile ProfileClusterAccessProfile { get; set; }
        /// <summary>Version with 3/4 part.</summary>
        string ProfileClusterVersion { get; set; }
        /// <summary>Component list of this cluster type and version.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterComponentsItem> ProfileComponent { get; set; }
        /// <summary>Cluster connectivity profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IConnectivityProfile ProfileConnectivityProfile { get; set; }
        /// <summary>The Flink cluster profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IFlinkProfile ProfileFlinkProfile { get; set; }
        /// <summary>
        /// This property is required by Trino, Spark and Flink cluster but is optional for Kafka cluster.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IIdentityProfile ProfileIdentityProfile { get; set; }
        /// <summary>The Kafka cluster profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IKafkaProfile ProfileKafkaProfile { get; set; }
        /// <summary>LLAP cluster profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterProfileLlapProfile ProfileLlapProfile { get; set; }
        /// <summary>Cluster log analytics profile to enable or disable OMS agent for cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterLogAnalyticsProfile ProfileLogAnalyticsProfile { get; set; }
        /// <summary>Version with three part.</summary>
        string ProfileOssVersion { get; set; }
        /// <summary>Cluster Prometheus profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPrometheusProfile ProfilePrometheusProfile { get; set; }
        /// <summary>Cluster Ranger plugin profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterRangerPluginProfile ProfileRangerPluginProfile { get; set; }
        /// <summary>The ranger cluster profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerProfile ProfileRangerProfile { get; set; }
        /// <summary>The script action profile list.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScriptActionProfile> ProfileScriptActionProfile { get; set; }
        /// <summary>The cluster secret profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISecretsProfile ProfileSecretsProfile { get; set; }
        /// <summary>The service configs profiles.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterServiceConfigsProfile> ProfileServiceConfigsProfile { get; set; }
        /// <summary>The spark cluster profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISparkProfile ProfileSparkProfile { get; set; }
        /// <summary>Ssh profile for the cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISshProfile ProfileSshProfile { get; set; }
        /// <summary>Stub cluster profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterProfileStubProfile ProfileStubProfile { get; set; }
        /// <summary>Trino Cluster profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoProfile ProfileTrinoProfile { get; set; }
        /// <summary>Enable Prometheus for cluster or not.</summary>
        bool? PrometheuProfileEnabled { get; set; }
        /// <summary>Gets or sets the properties. Define cluster specific properties.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterResourceProperties Property { get; set; }
        /// <summary>Provisioning state of the resource.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("Accepted", "Succeeded", "Canceled", "Failed")]
        string ProvisioningState { get; set; }
        /// <summary>
        /// List of usernames that should be marked as ranger admins. These usernames should match the user principal name (UPN) of
        /// the respective AAD users.
        /// </summary>
        System.Collections.Generic.List<string> RangerAdmin { get; set; }

        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerAdminSpecDatabase RangerAdminDatabase { get; set; }
        /// <summary>
        /// Azure storage location of the blobs. MSI should have read/write access to this Storage account.
        /// </summary>
        string RangerAuditStorageAccount { get; set; }
        /// <summary>Enable Ranger for cluster or not.</summary>
        bool? RangerPluginProfileEnabled { get; set; }
        /// <summary>Specification for the Ranger Admin service.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerAdminSpec RangerProfileRangerAdmin { get; set; }
        /// <summary>Properties required to describe audit log storage.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerAuditSpec RangerProfileRangerAudit { get; set; }
        /// <summary>Specification for the Ranger Usersync service</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerUsersyncSpec RangerProfileRangerUsersync { get; set; }
        /// <summary>Denotes whether usersync service should be enabled</summary>
        bool? RangerUsersyncEnabled { get; set; }
        /// <summary>
        /// List of groups that should be synced. These group names should match the object id of the respective AAD groups.
        /// </summary>
        System.Collections.Generic.List<string> RangerUsersyncGroup { get; set; }
        /// <summary>
        /// User & groups can be synced automatically or via a static list that's refreshed.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("static", "automatic")]
        string RangerUsersyncMode { get; set; }
        /// <summary>
        /// List of user names that should be synced. These usernames should match the User principal name of the respective AAD users.
        /// </summary>
        System.Collections.Generic.List<string> RangerUsersyncUser { get; set; }
        /// <summary>Azure storage location of a mapping file that lists user & group associations.</summary>
        string RangerUsersyncUserMappingLocation { get; set; }
        /// <summary>
        /// Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are
        /// default when an specified scaling operation is executed (scale up/scale down)
        /// </summary>
        int? ScheduleBasedConfigDefaultCount { get; set; }
        /// <summary>
        /// This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules
        /// within the schedule across days and times (start/end).
        /// </summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISchedule> ScheduleBasedConfigSchedule { get; set; }
        /// <summary>
        /// User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        /// </summary>
        string ScheduleBasedConfigTimeZone { get; set; }
        /// <summary>
        /// Name of the user Key Vault where all the cluster specific user secrets are stored.
        /// </summary>
        string SecretProfileKeyVaultResourceId { get; set; }
        /// <summary>Properties of Key Vault secret.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISecretReference> SecretProfileSecret { get; set; }
        /// <summary>The default storage URL.</summary>
        string SparkProfileDefaultStorageUrl { get; set; }
        /// <summary>The metastore specification for Spark cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISparkMetastoreSpec SparkProfileMetastoreSpec { get; set; }
        /// <summary>Spark user plugins spec</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISparkUserPlugins SparkProfileUserPluginsSpec { get; set; }
        /// <summary>Spark user plugins.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISparkUserPlugin> SparkProfileUserPluginsSpecPlugin { get; set; }
        /// <summary>Number of ssh pods per cluster.</summary>
        int? SshProfileCount { get; set; }
        /// <summary>
        /// Prefix of the pod names. Pod number will be appended to the prefix. The ingress URLs for the pods will be available at
        /// <clusterFqdn>/<sshBasePath>/<prefix>-<number>
        /// </summary>
        string SshProfilePodPrefix { get; set; }
        /// <summary>Business status of the resource.</summary>
        string Status { get; set; }
        /// <summary>
        /// Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        /// </summary>
        string StorageHivecatalogName { get; set; }
        /// <summary>
        /// Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under
        /// schema trinologs.
        /// </summary>
        string StorageHivecatalogSchema { get; set; }
        /// <summary>
        /// Retention period for query log table partitions, this doesn't have any affect on actual data.
        /// </summary>
        int? StoragePartitionRetentionInDay { get; set; }
        /// <summary>Azure storage location of the blobs.</summary>
        string StoragePath { get; set; }
        /// <summary>Storage key is only required for wasb(s) storage.</summary>
        string StorageStoragekey { get; set; }
        /// <summary>Storage account uri which is used for savepoint and checkpoint state.</summary>
        string StorageUri { get; set; }
        /// <summary>The required CPU.</summary>
        float? TaskManagerCpu { get; set; }
        /// <summary>The required memory in MB, Container memory will be 110 percentile</summary>
        long? TaskManagerMemory { get; set; }
        /// <summary>Trino cluster catalog options.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ICatalogOptions TrinoProfileCatalogOption { get; set; }
        /// <summary>hive catalog options.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IHiveCatalogOption> TrinoProfileCatalogOptionsHive { get; set; }
        /// <summary>Trino Coordinator.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoCoordinator TrinoProfileCoordinator { get; set; }
        /// <summary>Trino user plugins spec</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoUserPlugins TrinoProfileUserPluginsSpec { get; set; }
        /// <summary>Trino user plugins.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoUserPlugin> TrinoProfileUserPluginsSpecPlugin { get; set; }
        /// <summary>User telemetry</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoUserTelemetry TrinoProfileUserTelemetrySpec { get; set; }
        /// <summary>Trino worker.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoWorker TrinoProfileWorker { get; set; }
        /// <summary>Trino user telemetry definition.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoTelemetryConfig UserTelemetrySpecStorage { get; set; }
        /// <summary>Web connectivity endpoint.</summary>
        string WebFqdn { get; set; }
        /// <summary>
        /// Private web connectivity endpoint. This property will only be returned when enableInternalIngress is true.
        /// </summary>
        string WebPrivateFqdn { get; set; }
        /// <summary>Trino debug configuration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoDebugConfig WorkerDebug { get; set; }
        /// <summary>The flag that if enable debug or not.</summary>
        bool? WorkerDebugEnable { get; set; }
        /// <summary>The debug port.</summary>
        int? WorkerDebugPort { get; set; }
        /// <summary>The flag that if suspend debug or not.</summary>
        bool? WorkerDebugSuspend { get; set; }

    }
}