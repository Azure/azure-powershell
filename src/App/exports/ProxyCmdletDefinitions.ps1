
# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Code generated by Microsoft (R) AutoRest Code Generator.Changes may cause incorrect behavior and will be lost if the code
# is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Deactivates a revision for a Container App
.Description
Deactivates a revision for a Container App
.Example
Disable-AzContainerAppRevision -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app -Name azps-containerapp-1--6a9svx2 -PassThru
.Example
$containerapp = Get-AzContainerApp -ResourceGroupName azps_test_group_app -Name azps-containerapp-1
Disable-AzContainerAppRevision -ContainerAppInputObject $containerapp -Name azps-containerapp-1--6a9svx2 -PassThru

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTAINERAPPINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/disable-azcontainerapprevision
#>
function Disable-AzContainerAppRevision {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Deactivate', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Deactivate', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(ParameterSetName='Deactivate', Mandatory)]
    [Parameter(ParameterSetName='DeactivateViaIdentityContainerApp', Mandatory)]
    [Alias('RevisionName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App Revision.
    ${Name},

    [Parameter(ParameterSetName='Deactivate', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Deactivate')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeactivateViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='DeactivateViaIdentityContainerApp', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONTAINERAPPINPUTOBJECT properties and create a hash table.
    ${ContainerAppInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Deactivate = 'Az.App.private\Disable-AzContainerAppRevision_Deactivate';
            DeactivateViaIdentity = 'Az.App.private\Disable-AzContainerAppRevision_DeactivateViaIdentity';
            DeactivateViaIdentityContainerApp = 'Az.App.private\Disable-AzContainerAppRevision_DeactivateViaIdentityContainerApp';
        }
        if (('Deactivate') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Activates a revision for a Container App
.Description
Activates a revision for a Container App
.Example
Enable-AzContainerAppRevision -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app -Name azps-containerapp-1--6a9svx2 -PassThru
.Example
$containerapp = Get-AzContainerApp -ResourceGroupName azps_test_group_app -Name azps-containerapp-1
Enable-AzContainerAppRevision -ContainerAppInputObject $containerapp -Name azps-containerapp-1--6a9svx2 -PassThru

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTAINERAPPINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/enable-azcontainerapprevision
#>
function Enable-AzContainerAppRevision {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Activate', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Activate', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(ParameterSetName='Activate', Mandatory)]
    [Parameter(ParameterSetName='ActivateViaIdentityContainerApp', Mandatory)]
    [Alias('RevisionName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App Revision.
    ${Name},

    [Parameter(ParameterSetName='Activate', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Activate')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='ActivateViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='ActivateViaIdentityContainerApp', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONTAINERAPPINPUTOBJECT properties and create a hash table.
    ${ContainerAppInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Activate = 'Az.App.private\Enable-AzContainerAppRevision_Activate';
            ActivateViaIdentity = 'Az.App.private\Enable-AzContainerAppRevision_ActivateViaIdentity';
            ActivateViaIdentityContainerApp = 'Az.App.private\Enable-AzContainerAppRevision_ActivateViaIdentityContainerApp';
        }
        if (('Activate') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a AuthConfig of a Container App.
.Description
Get a AuthConfig of a Container App.
.Example
Get-AzContainerAppAuthConfig -ContainerAppName azps-containerapp-2 -ResourceGroupName azps_test_group_app
.Example
Get-AzContainerAppAuthConfig -ContainerAppName azps-containerapp-2 -ResourceGroupName azps_test_group_app -Name current
.Example
$containerapp = Get-AzContainerApp -Name azps-containerapp-2 -ResourceGroupName azps_test_group_app
Get-AzContainerAppAuthConfig -ContainerAppInputObject $containerapp -Name current

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfig
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTAINERAPPINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappauthconfig
#>
function Get-AzContainerAppAuthConfig {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfig])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityContainerApp', Mandatory)]
    [Alias('AuthConfigName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App AuthConfig.
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityContainerApp', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONTAINERAPPINPUTOBJECT properties and create a hash table.
    ${ContainerAppInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppAuthConfig_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppAuthConfig_GetViaIdentity';
            GetViaIdentityContainerApp = 'Az.App.private\Get-AzContainerAppAuthConfig_GetViaIdentityContainerApp';
            List = 'Az.App.private\Get-AzContainerAppAuthConfig_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get auth token for a container app
.Description
Get auth token for a container app
.Example
Get-AzContainerAppAuthToken -ContainerAppName azps-containerapp-2 -ResourceGroupName azps_test_group_app
.Example
$containerapp = Get-AzContainerApp -ResourceGroupName azps_test_group_app -Name azps-containerapp-1
Get-AzContainerAppAuthToken -InputObject $containerapp

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainerAppAuthToken
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappauthtoken
#>
function Get-AzContainerAppAuthToken {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainerAppAuthToken])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppAuthToken_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppAuthToken_GetViaIdentity';
        }
        if (('Get') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get all available workload profiles for a location.
.Description
Get all available workload profiles for a location.
.Example
Get-AzContainerAppAvailableWorkloadProfile -Location eastus

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAvailableWorkloadProfile
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappavailableworkloadprofile
#>
function Get-AzContainerAppAvailableWorkloadProfile {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAvailableWorkloadProfile])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of Azure region.
    ${Location},

    [Parameter(ParameterSetName='Get')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppAvailableWorkloadProfile_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppAvailableWorkloadProfile_GetViaIdentity';
        }
        if (('Get') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get all billingMeters for a location.
.Description
Get all billingMeters for a location.
.Example
Get-AzContainerAppBillingMeter -Location eastus

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IBillingMeterCollection
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappbillingmeter
#>
function Get-AzContainerAppBillingMeter {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IBillingMeterCollection])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of Azure region.
    ${Location},

    [Parameter(ParameterSetName='Get')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppBillingMeter_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppBillingMeter_GetViaIdentity';
        }
        if (('Get') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get the specified Certificate.
.Description
Get the specified Certificate.
.Example
Get-AzContainerAppConnectedEnvCert -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app
.Example
Get-AzContainerAppConnectedEnvCert -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Name azps-connectedenvcert
.Example
$connectedenv = Get-AzContainerAppConnectedEnv -ResourceGroupName azps_test_group_app -Name azps-connectedenv
Get-AzContainerAppConnectedEnvCert -ConnectedEnvironmentInputObject $connectedenv -Name azps-connectedenvcert

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICertificate
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONNECTEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappconnectedenvcert
#>
function Get-AzContainerAppConnectedEnvCert {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICertificate])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Connected Environment.
    ${ConnectedEnvironmentName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityConnectedEnvironment', Mandatory)]
    [Alias('CertificateName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Certificate.
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityConnectedEnvironment', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONNECTEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ConnectedEnvironmentInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppConnectedEnvCert_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppConnectedEnvCert_GetViaIdentity';
            GetViaIdentityConnectedEnvironment = 'Az.App.private\Get-AzContainerAppConnectedEnvCert_GetViaIdentityConnectedEnvironment';
            List = 'Az.App.private\Get-AzContainerAppConnectedEnvCert_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
List secrets for a dapr component
.Description
List secrets for a dapr component
.Example
Get-AzContainerAppConnectedEnvDaprSecret -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -DaprName azps-connectedenvdapr

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprSecretsCollection
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappconnectedenvdaprsecret
#>
function Get-AzContainerAppConnectedEnvDaprSecret {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprSecretsCollection])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the connected environment.
    ${ConnectedEnvironmentName},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Dapr Component.
    ${DaprName},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            List = 'Az.App.private\Get-AzContainerAppConnectedEnvDaprSecret_List';
        }
        if (('List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a dapr component.
.Description
Get a dapr component.
.Example
Get-AzContainerAppConnectedEnvDapr -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app
.Example
Get-AzContainerAppConnectedEnvDapr -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Name azps-connectedenvdapr
.Example
$connectedenv = Get-AzContainerAppConnectedEnv -ResourceGroupName azps_test_group_app -Name azps-connectedenv
Get-AzContainerAppConnectedEnvDapr -ConnectedEnvironmentInputObject $connectedenv -Name azps-connectedenvdapr

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprComponent
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONNECTEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappconnectedenvdapr
#>
function Get-AzContainerAppConnectedEnvDapr {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprComponent])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the connected environment.
    ${ConnectedEnvironmentName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityConnectedEnvironment', Mandatory)]
    [Alias('DaprName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Dapr Component.
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityConnectedEnvironment', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONNECTEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ConnectedEnvironmentInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppConnectedEnvDapr_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppConnectedEnvDapr_GetViaIdentity';
            GetViaIdentityConnectedEnvironment = 'Az.App.private\Get-AzContainerAppConnectedEnvDapr_GetViaIdentityConnectedEnvironment';
            List = 'Az.App.private\Get-AzContainerAppConnectedEnvDapr_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get storage for a connectedEnvironment.
.Description
Get storage for a connectedEnvironment.
.Example
Get-AzContainerAppConnectedEnvStorage -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app
.Example
Get-AzContainerAppConnectedEnvStorage -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Name azpstestsa
.Example
$connectedenv = Get-AzContainerAppConnectedEnv -ResourceGroupName azps_test_group_app -Name azps-connectedenv
Get-AzContainerAppConnectedEnvStorage -ConnectedEnvironmentInputObject $connectedenv -Name azpstestsa

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IConnectedEnvironmentStorage
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IConnectedEnvironmentStoragesCollection
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONNECTEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappconnectedenvstorage
#>
function Get-AzContainerAppConnectedEnvStorage {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IConnectedEnvironmentStorage], [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IConnectedEnvironmentStoragesCollection])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Environment.
    ${ConnectedEnvironmentName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityConnectedEnvironment', Mandatory)]
    [Alias('StorageName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the storage.
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityConnectedEnvironment', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONNECTEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ConnectedEnvironmentInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppConnectedEnvStorage_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppConnectedEnvStorage_GetViaIdentity';
            GetViaIdentityConnectedEnvironment = 'Az.App.private\Get-AzContainerAppConnectedEnvStorage_GetViaIdentityConnectedEnvironment';
            List = 'Az.App.private\Get-AzContainerAppConnectedEnvStorage_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get the properties of an connectedEnvironment.
.Description
Get the properties of an connectedEnvironment.
.Example
Get-AzContainerAppConnectedEnv
.Example
Get-AzContainerAppConnectedEnv -ResourceGroupName azps_test_group_app
.Example
Get-AzContainerAppConnectedEnv -ResourceGroupName azps_test_group_app -Name azps-connectedenv

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IConnectedEnvironment
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappconnectedenv
#>
function Get-AzContainerAppConnectedEnv {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IConnectedEnvironment])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Alias('ConnectedEnvironmentName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the connectedEnvironment.
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List1', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Parameter(ParameterSetName='List1')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppConnectedEnv_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppConnectedEnv_GetViaIdentity';
            List = 'Az.App.private\Get-AzContainerAppConnectedEnv_List';
            List1 = 'Az.App.private\Get-AzContainerAppConnectedEnv_List1';
        }
        if (('Get', 'List', 'List1') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Analyzes a custom hostname for a Container App
.Description
Analyzes a custom hostname for a Container App
.Example
Get-AzContainerAppCustomHostName -ContainerAppName azps-containerapp-2 -ResourceGroupName azps_test_group_app

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICustomHostnameAnalysisResult
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappcustomhostname
#>
function Get-AzContainerAppCustomHostName {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICustomHostnameAnalysisResult])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Query')]
    [System.String]
    # Custom hostname.
    ${CustomHostname},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            List = 'Az.App.private\Get-AzContainerAppCustomHostName_List';
        }
        if (('List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a diagnostics result of a Container App.
.Description
Get a diagnostics result of a Container App.
.Example
Get-AzContainerAppDiagnosticDetector -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDiagnostics
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTAINERAPPINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappdiagnosticdetector
#>
function Get-AzContainerAppDiagnosticDetector {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDiagnostics])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityContainerApp', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App Detector.
    ${DetectorName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityContainerApp', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONTAINERAPPINPUTOBJECT properties and create a hash table.
    ${ContainerAppInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppDiagnosticDetector_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppDiagnosticDetector_GetViaIdentity';
            GetViaIdentityContainerApp = 'Az.App.private\Get-AzContainerAppDiagnosticDetector_GetViaIdentityContainerApp';
            List = 'Az.App.private\Get-AzContainerAppDiagnosticDetector_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a revision of a Container App.
.Description
Get a revision of a Container App.
.Example
Get-AzContainerAppDiagnosticRevision -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app
.Example
Get-AzContainerAppDiagnosticRevision -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app -RevisionName azps-containerapp-1--6a9svx2

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IRevision
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTAINERAPPINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappdiagnosticrevision
#>
function Get-AzContainerAppDiagnosticRevision {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IRevision])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityContainerApp', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App Revision.
    ${RevisionName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityContainerApp', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONTAINERAPPINPUTOBJECT properties and create a hash table.
    ${ContainerAppInputObject},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Query')]
    [System.String]
    # The filter to apply on the operation.
    ${Filter},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppDiagnosticRevision_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppDiagnosticRevision_GetViaIdentity';
            GetViaIdentityContainerApp = 'Az.App.private\Get-AzContainerAppDiagnosticRevision_GetViaIdentityContainerApp';
            List = 'Az.App.private\Get-AzContainerAppDiagnosticRevision_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get the properties of a Container App.
.Description
Get the properties of a Container App.
.Example
Get-AzContainerAppDiagnosticRoot -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainerApp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappdiagnosticroot
#>
function Get-AzContainerAppDiagnosticRoot {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainerApp])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppDiagnosticRoot_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppDiagnosticRoot_GetViaIdentity';
        }
        if (('Get') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get details of a single job execution
.Description
Get details of a single job execution
.Example
Get-AzContainerAppJobExecution -JobName azps-app-job -ResourceGroupName azps_test_group_app -Name "azps-app-job-vvhlnul"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJobExecution
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

JOBINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappjobexecution
#>
function Get-AzContainerAppJobExecution {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJobExecution])]
[CmdletBinding(DefaultParameterSetName='Job', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Job', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Job Name
    ${JobName},

    [Parameter(ParameterSetName='Job', Mandatory)]
    [Parameter(ParameterSetName='JobViaIdentityJob', Mandatory)]
    [Alias('JobExecutionName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Job execution name.
    ${Name},

    [Parameter(ParameterSetName='Job', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Job')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='JobViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='JobViaIdentityJob', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for JOBINPUTOBJECT properties and create a hash table.
    ${JobInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Job = 'Az.App.private\Get-AzContainerAppJobExecution_Job';
            JobViaIdentity = 'Az.App.private\Get-AzContainerAppJobExecution_JobViaIdentity';
            JobViaIdentityJob = 'Az.App.private\Get-AzContainerAppJobExecution_JobViaIdentityJob';
        }
        if (('Job') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
List secrets for a container apps job
.Description
List secrets for a container apps job
.Example
Get-AzContainerAppJobSecret -JobName azps-app-job -ResourceGroupName azps_test_group_app

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJobSecretsCollection
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappjobsecret
#>
function Get-AzContainerAppJobSecret {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJobSecretsCollection])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Job Name
    ${JobName},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            List = 'Az.App.private\Get-AzContainerAppJobSecret_List';
        }
        if (('List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get the properties of a Container Apps Job.
.Description
Get the properties of a Container Apps Job.
.Example
Get-AzContainerAppJob
.Example
Get-AzContainerAppJob -ResourceGroupName azps_test_group_app
.Example
Get-AzContainerAppJob -ResourceGroupName azps_test_group_app -Name azps-app-job

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJob
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappjob
#>
function Get-AzContainerAppJob {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJob])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Alias('JobName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Job Name
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List1', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Parameter(ParameterSetName='List1')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppJob_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppJob_GetViaIdentity';
            List = 'Az.App.private\Get-AzContainerAppJob_List';
            List1 = 'Az.App.private\Get-AzContainerAppJob_List1';
        }
        if (('Get', 'List', 'List1') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get the specified Managed Certificate.
.Description
Get the specified Managed Certificate.
.Example
Get-AzContainerAppManagedCert -EnvName azps-env -Name azps-managedcert -ResourceGroupName azps_test_group_app
.Example
Get-AzContainerAppManagedCert -EnvName azps-env -ResourceGroupName azps_test_group_app

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedCertificate
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

MANAGEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappmanagedcert
#>
function Get-AzContainerAppManagedCert {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedCertificate])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment.
    ${EnvName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityManagedEnvironment', Mandatory)]
    [Alias('ManagedCertificateName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Certificate.
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityManagedEnvironment', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for MANAGEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ManagedEnvironmentInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppManagedCert_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppManagedCert_GetViaIdentity';
            GetViaIdentityManagedEnvironment = 'Az.App.private\Get-AzContainerAppManagedCert_GetViaIdentityManagedEnvironment';
            List = 'Az.App.private\Get-AzContainerAppManagedCert_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Checks if resource name is available.
.Description
Checks if resource name is available.
.Example
Get-AzContainerAppManagedEnvAuthToken -ResourceGroupName azps_test_group_app -EnvName azps-env

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IEnvironmentAuthToken
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappmanagedenvauthtoken
#>
function Get-AzContainerAppManagedEnvAuthToken {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IEnvironmentAuthToken])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment.
    ${EnvName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppManagedEnvAuthToken_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppManagedEnvAuthToken_GetViaIdentity';
        }
        if (('Get') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get the specified Certificate.
.Description
Get the specified Certificate.
.Example
Get-AzContainerAppManagedEnvCert -EnvName azps-env -ResourceGroupName azps_test_group_app
.Example
Get-AzContainerAppManagedEnvCert -EnvName azps-env -ResourceGroupName azps_test_group_app -Name azps-env-cert
.Example
$managedenv = Get-AzContainerAppManagedEnv -Name azps-env -ResourceGroupName azps_test_group_app
Get-AzContainerAppManagGet-AzContainerAppManagedEnvCert -ManagedEnvironmentInputObject $managedenv -Name azps-env-cert

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICertificate
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

MANAGEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappmanagedenvcert
#>
function Get-AzContainerAppManagedEnvCert {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICertificate])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment.
    ${EnvName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityManagedEnvironment', Mandatory)]
    [Alias('CertificateName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Certificate.
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityManagedEnvironment', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for MANAGEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ManagedEnvironmentInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppManagedEnvCert_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppManagedEnvCert_GetViaIdentity';
            GetViaIdentityManagedEnvironment = 'Az.App.private\Get-AzContainerAppManagedEnvCert_GetViaIdentityManagedEnvironment';
            List = 'Az.App.private\Get-AzContainerAppManagedEnvCert_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
List secrets for a dapr component
.Description
List secrets for a dapr component
.Example
Get-AzContainerAppManagedEnvDaprSecret -DaprName azps-dapr -EnvName azps-env -ResourceGroupName azps_test_group_app

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprSecretsCollection
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappmanagedenvdaprsecret
#>
function Get-AzContainerAppManagedEnvDaprSecret {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprSecretsCollection])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Dapr Component.
    ${DaprName},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment.
    ${EnvName},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            List = 'Az.App.private\Get-AzContainerAppManagedEnvDaprSecret_List';
        }
        if (('List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a dapr component.
.Description
Get a dapr component.
.Example
Get-AzContainerAppManagedEnvDapr -EnvName azps-env -ResourceGroupName azps_test_group_app
.Example
Get-AzContainerAppManagedEnvDapr -EnvName azps-env -ResourceGroupName azps_test_group_app -Name azps-dapr
.Example
$managedenv = Get-AzContainerAppManagedEnv -Name azps-env -ResourceGroupName azps_test_group_app
Get-AzContainerAppManagedEnvDapr -ManagedEnvironmentInputObject $managedenv -Name azps-dapr

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprComponent
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

MANAGEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappmanagedenvdapr
#>
function Get-AzContainerAppManagedEnvDapr {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprComponent])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment.
    ${EnvName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityManagedEnvironment', Mandatory)]
    [Alias('DaprName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Dapr Component.
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityManagedEnvironment', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for MANAGEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ManagedEnvironmentInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppManagedEnvDapr_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppManagedEnvDapr_GetViaIdentity';
            GetViaIdentityManagedEnvironment = 'Az.App.private\Get-AzContainerAppManagedEnvDapr_GetViaIdentityManagedEnvironment';
            List = 'Az.App.private\Get-AzContainerAppManagedEnvDapr_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get the diagnostics data for a Managed Environment used to host container apps.
.Description
Get the diagnostics data for a Managed Environment used to host container apps.
.Example
Get-AzContainerAppManagedEnvDiagnosticDetector -EnvName azps-env -ResourceGroupName azps_test_group_app

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDiagnostics
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDiagnosticsCollection
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

MANAGEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappmanagedenvdiagnosticdetector
#>
function Get-AzContainerAppManagedEnvDiagnosticDetector {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDiagnostics], [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDiagnosticsCollection])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Environment.
    ${EnvName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityManagedEnvironment', Mandatory)]
    [Alias('DetectorName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment detector.
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityManagedEnvironment', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for MANAGEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ManagedEnvironmentInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppManagedEnvDiagnosticDetector_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppManagedEnvDiagnosticDetector_GetViaIdentity';
            GetViaIdentityManagedEnvironment = 'Az.App.private\Get-AzContainerAppManagedEnvDiagnosticDetector_GetViaIdentityManagedEnvironment';
            List = 'Az.App.private\Get-AzContainerAppManagedEnvDiagnosticDetector_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get the properties of a Managed Environment used to host container apps.
.Description
Get the properties of a Managed Environment used to host container apps.
.Example
Get-AzContainerAppManagedEnvDiagnosticRoot -EnvName azps-env -ResourceGroupName azps_test_group_app

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedEnvironment
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappmanagedenvdiagnosticroot
#>
function Get-AzContainerAppManagedEnvDiagnosticRoot {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedEnvironment])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Environment.
    ${EnvName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppManagedEnvDiagnosticRoot_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppManagedEnvDiagnosticRoot_GetViaIdentity';
        }
        if (('Get') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get storage for a managedEnvironment.
.Description
Get storage for a managedEnvironment.
.Example
Get-AzContainerAppManagedEnvStorage -EnvName azps-env -ResourceGroupName azps_test_group_app
.Example
Get-AzContainerAppManagedEnvStorage -EnvName azps-env -ResourceGroupName azps_test_group_app -Name azpstestsa
.Example
$managedenv = Get-AzContainerAppManagedEnv -Name azps-env -ResourceGroupName azps_test_group_app
Get-AzContainerAppManagedEnvStorage -ManagedEnvironmentInputObject $managedenv -Name azpstestsa

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedEnvironmentStorage
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedEnvironmentStoragesCollection
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

MANAGEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappmanagedenvstorage
#>
function Get-AzContainerAppManagedEnvStorage {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedEnvironmentStorage], [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedEnvironmentStoragesCollection])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Environment.
    ${EnvName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityManagedEnvironment', Mandatory)]
    [Alias('StorageName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the storage.
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityManagedEnvironment', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for MANAGEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ManagedEnvironmentInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppManagedEnvStorage_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppManagedEnvStorage_GetViaIdentity';
            GetViaIdentityManagedEnvironment = 'Az.App.private\Get-AzContainerAppManagedEnvStorage_GetViaIdentityManagedEnvironment';
            List = 'Az.App.private\Get-AzContainerAppManagedEnvStorage_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get all workload Profile States for a Managed Environment.
.Description
Get all workload Profile States for a Managed Environment.
.Example
Get-AzContainerAppManagedEnvWorkloadProfileState -EnvName azps-env -ResourceGroupName azps_test_group_app

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IWorkloadProfileStates
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappmanagedenvworkloadprofilestate
#>
function Get-AzContainerAppManagedEnvWorkloadProfileState {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IWorkloadProfileStates])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment.
    ${EnvName},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            List = 'Az.App.private\Get-AzContainerAppManagedEnvWorkloadProfileState_List';
        }
        if (('List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get the properties of a Managed Environment used to host container apps.
.Description
Get the properties of a Managed Environment used to host container apps.
.Example
Get-AzContainerAppManagedEnv
.Example
Get-AzContainerAppManagedEnv -ResourceGroupName azps_test_group_app
.Example
Get-AzContainerAppManagedEnv -ResourceGroupName azps_test_group_app -Name azps-env

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedEnvironment
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappmanagedenv
#>
function Get-AzContainerAppManagedEnv {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedEnvironment])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Alias('EnvName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Environment.
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List1', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Parameter(ParameterSetName='List1')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppManagedEnv_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppManagedEnv_GetViaIdentity';
            List = 'Az.App.private\Get-AzContainerAppManagedEnv_List';
            List1 = 'Az.App.private\Get-AzContainerAppManagedEnv_List1';
        }
        if (('Get', 'List', 'List1') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a replica for a Container App Revision.
.Description
Get a replica for a Container App Revision.
.Example
Get-AzContainerAppRevisionReplica -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app -RevisionName azps-containerapp-1--xdmhk31
.Example
Get-AzContainerAppRevisionReplica -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app -RevisionName azps-containerapp-1--xdmhk31 -Name azps
.Example
$obj = Get-AzContainerAppRevision -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app

Get-AzContainerAppRevisionReplica -RevisionInputObject $obj -Name azps-containerapp-1--xdmhk31-7fdbf895c6-rh65t
.Example
$obj = Get-AzContainerApp -ResourceGroupName azps_test_group_app -Name azps-containerapp-1

Get-AzContainerAppRevisionReplica -ContainerAppInputObject $obj -RevisionName azps-containerapp-1--xdmhk31 -Name azps-containerapp-1--xdmhk31-7fdbf895c6-rh65t

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IReplica
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IReplicaCollection
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTAINERAPPINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

REVISIONINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerapprevisionreplica
#>
function Get-AzContainerAppRevisionReplica {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IReplica], [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IReplicaCollection])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityContainerApp', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityRevision', Mandatory)]
    [Alias('ReplicaName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App Revision Replica.
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityContainerApp', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App Revision.
    ${RevisionName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityContainerApp', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONTAINERAPPINPUTOBJECT properties and create a hash table.
    ${ContainerAppInputObject},

    [Parameter(ParameterSetName='GetViaIdentityRevision', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for REVISIONINPUTOBJECT properties and create a hash table.
    ${RevisionInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppRevisionReplica_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppRevisionReplica_GetViaIdentity';
            GetViaIdentityContainerApp = 'Az.App.private\Get-AzContainerAppRevisionReplica_GetViaIdentityContainerApp';
            GetViaIdentityRevision = 'Az.App.private\Get-AzContainerAppRevisionReplica_GetViaIdentityRevision';
            List = 'Az.App.private\Get-AzContainerAppRevisionReplica_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a revision of a Container App.
.Description
Get a revision of a Container App.
.Example
Get-AzContainerAppRevision -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app
.Example
Get-AzContainerAppRevision -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app -Name azps-containerapp-1--6a9svx2
.Example
$containerapp = Get-AzContainerApp -ResourceGroupName azps_test_group_app -Name azps-containerapp-1
Get-AzContainerAppRevision -ContainerAppInputObject $containerapp -Name azps-containerapp-1--6a9svx2

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IRevision
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTAINERAPPINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerapprevision
#>
function Get-AzContainerAppRevision {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IRevision])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityContainerApp', Mandatory)]
    [Alias('RevisionName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App Revision.
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityContainerApp', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONTAINERAPPINPUTOBJECT properties and create a hash table.
    ${ContainerAppInputObject},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Query')]
    [System.String]
    # The filter to apply on the operation.
    ${Filter},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppRevision_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppRevision_GetViaIdentity';
            GetViaIdentityContainerApp = 'Az.App.private\Get-AzContainerAppRevision_GetViaIdentityContainerApp';
            List = 'Az.App.private\Get-AzContainerAppRevision_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
List secrets for a container app
.Description
List secrets for a container app
.Example
Get-AzContainerAppSecret -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISecretsCollection
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappsecret
#>
function Get-AzContainerAppSecret {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISecretsCollection])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            List = 'Az.App.private\Get-AzContainerAppSecret_List';
        }
        if (('List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a SourceControl of a Container App.
.Description
Get a SourceControl of a Container App.
.Example
Get-AzContainerAppSourceControl -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app
.Example
Get-AzContainerAppSourceControl -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app -Name current
.Example
$containerapp = Get-AzContainerApp -ResourceGroupName azps_test_group_app -Name azps-containerapp-1
Get-AzContainerAppSourceControl -ContainerAppInputObject $containerapp -Name current

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISourceControl
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTAINERAPPINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerappsourcecontrol
#>
function Get-AzContainerAppSourceControl {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISourceControl])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityContainerApp', Mandatory)]
    [Alias('SourceControlName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App SourceControl.
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityContainerApp', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONTAINERAPPINPUTOBJECT properties and create a hash table.
    ${ContainerAppInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerAppSourceControl_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerAppSourceControl_GetViaIdentity';
            GetViaIdentityContainerApp = 'Az.App.private\Get-AzContainerAppSourceControl_GetViaIdentityContainerApp';
            List = 'Az.App.private\Get-AzContainerAppSourceControl_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get the properties of a Container App.
.Description
Get the properties of a Container App.
.Example
Get-AzContainerApp
.Example
Get-AzContainerApp -ResourceGroupName azps_test_group_app
.Example
Get-AzContainerApp -ResourceGroupName azps_test_group_app -Name azps-containerapp-1

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainerApp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/get-azcontainerapp
#>
function Get-AzContainerApp {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainerApp])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Alias('ContainerAppName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List1', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Parameter(ParameterSetName='List1')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='GetViaIdentity')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.App.private\Get-AzContainerApp_Get';
            GetViaIdentity = 'Az.App.private\Get-AzContainerApp_GetViaIdentity';
            List = 'Az.App.private\Get-AzContainerApp_List';
            List1 = 'Az.App.private\Get-AzContainerApp_List1';
        }
        if (('Get', 'List', 'List1') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create the AuthConfig for a Container App.
.Description
Create the AuthConfig for a Container App.
.Example
$identity = New-AzContainerAppIdentityProviderObject -RegistrationAppId xxxxxx@xxx.com -RegistrationAppSecretSettingName redis-config

New-AzContainerAppAuthConfig -Name current -ContainerAppName azps-containerapp-2 -ResourceGroupName azps_test_group_app -PlatformEnabled -GlobalValidationUnauthenticatedClientAction 'AllowAnonymous' -IdentityProvider $identity

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfig
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTAINERAPPINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

IDENTITYPROVIDER <IIdentityProviders>: The configuration settings of each of the identity providers used to configure ContainerApp Service Authentication/Authorization.
  [AllowedPrincipalGroup <List<String>>]: The list of the allowed groups.
  [AllowedPrincipalIdentity <List<String>>]: The list of the allowed identities.
  [AppleEnabled <Boolean?>]: <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
  [AppleLoginScope <List<String>>]: A list of the scopes that should be requested while authenticating.
  [AppleRegistrationClientId <String>]: The Client ID of the app used for login.
  [AppleRegistrationClientSecretSettingName <String>]: The app setting name that contains the client secret.
  [AzureActiveDirectoryEnabled <Boolean?>]: <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
  [AzureActiveDirectoryIsAutoProvisioned <Boolean?>]: Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.         This is an internal flag primarily intended to support the Azure Management Portal. Users should not         read or write to this property.
  [AzureActiveDirectoryRegistrationClientId <String>]: The Client ID of this relying party application, known as the client_id.         This setting is required for enabling OpenID Connection authentication with Azure Active Directory or         other 3rd party OpenID Connect providers.         More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
  [AzureActiveDirectoryRegistrationClientSecretSettingName <String>]: The app setting name that contains the client secret of the relying party application.
  [AzureActiveDirectoryValidationAllowedAudience <List<String>>]: The list of audiences that can make successful authentication/authorization requests.
  [AzureStaticWebAppEnabled <Boolean?>]: <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
  [AzureStaticWebAppsRegistrationClientId <String>]: The Client ID of the app used for login.
  [CustomOpenIdConnectProvider <IIdentityProvidersCustomOpenIdConnectProviders>]: The map of the name of the alias of each custom Open ID Connect provider to the         configuration settings of the custom Open ID Connect provider.
    [(Any) <ICustomOpenIdConnectProvider>]: This indicates any property can be added to this object.
  [DefaultAuthorizationPolicyAllowedApplication <List<String>>]: The configuration settings of the Azure Active Directory allowed applications.
  [FacebookEnabled <Boolean?>]: <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
  [FacebookGraphApiVersion <String>]: The version of the Facebook api to be used while logging in.
  [FacebookLoginScope <List<String>>]: A list of the scopes that should be requested while authenticating.
  [GitHubEnabled <Boolean?>]: <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
  [GitHubLoginScope <List<String>>]: A list of the scopes that should be requested while authenticating.
  [GitHubRegistrationClientId <String>]: The Client ID of the app used for login.
  [GitHubRegistrationClientSecretSettingName <String>]: The app setting name that contains the client secret.
  [GoogleEnabled <Boolean?>]: <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
  [GoogleLoginScope <List<String>>]: A list of the scopes that should be requested while authenticating.
  [GoogleRegistrationClientId <String>]: The Client ID of the app used for login.
  [GoogleRegistrationClientSecretSettingName <String>]: The app setting name that contains the client secret.
  [GoogleValidationAllowedAudience <List<String>>]: The configuration settings of the allowed list of audiences from which to validate the JWT token.
  [JwtClaimCheckAllowedClientApplication <List<String>>]: The list of the allowed client applications.
  [JwtClaimCheckAllowedGroup <List<String>>]: The list of the allowed groups.
  [LoginDisableWwwAuthenticate <Boolean?>]: <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
  [LoginParameter <List<String>>]: Login parameters to send to the OpenID Connect authorization endpoint when         a user logs in. Each parameter must be in the form "key=value".
  [RegistrationAppId <String>]: The App ID of the app used for login.
  [RegistrationAppSecretSettingName <String>]: The app setting name that contains the app secret.
  [RegistrationClientSecretCertificateIssuer <String>]: An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes. This property acts as         a replacement for the Client Secret Certificate Thumbprint. It is also optional.
  [RegistrationClientSecretCertificateSubjectAlternativeName <String>]: An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes. This property acts as         a replacement for the Client Secret Certificate Thumbprint. It is also optional.
  [RegistrationClientSecretCertificateThumbprint <String>]: An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as         a replacement for the Client Secret. It is also optional.
  [RegistrationConsumerKey <String>]: The OAuth 1.0a consumer key of the Twitter application used for sign-in.         This setting is required for enabling Twitter Sign-In.         Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
  [RegistrationConsumerSecretSettingName <String>]: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter         application used for sign-in.
  [RegistrationOpenIdIssuer <String>]: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.         When using Azure Active Directory, this value is the URI of the directory tenant, e.g. https://login.microsoftonline.com/v2.0/{tenant-guid}/.         This URI is a case-sensitive identifier for the token issuer.         More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
  [TwitterEnabled <Boolean?>]: <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/new-azcontainerappauthconfig
#>
function New-AzContainerAppAuthConfig {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfig])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Alias('AuthConfigName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App AuthConfig.
    ${Name},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaJsonFilePath')]
    [Parameter(ParameterSetName='CreateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONTAINERAPPINPUTOBJECT properties and create a hash table.
    ${ContainerAppInputObject},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("FixedTime", "IdentityProviderDerived")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The convention used when determining the session cookie's expiration.
    ${CookieExpirationConvention},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The time after the request is made when the session cookie should expire.
    ${CookieExpirationTimeToExpiration},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("NoProxy", "Standard", "Custom")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The convention used to determine the url of the request made.
    ${ForwardProxyConvention},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The name of the header containing the host of the request.
    ${ForwardProxyCustomHostHeaderName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The name of the header containing the scheme of the request.
    ${ForwardProxyCustomProtoHeaderName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # The paths for which unauthenticated flow would not be redirected to the login page.
    ${GlobalValidationExcludedPath},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The default authentication provider to use when multiple providers are configured.This setting is only needed if multiple providers are configured and the unauthenticated clientaction is set to "RedirectToLoginPage".
    ${GlobalValidationRedirectToProvider},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("RedirectToLoginPage", "AllowAnonymous", "Return401", "Return403")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The action to take when an unauthenticated client attempts to access the app.
    ${GlobalValidationUnauthenticatedClientAction},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.
    ${HttpSettingRequireHttps},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IIdentityProviders]
    # The configuration settings of each of the identity providers used to configure ContainerApp Service Authentication/Authorization.
    # To construct, see NOTES section for IDENTITYPROVIDER properties and create a hash table.
    ${IdentityProvider},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # External URLs that can be redirected to as part of logging in or logging out of the app.
    # Note that the query string part of the URL is ignored.This is an advanced setting typically only needed by Windows Store application backends.Note that URLs within the current domain are always implicitly allowed.
    ${LoginAllowedExternalRedirectUrl},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
    ${LoginPreserveUrlFragmentsForLogin},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The time after the request is made when the nonce should expire.
    ${NonceExpirationInterval},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
    ${NonceValidateNonce},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
    ${PlatformEnabled},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The RuntimeVersion of the Authentication / Authorization feature in use for the current app.The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
    ${PlatformRuntimeVersion},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The prefix that should precede all the authentication/authorization paths.
    ${RouteApiPrefix},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The endpoint at which a logout request should be made.
    ${RouteLogoutEndpoint},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.App.private\New-AzContainerAppAuthConfig_CreateExpanded';
            CreateViaIdentityContainerAppExpanded = 'Az.App.private\New-AzContainerAppAuthConfig_CreateViaIdentityContainerAppExpanded';
            CreateViaIdentityExpanded = 'Az.App.private\New-AzContainerAppAuthConfig_CreateViaIdentityExpanded';
            CreateViaJsonFilePath = 'Az.App.private\New-AzContainerAppAuthConfig_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.App.private\New-AzContainerAppAuthConfig_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create a Certificate.
.Description
Create a Certificate.
.Example
New-SelfSignedCertificate -DnsName "www.fabrikam.com", "www.contoso.com" -CertStoreLocation "cert:\LocalMachine\My"
Get-ChildItem -Path cert:\LocalMachine\My
$mypwd = ConvertTo-SecureString -String "1234" -Force -AsPlainText
Get-ChildItem -Path cert:\localMachine\my\F61C9A8C53D0500F819463A66C5921AA09E1B787 | Export-PfxCertificate -FilePath C:\mypfx.pfx -Password $mypwd

New-AzContainerAppConnectedEnvCert -Name azps-connectedenvcert -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Location eastus -InputFile "C:\mypfx.pfx" -Password $mypwd

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICertificate
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONNECTEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/new-azcontainerappconnectedenvcert
#>
function New-AzContainerAppConnectedEnvCert {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICertificate])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Connected Environment.
    ${ConnectedEnvironmentName},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Alias('CertificateName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Certificate.
    ${Name},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaJsonFilePath')]
    [Parameter(ParameterSetName='CreateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONNECTEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ConnectedEnvironmentInputObject},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The geo-location where the resource lives
    ${Location},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Input File for Value (PFX or PEM blob)
    ${InputFile},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Security.SecureString]
    # Certificate password
    ${Password},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ITrackedResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.App.private\New-AzContainerAppConnectedEnvCert_CreateExpanded';
            CreateViaIdentityConnectedEnvironmentExpanded = 'Az.App.private\New-AzContainerAppConnectedEnvCert_CreateViaIdentityConnectedEnvironmentExpanded';
            CreateViaIdentityExpanded = 'Az.App.private\New-AzContainerAppConnectedEnvCert_CreateViaIdentityExpanded';
            CreateViaJsonFilePath = 'Az.App.private\New-AzContainerAppConnectedEnvCert_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.App.private\New-AzContainerAppConnectedEnvCert_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create a Dapr Component in a connected environment.
.Description
Create a Dapr Component in a connected environment.
.Example
$scope = @("container-app-1","container-app-2")
$secretObject = New-AzContainerAppSecretObject -Name "masterkey" -Value "keyvalue"
$daprMetaData = New-AzContainerAppDaprMetadataObject -Name "masterkey" -Value "masterkey"

New-AzContainerAppConnectedEnvDapr -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Name azps-connectedenvdapr -ComponentType "state.azure.cosmosdb" -Version v1 -IgnoreError:$false -InitTimeout 50s -Scope $scope -Secret $secretObject -Metadata $daprMetaData

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprComponent
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONNECTEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

METADATA <IDaprMetadata[]>: Component metadata
  [Name <String>]: Metadata property name.
  [SecretRef <String>]: Name of the Dapr Component secret from which to pull the metadata property value.
  [Value <String>]: Metadata property value.

SECRET <ISecret[]>: Collection of secrets used by a Dapr component
  [Identity <String>]: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
  [KeyVaultUrl <String>]: Azure Key Vault URL pointing to the secret referenced by the container app.
  [Name <String>]: Secret Name.
  [Value <String>]: Secret Value.
.Link
https://learn.microsoft.com/powershell/module/az.app/new-azcontainerappconnectedenvdapr
#>
function New-AzContainerAppConnectedEnvDapr {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprComponent])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the connected environment.
    ${ConnectedEnvironmentName},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Alias('DaprName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Dapr Component.
    ${Name},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaJsonFilePath')]
    [Parameter(ParameterSetName='CreateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONNECTEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ConnectedEnvironmentInputObject},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Component type
    ${ComponentType},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean describing if the component errors are ignores
    ${IgnoreError},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Initialization timeout
    ${InitTimeout},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprMetadata[]]
    # Component metadata
    # To construct, see NOTES section for METADATA properties and create a hash table.
    ${Metadata},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # Names of container apps that can use this Dapr component
    ${Scope},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISecret[]]
    # Collection of secrets used by a Dapr component
    # To construct, see NOTES section for SECRET properties and create a hash table.
    ${Secret},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Name of a Dapr component to retrieve component secrets from
    ${SecretStoreComponent},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Component version
    ${Version},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.App.private\New-AzContainerAppConnectedEnvDapr_CreateExpanded';
            CreateViaIdentityConnectedEnvironmentExpanded = 'Az.App.private\New-AzContainerAppConnectedEnvDapr_CreateViaIdentityConnectedEnvironmentExpanded';
            CreateViaIdentityExpanded = 'Az.App.private\New-AzContainerAppConnectedEnvDapr_CreateViaIdentityExpanded';
            CreateViaJsonFilePath = 'Az.App.private\New-AzContainerAppConnectedEnvDapr_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.App.private\New-AzContainerAppConnectedEnvDapr_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create storage for a connectedEnvironment.
.Description
Create storage for a connectedEnvironment.
.Example
New-AzStorageAccount -ResourceGroupName azps_test_group_app -AccountName azpstestsa -Location eastus -SkuName Standard_GRS
$storageAccountKey = (Get-AzStorageAccountKey -ResourceGroupName azps_test_group_app -AccountName azpstestsa).Value[0]

New-AzContainerAppConnectedEnvStorage -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Name azpstestsa -AzureFileAccessMode 'ReadWrite' -AzureFileAccountKey $storageAccountKey -AzureFileAccountName azpstestsa -AzureFileShareName azps-rw-sharename

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IConnectedEnvironmentStorage
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONNECTEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/new-azcontainerappconnectedenvstorage
#>
function New-AzContainerAppConnectedEnvStorage {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IConnectedEnvironmentStorage])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Environment.
    ${ConnectedEnvironmentName},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Alias('StorageName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the storage.
    ${Name},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaJsonFilePath')]
    [Parameter(ParameterSetName='CreateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONNECTEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ConnectedEnvironmentInputObject},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("ReadOnly", "ReadWrite")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Access mode for storage
    ${AzureFileAccessMode},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Storage account key for azure file.
    ${AzureFileAccountKey},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Storage account name for azure file.
    ${AzureFileAccountName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityConnectedEnvironmentExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Azure file share name.
    ${AzureFileShareName},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.App.private\New-AzContainerAppConnectedEnvStorage_CreateExpanded';
            CreateViaIdentityConnectedEnvironmentExpanded = 'Az.App.private\New-AzContainerAppConnectedEnvStorage_CreateViaIdentityConnectedEnvironmentExpanded';
            CreateViaIdentityExpanded = 'Az.App.private\New-AzContainerAppConnectedEnvStorage_CreateViaIdentityExpanded';
            CreateViaJsonFilePath = 'Az.App.private\New-AzContainerAppConnectedEnvStorage_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.App.private\New-AzContainerAppConnectedEnvStorage_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an connectedEnvironment.
.Description
Create an connectedEnvironment.
.Example
New-AzContainerAppConnectedEnv -Name azps-connectedenv -ResourceGroupName azps_test_group_app -Location eastus -ExtendedLocationName "/subscriptions/{subId}/resourceGroups/azps_test_group_app/providers/Microsoft.ExtendedLocation/customLocations/my-custom-location" -ExtendedLocationType CustomLocation


.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IConnectedEnvironment
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/new-azcontainerappconnectedenv
#>
function New-AzContainerAppConnectedEnv {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IConnectedEnvironment])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Alias('ConnectedEnvironmentName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the connectedEnvironment.
    ${Name},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaJsonFilePath')]
    [Parameter(ParameterSetName='CreateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The geo-location where the resource lives
    ${Location},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Input File for CustomDomainConfigurationCertificateValue (PFX or PEM blob)
    ${CustomDomainConfigurationCertificateValueInputFile},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Dns suffix for the environment domain
    ${CustomDomainConfigurationDnsSuffix},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Security.SecureString]
    # Certificate password.
    ${CustomDomainPassword},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Application Insights connection string used by Dapr to export Service to Service communication telemetry
    ${DaprAiConnectionString},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The name of the extended location.
    ${ExtendedLocationName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("CustomLocation")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The type of the extended location.
    ${ExtendedLocationType},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Static IP of the connectedEnvironment
    ${StaticIP},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ITrackedResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.App.private\New-AzContainerAppConnectedEnv_CreateExpanded';
            CreateViaIdentityExpanded = 'Az.App.private\New-AzContainerAppConnectedEnv_CreateViaIdentityExpanded';
            CreateViaJsonFilePath = 'Az.App.private\New-AzContainerAppConnectedEnv_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.App.private\New-AzContainerAppConnectedEnv_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create a Container Apps Job.
.Description
Create a Container Apps Job.
.Example
$EnvId = (Get-AzContainerAppManagedEnv -ResourceGroupName azps_test_group_app -Name azps-env).Id
$probeHttpGetHttpHeader = New-AzContainerAppProbeHeaderObject -Name "Custom-Header" -Value "Awesome"
$probe = New-AzContainerAppProbeObject -Type "Liveness" -HttpGetPath "/health" -HttpGetPort 8080 -InitialDelaySecond 3 -PeriodSecond 3 -HttpGetHttpHeader $probeHttpGetHttpHeader
$temp = New-AzContainerAppTemplateObject -Image "mcr.microsoft.com/k8se/quickstart-jobs:latest" -Name "simple-hello-world-container" -Probe $probe -ResourceCpu 0.25 -ResourceMemory "0.5Gi"

New-AzContainerAppJob -Name azps-app-job -ResourceGroupName azps_test_group_app -Location eastus -ConfigurationReplicaRetryLimit 10 -ConfigurationReplicaTimeout 10 -ConfigurationTriggerType Manual -EnvironmentId $EnvId -ManualTriggerConfigParallelism 4 -ManualTriggerConfigReplicaCompletionCount 1 -TemplateContainer $temp

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJob
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONFIGURATIONREGISTRY <IRegistryCredentials[]>: Collection of private container registry credentials used by a Container apps job
  [Identity <String>]: A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
  [PasswordSecretRef <String>]: The name of the Secret that contains the registry login password
  [Server <String>]: Container Registry Server
  [Username <String>]: Container Registry Username

CONFIGURATIONSECRET <ISecret[]>: Collection of secrets used by a Container Apps Job
  [Identity <String>]: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
  [KeyVaultUrl <String>]: Azure Key Vault URL pointing to the secret referenced by the container app.
  [Name <String>]: Secret Name.
  [Value <String>]: Secret Value.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

SCALERULE <IJobScaleRule[]>: Scaling rules.
  [Auth <List<IScaleRuleAuth>>]: Authentication secrets for the scale rule.
    [SecretRef <String>]: Name of the secret from which to pull the auth params.
    [TriggerParameter <String>]: Trigger Parameter that uses the secret
  [Metadata <IAny>]: Metadata properties to describe the scale rule.
  [Name <String>]: Scale Rule Name
  [Type <String>]: Type of the scale rule         eg: azure-servicebus, redis etc.

TEMPLATECONTAINER <IContainer[]>: List of container definitions for the Container App.
  [Arg <List<String>>]: Container start command arguments.
  [Command <List<String>>]: Container start command.
  [Env <List<IEnvironmentVar>>]: Container environment variables.
    [Name <String>]: Environment variable name.
    [SecretRef <String>]: Name of the Container App secret from which to pull the environment variable value.
    [Value <String>]: Non-secret environment variable value.
  [Image <String>]: Container image tag.
  [Name <String>]: Custom container name.
  [ResourceCpu <Double?>]: Required CPU in cores, e.g. 0.5
  [ResourceMemory <String>]: Required memory, e.g. "250Mb"
  [VolumeMount <List<IVolumeMount>>]: Container volume mounts.
    [MountPath <String>]: Path within the container at which the volume should be mounted.Must not contain ':'.
    [SubPath <String>]: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
    [VolumeName <String>]: This must match the Name of a Volume.
  [Probe <List<IContainerAppProbe>>]: List of probes for the container.
    [FailureThreshold <Int32?>]: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
    [HttpGetHost <String>]: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
    [HttpGetHttpHeader <List<IContainerAppProbeHttpGetHttpHeadersItem>>]: Custom headers to set in the request. HTTP allows repeated headers.
      Name <String>: The header field name
      Value <String>: The header field value
    [HttpGetPath <String>]: Path to access on the HTTP server.
    [HttpGetPort <Int32?>]: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
    [HttpGetScheme <String>]: Scheme to use for connecting to the host. Defaults to HTTP.
    [InitialDelaySecond <Int32?>]: Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
    [PeriodSecond <Int32?>]: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
    [SuccessThreshold <Int32?>]: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
    [TcpSocketHost <String>]: Optional: Host name to connect to, defaults to the pod IP.
    [TcpSocketPort <Int32?>]: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
    [TerminationGracePeriodSecond <Int64?>]: Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
    [TimeoutSecond <Int32?>]: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
    [Type <String>]: The type of probe.

TEMPLATEINITCONTAINER <IInitContainer[]>: List of specialized containers that run before app containers.
  [Arg <List<String>>]: Container start command arguments.
  [Command <List<String>>]: Container start command.
  [Env <List<IEnvironmentVar>>]: Container environment variables.
    [Name <String>]: Environment variable name.
    [SecretRef <String>]: Name of the Container App secret from which to pull the environment variable value.
    [Value <String>]: Non-secret environment variable value.
  [Image <String>]: Container image tag.
  [Name <String>]: Custom container name.
  [ResourceCpu <Double?>]: Required CPU in cores, e.g. 0.5
  [ResourceMemory <String>]: Required memory, e.g. "250Mb"
  [VolumeMount <List<IVolumeMount>>]: Container volume mounts.
    [MountPath <String>]: Path within the container at which the volume should be mounted.Must not contain ':'.
    [SubPath <String>]: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
    [VolumeName <String>]: This must match the Name of a Volume.

TEMPLATEVOLUME <IVolume[]>: List of volume definitions for the Container App.
  [MountOption <String>]: Mount options used while mounting the AzureFile. Must be a comma-separated string.
  [Name <String>]: Volume name.
  [Secret <List<ISecretVolumeItem>>]: List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to volume.
    [Path <String>]: Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
    [SecretRef <String>]: Name of the Container App secret from which to pull the secret value.
  [StorageName <String>]: Name of storage resource. No need to provide for EmptyDir and Secret.
  [StorageType <String>]: Storage type for the volume. If not provided, use EmptyDir.
.Link
https://learn.microsoft.com/powershell/module/az.app/new-azcontainerappjob
#>
function New-AzContainerAppJob {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJob])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Alias('JobName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Job Name
    ${Name},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaJsonFilePath')]
    [Parameter(ParameterSetName='CreateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The geo-location where the resource lives
    ${Location},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IRegistryCredentials[]]
    # Collection of private container registry credentials used by a Container apps job
    # To construct, see NOTES section for CONFIGURATIONREGISTRY properties and create a hash table.
    ${ConfigurationRegistry},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Maximum number of retries before failing the job.
    ${ConfigurationReplicaRetryLimit},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Maximum number of seconds a replica is allowed to run.
    ${ConfigurationReplicaTimeout},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISecret[]]
    # Collection of secrets used by a Container Apps Job
    # To construct, see NOTES section for CONFIGURATIONSECRET properties and create a hash table.
    ${ConfigurationSecret},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("Schedule", "Event", "Manual")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Trigger type of the job
    ${ConfigurationTriggerType},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Resource ID of environment.
    ${EnvironmentId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Number of parallel replicas of a job that can run at a given time.
    ${EventTriggerConfigParallelism},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Minimum number of successful replica completions before overall job completion.
    ${EventTriggerConfigReplicaCompletionCount},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("None", "SystemAssigned", "UserAssigned", "SystemAssigned,UserAssigned")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
    ${IdentityType},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IUserAssignedIdentities]))]
    [System.Collections.Hashtable]
    # The set of user assigned identities associated with the resource.
    # The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
    # The dictionary values can be empty objects ({}) in requests.
    ${IdentityUserAssignedIdentity},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Number of parallel replicas of a job that can run at a given time.
    ${ManualTriggerConfigParallelism},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Minimum number of successful replica completions before overall job completion.
    ${ManualTriggerConfigReplicaCompletionCount},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Maximum number of job executions that are created for a trigger, default 100.
    ${ScaleMaxExecution},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Minimum number of job executions that are created for a trigger, default 0
    ${ScaleMinExecution},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Interval to check each event source in seconds.
    # Defaults to 30s
    ${ScalePollingInterval},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJobScaleRule[]]
    # Scaling rules.
    # To construct, see NOTES section for SCALERULE properties and create a hash table.
    ${ScaleRule},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Cron formatted repeating schedule ("* * * * *") of a Cron Job.
    ${ScheduleTriggerConfigCronExpression},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Number of parallel replicas of a job that can run at a given time.
    ${ScheduleTriggerConfigParallelism},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Minimum number of successful replica completions before overall job completion.
    ${ScheduleTriggerConfigReplicaCompletionCount},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ITrackedResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainer[]]
    # List of container definitions for the Container App.
    # To construct, see NOTES section for TEMPLATECONTAINER properties and create a hash table.
    ${TemplateContainer},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IInitContainer[]]
    # List of specialized containers that run before app containers.
    # To construct, see NOTES section for TEMPLATEINITCONTAINER properties and create a hash table.
    ${TemplateInitContainer},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IVolume[]]
    # List of volume definitions for the Container App.
    # To construct, see NOTES section for TEMPLATEVOLUME properties and create a hash table.
    ${TemplateVolume},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Workload profile name to pin for container apps job execution.
    ${WorkloadProfileName},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.App.private\New-AzContainerAppJob_CreateExpanded';
            CreateViaIdentityExpanded = 'Az.App.private\New-AzContainerAppJob_CreateViaIdentityExpanded';
            CreateViaJsonFilePath = 'Az.App.private\New-AzContainerAppJob_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.App.private\New-AzContainerAppJob_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create a Managed Certificate.
.Description
Create a Managed Certificate.
.Example
New-AzContainerAppManagedCert -EnvName azps-env -Name azps-managedcert -ResourceGroupName azps_test_group_app -Location eastus -DomainControlValidation TXT -SubjectName "mycertweb.com"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedCertificate
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

MANAGEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/new-azcontainerappmanagedcert
#>
function New-AzContainerAppManagedCert {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedCertificate])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment.
    ${EnvName},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Alias('ManagedCertificateName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Certificate.
    ${Name},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaJsonFilePath')]
    [Parameter(ParameterSetName='CreateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for MANAGEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ManagedEnvironmentInputObject},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The geo-location where the resource lives
    ${Location},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("CNAME", "HTTP", "TXT")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Selected type of domain control validation for managed certificates.
    ${DomainControlValidation},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Subject name of the certificate.
    ${SubjectName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ITrackedResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.App.private\New-AzContainerAppManagedCert_CreateExpanded';
            CreateViaIdentityExpanded = 'Az.App.private\New-AzContainerAppManagedCert_CreateViaIdentityExpanded';
            CreateViaIdentityManagedEnvironmentExpanded = 'Az.App.private\New-AzContainerAppManagedCert_CreateViaIdentityManagedEnvironmentExpanded';
            CreateViaJsonFilePath = 'Az.App.private\New-AzContainerAppManagedCert_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.App.private\New-AzContainerAppManagedCert_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create a Certificate.
.Description
Create a Certificate.
.Example
New-SelfSignedCertificate -DnsName "www.fabrikam.com", "www.contoso.com" -CertStoreLocation "cert:\LocalMachine\My"
Get-ChildItem -Path cert:\LocalMachine\My
$mypwd = ConvertTo-SecureString -String "1234" -Force -AsPlainText
Get-ChildItem -Path cert:\localMachine\my\F61C9A8C53D0500F819463A66C5921AA09E1B787 | Export-PfxCertificate -FilePath C:\mypfx.pfx -Password $mypwd

New-AzContainerAppManagedEnvCert -EnvName azps-env -Name azps-env-cert -ResourceGroupName azps_test_group_app -Location eastus -InputFile "C:\mypfx.pfx" -Password $mypwd

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICertificate
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

MANAGEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/new-azcontainerappmanagedenvcert
#>
function New-AzContainerAppManagedEnvCert {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICertificate])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment.
    ${EnvName},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Alias('CertificateName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Certificate.
    ${Name},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaJsonFilePath')]
    [Parameter(ParameterSetName='CreateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for MANAGEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ManagedEnvironmentInputObject},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The geo-location where the resource lives
    ${Location},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Input File for Value (PFX or PEM blob)
    ${InputFile},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Security.SecureString]
    # Certificate password
    ${Password},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ITrackedResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.App.private\New-AzContainerAppManagedEnvCert_CreateExpanded';
            CreateViaIdentityExpanded = 'Az.App.private\New-AzContainerAppManagedEnvCert_CreateViaIdentityExpanded';
            CreateViaIdentityManagedEnvironmentExpanded = 'Az.App.private\New-AzContainerAppManagedEnvCert_CreateViaIdentityManagedEnvironmentExpanded';
            CreateViaJsonFilePath = 'Az.App.private\New-AzContainerAppManagedEnvCert_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.App.private\New-AzContainerAppManagedEnvCert_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create a Dapr Component in a Managed Environment.
.Description
Create a Dapr Component in a Managed Environment.
.Example
$scope = @("container-app-1","container-app-2")
$secretObject = New-AzContainerAppSecretObject -Name "masterkey" -Value "keyvalue"
$daprMetaData = New-AzContainerAppDaprMetadataObject -Name "masterkey" -Value "masterkey"

New-AzContainerAppManagedEnvDapr -Name azps-dapr -EnvName azps-env -ResourceGroupName azps_test_group_app -componentType state.azure.cosmosdb -Version v1 -IgnoreError:$false -InitTimeout 50s -Scope $scope -Secret $secretObject -Metadata $daprMetaData

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprComponent
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

MANAGEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

METADATA <IDaprMetadata[]>: Component metadata
  [Name <String>]: Metadata property name.
  [SecretRef <String>]: Name of the Dapr Component secret from which to pull the metadata property value.
  [Value <String>]: Metadata property value.

SECRET <ISecret[]>: Collection of secrets used by a Dapr component
  [Identity <String>]: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
  [KeyVaultUrl <String>]: Azure Key Vault URL pointing to the secret referenced by the container app.
  [Name <String>]: Secret Name.
  [Value <String>]: Secret Value.
.Link
https://learn.microsoft.com/powershell/module/az.app/new-azcontainerappmanagedenvdapr
#>
function New-AzContainerAppManagedEnvDapr {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprComponent])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment.
    ${EnvName},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Alias('DaprName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Dapr Component.
    ${Name},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaJsonFilePath')]
    [Parameter(ParameterSetName='CreateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for MANAGEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ManagedEnvironmentInputObject},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Component type
    ${ComponentType},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean describing if the component errors are ignores
    ${IgnoreError},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Initialization timeout
    ${InitTimeout},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprMetadata[]]
    # Component metadata
    # To construct, see NOTES section for METADATA properties and create a hash table.
    ${Metadata},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # Names of container apps that can use this Dapr component
    ${Scope},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISecret[]]
    # Collection of secrets used by a Dapr component
    # To construct, see NOTES section for SECRET properties and create a hash table.
    ${Secret},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Name of a Dapr component to retrieve component secrets from
    ${SecretStoreComponent},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Component version
    ${Version},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.App.private\New-AzContainerAppManagedEnvDapr_CreateExpanded';
            CreateViaIdentityExpanded = 'Az.App.private\New-AzContainerAppManagedEnvDapr_CreateViaIdentityExpanded';
            CreateViaIdentityManagedEnvironmentExpanded = 'Az.App.private\New-AzContainerAppManagedEnvDapr_CreateViaIdentityManagedEnvironmentExpanded';
            CreateViaJsonFilePath = 'Az.App.private\New-AzContainerAppManagedEnvDapr_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.App.private\New-AzContainerAppManagedEnvDapr_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create storage for a managedEnvironment.
.Description
Create storage for a managedEnvironment.
.Example
New-AzStorageAccount -ResourceGroupName azps_test_group_app -AccountName azpstestsa -Location eastus -SkuName Standard_GRS
$storageAccountKey = (Get-AzStorageAccountKey -ResourceGroupName azps_test_group_app -AccountName azpstestsa).Value[0]

New-AzContainerAppManagedEnvStorage -EnvName azps-env -ResourceGroupName azps_test_group_app -Name azpstestsa -AzureFileAccessMode 'ReadWrite' -AzureFileAccountKey $storageAccountKey -AzureFileAccountName azpstestsa -AzureFileShareName azps-rw-sharename

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedEnvironmentStorage
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

MANAGEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/new-azcontainerappmanagedenvstorage
#>
function New-AzContainerAppManagedEnvStorage {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedEnvironmentStorage])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Environment.
    ${EnvName},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Alias('StorageName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the storage.
    ${Name},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaJsonFilePath')]
    [Parameter(ParameterSetName='CreateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for MANAGEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ManagedEnvironmentInputObject},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("ReadOnly", "ReadWrite")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Access mode for storage
    ${AzureFileAccessMode},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Storage account key for azure file.
    ${AzureFileAccountKey},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Storage account name for azure file.
    ${AzureFileAccountName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityManagedEnvironmentExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Azure file share name.
    ${AzureFileShareName},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.App.private\New-AzContainerAppManagedEnvStorage_CreateExpanded';
            CreateViaIdentityExpanded = 'Az.App.private\New-AzContainerAppManagedEnvStorage_CreateViaIdentityExpanded';
            CreateViaIdentityManagedEnvironmentExpanded = 'Az.App.private\New-AzContainerAppManagedEnvStorage_CreateViaIdentityManagedEnvironmentExpanded';
            CreateViaJsonFilePath = 'Az.App.private\New-AzContainerAppManagedEnvStorage_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.App.private\New-AzContainerAppManagedEnvStorage_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create a Managed Environment used to host container apps.
.Description
Create a Managed Environment used to host container apps.
.Example
New-AzOperationalInsightsWorkspace -ResourceGroupName azps_test_group_app -Name workspace-azpstestgp -Sku PerGB2018 -Location canadacentral -PublicNetworkAccessForIngestion "Enabled" -PublicNetworkAccessForQuery "Enabled"

$CustomId = (Get-AzOperationalInsightsWorkspace -ResourceGroupName azps_test_group_app -Name workspace-azpstestgp).CustomerId
$SharedKey = (Get-AzOperationalInsightsWorkspaceSharedKey -ResourceGroupName azps_test_group_app -Name workspace-azpstestgp).PrimarySharedKey
$workloadProfile = New-AzContainerAppWorkloadProfileObject -Name "Consumption" -Type "Consumption"

New-AzContainerAppManagedEnv -Name azps-env -ResourceGroupName azps_test_group_app -Location eastus -AppLogConfigurationDestination "log-analytics" -LogAnalyticConfigurationCustomerId $CustomId -LogAnalyticConfigurationSharedKey $SharedKey -VnetConfigurationInternal:$false -WorkloadProfile $workloadProfile

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedEnvironment
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

WORKLOADPROFILE <IWorkloadProfile[]>: Workload profiles configured for the Managed Environment.
  Name <String>: Workload profile type for the workloads to run on.
  Type <String>: Workload profile type for the workloads to run on.
  [MaximumCount <Int32?>]: The maximum capacity.
  [MinimumCount <Int32?>]: The minimum capacity.
.Link
https://learn.microsoft.com/powershell/module/az.app/new-azcontainerappmanagedenv
#>
function New-AzContainerAppManagedEnv {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedEnvironment])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Alias('EnvName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Environment.
    ${Name},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaJsonFilePath')]
    [Parameter(ParameterSetName='CreateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The geo-location where the resource lives
    ${Location},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Logs destination, can be 'log-analytics', 'azure-monitor' or 'none'
    ${AppLogConfigurationDestination},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Input File for CustomDomainConfigurationCertificateValue (PFX or PEM blob)
    ${CustomDomainConfigurationCertificateValueInputFile},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Dns suffix for the environment domain
    ${CustomDomainConfigurationDnsSuffix},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Security.SecureString]
    # Certificate password.
    ${CustomDomainPassword},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Application Insights connection string used by Dapr to export Service to Service communication telemetry
    ${DaprAiConnectionString},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Azure Monitor instrumentation key used by Dapr to export Service to Service communication telemetry
    ${DaprAiInstrumentationKey},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Name of the platform-managed resource group created for the Managed Environment to host infrastructure resources.
    # If a subnet ID is provided, this resource group will be created in the same subscription as the subnet.
    ${InfrastructureResourceGroup},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Kind of the Environment.
    ${Kind},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Log analytics customer id
    ${LogAnalyticConfigurationCustomerId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Log analytics customer key
    ${LogAnalyticConfigurationSharedKey},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean indicating whether the mutual TLS authentication is enabled
    ${MtlEnabled},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ITrackedResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # CIDR notation IP range assigned to the Docker bridge, network.
    # Must not overlap with any other provided IP ranges.
    ${VnetConfigurationDockerBridgeCidr},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Resource ID of a subnet for infrastructure components.
    # Must not overlap with any other provided IP ranges.
    ${VnetConfigurationInfrastructureSubnetId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean indicating the environment only has an internal load balancer.
    # These environments do not have a public static IP resource.
    # They must provide infrastructureSubnetId if enabling this property
    ${VnetConfigurationInternal},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # IP range in CIDR notation that can be reserved for environment infrastructure IP addresses.
    # Must not overlap with any other provided IP ranges.
    ${VnetConfigurationPlatformReservedCidr},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # An IP address from the IP range defined by platformReservedCidr that will be reserved for the internal DNS server.
    ${VnetConfigurationPlatformReservedDnsIP},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IWorkloadProfile[]]
    # Workload profiles configured for the Managed Environment.
    # To construct, see NOTES section for WORKLOADPROFILE properties and create a hash table.
    ${WorkloadProfile},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Whether or not this Managed Environment is zone-redundant.
    ${ZoneRedundant},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.App.private\New-AzContainerAppManagedEnv_CreateExpanded';
            CreateViaIdentityExpanded = 'Az.App.private\New-AzContainerAppManagedEnv_CreateViaIdentityExpanded';
            CreateViaJsonFilePath = 'Az.App.private\New-AzContainerAppManagedEnv_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.App.private\New-AzContainerAppManagedEnv_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create the SourceControl for a Container App.
.Description
Create the SourceControl for a Container App.
.Example
$AzureClientSecret = ConvertTo-SecureString -String "1234" -Force -AsPlainText
$RegistryPassword = ConvertTo-SecureString -String "1234" -Force -AsPlainText
$GithubAccessToken = ConvertTo-SecureString -String "1234" -Force -AsPlainText

New-AzContainerAppSourceControl -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app -Name current -AzureClientId "UserObjectId" -AzureClientSecret $AzureClientSecret -AzureKind "feaderated" -AzureTenantId "UserDirectoryID" -Branch "main" -GithubContextPath "./" -GithubAccessToken $GithubAccessToken -GithubConfigurationImage "azps-containerapp-1" -RegistryPassword $RegistryPassword -RegistryUrl "azpscontainerregistry.azurecr.io" -RegistryUserName "azpscontainerregistry" -RepoUrl "https://github.com/lijinpei2008/ghatest"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISourceControl
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTAINERAPPINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/new-azcontainerappsourcecontrol
#>
function New-AzContainerAppSourceControl {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISourceControl])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Alias('SourceControlName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App SourceControl.
    ${Name},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaJsonFilePath')]
    [Parameter(ParameterSetName='CreateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONTAINERAPPINPUTOBJECT properties and create a hash table.
    ${ContainerAppInputObject},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Client Id.
    ${AzureClientId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Security.SecureString]
    # Client Secret.
    ${AzureClientSecret},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Kind of auth github does for deploying the template
    ${AzureKind},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Subscription Id.
    ${AzureSubscriptionId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Tenant Id.
    ${AzureTenantId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The branch which will trigger the auto deployment
    ${Branch},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Security.SecureString]
    # One time Github PAT to configure github environment
    ${GithubAccessToken},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Image name
    ${GithubConfigurationImage},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Context path
    ${GithubContextPath},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Operation system
    ${GithubOS},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Code or Image
    ${GithubPublishType},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Runtime stack
    ${GithubRuntimeStack},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Runtime version
    ${GithubRuntimeVersion},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Security.SecureString]
    # registry secret.
    ${RegistryPassword},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # registry server Url.
    ${RegistryUrl},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # registry username.
    ${RegistryUserName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityContainerAppExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The repo url which will be integrated to ContainerApp.
    ${RepoUrl},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.App.private\New-AzContainerAppSourceControl_CreateExpanded';
            CreateViaIdentityContainerAppExpanded = 'Az.App.private\New-AzContainerAppSourceControl_CreateViaIdentityContainerAppExpanded';
            CreateViaIdentityExpanded = 'Az.App.private\New-AzContainerAppSourceControl_CreateViaIdentityExpanded';
            CreateViaJsonFilePath = 'Az.App.private\New-AzContainerAppSourceControl_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.App.private\New-AzContainerAppSourceControl_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create a Container App.
.Description
Create a Container App.
.Example
New-AzOperationalInsightsWorkspace -ResourceGroupName azps_test_group_app -Name workspace-azpstestgp -Sku PerGB2018 -Location eastus -PublicNetworkAccessForIngestion "Enabled" -PublicNetworkAccessForQuery "Enabled"

$CustomId = (Get-AzOperationalInsightsWorkspace -ResourceGroupName azps_test_group_app -Name workspace-azpstestgp).CustomerId
$SharedKey = (Get-AzOperationalInsightsWorkspaceSharedKey -ResourceGroupName azps_test_group_app -Name workspace-azpstestgp).PrimarySharedKey
$workloadProfile = New-AzContainerAppWorkloadProfileObject -Name "Consumption" -Type "Consumption"
New-AzContainerAppManagedEnv -Name azps-env -ResourceGroupName azps_test_group_app -Location eastus -AppLogConfigurationDestination "log-analytics" -LogAnalyticConfigurationCustomerId $CustomId -LogAnalyticConfigurationSharedKey $SharedKey -VnetConfigurationInternal:$false -WorkloadProfile $workloadProfile
$EnvId = (Get-AzContainerAppManagedEnv -ResourceGroupName azps_test_group_app -Name azps-env).Id

New-SelfSignedCertificate -DnsName "www.fabrikam.com", "www.contoso.com" -CertStoreLocation "cert:\LocalMachine\My"
Get-ChildItem -Path cert:\LocalMachine\My
$mypwd = ConvertTo-SecureString -String "1234" -Force -AsPlainText
Get-ChildItem -Path cert:\localMachine\my\F61C9A8C53D0500F819463A66C5921AA09E1B787 | Export-PfxCertificate -FilePath C:\mypfx.pfx -Password $mypwd
New-AzContainerAppManagedEnvCert -EnvName azps-env -Name azps-env-cert -ResourceGroupName azps_test_group_app -Location eastus -InputFile "C:\mypfx.pfx" -Password $mypwd

$trafficWeight = New-AzContainerAppTrafficWeightObject -Label "production" -Weight 100 -LatestRevision:$True
$iPSecurityRestrictionRule = New-AzContainerAppIPSecurityRestrictionRuleObject -Action "Allow" -IPAddressRange "192.168.1.1/32" -Name "Allow work IP A subnet"
$secretObject = New-AzContainerAppSecretObject -Name "redis-config" -Value "redis-password"
$customDomain = New-AzContainerAppCustomDomainObject -Name "mycertweb.com" -BindingType Disabled

$configuration = New-AzContainerAppConfigurationObject -IngressCustomDomain $customDomain -IngressIPSecurityRestriction $iPSecurityRestrictionRule -IngressTraffic $trafficWeight -IngressExternal:$True -IngressTargetPort 80 -IngressClientCertificateMode "accept" -CorPolicyAllowedOrigin "https://a.test.com","https://b.test.com" -CorPolicyAllowedMethod "GET","POST" -CorPolicyAllowedHeader "HEADER1","HEADER2" -CorPolicyExposeHeader "HEADER3","HEADER4" -CorPolicyMaxAge 1234 -CorPolicyAllowCredentials:$True -DaprEnabled:$True -DaprAppPort 3000 -DaprAppProtocol "http" -DaprHttpReadBufferSize 30 -DaprHttpMaxRequestSize 10 -DaprLogLevel "debug" -DaprEnableApiLogging:$True -MaxInactiveRevision 10 -ServiceType "redis" -Secret $secretObject

$serviceBind = New-AzContainerAppServiceBindObject -Name "redisService" -ServiceId "/subscriptions/{subId}/resourceGroups/azps_test_group_app/providers/Microsoft.App/containerApps/azps-containerapp-1"

$probeHttpGetHttpHeader = New-AzContainerAppProbeHeaderObject -Name "Custom-Header" -Value "Awesome"
$probe = New-AzContainerAppProbeObject -Type "Liveness" -HttpGetPath "/health" -HttpGetPort 8080 -InitialDelaySecond 3 -PeriodSecond 3 -HttpGetHttpHeader $probeHttpGetHttpHeader
$temp = New-AzContainerAppTemplateObject -Image "mcr.microsoft.com/k8se/quickstart-jobs:latest" -Name "simple-hello-world-container" -Probe $probe -ResourceCpu 0.25 -ResourceMemory "0.5Gi"
$temp2 = New-AzContainerAppInitContainerTemplateObject -Image "mcr.microsoft.com/k8se/quickstart-jobs:latest" -Name "simple-hello-world-container2" -ResourceCpu 0.25 -ResourceMemory "0.5Gi" -Command "/bin/sh" -Arg "-c","echo hello; sleep 10;"

New-AzContainerApp -Name "azps-containerapp-1" -ResourceGroupName "azps_test_group_app" -Location "eastus" -Configuration $configuration -TemplateContainer $temp -TemplateInitContainer $temp2 -TemplateServiceBind $serviceBind -EnvironmentId $EnvId
.Example
# Here you need to provide the resource "CustomLocation", for more information on how to create a resource CustomLocation, please refer to the help file: https://learn.microsoft.com/en-us/azure/container-apps/azure-arc-enable-cluster?tabs=azure-powershell
New-AzContainerAppConnectedEnv -Name azps-connectedenv -ResourceGroupName azps_test_group_app -Location eastus -ExtendedLocationName "/subscriptions/{subId}/resourceGroups/azps_test_group_app/providers/Microsoft.ExtendedLocation/customLocations/my-custom-location" -ExtendedLocationType CustomLocation
$EnvId = (Get-AzContainerAppConnectedEnv -ResourceGroupName azps_test_group_app -Name azps-connectedenv).Id

New-SelfSignedCertificate -DnsName "www.fabrikam.com", "www.contoso.com" -CertStoreLocation "cert:\LocalMachine\My"
Get-ChildItem -Path cert:\LocalMachine\My
$mypwd = ConvertTo-SecureString -String "1234" -Force -AsPlainText
Get-ChildItem -Path cert:\localMachine\my\F61C9A8C53D0500F819463A66C5921AA09E1B787 | Export-PfxCertificate -FilePath C:\mypfx.pfx -Password $mypwd
New-AzContainerAppConnectedEnvCert -Name azps-connectedenvcert -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Location eastus -InputFile "C:\mypfx.pfx" -Password $mypwd

$trafficWeight = New-AzContainerAppTrafficWeightObject -Label "production" -Weight 100 -LatestRevision:$True
$secretObject = New-AzContainerAppSecretObject -Name "redis-config" -Value "redis-password"
$configuration = New-AzContainerAppConfigurationObject -IngressTraffic $trafficWeight -IngressExternal:$True -IngressTargetPort 80 -Secret $secretObject

$temp = New-AzContainerAppTemplateObject -Image "mcr.microsoft.com/k8se/quickstart-jobs:latest" -Name "simple-hello-world-container" -ResourceCpu 0.25 -ResourceMemory "0.5Gi"
$temp2 = New-AzContainerAppInitContainerTemplateObject -Image "mcr.microsoft.com/k8se/quickstart-jobs:latest" -Name "simple-hello-world-container2" -ResourceCpu 0.25 -ResourceMemory "0.5Gi" -Command "/bin/sh" -Arg "-c","echo hello; sleep 10;"

New-AzContainerApp -Name "azps-containerapp-2" -ResourceGroupName "azps_test_group_app" -Location "eastus" -Configuration $configuration -TemplateContainer $temp -TemplateInitContainer $temp2 -EnvironmentId $EnvId -ExtendedLocationName "/subscriptions/{subId}/resourceGroups/azps_test_group_app/providers/Microsoft.ExtendedLocation/customLocations/my-custom-location" -ExtendedLocationType CustomLocation

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainerApp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONFIGURATION <IConfiguration>: Non versioned Container App configuration properties.
  [ActiveRevisionsMode <String>]: ActiveRevisionsMode controls how active revisions are handled for the Container app:         <list><item>Multiple: multiple revisions can be active.</item><item>Single: Only one revision can be active at a time. Revision weights can not be used in this mode. If no value if provided, this is the default.</item></list>
  [CorPolicyAllowCredentials <Boolean?>]: Specifies whether the resource allows credentials
  [CorPolicyAllowedHeader <List<String>>]: Specifies the content for the access-control-allow-headers header
  [CorPolicyAllowedMethod <List<String>>]: Specifies the content for the access-control-allow-methods header
  [CorPolicyAllowedOrigin <List<String>>]: Specifies the content for the access-control-allow-origins header
  [CorPolicyExposeHeader <List<String>>]: Specifies the content for the access-control-expose-headers header 
  [CorPolicyMaxAge <Int32?>]: Specifies the content for the access-control-max-age header
  [DaprAppId <String>]: Dapr application identifier
  [DaprAppPort <Int32?>]: Tells Dapr which port your application is listening on
  [DaprAppProtocol <String>]: Tells Dapr which protocol your application is using. Valid options are http and grpc. Default is http
  [DaprEnableApiLogging <Boolean?>]: Enables API logging for the Dapr sidecar
  [DaprEnabled <Boolean?>]: Boolean indicating if the Dapr side car is enabled
  [DaprHttpMaxRequestSize <Int32?>]: Increasing max size of request body http and grpc servers parameter in MB to handle uploading of big files. Default is 4 MB.
  [DaprHttpReadBufferSize <Int32?>]: Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
  [DaprLogLevel <String>]: Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
  [IngressAllowInsecure <Boolean?>]: Bool indicating if HTTP connections to is allowed. If set to false HTTP connections are automatically redirected to HTTPS connections
  [IngressClientCertificateMode <String>]: Client certificate mode for mTLS authentication. Ignore indicates server drops client certificate on forwarding. Accept indicates server forwards client certificate but does not require a client certificate. Require indicates server requires a client certificate.
  [IngressCustomDomain <List<ICustomDomain>>]: custom domain bindings for Container Apps' hostnames.
    Name <String>: Hostname.
    [BindingType <String>]: Custom Domain binding type.
    [CertificateId <String>]: Resource Id of the Certificate to be bound to this hostname. Must exist in the Managed Environment.
  [IngressExposedPort <Int32?>]: Exposed Port in containers for TCP traffic from ingress
  [IngressExternal <Boolean?>]: Bool indicating if app exposes an external http endpoint
  [IngressIPSecurityRestriction <List<IIPSecurityRestrictionRule>>]: Rules to restrict incoming IP address.
    Action <String>: Allow or Deny rules to determine for incoming IP. Note: Rules can only consist of ALL Allow or ALL Deny
    IPAddressRange <String>: CIDR notation to match incoming IP address
    Name <String>: Name for the IP restriction rule.
    [Description <String>]: Describe the IP restriction rule that is being sent to the container-app. This is an optional field.
  [IngressTargetPort <Int32?>]: Target Port in containers for traffic from ingress
  [IngressTraffic <List<ITrafficWeight>>]: Traffic weights for app's revisions
    [Label <String>]: Associates a traffic label with a revision
    [LatestRevision <Boolean?>]: Indicates that the traffic weight belongs to a latest stable revision
    [RevisionName <String>]: Name of a revision
    [Weight <Int32?>]: Traffic weight assigned to a revision
  [IngressTransport <String>]: Ingress transport protocol
  [MaxInactiveRevision <Int32?>]: Optional. Max inactive revisions a Container App can have.
  [Registry <List<IRegistryCredentials>>]: Collection of private container registry credentials for containers used by the Container app
    [Identity <String>]: A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
    [PasswordSecretRef <String>]: The name of the Secret that contains the registry login password
    [Server <String>]: Container Registry Server
    [Username <String>]: Container Registry Username
  [Secret <List<ISecret>>]: Collection of secrets used by a Container app
    [Identity <String>]: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
    [KeyVaultUrl <String>]: Azure Key Vault URL pointing to the secret referenced by the container app.
    [Name <String>]: Secret Name.
    [Value <String>]: Secret Value.
  [ServiceType <String>]: Dev ContainerApp service type
  [StickySessionAffinity <String>]: Sticky Session Affinity

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

SCALERULE <IScaleRule[]>: Scaling rules.
  [AzureQueueAuth <List<IScaleRuleAuth>>]: Authentication secrets for the queue scale rule.
    [SecretRef <String>]: Name of the secret from which to pull the auth params.
    [TriggerParameter <String>]: Trigger Parameter that uses the secret
  [AzureQueueLength <Int32?>]: Queue length.
  [AzureQueueName <String>]: Queue name.
  [CustomAuth <List<IScaleRuleAuth>>]: Authentication secrets for the custom scale rule.
  [CustomMetadata <ICustomScaleRuleMetadata>]: Metadata properties to describe custom scale rule.
    [(Any) <String>]: This indicates any property can be added to this object.
  [CustomType <String>]: Type of the custom scale rule         eg: azure-servicebus, redis etc.
  [HttpAuth <List<IScaleRuleAuth>>]: Authentication secrets for the custom scale rule.
  [HttpMetadata <IHttpScaleRuleMetadata>]: Metadata properties to describe http scale rule.
    [(Any) <String>]: This indicates any property can be added to this object.
  [Name <String>]: Scale Rule Name
  [TcpAuth <List<IScaleRuleAuth>>]: Authentication secrets for the tcp scale rule.
  [TcpMetadata <ITcpScaleRuleMetadata>]: Metadata properties to describe tcp scale rule.
    [(Any) <String>]: This indicates any property can be added to this object.

TEMPLATECONTAINER <IContainer[]>: List of container definitions for the Container App.
  [Arg <List<String>>]: Container start command arguments.
  [Command <List<String>>]: Container start command.
  [Env <List<IEnvironmentVar>>]: Container environment variables.
    [Name <String>]: Environment variable name.
    [SecretRef <String>]: Name of the Container App secret from which to pull the environment variable value.
    [Value <String>]: Non-secret environment variable value.
  [Image <String>]: Container image tag.
  [Name <String>]: Custom container name.
  [ResourceCpu <Double?>]: Required CPU in cores, e.g. 0.5
  [ResourceMemory <String>]: Required memory, e.g. "250Mb"
  [VolumeMount <List<IVolumeMount>>]: Container volume mounts.
    [MountPath <String>]: Path within the container at which the volume should be mounted.Must not contain ':'.
    [SubPath <String>]: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
    [VolumeName <String>]: This must match the Name of a Volume.
  [Probe <List<IContainerAppProbe>>]: List of probes for the container.
    [FailureThreshold <Int32?>]: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
    [HttpGetHost <String>]: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
    [HttpGetHttpHeader <List<IContainerAppProbeHttpGetHttpHeadersItem>>]: Custom headers to set in the request. HTTP allows repeated headers.
      Name <String>: The header field name
      Value <String>: The header field value
    [HttpGetPath <String>]: Path to access on the HTTP server.
    [HttpGetPort <Int32?>]: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
    [HttpGetScheme <String>]: Scheme to use for connecting to the host. Defaults to HTTP.
    [InitialDelaySecond <Int32?>]: Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
    [PeriodSecond <Int32?>]: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
    [SuccessThreshold <Int32?>]: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
    [TcpSocketHost <String>]: Optional: Host name to connect to, defaults to the pod IP.
    [TcpSocketPort <Int32?>]: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
    [TerminationGracePeriodSecond <Int64?>]: Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
    [TimeoutSecond <Int32?>]: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
    [Type <String>]: The type of probe.

TEMPLATEINITCONTAINER <IInitContainer[]>: List of specialized containers that run before app containers.
  [Arg <List<String>>]: Container start command arguments.
  [Command <List<String>>]: Container start command.
  [Env <List<IEnvironmentVar>>]: Container environment variables.
    [Name <String>]: Environment variable name.
    [SecretRef <String>]: Name of the Container App secret from which to pull the environment variable value.
    [Value <String>]: Non-secret environment variable value.
  [Image <String>]: Container image tag.
  [Name <String>]: Custom container name.
  [ResourceCpu <Double?>]: Required CPU in cores, e.g. 0.5
  [ResourceMemory <String>]: Required memory, e.g. "250Mb"
  [VolumeMount <List<IVolumeMount>>]: Container volume mounts.
    [MountPath <String>]: Path within the container at which the volume should be mounted.Must not contain ':'.
    [SubPath <String>]: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
    [VolumeName <String>]: This must match the Name of a Volume.

TEMPLATESERVICEBIND <IServiceBind[]>: List of container app services bound to the app
  [Name <String>]: Name of the service bind
  [ServiceId <String>]: Resource id of the target service

TEMPLATEVOLUME <IVolume[]>: List of volume definitions for the Container App.
  [MountOption <String>]: Mount options used while mounting the AzureFile. Must be a comma-separated string.
  [Name <String>]: Volume name.
  [Secret <List<ISecretVolumeItem>>]: List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to volume.
    [Path <String>]: Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
    [SecretRef <String>]: Name of the Container App secret from which to pull the secret value.
  [StorageName <String>]: Name of storage resource. No need to provide for EmptyDir and Secret.
  [StorageType <String>]: Storage type for the volume. If not provided, use EmptyDir.
.Link
https://learn.microsoft.com/powershell/module/az.app/new-azcontainerapp
#>
function New-AzContainerApp {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainerApp])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Alias('ContainerAppName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${Name},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaJsonFilePath')]
    [Parameter(ParameterSetName='CreateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The geo-location where the resource lives
    ${Location},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IConfiguration]
    # Non versioned Container App configuration properties.
    # To construct, see NOTES section for CONFIGURATION properties and create a hash table.
    ${Configuration},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Resource ID of environment.
    ${EnvironmentId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The name of the extended location.
    ${ExtendedLocationName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("CustomLocation")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The type of the extended location.
    ${ExtendedLocationType},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("None", "SystemAssigned", "UserAssigned", "SystemAssigned,UserAssigned")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
    ${IdentityType},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IUserAssignedIdentities]))]
    [System.Collections.Hashtable]
    # The set of user assigned identities associated with the resource.
    # The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
    # The dictionary values can be empty objects ({}) in requests.
    ${IdentityUserAssignedIdentity},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The fully qualified resource ID of the resource that manages this resource.
    # Indicates if this resource is managed by another Azure resource.
    # If this is present, complete mode deployment will not delete the resource if it is removed from the template since it is managed by another resource.
    ${ManagedBy},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Deprecated.
    # Resource ID of the Container App's environment.
    ${ManagedEnvironmentId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Optional.
    # Maximum number of container replicas.
    # Defaults to 10 if not set.
    ${ScaleMaxReplica},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Optional.
    # Minimum number of container replicas.
    ${ScaleMinReplica},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IScaleRule[]]
    # Scaling rules.
    # To construct, see NOTES section for SCALERULE properties and create a hash table.
    ${ScaleRule},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ITrackedResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainer[]]
    # List of container definitions for the Container App.
    # To construct, see NOTES section for TEMPLATECONTAINER properties and create a hash table.
    ${TemplateContainer},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IInitContainer[]]
    # List of specialized containers that run before app containers.
    # To construct, see NOTES section for TEMPLATEINITCONTAINER properties and create a hash table.
    ${TemplateInitContainer},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # User friendly suffix that is appended to the revision name
    ${TemplateRevisionSuffix},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IServiceBind[]]
    # List of container app services bound to the app
    # To construct, see NOTES section for TEMPLATESERVICEBIND properties and create a hash table.
    ${TemplateServiceBind},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int64]
    # Optional duration in seconds the Container App Instance needs to terminate gracefully.
    # Value must be non-negative integer.
    # The value zero indicates stop immediately via the kill signal (no opportunity to shut down).
    # If this value is nil, the default grace period will be used instead.
    # Set this value longer than the expected cleanup time for your process.
    # Defaults to 30 seconds.
    ${TemplateTerminationGracePeriodSecond},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IVolume[]]
    # List of volume definitions for the Container App.
    # To construct, see NOTES section for TEMPLATEVOLUME properties and create a hash table.
    ${TemplateVolume},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Workload profile name to pin for container app execution.
    ${WorkloadProfileName},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.App.private\New-AzContainerApp_CreateExpanded';
            CreateViaIdentityExpanded = 'Az.App.private\New-AzContainerApp_CreateViaIdentityExpanded';
            CreateViaJsonFilePath = 'Az.App.private\New-AzContainerApp_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.App.private\New-AzContainerApp_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Delete a Container App AuthConfig.
.Description
Delete a Container App AuthConfig.
.Example
Remove-AzContainerAppAuthConfig -ContainerAppName azps-containerapp-2 -ResourceGroupName azps_test_group_app -Name current
.Example
$containerapp = Get-AzContainerApp -ResourceGroupName azps_test_group_app -Name azps-containerapp-2

Remove-AzContainerAppAuthConfig -ContainerAppInputObject $containerapp -Name current
.Example
$authconfig = Get-AzContainerAppAuthConfig -Name current -ContainerAppName azps-containerapp-2 -ResourceGroupName azps_test_group_app

Remove-AzContainerAppAuthConfig -InputObject $authconfig

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTAINERAPPINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/remove-azcontainerappauthconfig
#>
function Remove-AzContainerAppAuthConfig {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Parameter(ParameterSetName='DeleteViaIdentityContainerApp', Mandatory)]
    [Alias('AuthConfigName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App AuthConfig.
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='DeleteViaIdentityContainerApp', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONTAINERAPPINPUTOBJECT properties and create a hash table.
    ${ContainerAppInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.App.private\Remove-AzContainerAppAuthConfig_Delete';
            DeleteViaIdentity = 'Az.App.private\Remove-AzContainerAppAuthConfig_DeleteViaIdentity';
            DeleteViaIdentityContainerApp = 'Az.App.private\Remove-AzContainerAppAuthConfig_DeleteViaIdentityContainerApp';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Deletes the specified Certificate.
.Description
Deletes the specified Certificate.
.Example
Remove-AzContainerAppConnectedEnvCert -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Name azps-connectedenvcert
.Example
$connectedenv = Get-AzContainerAppConnectedEnv -ResourceGroupName azps_test_group_app -Name azps-connectedenv

Remove-AzContainerAppConnectedEnvCert -ConnectedEnvironmentInputObject $connectedenv -Name azps-connectedenvcert
.Example
$connectedenvcert = Get-AzContainerAppConnectedEnvCert -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Name azps-connectedenvcert

Remove-AzContainerAppConnectedEnvCert -InputObject $connectedenvcert

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONNECTEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/remove-azcontainerappconnectedenvcert
#>
function Remove-AzContainerAppConnectedEnvCert {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Connected Environment.
    ${ConnectedEnvironmentName},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Parameter(ParameterSetName='DeleteViaIdentityConnectedEnvironment', Mandatory)]
    [Alias('CertificateName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Certificate.
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='DeleteViaIdentityConnectedEnvironment', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONNECTEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ConnectedEnvironmentInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.App.private\Remove-AzContainerAppConnectedEnvCert_Delete';
            DeleteViaIdentity = 'Az.App.private\Remove-AzContainerAppConnectedEnvCert_DeleteViaIdentity';
            DeleteViaIdentityConnectedEnvironment = 'Az.App.private\Remove-AzContainerAppConnectedEnvCert_DeleteViaIdentityConnectedEnvironment';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Delete a Dapr Component from a connected environment.
.Description
Delete a Dapr Component from a connected environment.
.Example
Remove-AzContainerAppConnectedEnvDapr -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Name azps-connectedenvdapr
.Example
$connectedenv = Get-AzContainerAppConnectedEnv -ResourceGroupName azps_test_group_app -Name azps-connectedenv

Remove-AzContainerAppConnectedEnvDapr -ConnectedEnvironmentInputObject $connectedenv -Name azps-connectedenvdapr
.Example
$connectedenvdapr = Get-AzContainerAppConnectedEnvDapr -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Name azps-connectedenvdapr

Remove-AzContainerAppConnectedEnvDapr -InpitObject $connectedenvdapr

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONNECTEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/remove-azcontainerappconnectedenvdapr
#>
function Remove-AzContainerAppConnectedEnvDapr {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the connected environment.
    ${ConnectedEnvironmentName},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Parameter(ParameterSetName='DeleteViaIdentityConnectedEnvironment', Mandatory)]
    [Alias('DaprName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Dapr Component.
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='DeleteViaIdentityConnectedEnvironment', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONNECTEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ConnectedEnvironmentInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.App.private\Remove-AzContainerAppConnectedEnvDapr_Delete';
            DeleteViaIdentity = 'Az.App.private\Remove-AzContainerAppConnectedEnvDapr_DeleteViaIdentity';
            DeleteViaIdentityConnectedEnvironment = 'Az.App.private\Remove-AzContainerAppConnectedEnvDapr_DeleteViaIdentityConnectedEnvironment';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Delete storage for a connectedEnvironment.
.Description
Delete storage for a connectedEnvironment.
.Example
Remove-AzContainerAppConnectedEnvStorage -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Name azpstestsa
.Example
$connectedenv = Get-AzContainerAppConnectedEnv -ResourceGroupName azps_test_group_app -Name azps-connectedenv

Remove-AzContainerAppConnectedEnvStorage -ConnectedEnvironmentInputObject $connectedenv -Name azpstestsa
.Example
$connectedenvstorage = Get-AzContainerAppConnectedEnvStorage -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Name azpstestsa

Remove-AzContainerAppConnectedEnvStorage -InputObject $connectedenvstorage

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONNECTEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/remove-azcontainerappconnectedenvstorage
#>
function Remove-AzContainerAppConnectedEnvStorage {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Environment.
    ${ConnectedEnvironmentName},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Parameter(ParameterSetName='DeleteViaIdentityConnectedEnvironment', Mandatory)]
    [Alias('StorageName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the storage.
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='DeleteViaIdentityConnectedEnvironment', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONNECTEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ConnectedEnvironmentInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.App.private\Remove-AzContainerAppConnectedEnvStorage_Delete';
            DeleteViaIdentity = 'Az.App.private\Remove-AzContainerAppConnectedEnvStorage_DeleteViaIdentity';
            DeleteViaIdentityConnectedEnvironment = 'Az.App.private\Remove-AzContainerAppConnectedEnvStorage_DeleteViaIdentityConnectedEnvironment';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Delete an connectedEnvironment.
.Description
Delete an connectedEnvironment.
.Example
Remove-AzContainerAppConnectedEnv -ResourceGroupName azps_test_group_app -Name azps-connectedenv
.Example
$connectedenv = Get-AzContainerAppConnectedEnv -ResourceGroupName azps_test_group_app -Name azps-connectedenv
Remove-AzContainerAppConnectedEnv -InputObject $connectedenv

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/remove-azcontainerappconnectedenv
#>
function Remove-AzContainerAppConnectedEnv {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Alias('ConnectedEnvironmentName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the connectedEnvironment.
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.App.private\Remove-AzContainerAppConnectedEnv_Delete';
            DeleteViaIdentity = 'Az.App.private\Remove-AzContainerAppConnectedEnv_DeleteViaIdentity';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Delete a Container Apps Job.
.Description
Delete a Container Apps Job.
.Example
Remove-AzContainerAppJob -ResourceGroupName azps_test_group_app -Name azps-app-job
.Example
$job = Get-AzContainerAppJob -ResourceGroupName azps_test_group_app -Name azps-app-job
Remove-AzContainerAppJob -InputObject $job

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/remove-azcontainerappjob
#>
function Remove-AzContainerAppJob {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Alias('JobName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Job Name
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.App.private\Remove-AzContainerAppJob_Delete';
            DeleteViaIdentity = 'Az.App.private\Remove-AzContainerAppJob_DeleteViaIdentity';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Deletes the specified Managed Certificate.
.Description
Deletes the specified Managed Certificate.
.Example
Remove-AzContainerAppManagedCert -EnvName azps-env -ResourceGroupName azps_test_group_app -Name azps-managedcert
.Example
$managedcert = Get-AzContainerAppManagedCert -EnvName azps-env -ResourceGroupName azps_test_group_app -Name azps-managedcert

Remove-AzContainerAppManagedCert -InputObject $managedcert

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

MANAGEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/remove-azcontainerappmanagedcert
#>
function Remove-AzContainerAppManagedCert {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment.
    ${EnvName},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Parameter(ParameterSetName='DeleteViaIdentityManagedEnvironment', Mandatory)]
    [Alias('ManagedCertificateName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Certificate.
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='DeleteViaIdentityManagedEnvironment', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for MANAGEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ManagedEnvironmentInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.App.private\Remove-AzContainerAppManagedCert_Delete';
            DeleteViaIdentity = 'Az.App.private\Remove-AzContainerAppManagedCert_DeleteViaIdentity';
            DeleteViaIdentityManagedEnvironment = 'Az.App.private\Remove-AzContainerAppManagedCert_DeleteViaIdentityManagedEnvironment';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Deletes the specified Certificate.
.Description
Deletes the specified Certificate.
.Example
Remove-AzContainerAppManagedEnvCert -EnvName azps-env -ResourceGroupName azps_test_group_app -Name azps-env-cert
.Example
$managedenvcert = Get-AzContainerAppManagedEnvCert -EnvName azps-env -ResourceGroupName azps_test_group_app -Name azps-env-cert

Remove-AzContainerAppManagedEnvCert -InputObject $managedenvcert
.Example
$managedenv = Get-AzContainerAppManagedEnv -Name azps-env -ResourceGroupName azps_test_group_app

Remove-AzContainerAppManagedEnvCert -ManagedEnvironmentInputObject $managedenv -Name azps-env-cert

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

MANAGEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/remove-azcontainerappmanagedenvcert
#>
function Remove-AzContainerAppManagedEnvCert {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment.
    ${EnvName},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Parameter(ParameterSetName='DeleteViaIdentityManagedEnvironment', Mandatory)]
    [Alias('CertificateName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Certificate.
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='DeleteViaIdentityManagedEnvironment', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for MANAGEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ManagedEnvironmentInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.App.private\Remove-AzContainerAppManagedEnvCert_Delete';
            DeleteViaIdentity = 'Az.App.private\Remove-AzContainerAppManagedEnvCert_DeleteViaIdentity';
            DeleteViaIdentityManagedEnvironment = 'Az.App.private\Remove-AzContainerAppManagedEnvCert_DeleteViaIdentityManagedEnvironment';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Delete a Dapr Component from a Managed Environment.
.Description
Delete a Dapr Component from a Managed Environment.
.Example
Remove-AzContainerAppManagedEnvDapr -EnvName azps-env -ResourceGroupName azps_test_group_app -Name azps-dapr
.Example
$managedenvdapr = Get-AzContainerAppManagedEnvDapr -EnvName azps-env -ResourceGroupName azps_test_group_app -Name azps-dapr

Remove-AzContainerAppManagedEnvDapr -InputObject $managedenvdapr
.Example
$managedenv = Get-AzContainerAppManagedEnv -Name azps-env -ResourceGroupName azps_test_group_app

Remove-AzContainerAppManagedEnvDapr -ManagedEnvironmentInputObject $managedenv -Name azps-dapr

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

MANAGEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/remove-azcontainerappmanagedenvdapr
#>
function Remove-AzContainerAppManagedEnvDapr {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment.
    ${EnvName},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Parameter(ParameterSetName='DeleteViaIdentityManagedEnvironment', Mandatory)]
    [Alias('DaprName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Dapr Component.
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='DeleteViaIdentityManagedEnvironment', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for MANAGEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ManagedEnvironmentInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.App.private\Remove-AzContainerAppManagedEnvDapr_Delete';
            DeleteViaIdentity = 'Az.App.private\Remove-AzContainerAppManagedEnvDapr_DeleteViaIdentity';
            DeleteViaIdentityManagedEnvironment = 'Az.App.private\Remove-AzContainerAppManagedEnvDapr_DeleteViaIdentityManagedEnvironment';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Delete storage for a managedEnvironment.
.Description
Delete storage for a managedEnvironment.
.Example
Remove-AzContainerAppManagedEnvStorage -EnvName azps-env -ResourceGroupName azps_test_group_app -Name azpstestsa
.Example
$managedenvstorage = Get-AzContainerAppManagedEnvStorage -EnvName azps-env -ResourceGroupName azps_test_group_app -Name azpstestsa

Remove-AzContainerAppManagedEnvStorage -InputObject $managedenvstorage
.Example
$managedenv = Get-AzContainerAppManagedEnv -Name azps-env -ResourceGroupName azps_test_group_app

Remove-AzContainerAppManagedEnvStorage -ManagedEnvironmentInputObject $managedenv -Name azpstestsa

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

MANAGEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/remove-azcontainerappmanagedenvstorage
#>
function Remove-AzContainerAppManagedEnvStorage {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Environment.
    ${EnvName},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Parameter(ParameterSetName='DeleteViaIdentityManagedEnvironment', Mandatory)]
    [Alias('StorageName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the storage.
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='DeleteViaIdentityManagedEnvironment', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for MANAGEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ManagedEnvironmentInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.App.private\Remove-AzContainerAppManagedEnvStorage_Delete';
            DeleteViaIdentity = 'Az.App.private\Remove-AzContainerAppManagedEnvStorage_DeleteViaIdentity';
            DeleteViaIdentityManagedEnvironment = 'Az.App.private\Remove-AzContainerAppManagedEnvStorage_DeleteViaIdentityManagedEnvironment';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Delete a Managed Environment if it does not have any container apps.
.Description
Delete a Managed Environment if it does not have any container apps.
.Example
Remove-AzContainerAppManagedEnv -Name azpsenv -ResourceGroupName azps_test_group_app
.Example
$managedenv = Get-AzContainerAppManagedEnv -Name azpsenv -ResourceGroupName azps_test_group_app

Remove-AzContainerAppManagedEnv -InputObject $managedenv

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/remove-azcontainerappmanagedenv
#>
function Remove-AzContainerAppManagedEnv {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Alias('EnvName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Environment.
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.App.private\Remove-AzContainerAppManagedEnv_Delete';
            DeleteViaIdentity = 'Az.App.private\Remove-AzContainerAppManagedEnv_DeleteViaIdentity';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Delete a Container App.
.Description
Delete a Container App.
.Example
Remove-AzContainerApp -Name azps-containerapp-1 -ResourceGroupName azps_test_group_app
.Example
$containerapp = Get-AzContainerApp -Name azps-containerapp-1 -ResourceGroupName azps_test_group_app
Remove-AzContainerApp -InputObject $containerapp

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/remove-azcontainerapp
#>
function Remove-AzContainerApp {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Alias('ContainerAppName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.App.private\Remove-AzContainerApp_Delete';
            DeleteViaIdentity = 'Az.App.private\Remove-AzContainerApp_DeleteViaIdentity';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Restarts a revision for a Container App
.Description
Restarts a revision for a Container App
.Example
Restart-AzContainerAppRevision -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app -Name azps-containerapp-1--6a9svx2 -PassThru
.Example
$containerapp = Get-AzContainerApp -ResourceGroupName azps_test_group_app -Name azps-containerapp-1
Restart-AzContainerAppRevision -ContainerAppInputObject $containerapp -Name azps-containerapp-1--6a9svx2 -PassThru

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTAINERAPPINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/restart-azcontainerapprevision
#>
function Restart-AzContainerAppRevision {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Restart', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Restart', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(ParameterSetName='Restart', Mandatory)]
    [Parameter(ParameterSetName='RestartViaIdentityContainerApp', Mandatory)]
    [Alias('RevisionName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App Revision.
    ${Name},

    [Parameter(ParameterSetName='Restart', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Restart')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='RestartViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='RestartViaIdentityContainerApp', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONTAINERAPPINPUTOBJECT properties and create a hash table.
    ${ContainerAppInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Restart = 'Az.App.private\Restart-AzContainerAppRevision_Restart';
            RestartViaIdentity = 'Az.App.private\Restart-AzContainerAppRevision_RestartViaIdentity';
            RestartViaIdentityContainerApp = 'Az.App.private\Restart-AzContainerAppRevision_RestartViaIdentityContainerApp';
        }
        if (('Restart') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Start a Container Apps Job
.Description
Start a Container Apps Job
.Example
$initContainer = New-AzContainerAppJobExecutionContainerObject -Image "mcr.microsoft.com/k8se/quickstart-jobs:lates" -Name "simple-hello-world-container2" -ResourceCpu 0.25 -ResourceMemory "0.5Gi" -Command "/bin/sh" -Arg "-c","echo hello; sleep 10;"
Start-AzContainerAppJob -Name azps-app-job -ResourceGroupName azps_test_group_app -InitContainer $initContainer

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJobExecutionTemplate
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJobExecutionBase
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTAINER <IJobExecutionContainer[]>: List of container definitions for the Container Apps Job.
  [Arg <List<String>>]: Container start command arguments.
  [Command <List<String>>]: Container start command.
  [Env <List<IEnvironmentVar>>]: Container environment variables.
    [Name <String>]: Environment variable name.
    [SecretRef <String>]: Name of the Container App secret from which to pull the environment variable value.
    [Value <String>]: Non-secret environment variable value.
  [Image <String>]: Container image tag.
  [Name <String>]: Custom container name.
  [ResourceCpu <Double?>]: Required CPU in cores, e.g. 0.5
  [ResourceMemory <String>]: Required memory, e.g. "250Mb"

INITCONTAINER <IJobExecutionContainer[]>: List of specialized containers that run before job containers.
  [Arg <List<String>>]: Container start command arguments.
  [Command <List<String>>]: Container start command.
  [Env <List<IEnvironmentVar>>]: Container environment variables.
    [Name <String>]: Environment variable name.
    [SecretRef <String>]: Name of the Container App secret from which to pull the environment variable value.
    [Value <String>]: Non-secret environment variable value.
  [Image <String>]: Container image tag.
  [Name <String>]: Custom container name.
  [ResourceCpu <Double?>]: Required CPU in cores, e.g. 0.5
  [ResourceMemory <String>]: Required memory, e.g. "250Mb"

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

TEMPLATE <IJobExecutionTemplate>: Job's execution template, containing container configuration for a job's execution
  [Container <List<IJobExecutionContainer>>]: List of container definitions for the Container Apps Job.
    [Arg <List<String>>]: Container start command arguments.
    [Command <List<String>>]: Container start command.
    [Env <List<IEnvironmentVar>>]: Container environment variables.
      [Name <String>]: Environment variable name.
      [SecretRef <String>]: Name of the Container App secret from which to pull the environment variable value.
      [Value <String>]: Non-secret environment variable value.
    [Image <String>]: Container image tag.
    [Name <String>]: Custom container name.
    [ResourceCpu <Double?>]: Required CPU in cores, e.g. 0.5
    [ResourceMemory <String>]: Required memory, e.g. "250Mb"
  [InitContainer <List<IJobExecutionContainer>>]: List of specialized containers that run before job containers.
.Link
https://learn.microsoft.com/powershell/module/az.app/start-azcontainerappjob
#>
function Start-AzContainerAppJob {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJobExecutionBase])]
[CmdletBinding(DefaultParameterSetName='StartExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Start', Mandatory)]
    [Parameter(ParameterSetName='StartExpanded', Mandatory)]
    [Parameter(ParameterSetName='StartViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='StartViaJsonString', Mandatory)]
    [Alias('JobName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Job Name
    ${Name},

    [Parameter(ParameterSetName='Start', Mandatory)]
    [Parameter(ParameterSetName='StartExpanded', Mandatory)]
    [Parameter(ParameterSetName='StartViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='StartViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Start')]
    [Parameter(ParameterSetName='StartExpanded')]
    [Parameter(ParameterSetName='StartViaJsonFilePath')]
    [Parameter(ParameterSetName='StartViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='StartViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='StartViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Start', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='StartViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJobExecutionTemplate]
    # Job's execution template, containing container configuration for a job's execution
    # To construct, see NOTES section for TEMPLATE properties and create a hash table.
    ${Template},

    [Parameter(ParameterSetName='StartExpanded')]
    [Parameter(ParameterSetName='StartViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJobExecutionContainer[]]
    # List of container definitions for the Container Apps Job.
    # To construct, see NOTES section for CONTAINER properties and create a hash table.
    ${Container},

    [Parameter(ParameterSetName='StartExpanded')]
    [Parameter(ParameterSetName='StartViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJobExecutionContainer[]]
    # List of specialized containers that run before job containers.
    # To construct, see NOTES section for INITCONTAINER properties and create a hash table.
    ${InitContainer},

    [Parameter(ParameterSetName='StartViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Start operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='StartViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Start operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Start = 'Az.App.private\Start-AzContainerAppJob_Start';
            StartExpanded = 'Az.App.private\Start-AzContainerAppJob_StartExpanded';
            StartViaIdentity = 'Az.App.private\Start-AzContainerAppJob_StartViaIdentity';
            StartViaIdentityExpanded = 'Az.App.private\Start-AzContainerAppJob_StartViaIdentityExpanded';
            StartViaJsonFilePath = 'Az.App.private\Start-AzContainerAppJob_StartViaJsonFilePath';
            StartViaJsonString = 'Az.App.private\Start-AzContainerAppJob_StartViaJsonString';
        }
        if (('Start', 'StartExpanded', 'StartViaJsonFilePath', 'StartViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Start a container app
.Description
Start a container app
.Example
Start-AzContainerApp -Name azps-containerapp-1 -ResourceGroupName azps_test_group_app

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainerApp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/start-azcontainerapp
#>
function Start-AzContainerApp {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainerApp])]
[CmdletBinding(DefaultParameterSetName='Start', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Start', Mandatory)]
    [Alias('ContainerAppName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${Name},

    [Parameter(ParameterSetName='Start', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Start')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='StartViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Start = 'Az.App.private\Start-AzContainerApp_Start';
            StartViaIdentity = 'Az.App.private\Start-AzContainerApp_StartViaIdentity';
        }
        if (('Start') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Terminates execution of a running container apps job
.Description
Terminates execution of a running container apps job
.Example
Stop-AzContainerAppJobExecution -JobName azps-app-job2 -ResourceGroupName azps_test_group_app -Name azps-app-job-vvhlnul -PassThru

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

JOBINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/stop-azcontainerappjobexecution
#>
function Stop-AzContainerAppJobExecution {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Stop', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Stop', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Job Name
    ${JobName},

    [Parameter(ParameterSetName='Stop', Mandatory)]
    [Parameter(ParameterSetName='StopViaIdentityJob', Mandatory)]
    [Alias('JobExecutionName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Job execution name.
    ${Name},

    [Parameter(ParameterSetName='Stop', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Stop')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='StopViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='StopViaIdentityJob', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for JOBINPUTOBJECT properties and create a hash table.
    ${JobInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Stop = 'Az.App.private\Stop-AzContainerAppJobExecution_Stop';
            StopViaIdentity = 'Az.App.private\Stop-AzContainerAppJobExecution_StopViaIdentity';
            StopViaIdentityJob = 'Az.App.private\Stop-AzContainerAppJobExecution_StopViaIdentityJob';
        }
        if (('Stop') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Stop a container app
.Description
Stop a container app
.Example
Stop-AzContainerApp -Name azps-containerapp-1 -ResourceGroupName azps_test_group_app

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainerApp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/stop-azcontainerapp
#>
function Stop-AzContainerApp {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainerApp])]
[CmdletBinding(DefaultParameterSetName='Stop', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Stop', Mandatory)]
    [Alias('ContainerAppName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${Name},

    [Parameter(ParameterSetName='Stop', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Stop')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='StopViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Stop = 'Az.App.private\Stop-AzContainerApp_Stop';
            StopViaIdentity = 'Az.App.private\Stop-AzContainerApp_StopViaIdentity';
        }
        if (('Stop') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Checks if resource connectedEnvironmentName is available.
.Description
Checks if resource connectedEnvironmentName is available.
.Example
Test-AzContainerAppConnectedEnvNameAvailability -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Type Microsoft.App/containerApps -Name azpsconenv

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICheckNameAvailabilityRequest
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICheckNameAvailabilityResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CHECKNAMEAVAILABILITYREQUEST <ICheckNameAvailabilityRequest>: The check availability request body.
  [Name <String>]: The name of the resource for which availability needs to be checked.
  [Type <String>]: The resource type.
.Link
https://learn.microsoft.com/powershell/module/az.app/test-azcontainerappconnectedenvnameavailability
#>
function Test-AzContainerAppConnectedEnvNameAvailability {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICheckNameAvailabilityResponse])]
[CmdletBinding(DefaultParameterSetName='CheckExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment.
    ${ConnectedEnvironmentName},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='Check', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICheckNameAvailabilityRequest]
    # The check availability request body.
    # To construct, see NOTES section for CHECKNAMEAVAILABILITYREQUEST properties and create a hash table.
    ${CheckNameAvailabilityRequest},

    [Parameter(ParameterSetName='CheckExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The name of the resource for which availability needs to be checked.
    ${Name},

    [Parameter(ParameterSetName='CheckExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The resource type.
    ${Type},

    [Parameter(ParameterSetName='CheckViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Check operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CheckViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Check operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Check = 'Az.App.private\Test-AzContainerAppConnectedEnvNameAvailability_Check';
            CheckExpanded = 'Az.App.private\Test-AzContainerAppConnectedEnvNameAvailability_CheckExpanded';
            CheckViaJsonFilePath = 'Az.App.private\Test-AzContainerAppConnectedEnvNameAvailability_CheckViaJsonFilePath';
            CheckViaJsonString = 'Az.App.private\Test-AzContainerAppConnectedEnvNameAvailability_CheckViaJsonString';
        }
        if (('Check', 'CheckExpanded', 'CheckViaJsonFilePath', 'CheckViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Checks if resource name is available.
.Description
Checks if resource name is available.
.Example
Test-AzContainerAppNamespaceAvailability -EnvName azpsenv -ResourceGroupName azps_test_group_app -Name azpsapp -Type Microsoft.App/containerApps

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICheckNameAvailabilityRequest
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICheckNameAvailabilityResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CHECKNAMEAVAILABILITYREQUEST <ICheckNameAvailabilityRequest>: The check availability request body.
  [Name <String>]: The name of the resource for which availability needs to be checked.
  [Type <String>]: The resource type.
.Link
https://learn.microsoft.com/powershell/module/az.app/test-azcontainerappnamespaceavailability
#>
function Test-AzContainerAppNamespaceAvailability {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICheckNameAvailabilityResponse])]
[CmdletBinding(DefaultParameterSetName='CheckExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment.
    ${EnvName},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='Check', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICheckNameAvailabilityRequest]
    # The check availability request body.
    # To construct, see NOTES section for CHECKNAMEAVAILABILITYREQUEST properties and create a hash table.
    ${CheckNameAvailabilityRequest},

    [Parameter(ParameterSetName='CheckExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The name of the resource for which availability needs to be checked.
    ${Name},

    [Parameter(ParameterSetName='CheckExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The resource type.
    ${Type},

    [Parameter(ParameterSetName='CheckViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Check operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CheckViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Check operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Check = 'Az.App.private\Test-AzContainerAppNamespaceAvailability_Check';
            CheckExpanded = 'Az.App.private\Test-AzContainerAppNamespaceAvailability_CheckExpanded';
            CheckViaJsonFilePath = 'Az.App.private\Test-AzContainerAppNamespaceAvailability_CheckViaJsonFilePath';
            CheckViaJsonString = 'Az.App.private\Test-AzContainerAppNamespaceAvailability_CheckViaJsonString';
        }
        if (('Check', 'CheckExpanded', 'CheckViaJsonFilePath', 'CheckViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create the AuthConfig for a Container App.
.Description
Create the AuthConfig for a Container App.
.Example
Update-AzContainerAppAuthConfig -Name current -ContainerAppName azps-containerapp-2 -ResourceGroupName azps_test_group_app -PlatformEnabled -GlobalValidationUnauthenticatedClientAction RedirectToLoginPage -IdentityProvider $identity
.Example
$containerapp = Get-AzContainerApp -ResourceGroupName azps_test_group_app -Name azps-containerapp-2

Update-AzContainerAppAuthConfig -Name current -ContainerAppInputObject $containerapp -PlatformEnabled -GlobalValidationUnauthenticatedClientAction RedirectToLoginPage -IdentityProvider $identity
.Example
$authconfig = Get-AzContainerAppAuthConfig -Name current -ContainerAppName azps-containerapp-2 -ResourceGroupName azps_test_group_app

Update-AzContainerAppAuthConfig -InputObject $authconfig -PlatformEnabled -GlobalValidationUnauthenticatedClientAction RedirectToLoginPage -IdentityProvider $identity

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfig
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTAINERAPPINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

IDENTITYPROVIDER <IIdentityProviders>: The configuration settings of each of the identity providers used to configure ContainerApp Service Authentication/Authorization.
  [AllowedPrincipalGroup <List<String>>]: The list of the allowed groups.
  [AllowedPrincipalIdentity <List<String>>]: The list of the allowed identities.
  [AppleEnabled <Boolean?>]: <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
  [AppleLoginScope <List<String>>]: A list of the scopes that should be requested while authenticating.
  [AppleRegistrationClientId <String>]: The Client ID of the app used for login.
  [AppleRegistrationClientSecretSettingName <String>]: The app setting name that contains the client secret.
  [AzureActiveDirectoryEnabled <Boolean?>]: <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
  [AzureActiveDirectoryIsAutoProvisioned <Boolean?>]: Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.         This is an internal flag primarily intended to support the Azure Management Portal. Users should not         read or write to this property.
  [AzureActiveDirectoryRegistrationClientId <String>]: The Client ID of this relying party application, known as the client_id.         This setting is required for enabling OpenID Connection authentication with Azure Active Directory or         other 3rd party OpenID Connect providers.         More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html
  [AzureActiveDirectoryRegistrationClientSecretSettingName <String>]: The app setting name that contains the client secret of the relying party application.
  [AzureActiveDirectoryValidationAllowedAudience <List<String>>]: The list of audiences that can make successful authentication/authorization requests.
  [AzureStaticWebAppEnabled <Boolean?>]: <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
  [AzureStaticWebAppsRegistrationClientId <String>]: The Client ID of the app used for login.
  [CustomOpenIdConnectProvider <IIdentityProvidersCustomOpenIdConnectProviders>]: The map of the name of the alias of each custom Open ID Connect provider to the         configuration settings of the custom Open ID Connect provider.
    [(Any) <ICustomOpenIdConnectProvider>]: This indicates any property can be added to this object.
  [DefaultAuthorizationPolicyAllowedApplication <List<String>>]: The configuration settings of the Azure Active Directory allowed applications.
  [FacebookEnabled <Boolean?>]: <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
  [FacebookGraphApiVersion <String>]: The version of the Facebook api to be used while logging in.
  [FacebookLoginScope <List<String>>]: A list of the scopes that should be requested while authenticating.
  [GitHubEnabled <Boolean?>]: <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
  [GitHubLoginScope <List<String>>]: A list of the scopes that should be requested while authenticating.
  [GitHubRegistrationClientId <String>]: The Client ID of the app used for login.
  [GitHubRegistrationClientSecretSettingName <String>]: The app setting name that contains the client secret.
  [GoogleEnabled <Boolean?>]: <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
  [GoogleLoginScope <List<String>>]: A list of the scopes that should be requested while authenticating.
  [GoogleRegistrationClientId <String>]: The Client ID of the app used for login.
  [GoogleRegistrationClientSecretSettingName <String>]: The app setting name that contains the client secret.
  [GoogleValidationAllowedAudience <List<String>>]: The configuration settings of the allowed list of audiences from which to validate the JWT token.
  [JwtClaimCheckAllowedClientApplication <List<String>>]: The list of the allowed client applications.
  [JwtClaimCheckAllowedGroup <List<String>>]: The list of the allowed groups.
  [LoginDisableWwwAuthenticate <Boolean?>]: <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
  [LoginParameter <List<String>>]: Login parameters to send to the OpenID Connect authorization endpoint when         a user logs in. Each parameter must be in the form "key=value".
  [RegistrationAppId <String>]: The App ID of the app used for login.
  [RegistrationAppSecretSettingName <String>]: The app setting name that contains the app secret.
  [RegistrationClientSecretCertificateIssuer <String>]: An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes. This property acts as         a replacement for the Client Secret Certificate Thumbprint. It is also optional.
  [RegistrationClientSecretCertificateSubjectAlternativeName <String>]: An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes. This property acts as         a replacement for the Client Secret Certificate Thumbprint. It is also optional.
  [RegistrationClientSecretCertificateThumbprint <String>]: An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes. This property acts as         a replacement for the Client Secret. It is also optional.
  [RegistrationConsumerKey <String>]: The OAuth 1.0a consumer key of the Twitter application used for sign-in.         This setting is required for enabling Twitter Sign-In.         Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in
  [RegistrationConsumerSecretSettingName <String>]: The app setting name that contains the OAuth 1.0a consumer secret of the Twitter         application used for sign-in.
  [RegistrationOpenIdIssuer <String>]: The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.         When using Azure Active Directory, this value is the URI of the directory tenant, e.g. https://login.microsoftonline.com/v2.0/{tenant-guid}/.         This URI is a case-sensitive identifier for the token issuer.         More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html
  [TwitterEnabled <Boolean?>]: <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/update-azcontainerappauthconfig
#>
function Update-AzContainerAppAuthConfig {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfig])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaIdentityContainerAppExpanded', Mandatory)]
    [Alias('AuthConfigName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App AuthConfig.
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityContainerAppExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONTAINERAPPINPUTOBJECT properties and create a hash table.
    ${ContainerAppInputObject},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("FixedTime", "IdentityProviderDerived")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The convention used when determining the session cookie's expiration.
    ${CookieExpirationConvention},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The time after the request is made when the session cookie should expire.
    ${CookieExpirationTimeToExpiration},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("NoProxy", "Standard", "Custom")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The convention used to determine the url of the request made.
    ${ForwardProxyConvention},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The name of the header containing the host of the request.
    ${ForwardProxyCustomHostHeaderName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The name of the header containing the scheme of the request.
    ${ForwardProxyCustomProtoHeaderName},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # The paths for which unauthenticated flow would not be redirected to the login page.
    ${GlobalValidationExcludedPath},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The default authentication provider to use when multiple providers are configured.This setting is only needed if multiple providers are configured and the unauthenticated clientaction is set to "RedirectToLoginPage".
    ${GlobalValidationRedirectToProvider},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("RedirectToLoginPage", "AllowAnonymous", "Return401", "Return403")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The action to take when an unauthenticated client attempts to access the app.
    ${GlobalValidationUnauthenticatedClientAction},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.
    ${HttpSettingRequireHttps},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IIdentityProviders]
    # The configuration settings of each of the identity providers used to configure ContainerApp Service Authentication/Authorization.
    # To construct, see NOTES section for IDENTITYPROVIDER properties and create a hash table.
    ${IdentityProvider},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # External URLs that can be redirected to as part of logging in or logging out of the app.
    # Note that the query string part of the URL is ignored.This is an advanced setting typically only needed by Windows Store application backends.Note that URLs within the current domain are always implicitly allowed.
    ${LoginAllowedExternalRedirectUrl},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
    ${LoginPreserveUrlFragmentsForLogin},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The time after the request is made when the nonce should expire.
    ${NonceExpirationInterval},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
    ${NonceValidateNonce},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
    ${PlatformEnabled},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The RuntimeVersion of the Authentication / Authorization feature in use for the current app.The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
    ${PlatformRuntimeVersion},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The prefix that should precede all the authentication/authorization paths.
    ${RouteApiPrefix},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The endpoint at which a logout request should be made.
    ${RouteLogoutEndpoint},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.App.private\Update-AzContainerAppAuthConfig_UpdateExpanded';
            UpdateViaIdentityContainerAppExpanded = 'Az.App.private\Update-AzContainerAppAuthConfig_UpdateViaIdentityContainerAppExpanded';
            UpdateViaIdentityExpanded = 'Az.App.private\Update-AzContainerAppAuthConfig_UpdateViaIdentityExpanded';
        }
        if (('UpdateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Patches a certificate.
Currently only patching of tags is supported
.Description
Patches a certificate.
Currently only patching of tags is supported
.Example
Update-AzContainerAppConnectedEnvCert -Name azps-connectedenvcert -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Tag @{"abc"="123"}
.Example
$connectedenv = Get-AzContainerAppConnectedEnv -ResourceGroupName azps_test_group_app -Name azps-connectedenv
Update-AzContainerAppConnectedEnvCert -Name azps-connectedenvcert -ConnectedEnvironmentInputObject $connectedenv -Tag @{"abc"="123"}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICertificate
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONNECTEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/update-azcontainerappconnectedenvcert
#>
function Update-AzContainerAppConnectedEnvCert {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICertificate])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Connected Environment.
    ${ConnectedEnvironmentName},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaIdentityConnectedEnvironmentExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Alias('CertificateName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Certificate.
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath')]
    [Parameter(ParameterSetName='UpdateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityConnectedEnvironmentExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONNECTEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ConnectedEnvironmentInputObject},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityConnectedEnvironmentExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICertificatePatchTags]))]
    [System.Collections.Hashtable]
    # Application-specific metadata in the form of key-value pairs.
    ${Tag},

    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Update operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Update operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.App.private\Update-AzContainerAppConnectedEnvCert_UpdateExpanded';
            UpdateViaIdentityConnectedEnvironmentExpanded = 'Az.App.private\Update-AzContainerAppConnectedEnvCert_UpdateViaIdentityConnectedEnvironmentExpanded';
            UpdateViaIdentityExpanded = 'Az.App.private\Update-AzContainerAppConnectedEnvCert_UpdateViaIdentityExpanded';
            UpdateViaJsonFilePath = 'Az.App.private\Update-AzContainerAppConnectedEnvCert_UpdateViaJsonFilePath';
            UpdateViaJsonString = 'Az.App.private\Update-AzContainerAppConnectedEnvCert_UpdateViaJsonString';
        }
        if (('UpdateExpanded', 'UpdateViaJsonFilePath', 'UpdateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create a Dapr Component in a connected environment.
.Description
Create a Dapr Component in a connected environment.
.Example
$secretObject = New-AzContainerAppSecretObject -Name "masterkey" -Value "keyvalue"
$daprMetaData = New-AzContainerAppDaprMetadataObject -Name "masterkey" -Value "masterkey"

Update-AzContainerAppConnectedEnvDapr -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Name azps-connectedenvdapr -ComponentType "state.azure.cosmosdb" -Version v2 -IgnoreError:$false -InitTimeout 60s -Secret $secretObject -Metadata $daprMetaData
.Example
$secretObject = New-AzContainerAppSecretObject -Name "masterkey" -Value "keyvalue"
$daprMetaData = New-AzContainerAppDaprMetadataObject -Name "masterkey" -Value "masterkey"
$connectedenv = Get-AzContainerAppConnectedEnv -ResourceGroupName azps_test_group_app -Name azps-connectedenv

Update-AzContainerAppConnectedEnvDapr -ConnectedEnvironmentInputObject $connectedenv -Name azps-connectedenvdapr -ComponentType "state.azure.cosmosdb" -Version v2 -IgnoreError:$false -InitTimeout 60s -Secret $secretObject -Metadata $daprMetaData
.Example
$secretObject = New-AzContainerAppSecretObject -Name "masterkey" -Value "keyvalue"
$daprMetaData = New-AzContainerAppDaprMetadataObject -Name "masterkey" -Value "masterkey"
$connectedenvdapr = Get-AzContainerAppConnectedEnvDapr -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Name azps-connectedenvdapr

Update-AzContainerAppConnectedEnvDapr -InputObject $connectedenvdapr -ComponentType "state.azure.cosmosdb" -Version v2 -IgnoreError:$false -InitTimeout 60s -Secret $secretObject -Metadata $daprMetaData

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprComponent
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONNECTEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

METADATA <IDaprMetadata[]>: Component metadata
  [Name <String>]: Metadata property name.
  [SecretRef <String>]: Name of the Dapr Component secret from which to pull the metadata property value.
  [Value <String>]: Metadata property value.

SECRET <ISecret[]>: Collection of secrets used by a Dapr component
  [Identity <String>]: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
  [KeyVaultUrl <String>]: Azure Key Vault URL pointing to the secret referenced by the container app.
  [Name <String>]: Secret Name.
  [Value <String>]: Secret Value.
.Link
https://learn.microsoft.com/powershell/module/az.app/update-azcontainerappconnectedenvdapr
#>
function Update-AzContainerAppConnectedEnvDapr {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprComponent])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the connected environment.
    ${ConnectedEnvironmentName},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaIdentityConnectedEnvironmentExpanded', Mandatory)]
    [Alias('DaprName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Dapr Component.
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityConnectedEnvironmentExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONNECTEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ConnectedEnvironmentInputObject},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Component type
    ${ComponentType},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean describing if the component errors are ignores
    ${IgnoreError},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Initialization timeout
    ${InitTimeout},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprMetadata[]]
    # Component metadata
    # To construct, see NOTES section for METADATA properties and create a hash table.
    ${Metadata},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # Names of container apps that can use this Dapr component
    ${Scope},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISecret[]]
    # Collection of secrets used by a Dapr component
    # To construct, see NOTES section for SECRET properties and create a hash table.
    ${Secret},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Name of a Dapr component to retrieve component secrets from
    ${SecretStoreComponent},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Component version
    ${Version},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.App.private\Update-AzContainerAppConnectedEnvDapr_UpdateExpanded';
            UpdateViaIdentityConnectedEnvironmentExpanded = 'Az.App.private\Update-AzContainerAppConnectedEnvDapr_UpdateViaIdentityConnectedEnvironmentExpanded';
            UpdateViaIdentityExpanded = 'Az.App.private\Update-AzContainerAppConnectedEnvDapr_UpdateViaIdentityExpanded';
        }
        if (('UpdateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create storage for a connectedEnvironment.
.Description
Create storage for a connectedEnvironment.
.Example
$storageAccountKey = (Get-AzStorageAccountKey -ResourceGroupName azps_test_group_app -AccountName azpstestsa).Value[0]

Update-AzContainerAppConnectedEnvStorage -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Name azpstestsa -AzureFileAccessMode 'ReadWrite' -AzureFileAccountKey $storageAccountKey -AzureFileAccountName azpstestsa -AzureFileShareName azps-rw-sharename
.Example
$storageAccountKey = (Get-AzStorageAccountKey -ResourceGroupName azps_test_group_app -AccountName azpstestsa).Value[0]
$connectedenv = Get-AzContainerAppConnectedEnv -ResourceGroupName azps_test_group_app -Name azps-connectedenv

Update-AzContainerAppConnectedEnvStorage -ConnectedEnvironmentInputObject $connectedenv -Name azpstestsa -AzureFileAccessMode 'ReadWrite' -AzureFileAccountKey $storageAccountKey -AzureFileAccountName azpstestsa -AzureFileShareName azps-rw-sharename
.Example
$storageAccountKey = (Get-AzStorageAccountKey -ResourceGroupName azps_test_group_app -AccountName azpstestsa).Value[0]
$connectedenvstorage = Get-AzContainerAppConnectedEnvStorage -ConnectedEnvironmentName azps-connectedenv -ResourceGroupName azps_test_group_app -Name azpstestsa

Update-AzContainerAppConnectedEnvStorage -InputObject $connectedenvstorage -AzureFileAccessMode 'ReadWrite' -AzureFileAccountKey $storageAccountKey -AzureFileAccountName azpstestsa -AzureFileShareName azps-rw-sharename

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IConnectedEnvironmentStorage
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONNECTEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/update-azcontainerappconnectedenvstorage
#>
function Update-AzContainerAppConnectedEnvStorage {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IConnectedEnvironmentStorage])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Environment.
    ${ConnectedEnvironmentName},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaIdentityConnectedEnvironmentExpanded', Mandatory)]
    [Alias('StorageName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the storage.
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityConnectedEnvironmentExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONNECTEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ConnectedEnvironmentInputObject},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("ReadOnly", "ReadWrite")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Access mode for storage
    ${AzureFileAccessMode},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Storage account key for azure file.
    ${AzureFileAccountKey},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Storage account name for azure file.
    ${AzureFileAccountName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Azure file share name.
    ${AzureFileShareName},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.App.private\Update-AzContainerAppConnectedEnvStorage_UpdateExpanded';
            UpdateViaIdentityConnectedEnvironmentExpanded = 'Az.App.private\Update-AzContainerAppConnectedEnvStorage_UpdateViaIdentityConnectedEnvironmentExpanded';
            UpdateViaIdentityExpanded = 'Az.App.private\Update-AzContainerAppConnectedEnvStorage_UpdateViaIdentityExpanded';
        }
        if (('UpdateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Patches a Container Apps Job using JSON Merge Patch
.Description
Patches a Container Apps Job using JSON Merge Patch
.Example
$EnvId = (Get-AzContainerAppManagedEnv -ResourceGroupName azps_test_group_app -Name azps-env).Id
$probeHttpGetHttpHeader = New-AzContainerAppProbeHeaderObject -Name "Custom-Header" -Value "Awesome"
$probe = New-AzContainerAppProbeObject -Type "Liveness" -HttpGetPath "/health" -HttpGetPort 8080 -InitialDelaySecond 3 -PeriodSecond 3 -HttpGetHttpHeader $probeHttpGetHttpHeader
$temp = New-AzContainerAppTemplateObject -Image "mcr.microsoft.com/k8se/quickstart:latest" -Name "simple-hello-world-container" -Probe $probe -ResourceCpu 0.25 -ResourceMemory "0.5Gi"

Update-AzContainerAppJob -Name azps-app-job -ResourceGroupName azps_test_group_app -ConfigurationReplicaRetryLimit 10 -ConfigurationReplicaTimeout 10 -ConfigurationTriggerType Manual -EnvironmentId $EnvId -ManualTriggerConfigParallelism 4 -ManualTriggerConfigReplicaCompletionCount 1 -TemplateContainer $temp

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJob
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONFIGURATIONREGISTRY <IRegistryCredentials[]>: Collection of private container registry credentials used by a Container apps job
  [Identity <String>]: A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
  [PasswordSecretRef <String>]: The name of the Secret that contains the registry login password
  [Server <String>]: Container Registry Server
  [Username <String>]: Container Registry Username

CONFIGURATIONSECRET <ISecret[]>: Collection of secrets used by a Container Apps Job
  [Identity <String>]: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
  [KeyVaultUrl <String>]: Azure Key Vault URL pointing to the secret referenced by the container app.
  [Name <String>]: Secret Name.
  [Value <String>]: Secret Value.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

SCALERULE <IJobScaleRule[]>: Scaling rules.
  [Auth <List<IScaleRuleAuth>>]: Authentication secrets for the scale rule.
    [SecretRef <String>]: Name of the secret from which to pull the auth params.
    [TriggerParameter <String>]: Trigger Parameter that uses the secret
  [Metadata <IAny>]: Metadata properties to describe the scale rule.
  [Name <String>]: Scale Rule Name
  [Type <String>]: Type of the scale rule         eg: azure-servicebus, redis etc.

TEMPLATECONTAINER <IContainer[]>: List of container definitions for the Container App.
  [Arg <List<String>>]: Container start command arguments.
  [Command <List<String>>]: Container start command.
  [Env <List<IEnvironmentVar>>]: Container environment variables.
    [Name <String>]: Environment variable name.
    [SecretRef <String>]: Name of the Container App secret from which to pull the environment variable value.
    [Value <String>]: Non-secret environment variable value.
  [Image <String>]: Container image tag.
  [Name <String>]: Custom container name.
  [ResourceCpu <Double?>]: Required CPU in cores, e.g. 0.5
  [ResourceMemory <String>]: Required memory, e.g. "250Mb"
  [VolumeMount <List<IVolumeMount>>]: Container volume mounts.
    [MountPath <String>]: Path within the container at which the volume should be mounted.Must not contain ':'.
    [SubPath <String>]: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
    [VolumeName <String>]: This must match the Name of a Volume.
  [Probe <List<IContainerAppProbe>>]: List of probes for the container.
    [FailureThreshold <Int32?>]: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
    [HttpGetHost <String>]: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
    [HttpGetHttpHeader <List<IContainerAppProbeHttpGetHttpHeadersItem>>]: Custom headers to set in the request. HTTP allows repeated headers.
      Name <String>: The header field name
      Value <String>: The header field value
    [HttpGetPath <String>]: Path to access on the HTTP server.
    [HttpGetPort <Int32?>]: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
    [HttpGetScheme <String>]: Scheme to use for connecting to the host. Defaults to HTTP.
    [InitialDelaySecond <Int32?>]: Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
    [PeriodSecond <Int32?>]: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
    [SuccessThreshold <Int32?>]: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
    [TcpSocketHost <String>]: Optional: Host name to connect to, defaults to the pod IP.
    [TcpSocketPort <Int32?>]: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
    [TerminationGracePeriodSecond <Int64?>]: Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
    [TimeoutSecond <Int32?>]: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
    [Type <String>]: The type of probe.

TEMPLATEINITCONTAINER <IInitContainer[]>: List of specialized containers that run before app containers.
  [Arg <List<String>>]: Container start command arguments.
  [Command <List<String>>]: Container start command.
  [Env <List<IEnvironmentVar>>]: Container environment variables.
    [Name <String>]: Environment variable name.
    [SecretRef <String>]: Name of the Container App secret from which to pull the environment variable value.
    [Value <String>]: Non-secret environment variable value.
  [Image <String>]: Container image tag.
  [Name <String>]: Custom container name.
  [ResourceCpu <Double?>]: Required CPU in cores, e.g. 0.5
  [ResourceMemory <String>]: Required memory, e.g. "250Mb"
  [VolumeMount <List<IVolumeMount>>]: Container volume mounts.
    [MountPath <String>]: Path within the container at which the volume should be mounted.Must not contain ':'.
    [SubPath <String>]: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
    [VolumeName <String>]: This must match the Name of a Volume.

TEMPLATEVOLUME <IVolume[]>: List of volume definitions for the Container App.
  [MountOption <String>]: Mount options used while mounting the AzureFile. Must be a comma-separated string.
  [Name <String>]: Volume name.
  [Secret <List<ISecretVolumeItem>>]: List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to volume.
    [Path <String>]: Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
    [SecretRef <String>]: Name of the Container App secret from which to pull the secret value.
  [StorageName <String>]: Name of storage resource. No need to provide for EmptyDir and Secret.
  [StorageType <String>]: Storage type for the volume. If not provided, use EmptyDir.
.Link
https://learn.microsoft.com/powershell/module/az.app/update-azcontainerappjob
#>
function Update-AzContainerAppJob {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJob])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Alias('JobName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Job Name
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath')]
    [Parameter(ParameterSetName='UpdateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IRegistryCredentials[]]
    # Collection of private container registry credentials used by a Container apps job
    # To construct, see NOTES section for CONFIGURATIONREGISTRY properties and create a hash table.
    ${ConfigurationRegistry},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Maximum number of retries before failing the job.
    ${ConfigurationReplicaRetryLimit},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Maximum number of seconds a replica is allowed to run.
    ${ConfigurationReplicaTimeout},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISecret[]]
    # Collection of secrets used by a Container Apps Job
    # To construct, see NOTES section for CONFIGURATIONSECRET properties and create a hash table.
    ${ConfigurationSecret},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("Schedule", "Event", "Manual")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Trigger type of the job
    ${ConfigurationTriggerType},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Resource ID of environment.
    ${EnvironmentId},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The endpoint of the eventstream of the container apps job.
    ${EventStreamEndpoint},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Number of parallel replicas of a job that can run at a given time.
    ${EventTriggerConfigParallelism},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Minimum number of successful replica completions before overall job completion.
    ${EventTriggerConfigReplicaCompletionCount},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("None", "SystemAssigned", "UserAssigned", "SystemAssigned,UserAssigned")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
    ${IdentityType},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IUserAssignedIdentities]))]
    [System.Collections.Hashtable]
    # The set of user assigned identities associated with the resource.
    # The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
    # The dictionary values can be empty objects ({}) in requests.
    ${IdentityUserAssignedIdentity},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Number of parallel replicas of a job that can run at a given time.
    ${ManualTriggerConfigParallelism},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Minimum number of successful replica completions before overall job completion.
    ${ManualTriggerConfigReplicaCompletionCount},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # Outbound IP Addresses of a container apps job.
    ${OutboundIPAddress},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Maximum number of job executions that are created for a trigger, default 100.
    ${ScaleMaxExecution},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Minimum number of job executions that are created for a trigger, default 0
    ${ScaleMinExecution},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Interval to check each event source in seconds.
    # Defaults to 30s
    ${ScalePollingInterval},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJobScaleRule[]]
    # Scaling rules.
    # To construct, see NOTES section for SCALERULE properties and create a hash table.
    ${ScaleRule},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Cron formatted repeating schedule ("* * * * *") of a Cron Job.
    ${ScheduleTriggerConfigCronExpression},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Number of parallel replicas of a job that can run at a given time.
    ${ScheduleTriggerConfigParallelism},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Minimum number of successful replica completions before overall job completion.
    ${ScheduleTriggerConfigReplicaCompletionCount},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IJobPatchPropertiesTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainer[]]
    # List of container definitions for the Container App.
    # To construct, see NOTES section for TEMPLATECONTAINER properties and create a hash table.
    ${TemplateContainer},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IInitContainer[]]
    # List of specialized containers that run before app containers.
    # To construct, see NOTES section for TEMPLATEINITCONTAINER properties and create a hash table.
    ${TemplateInitContainer},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IVolume[]]
    # List of volume definitions for the Container App.
    # To construct, see NOTES section for TEMPLATEVOLUME properties and create a hash table.
    ${TemplateVolume},

    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Update operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Update operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.App.private\Update-AzContainerAppJob_UpdateExpanded';
            UpdateViaIdentityExpanded = 'Az.App.private\Update-AzContainerAppJob_UpdateViaIdentityExpanded';
            UpdateViaJsonFilePath = 'Az.App.private\Update-AzContainerAppJob_UpdateViaJsonFilePath';
            UpdateViaJsonString = 'Az.App.private\Update-AzContainerAppJob_UpdateViaJsonString';
        }
        if (('UpdateExpanded', 'UpdateViaJsonFilePath', 'UpdateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Patches a managed certificate.
Oly patching of tags is supported
.Description
Patches a managed certificate.
Oly patching of tags is supported
.Example
Update-AzContainerAppManagedCert -EnvName azps-env -Name azps-managedcert -ResourceGroupName azps_test_group_app -Tag @{"abc"="123"}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedCertificate
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

MANAGEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/update-azcontainerappmanagedcert
#>
function Update-AzContainerAppManagedCert {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedCertificate])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment.
    ${EnvName},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaIdentityManagedEnvironmentExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Alias('ManagedCertificateName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Certificate.
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath')]
    [Parameter(ParameterSetName='UpdateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='UpdateViaIdentityManagedEnvironmentExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for MANAGEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ManagedEnvironmentInputObject},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityManagedEnvironmentExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedCertificatePatchTags]))]
    [System.Collections.Hashtable]
    # Application-specific metadata in the form of key-value pairs.
    ${Tag},

    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Update operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Update operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.App.private\Update-AzContainerAppManagedCert_UpdateExpanded';
            UpdateViaIdentityExpanded = 'Az.App.private\Update-AzContainerAppManagedCert_UpdateViaIdentityExpanded';
            UpdateViaIdentityManagedEnvironmentExpanded = 'Az.App.private\Update-AzContainerAppManagedCert_UpdateViaIdentityManagedEnvironmentExpanded';
            UpdateViaJsonFilePath = 'Az.App.private\Update-AzContainerAppManagedCert_UpdateViaJsonFilePath';
            UpdateViaJsonString = 'Az.App.private\Update-AzContainerAppManagedCert_UpdateViaJsonString';
        }
        if (('UpdateExpanded', 'UpdateViaJsonFilePath', 'UpdateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Patches a certificate.
Currently only patching of tags is supported
.Description
Patches a certificate.
Currently only patching of tags is supported
.Example
Update-AzContainerAppManagedEnvCert -EnvName azps-env -Name azps-env-cert -ResourceGroupName azps_test_group_app -Tag @{"abc"="123"}
.Example
$managedenvcert = Get-AzContainerAppManagedEnvCert -EnvName azps-env -Name azps-env-cert -ResourceGroupName azps_test_group_app

Update-AzContainerAppManagedEnvCert -InputObject $managedenvcert -Tag @{"abc"="123"}
.Example
$managedenv = Get-AzContainerAppManagedEnv -Name azps-env -ResourceGroupName azps_test_group_app

Update-AzContainerAppManagedEnvCert -ManagedEnvironmentInputObject $managedenv -Name azps-env-cert -Tag @{"abc"="123"}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICertificate
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

MANAGEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/update-azcontainerappmanagedenvcert
#>
function Update-AzContainerAppManagedEnvCert {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICertificate])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment.
    ${EnvName},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaIdentityManagedEnvironmentExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Alias('CertificateName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Certificate.
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath')]
    [Parameter(ParameterSetName='UpdateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='UpdateViaIdentityManagedEnvironmentExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for MANAGEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ManagedEnvironmentInputObject},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityManagedEnvironmentExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICertificatePatchTags]))]
    [System.Collections.Hashtable]
    # Application-specific metadata in the form of key-value pairs.
    ${Tag},

    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Update operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Update operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.App.private\Update-AzContainerAppManagedEnvCert_UpdateExpanded';
            UpdateViaIdentityExpanded = 'Az.App.private\Update-AzContainerAppManagedEnvCert_UpdateViaIdentityExpanded';
            UpdateViaIdentityManagedEnvironmentExpanded = 'Az.App.private\Update-AzContainerAppManagedEnvCert_UpdateViaIdentityManagedEnvironmentExpanded';
            UpdateViaJsonFilePath = 'Az.App.private\Update-AzContainerAppManagedEnvCert_UpdateViaJsonFilePath';
            UpdateViaJsonString = 'Az.App.private\Update-AzContainerAppManagedEnvCert_UpdateViaJsonString';
        }
        if (('UpdateExpanded', 'UpdateViaJsonFilePath', 'UpdateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create a Dapr Component in a Managed Environment.
.Description
Create a Dapr Component in a Managed Environment.
.Example
$scope = @("container-app-1","container-app-2")
$secretObject = New-AzContainerAppSecretObject -Name "masterkey" -Value "keyvalue"
$daprMetaData = New-AzContainerAppDaprMetadataObject -Name "masterkey" -Value "masterkey"

Update-AzContainerAppManagedEnvDapr -Name azps-dapr -EnvName azps-env -ResourceGroupName azps_test_group_app -componentType state.azure.cosmosdb -Version v2 -IgnoreError:$false -InitTimeout 60s -Scope $scope -Secret $secretObject -Metadata $daprMetaData
.Example
$scope = @("container-app-1","container-app-2")
$secretObject = New-AzContainerAppSecretObject -Name "masterkey" -Value "keyvalue"
$daprMetaData = New-AzContainerAppDaprMetadataObject -Name "masterkey" -Value "masterkey"
$managedenvdapr = Get-AzContainerAppManagedEnvDapr -Name azps-dapr -EnvName 4azps-env -ResourceGroupName azps_test_group_app

Update-AzContainerAppManagedEnvDapr -InputObject $managedenvdapr -componentType state.azure.cosmosdb -Version v2 -IgnoreError:$false -InitTimeout 60s -Scope $scope -Secret $secretObject -Metadata $daprMetaData
.Example
$scope = @("container-app-1","container-app-2")
$secretObject = New-AzContainerAppSecretObject -Name "masterkey" -Value "keyvalue"
$daprMetaData = New-AzContainerAppDaprMetadataObject -Name "masterkey" -Value "masterkey"
$managedenv = Get-AzContainerAppManagedEnv -Name azps-env -ResourceGroupName azps_test_group_app

Update-AzContainerAppManagedEnvDapr -Name azps-dapr -ManagedEnvironmentInputObject $managedenv -componentType state.azure.cosmosdb -Version v2 -IgnoreError:$false -InitTimeout 60s -Scope $scope -Secret $secretObject -Metadata $daprMetaData

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprComponent
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

MANAGEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

METADATA <IDaprMetadata[]>: Component metadata
  [Name <String>]: Metadata property name.
  [SecretRef <String>]: Name of the Dapr Component secret from which to pull the metadata property value.
  [Value <String>]: Metadata property value.

SECRET <ISecret[]>: Collection of secrets used by a Dapr component
  [Identity <String>]: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
  [KeyVaultUrl <String>]: Azure Key Vault URL pointing to the secret referenced by the container app.
  [Name <String>]: Secret Name.
  [Value <String>]: Secret Value.
.Link
https://learn.microsoft.com/powershell/module/az.app/update-azcontainerappmanagedenvdapr
#>
function Update-AzContainerAppManagedEnvDapr {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprComponent])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Managed Environment.
    ${EnvName},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaIdentityManagedEnvironmentExpanded', Mandatory)]
    [Alias('DaprName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Dapr Component.
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='UpdateViaIdentityManagedEnvironmentExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for MANAGEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ManagedEnvironmentInputObject},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Component type
    ${ComponentType},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean describing if the component errors are ignores
    ${IgnoreError},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Initialization timeout
    ${InitTimeout},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IDaprMetadata[]]
    # Component metadata
    # To construct, see NOTES section for METADATA properties and create a hash table.
    ${Metadata},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # Names of container apps that can use this Dapr component
    ${Scope},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISecret[]]
    # Collection of secrets used by a Dapr component
    # To construct, see NOTES section for SECRET properties and create a hash table.
    ${Secret},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Name of a Dapr component to retrieve component secrets from
    ${SecretStoreComponent},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Component version
    ${Version},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.App.private\Update-AzContainerAppManagedEnvDapr_UpdateExpanded';
            UpdateViaIdentityExpanded = 'Az.App.private\Update-AzContainerAppManagedEnvDapr_UpdateViaIdentityExpanded';
            UpdateViaIdentityManagedEnvironmentExpanded = 'Az.App.private\Update-AzContainerAppManagedEnvDapr_UpdateViaIdentityManagedEnvironmentExpanded';
        }
        if (('UpdateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create storage for a managedEnvironment.
.Description
Create storage for a managedEnvironment.
.Example
$storageAccountKey = (Get-AzStorageAccountKey -ResourceGroupName azps_test_group_app -AccountName azpstestsa).Value[0]

Update-AzContainerAppManagedEnvStorage -EnvName azps-env -ResourceGroupName azps_test_group_app -Name azpstestsa -AzureFileAccessMode 'ReadWrite' -AzureFileAccountKey $storageAccountKey -AzureFileAccountName azpstestsa -AzureFileShareName azps-rw-sharename
.Example
$storageAccountKey = (Get-AzStorageAccountKey -ResourceGroupName azps_test_group_app -AccountName azpstestsa).Value[0]
$managedenvstorage = Get-AzContainerAppManagedEnvStorage -EnvName azps-env -ResourceGroupName azps_test_group_app -Name azpstestsa

Update-AzContainerAppManagedEnvStorage -InputObject $managedenvstorage -AzureFileAccessMode 'ReadWrite' -AzureFileAccountKey $storageAccountKey -AzureFileAccountName azpstestsa -AzureFileShareName azps-rw-sharename
.Example
$storageAccountKey = (Get-AzStorageAccountKey -ResourceGroupName azps_test_group_app -AccountName azpstestsa).Value[0]
$managedenv = Get-AzContainerAppManagedEnv -Name azps-env -ResourceGroupName azps_test_group_app

Update-AzContainerAppManagedEnvStorage -ManagedEnvironmentInputObject $managedenv -Name azpstestsa -AzureFileAccessMode 'ReadWrite' -AzureFileAccountKey $storageAccountKey -AzureFileAccountName azpstestsa -AzureFileShareName azps-rw-sharename

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedEnvironmentStorage
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

MANAGEDENVIRONMENTINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/update-azcontainerappmanagedenvstorage
#>
function Update-AzContainerAppManagedEnvStorage {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedEnvironmentStorage])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Environment.
    ${EnvName},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaIdentityManagedEnvironmentExpanded', Mandatory)]
    [Alias('StorageName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the storage.
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='UpdateViaIdentityManagedEnvironmentExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for MANAGEDENVIRONMENTINPUTOBJECT properties and create a hash table.
    ${ManagedEnvironmentInputObject},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("ReadOnly", "ReadWrite")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Access mode for storage
    ${AzureFileAccessMode},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Storage account key for azure file.
    ${AzureFileAccountKey},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Storage account name for azure file.
    ${AzureFileAccountName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Azure file share name.
    ${AzureFileShareName},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.App.private\Update-AzContainerAppManagedEnvStorage_UpdateExpanded';
            UpdateViaIdentityExpanded = 'Az.App.private\Update-AzContainerAppManagedEnvStorage_UpdateViaIdentityExpanded';
            UpdateViaIdentityManagedEnvironmentExpanded = 'Az.App.private\Update-AzContainerAppManagedEnvStorage_UpdateViaIdentityManagedEnvironmentExpanded';
        }
        if (('UpdateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Patches a Managed Environment using JSON Merge Patch
.Description
Patches a Managed Environment using JSON Merge Patch
.Example
Update-AzContainerAppManagedEnv -Name azps-env -ResourceGroupName azps_test_group_app -Tag @{"abc"="123"}
.Example
$managedenv = Get-AzContainerAppManagedEnv -Name azps-env -ResourceGroupName azps_test_group_app

Update-AzContainerAppManagedEnv -InputObject $managedenv -Tag @{"abc"="123"}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedEnvironment
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

WORKLOADPROFILE <IWorkloadProfile[]>: Workload profiles configured for the Managed Environment.
  Name <String>: Workload profile type for the workloads to run on.
  Type <String>: Workload profile type for the workloads to run on.
  [MaximumCount <Int32?>]: The maximum capacity.
  [MinimumCount <Int32?>]: The minimum capacity.
.Link
https://learn.microsoft.com/powershell/module/az.app/update-azcontainerappmanagedenv
#>
function Update-AzContainerAppManagedEnv {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IManagedEnvironment])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Alias('EnvName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Environment.
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath')]
    [Parameter(ParameterSetName='UpdateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Logs destination, can be 'log-analytics', 'azure-monitor' or 'none'
    ${AppLogConfigurationDestination},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Input File for CustomDomainConfigurationCertificateValue (PFX or PEM blob)
    ${CustomDomainConfigurationCertificateValueInputFile},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Application Insights connection string used by Dapr to export Service to Service communication telemetry
    ${DaprAiConnectionString},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Azure Monitor instrumentation key used by Dapr to export Service to Service communication telemetry
    ${DaprAiInstrumentationKey},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Kind of the Environment.
    ${Kind},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Log analytics customer id
    ${LogAnalyticConfigurationCustomerId},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Log analytics customer key
    ${LogAnalyticConfigurationSharedKey},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Boolean indicating whether the mutual TLS authentication is enabled
    ${MtlEnabled},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ITrackedResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IWorkloadProfile[]]
    # Workload profiles configured for the Managed Environment.
    # To construct, see NOTES section for WORKLOADPROFILE properties and create a hash table.
    ${WorkloadProfile},

    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Update operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Update operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.App.private\Update-AzContainerAppManagedEnv_UpdateExpanded';
            UpdateViaIdentityExpanded = 'Az.App.private\Update-AzContainerAppManagedEnv_UpdateViaIdentityExpanded';
            UpdateViaJsonFilePath = 'Az.App.private\Update-AzContainerAppManagedEnv_UpdateViaJsonFilePath';
            UpdateViaJsonString = 'Az.App.private\Update-AzContainerAppManagedEnv_UpdateViaJsonString';
        }
        if (('UpdateExpanded', 'UpdateViaJsonFilePath', 'UpdateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create the SourceControl for a Container App.
.Description
Create the SourceControl for a Container App.
.Example
$AzureClientSecret = ConvertTo-SecureString -String "1234" -Force -AsPlainText
$RegistryPassword = ConvertTo-SecureString -String "1234" -Force -AsPlainText
$GithubAccessToken = ConvertTo-SecureString -String "1234" -Force -AsPlainText

Update-AzContainerAppSourceControl -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app -Name current -AzureClientId "UserObjectId" -AzureClientSecret $AzureClientSecret -AzureKind "feaderated" -AzureTenantId "UserDirectoryID" -Branch "main" -GithubContextPath "./" -GithubAccessToken $GithubAccessToken -GithubConfigurationImage "azps-containerapp-1" -RegistryPassword $RegistryPassword -RegistryUrl "azpscontainerregistry.azurecr.io" -RegistryUserName "azpscontainerregistry" -RepoUrl "https://github.com/lijinpei2008/ghatest"
.Example
$AzureClientSecret = ConvertTo-SecureString -String "1234" -Force -AsPlainText
$RegistryPassword = ConvertTo-SecureString -String "1234" -Force -AsPlainText
$GithubAccessToken = ConvertTo-SecureString -String "1234" -Force -AsPlainText
$sourcecontrol = Get-AzContainerAppSourceControl -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app -Name current

Update-AzContainerAppSourceControl -InputObject $sourcecontrol -AzureClientId "UserObjectId" -AzureClientSecret $AzureClientSecret -AzureKind "feaderated" -AzureTenantId "UserDirectoryID" -Branch "main" -GithubContextPath "./" -GithubAccessToken $GithubAccessToken -GithubConfigurationImage "azps-containerapp-1" -RegistryPassword $RegistryPassword -RegistryUrl "azpscontainerregistry.azurecr.io" -RegistryUserName "azpscontainerregistry" -RepoUrl "https://github.com/lijinpei2008/ghatest"
.Example
$AzureClientSecret = ConvertTo-SecureString -String "1234" -Force -AsPlainText
$RegistryPassword = ConvertTo-SecureString -String "1234" -Force -AsPlainText
$GithubAccessToken = ConvertTo-SecureString -String "1234" -Force -AsPlainText
$containerapp = Get-AzContainerApp -ResourceGroupName azps_test_group_app -Name azps-containerapp-1

Update-AzContainerAppSourceControl -ContainerAppInputObject $containerapp -Name current -AzureClientId "UserObjectId" -AzureClientSecret $AzureClientSecret -AzureKind "feaderated" -AzureTenantId "UserDirectoryID" -Branch "main" -GithubContextPath "./" -GithubAccessToken $GithubAccessToken -GithubConfigurationImage "azps-containerapp-1" -RegistryPassword $RegistryPassword -RegistryUrl "azpscontainerregistry.azurecr.io" -RegistryUserName "azpscontainerregistry" -RepoUrl "https://github.com/lijinpei2008/ghatest"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISourceControl
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONTAINERAPPINPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.
.Link
https://learn.microsoft.com/powershell/module/az.app/update-azcontainerappsourcecontrol
#>
function Update-AzContainerAppSourceControl {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISourceControl])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${ContainerAppName},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaIdentityContainerAppExpanded', Mandatory)]
    [Alias('SourceControlName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App SourceControl.
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityContainerAppExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for CONTAINERAPPINPUTOBJECT properties and create a hash table.
    ${ContainerAppInputObject},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Client Id.
    ${AzureClientId},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Security.SecureString]
    # Client Secret.
    ${AzureClientSecret},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Kind of auth github does for deploying the template
    ${AzureKind},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Subscription Id.
    ${AzureSubscriptionId},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Tenant Id.
    ${AzureTenantId},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The branch which will trigger the auto deployment
    ${Branch},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Security.SecureString]
    # One time Github PAT to configure github environment
    ${GithubAccessToken},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Image name
    ${GithubConfigurationImage},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Context path
    ${GithubContextPath},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Operation system
    ${GithubOS},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Code or Image
    ${GithubPublishType},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Runtime stack
    ${GithubRuntimeStack},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Runtime version
    ${GithubRuntimeVersion},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Security.SecureString]
    # registry secret.
    ${RegistryPassword},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # registry server Url.
    ${RegistryUrl},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # registry username.
    ${RegistryUserName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The repo url which will be integrated to ContainerApp.
    ${RepoUrl},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.App.private\Update-AzContainerAppSourceControl_UpdateExpanded';
            UpdateViaIdentityContainerAppExpanded = 'Az.App.private\Update-AzContainerAppSourceControl_UpdateViaIdentityContainerAppExpanded';
            UpdateViaIdentityExpanded = 'Az.App.private\Update-AzContainerAppSourceControl_UpdateViaIdentityExpanded';
        }
        if (('UpdateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Patches a Container App using JSON Merge Patch
.Description
Patches a Container App using JSON Merge Patch
.Example
$newSecretObject = New-AzContainerAppSecretObject -Name "yourkey" -Value "yourvalue"
$configuration = New-AzContainerAppConfigurationObject -DaprEnabled:$True -DaprAppPort 3000 -DaprAppProtocol "http" -DaprHttpReadBufferSize 30 -DaprHttpMaxRequestSize 10 -DaprLogLevel "debug" -DaprEnableApiLogging:$True -MaxInactiveRevision 10 -ServiceType "redis" -Secret $newSecretObject 

Update-AzContainerApp -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app -Configuration $configuration -Tag @{"123"="abc"}
.Example
$secretObject = Get-AzContainerAppSecret -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app
$newSecretObject1 = New-AzContainerAppSecretObject -Name "yourkey" -Value "yourvalue"
$newSecretObject2 = New-AzContainerAppSecretObject -Name $secretObject.Name -Value $secretObject.Value -Identity $secretObject.Identity -KeyVaultUrl $secretObject.KeyVaultUrl
$configuration = New-AzContainerAppConfigurationObject -DaprEnabled:$True -DaprAppPort 3000 -DaprAppProtocol "http" -DaprHttpReadBufferSize 30 -DaprHttpMaxRequestSize 10 -DaprLogLevel "debug" -DaprEnableApiLogging:$True -MaxInactiveRevision 10 -ServiceType "redis" -Secret $newSecretObject1,$newSecretObject2

Update-AzContainerApp -ContainerAppName azps-containerapp-1 -ResourceGroupName azps_test_group_app -Configuration $configuration -Tag @{"123"="abc"}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainerApp
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CONFIGURATION <IConfiguration>: Non versioned Container App configuration properties.
  [ActiveRevisionsMode <String>]: ActiveRevisionsMode controls how active revisions are handled for the Container app:         <list><item>Multiple: multiple revisions can be active.</item><item>Single: Only one revision can be active at a time. Revision weights can not be used in this mode. If no value if provided, this is the default.</item></list>
  [CorPolicyAllowCredentials <Boolean?>]: Specifies whether the resource allows credentials
  [CorPolicyAllowedHeader <List<String>>]: Specifies the content for the access-control-allow-headers header
  [CorPolicyAllowedMethod <List<String>>]: Specifies the content for the access-control-allow-methods header
  [CorPolicyAllowedOrigin <List<String>>]: Specifies the content for the access-control-allow-origins header
  [CorPolicyExposeHeader <List<String>>]: Specifies the content for the access-control-expose-headers header 
  [CorPolicyMaxAge <Int32?>]: Specifies the content for the access-control-max-age header
  [DaprAppId <String>]: Dapr application identifier
  [DaprAppPort <Int32?>]: Tells Dapr which port your application is listening on
  [DaprAppProtocol <String>]: Tells Dapr which protocol your application is using. Valid options are http and grpc. Default is http
  [DaprEnableApiLogging <Boolean?>]: Enables API logging for the Dapr sidecar
  [DaprEnabled <Boolean?>]: Boolean indicating if the Dapr side car is enabled
  [DaprHttpMaxRequestSize <Int32?>]: Increasing max size of request body http and grpc servers parameter in MB to handle uploading of big files. Default is 4 MB.
  [DaprHttpReadBufferSize <Int32?>]: Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
  [DaprLogLevel <String>]: Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
  [IngressAllowInsecure <Boolean?>]: Bool indicating if HTTP connections to is allowed. If set to false HTTP connections are automatically redirected to HTTPS connections
  [IngressClientCertificateMode <String>]: Client certificate mode for mTLS authentication. Ignore indicates server drops client certificate on forwarding. Accept indicates server forwards client certificate but does not require a client certificate. Require indicates server requires a client certificate.
  [IngressCustomDomain <List<ICustomDomain>>]: custom domain bindings for Container Apps' hostnames.
    Name <String>: Hostname.
    [BindingType <String>]: Custom Domain binding type.
    [CertificateId <String>]: Resource Id of the Certificate to be bound to this hostname. Must exist in the Managed Environment.
  [IngressExposedPort <Int32?>]: Exposed Port in containers for TCP traffic from ingress
  [IngressExternal <Boolean?>]: Bool indicating if app exposes an external http endpoint
  [IngressIPSecurityRestriction <List<IIPSecurityRestrictionRule>>]: Rules to restrict incoming IP address.
    Action <String>: Allow or Deny rules to determine for incoming IP. Note: Rules can only consist of ALL Allow or ALL Deny
    IPAddressRange <String>: CIDR notation to match incoming IP address
    Name <String>: Name for the IP restriction rule.
    [Description <String>]: Describe the IP restriction rule that is being sent to the container-app. This is an optional field.
  [IngressTargetPort <Int32?>]: Target Port in containers for traffic from ingress
  [IngressTraffic <List<ITrafficWeight>>]: Traffic weights for app's revisions
    [Label <String>]: Associates a traffic label with a revision
    [LatestRevision <Boolean?>]: Indicates that the traffic weight belongs to a latest stable revision
    [RevisionName <String>]: Name of a revision
    [Weight <Int32?>]: Traffic weight assigned to a revision
  [IngressTransport <String>]: Ingress transport protocol
  [MaxInactiveRevision <Int32?>]: Optional. Max inactive revisions a Container App can have.
  [Registry <List<IRegistryCredentials>>]: Collection of private container registry credentials for containers used by the Container app
    [Identity <String>]: A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
    [PasswordSecretRef <String>]: The name of the Secret that contains the registry login password
    [Server <String>]: Container Registry Server
    [Username <String>]: Container Registry Username
  [Secret <List<ISecret>>]: Collection of secrets used by a Container app
    [Identity <String>]: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
    [KeyVaultUrl <String>]: Azure Key Vault URL pointing to the secret referenced by the container app.
    [Name <String>]: Secret Name.
    [Value <String>]: Secret Value.
  [ServiceType <String>]: Dev ContainerApp service type
  [StickySessionAffinity <String>]: Sticky Session Affinity

INPUTOBJECT <IAppIdentity>: Identity Parameter
  [AuthConfigName <String>]: Name of the Container App AuthConfig.
  [CertificateName <String>]: Name of the Certificate.
  [ComponentName <String>]: Name of the Dapr Component.
  [ConnectedEnvironmentName <String>]: Name of the connectedEnvironment.
  [ContainerAppName <String>]: Name of the Container App.
  [DetectorName <String>]: Name of the Container App Detector.
  [EnvironmentName <String>]: Name of the Environment.
  [Id <String>]: Resource identity path
  [JobExecutionName <String>]: Job execution name.
  [JobName <String>]: Job Name
  [Location <String>]: The name of Azure region.
  [ManagedCertificateName <String>]: Name of the Managed Certificate.
  [ReplicaName <String>]: Name of the Container App Revision Replica.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [RevisionName <String>]: Name of the Container App Revision.
  [SourceControlName <String>]: Name of the Container App SourceControl.
  [StorageName <String>]: Name of the storage.
  [SubscriptionId <String>]: The ID of the target subscription.

SCALERULE <IScaleRule[]>: Scaling rules.
  [AzureQueueAuth <List<IScaleRuleAuth>>]: Authentication secrets for the queue scale rule.
    [SecretRef <String>]: Name of the secret from which to pull the auth params.
    [TriggerParameter <String>]: Trigger Parameter that uses the secret
  [AzureQueueLength <Int32?>]: Queue length.
  [AzureQueueName <String>]: Queue name.
  [CustomAuth <List<IScaleRuleAuth>>]: Authentication secrets for the custom scale rule.
  [CustomMetadata <ICustomScaleRuleMetadata>]: Metadata properties to describe custom scale rule.
    [(Any) <String>]: This indicates any property can be added to this object.
  [CustomType <String>]: Type of the custom scale rule         eg: azure-servicebus, redis etc.
  [HttpAuth <List<IScaleRuleAuth>>]: Authentication secrets for the custom scale rule.
  [HttpMetadata <IHttpScaleRuleMetadata>]: Metadata properties to describe http scale rule.
    [(Any) <String>]: This indicates any property can be added to this object.
  [Name <String>]: Scale Rule Name
  [TcpAuth <List<IScaleRuleAuth>>]: Authentication secrets for the tcp scale rule.
  [TcpMetadata <ITcpScaleRuleMetadata>]: Metadata properties to describe tcp scale rule.
    [(Any) <String>]: This indicates any property can be added to this object.

TEMPLATECONTAINER <IContainer[]>: List of container definitions for the Container App.
  [Arg <List<String>>]: Container start command arguments.
  [Command <List<String>>]: Container start command.
  [Env <List<IEnvironmentVar>>]: Container environment variables.
    [Name <String>]: Environment variable name.
    [SecretRef <String>]: Name of the Container App secret from which to pull the environment variable value.
    [Value <String>]: Non-secret environment variable value.
  [Image <String>]: Container image tag.
  [Name <String>]: Custom container name.
  [ResourceCpu <Double?>]: Required CPU in cores, e.g. 0.5
  [ResourceMemory <String>]: Required memory, e.g. "250Mb"
  [VolumeMount <List<IVolumeMount>>]: Container volume mounts.
    [MountPath <String>]: Path within the container at which the volume should be mounted.Must not contain ':'.
    [SubPath <String>]: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
    [VolumeName <String>]: This must match the Name of a Volume.
  [Probe <List<IContainerAppProbe>>]: List of probes for the container.
    [FailureThreshold <Int32?>]: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
    [HttpGetHost <String>]: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
    [HttpGetHttpHeader <List<IContainerAppProbeHttpGetHttpHeadersItem>>]: Custom headers to set in the request. HTTP allows repeated headers.
      Name <String>: The header field name
      Value <String>: The header field value
    [HttpGetPath <String>]: Path to access on the HTTP server.
    [HttpGetPort <Int32?>]: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
    [HttpGetScheme <String>]: Scheme to use for connecting to the host. Defaults to HTTP.
    [InitialDelaySecond <Int32?>]: Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
    [PeriodSecond <Int32?>]: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
    [SuccessThreshold <Int32?>]: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
    [TcpSocketHost <String>]: Optional: Host name to connect to, defaults to the pod IP.
    [TcpSocketPort <Int32?>]: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
    [TerminationGracePeriodSecond <Int64?>]: Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
    [TimeoutSecond <Int32?>]: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
    [Type <String>]: The type of probe.

TEMPLATEINITCONTAINER <IInitContainer[]>: List of specialized containers that run before app containers.
  [Arg <List<String>>]: Container start command arguments.
  [Command <List<String>>]: Container start command.
  [Env <List<IEnvironmentVar>>]: Container environment variables.
    [Name <String>]: Environment variable name.
    [SecretRef <String>]: Name of the Container App secret from which to pull the environment variable value.
    [Value <String>]: Non-secret environment variable value.
  [Image <String>]: Container image tag.
  [Name <String>]: Custom container name.
  [ResourceCpu <Double?>]: Required CPU in cores, e.g. 0.5
  [ResourceMemory <String>]: Required memory, e.g. "250Mb"
  [VolumeMount <List<IVolumeMount>>]: Container volume mounts.
    [MountPath <String>]: Path within the container at which the volume should be mounted.Must not contain ':'.
    [SubPath <String>]: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
    [VolumeName <String>]: This must match the Name of a Volume.

TEMPLATESERVICEBIND <IServiceBind[]>: List of container app services bound to the app
  [Name <String>]: Name of the service bind
  [ServiceId <String>]: Resource id of the target service

TEMPLATEVOLUME <IVolume[]>: List of volume definitions for the Container App.
  [MountOption <String>]: Mount options used while mounting the AzureFile. Must be a comma-separated string.
  [Name <String>]: Volume name.
  [Secret <List<ISecretVolumeItem>>]: List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to volume.
    [Path <String>]: Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
    [SecretRef <String>]: Name of the Container App secret from which to pull the secret value.
  [StorageName <String>]: Name of storage resource. No need to provide for EmptyDir and Secret.
  [StorageType <String>]: Storage type for the volume. If not provided, use EmptyDir.
.Link
https://learn.microsoft.com/powershell/module/az.app/update-azcontainerapp
#>
function Update-AzContainerApp {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainerApp])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Alias('ContainerAppName')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # Name of the Container App.
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath')]
    [Parameter(ParameterSetName='UpdateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAppIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IConfiguration]
    # Non versioned Container App configuration properties.
    # To construct, see NOTES section for CONFIGURATION properties and create a hash table.
    ${Configuration},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The name of the extended location.
    ${ExtendedLocationName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("CustomLocation")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The type of the extended location.
    ${ExtendedLocationType},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("None", "SystemAssigned", "UserAssigned", "SystemAssigned,UserAssigned")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
    ${IdentityType},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IUserAssignedIdentities]))]
    [System.Collections.Hashtable]
    # The set of user assigned identities associated with the resource.
    # The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
    # The dictionary values can be empty objects ({}) in requests.
    ${IdentityUserAssignedIdentity},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The fully qualified resource ID of the resource that manages this resource.
    # Indicates if this resource is managed by another Azure resource.
    # If this is present, complete mode deployment will not delete the resource if it is removed from the template since it is managed by another resource.
    ${ManagedBy},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Optional.
    # Maximum number of container replicas.
    # Defaults to 10 if not set.
    ${ScaleMaxReplica},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Optional.
    # Minimum number of container replicas.
    ${ScaleMinReplica},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IScaleRule[]]
    # Scaling rules.
    # To construct, see NOTES section for SCALERULE properties and create a hash table.
    ${ScaleRule},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ITrackedResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainer[]]
    # List of container definitions for the Container App.
    # To construct, see NOTES section for TEMPLATECONTAINER properties and create a hash table.
    ${TemplateContainer},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IInitContainer[]]
    # List of specialized containers that run before app containers.
    # To construct, see NOTES section for TEMPLATEINITCONTAINER properties and create a hash table.
    ${TemplateInitContainer},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # User friendly suffix that is appended to the revision name
    ${TemplateRevisionSuffix},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IServiceBind[]]
    # List of container app services bound to the app
    # To construct, see NOTES section for TEMPLATESERVICEBIND properties and create a hash table.
    ${TemplateServiceBind},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int64]
    # Optional duration in seconds the Container App Instance needs to terminate gracefully.
    # Value must be non-negative integer.
    # The value zero indicates stop immediately via the kill signal (no opportunity to shut down).
    # If this value is nil, the default grace period will be used instead.
    # Set this value longer than the expected cleanup time for your process.
    # Defaults to 30 seconds.
    ${TemplateTerminationGracePeriodSecond},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IVolume[]]
    # List of volume definitions for the Container App.
    # To construct, see NOTES section for TEMPLATEVOLUME properties and create a hash table.
    ${TemplateVolume},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Workload profile name to pin for container app execution.
    ${WorkloadProfileName},

    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Update operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Json string supplied to the Update operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.App.private\Update-AzContainerApp_UpdateExpanded';
            UpdateViaIdentityExpanded = 'Az.App.private\Update-AzContainerApp_UpdateViaIdentityExpanded';
            UpdateViaJsonFilePath = 'Az.App.private\Update-AzContainerApp_UpdateViaJsonFilePath';
            UpdateViaJsonString = 'Az.App.private\Update-AzContainerApp_UpdateViaJsonString';
        }
        if (('UpdateExpanded', 'UpdateViaJsonFilePath', 'UpdateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for Configuration.
.Description
Create an in-memory object for Configuration.
.Example
$customDomain = New-AzContainerAppCustomDomainObject -Name "www.my-name.com" -BindingType "SniEnabled" -CertificateId "/subscriptions/{subId}/resourceGroups/azps_test_group_app/providers/Microsoft.App/managedEnvironments/{manageEnvName}/certificates/{testcert}"
$trafficWeight = New-AzContainerAppTrafficWeightObject -Label "production" -RevisionName "testcontainerApp0-ab1234" -Weight 100
$iPSecurityRestrictionRule = New-AzContainerAppIPSecurityRestrictionRuleObject -Action "Allow" -IPAddressRange "192.168.1.1/32" -Name "Allow work IP A subnet"

New-AzContainerAppConfigurationObject -IngressCustomDomain $customDomain -IngressIPSecurityRestriction $iPSecurityRestrictionRule -IngressTraffic $trafficWeight -IngressExternal:$True -IngressTargetPort 3000 -IngressClientCertificateMode "accept" -CorPolicyAllowedOrigin "https://a.test.com","https://b.test.com" -CorPolicyAllowedMethod "GET","POST" -CorPolicyAllowedHeader "HEADER1","HEADER2" -CorPolicyExposeHeader "HEADER3","HEADER4" -CorPolicyMaxAge 1234 -CorPolicyAllowCredentials:$True -DaprEnabled:$True -DaprAppPort 3000 -DaprAppProtocol "http" -DaprHttpReadBufferSize 30 -DaprHttpMaxRequestSize 10 -DaprLogLevel "debug" -DaprEnableApiLogging:$True -MaxInactiveRevision 10 -ServiceType "redis" -IngressTransport "http"

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.Configuration
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INGRESSCUSTOMDOMAIN <ICustomDomain[]>: custom domain bindings for Container Apps' hostnames.
  Name <String>: Hostname.
  [BindingType <String>]: Custom Domain binding type.
  [CertificateId <String>]: Resource Id of the Certificate to be bound to this hostname. Must exist in the Managed Environment.

INGRESSIPSECURITYRESTRICTION <IIPSecurityRestrictionRule[]>: Rules to restrict incoming IP address.
  Action <String>: Allow or Deny rules to determine for incoming IP. Note: Rules can only consist of ALL Allow or ALL Deny
  IPAddressRange <String>: CIDR notation to match incoming IP address
  Name <String>: Name for the IP restriction rule.
  [Description <String>]: Describe the IP restriction rule that is being sent to the container-app. This is an optional field.

INGRESSTRAFFIC <ITrafficWeight[]>: Traffic weights for app's revisions.
  [Label <String>]: Associates a traffic label with a revision
  [LatestRevision <Boolean?>]: Indicates that the traffic weight belongs to a latest stable revision
  [RevisionName <String>]: Name of a revision
  [Weight <Int32?>]: Traffic weight assigned to a revision

REGISTRY <IRegistryCredentials[]>: Collection of private container registry credentials for containers used by the Container app.
  [Identity <String>]: A Managed Identity to use to authenticate with Azure Container Registry. For user-assigned identities, use the full user-assigned identity Resource ID. For system-assigned identities, use 'system'
  [PasswordSecretRef <String>]: The name of the Secret that contains the registry login password
  [Server <String>]: Container Registry Server
  [Username <String>]: Container Registry Username

SECRET <ISecret[]>: Collection of secrets used by a Container app.
  [Identity <String>]: Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
  [KeyVaultUrl <String>]: Azure Key Vault URL pointing to the secret referenced by the container app.
  [Name <String>]: Secret Name.
  [Value <String>]: Secret Value.
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappconfigurationobject
#>
function New-AzContainerAppConfigurationObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.Configuration])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("Multiple", "Single")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # ActiveRevisionsMode controls how active revisions are handled for the Container app:
    #         <list><item>Multiple: multiple revisions can be active.</item><item>Single: Only one revision can be active at a time.
    # Revision weights can not be used in this mode.
    # If no value if provided, this is the default.</item></list>.
    ${ActiveRevisionsMode},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Boolean]
    # Specifies whether the resource allows credentials.
    ${CorPolicyAllowCredentials},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # Specifies the content for the access-control-allow-headers header.
    ${CorPolicyAllowedHeader},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # Specifies the content for the access-control-allow-methods header.
    ${CorPolicyAllowedMethod},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # Specifies the content for the access-control-allow-origins header.
    ${CorPolicyAllowedOrigin},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # Specifies the content for the access-control-expose-headers header .
    ${CorPolicyExposeHeader},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Specifies the content for the access-control-max-age header.
    ${CorPolicyMaxAge},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Dapr application identifier.
    ${DaprAppId},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Tells Dapr which port your application is listening on.
    ${DaprAppPort},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("http", "grpc")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Tells Dapr which protocol your application is using.
    # Valid options are http and grpc.
    # Default is http.
    ${DaprAppProtocol},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Boolean]
    # Enables API logging for the Dapr sidecar.
    ${DaprEnableApiLogging},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Boolean]
    # Boolean indicating if the Dapr side car is enabled.
    ${DaprEnabled},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Increasing max size of request body http and grpc servers parameter in MB to handle uploading of big files.
    # Default is 4 MB.
    ${DaprHttpMaxRequestSize},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Dapr max size of http header read buffer in KB to handle when sending multi-KB headers.
    # Default is 65KB.
    ${DaprHttpReadBufferSize},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("info", "debug", "warn", "error")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Sets the log level for the Dapr sidecar.
    # Allowed values are debug, info, warn, error.
    # Default is info.
    ${DaprLogLevel},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Boolean]
    # Bool indicating if HTTP connections to is allowed.
    # If set to false HTTP connections are automatically redirected to HTTPS connections.
    ${IngressAllowInsecure},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("ignore", "accept", "require")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Client certificate mode for mTLS authentication.
    # Ignore indicates server drops client certificate on forwarding.
    # Accept indicates server forwards client certificate but does not require a client certificate.
    # Require indicates server requires a client certificate.
    ${IngressClientCertificateMode},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICustomDomain[]]
    # custom domain bindings for Container Apps' hostnames.
    # To construct, see NOTES section for INGRESSCUSTOMDOMAIN properties and create a hash table.
    ${IngressCustomDomain},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Exposed Port in containers for TCP traffic from ingress.
    ${IngressExposedPort},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Boolean]
    # Bool indicating if app exposes an external http endpoint.
    ${IngressExternal},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IIPSecurityRestrictionRule[]]
    # Rules to restrict incoming IP address.
    # To construct, see NOTES section for INGRESSIPSECURITYRESTRICTION properties and create a hash table.
    ${IngressIPSecurityRestriction},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Target Port in containers for traffic from ingress.
    ${IngressTargetPort},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.ITrafficWeight[]]
    # Traffic weights for app's revisions.
    # To construct, see NOTES section for INGRESSTRAFFIC properties and create a hash table.
    ${IngressTraffic},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("auto", "http", "http2", "tcp")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Ingress transport protocol.
    ${IngressTransport},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Optional.
    # Max inactive revisions a Container App can have.
    ${MaxInactiveRevision},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IRegistryCredentials[]]
    # Collection of private container registry credentials for containers used by the Container app.
    # To construct, see NOTES section for REGISTRY properties and create a hash table.
    ${Registry},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISecret[]]
    # Collection of secrets used by a Container app.
    # To construct, see NOTES section for SECRET properties and create a hash table.
    ${Secret},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Dev ContainerApp service type.
    ${ServiceType},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("sticky", "none")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Sticky Session Affinity.
    ${StickySessionAffinity}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppConfigurationObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for CustomDomain.
.Description
Create an in-memory object for CustomDomain.
.Example
$certificateId = (Get-AzContainerAppManagedEnvCert -EnvName azps-env -ResourceGroupName azps_test_group_app -Name azps-env-cert).Id

New-AzContainerAppCustomDomainObject -Name "www.my-name.com" -BindingType "SniEnabled" -CertificateId $certificateId

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.CustomDomain
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappcustomdomainobject
#>
function New-AzContainerAppCustomDomainObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.CustomDomain])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Hostname.
    ${Name},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("Disabled", "SniEnabled")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Custom Domain binding type.
    ${BindingType},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Resource Id of the Certificate to be bound to this hostname.
    # Must exist in the Managed Environment.
    ${CertificateId}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppCustomDomainObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for DaprMetadata.
.Description
Create an in-memory object for DaprMetadata.
.Example
New-AzContainerAppDaprMetadataObject -Name "masterkey" -Value "masterkey"

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.DaprMetadata
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappdaprmetadataobject
#>
function New-AzContainerAppDaprMetadataObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.DaprMetadata])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Metadata property name.
    ${Name},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Name of the Dapr Component secret from which to pull the metadata property value.
    ${SecretRef},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Metadata property value.
    ${Value}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppDaprMetadataObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for EnvironmentVar.
.Description
Create an in-memory object for EnvironmentVar.
.Example
New-AzContainerAppEnvironmentVarObject -Name "envVarName" -SecretRef "redis-secret" -Value "value"

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.EnvironmentVar
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappenvironmentvarobject
#>
function New-AzContainerAppEnvironmentVarObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.EnvironmentVar])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Environment variable name.
    ${Name},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Name of the Container App secret from which to pull the environment variable value.
    ${SecretRef},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Non-secret environment variable value.
    ${Value}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppEnvironmentVarObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for IdentityProviders.
.Description
Create an in-memory object for IdentityProviders.
.Example
New-AzContainerAppIdentityProviderObject -RegistrationAppId xxxxxx@xxx.com -RegistrationAppSecretSettingName redis-secret

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IdentityProviders
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CUSTOMOPENIDCONNECTPROVIDER <IIdentityProvidersCustomOpenIdConnectProviders>: The map of the name of the alias of each custom Open ID Connect provider to the         configuration settings of the custom Open ID Connect provider.
  [(Any) <ICustomOpenIdConnectProvider>]: This indicates any property can be added to this object.
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappidentityproviderobject
#>
function New-AzContainerAppIdentityProviderObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IdentityProviders])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # The list of the allowed groups.
    ${AllowedPrincipalGroup},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # The list of the allowed identities.
    ${AllowedPrincipalIdentity},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Boolean]
    # <code>false</code> if the Apple provider should not be enabled despite the set registration; otherwise, <code>true</code>.
    ${AppleEnabled},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # A list of the scopes that should be requested while authenticating.
    ${AppleLoginScope},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The Client ID of the app used for login.
    ${AppleRegistrationClientId},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The app setting name that contains the client secret.
    ${AppleRegistrationClientSecretSettingName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Boolean]
    # <code>false</code> if the Azure Active Directory provider should not be enabled despite the set registration; otherwise, <code>true</code>.
    ${AzureActiveDirectoryEnabled},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Boolean]
    # Gets a value indicating whether the Azure AD configuration was auto-provisioned using 1st party tooling.
    #         This is an internal flag primarily intended to support the Azure Management Portal.
    # Users should not
    #         read or write to this property.
    ${AzureActiveDirectoryIsAutoProvisioned},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The Client ID of this relying party application, known as the client_id.
    #         This setting is required for enabling OpenID Connection authentication with Azure Active Directory or
    #         other 3rd party OpenID Connect providers.
    #         More information on OpenID Connect: http://openid.net/specs/openid-connect-core-1_0.html.
    ${AzureActiveDirectoryRegistrationClientId},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The app setting name that contains the client secret of the relying party application.
    ${AzureActiveDirectoryRegistrationClientSecretSettingName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # The list of audiences that can make successful authentication/authorization requests.
    ${AzureActiveDirectoryValidationAllowedAudience},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Boolean]
    # <code>false</code> if the Azure Static Web Apps provider should not be enabled despite the set registration; otherwise, <code>true</code>.
    ${AzureStaticWebAppEnabled},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The Client ID of the app used for login.
    ${AzureStaticWebAppsRegistrationClientId},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IIdentityProvidersCustomOpenIdConnectProviders]
    # The map of the name of the alias of each custom Open ID Connect provider to the
    #         configuration settings of the custom Open ID Connect provider.
    # To construct, see NOTES section for CUSTOMOPENIDCONNECTPROVIDER properties and create a hash table.
    ${CustomOpenIdConnectProvider},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # The configuration settings of the Azure Active Directory allowed applications.
    ${DefaultAuthorizationPolicyAllowedApplication},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Boolean]
    # <code>false</code> if the Facebook provider should not be enabled despite the set registration; otherwise, <code>true</code>.
    ${FacebookEnabled},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The version of the Facebook api to be used while logging in.
    ${FacebookGraphApiVersion},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # A list of the scopes that should be requested while authenticating.
    ${FacebookLoginScope},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Boolean]
    # <code>false</code> if the GitHub provider should not be enabled despite the set registration; otherwise, <code>true</code>.
    ${GitHubEnabled},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # A list of the scopes that should be requested while authenticating.
    ${GitHubLoginScope},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The Client ID of the app used for login.
    ${GitHubRegistrationClientId},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The app setting name that contains the client secret.
    ${GitHubRegistrationClientSecretSettingName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Boolean]
    # <code>false</code> if the Google provider should not be enabled despite the set registration; otherwise, <code>true</code>.
    ${GoogleEnabled},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # A list of the scopes that should be requested while authenticating.
    ${GoogleLoginScope},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The Client ID of the app used for login.
    ${GoogleRegistrationClientId},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The app setting name that contains the client secret.
    ${GoogleRegistrationClientSecretSettingName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # The configuration settings of the allowed list of audiences from which to validate the JWT token.
    ${GoogleValidationAllowedAudience},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # The list of the allowed client applications.
    ${JwtClaimCheckAllowedClientApplication},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # The list of the allowed groups.
    ${JwtClaimCheckAllowedGroup},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Boolean]
    # <code>true</code> if the www-authenticate provider should be omitted from the request; otherwise, <code>false</code>.
    ${LoginDisableWwwAuthenticate},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # Login parameters to send to the OpenID Connect authorization endpoint when
    #         a user logs in.
    # Each parameter must be in the form "key=value".
    ${LoginParameter},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The App ID of the app used for login.
    ${RegistrationAppId},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The app setting name that contains the app secret.
    ${RegistrationAppSecretSettingName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # An alternative to the client secret thumbprint, that is the issuer of a certificate used for signing purposes.
    # This property acts as
    #         a replacement for the Client Secret Certificate Thumbprint.
    # It is also optional.
    ${RegistrationClientSecretCertificateIssuer},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # An alternative to the client secret thumbprint, that is the subject alternative name of a certificate used for signing purposes.
    # This property acts as
    #         a replacement for the Client Secret Certificate Thumbprint.
    # It is also optional.
    ${RegistrationClientSecretCertificateSubjectAlternativeName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # An alternative to the client secret, that is the thumbprint of a certificate used for signing purposes.
    # This property acts as
    #         a replacement for the Client Secret.
    # It is also optional.
    ${RegistrationClientSecretCertificateThumbprint},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The OAuth 1.0a consumer key of the Twitter application used for sign-in.
    #         This setting is required for enabling Twitter Sign-In.
    #         Twitter Sign-In documentation: https://dev.twitter.com/web/sign-in.
    ${RegistrationConsumerKey},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The app setting name that contains the OAuth 1.0a consumer secret of the Twitter
    #         application used for sign-in.
    ${RegistrationConsumerSecretSettingName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The OpenID Connect Issuer URI that represents the entity which issues access tokens for this application.
    #         When using Azure Active Directory, this value is the URI of the directory tenant, e.g.
    # https://login.microsoftonline.com/v2.0/{tenant-guid}/.
    #         This URI is a case-sensitive identifier for the token issuer.
    #         More information on OpenID Connect Discovery: http://openid.net/specs/openid-connect-discovery-1_0.html.
    ${RegistrationOpenIdIssuer},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Boolean]
    # <code>false</code> if the Twitter provider should not be enabled despite the set registration; otherwise, <code>true</code>.
    ${TwitterEnabled}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppIdentityProviderObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for InitContainer.
.Description
Create an in-memory object for InitContainer.
.Example
New-AzContainerAppInitContainerTemplateObject -Image "mcr.microsoft.com/k8se/quickstart:latest" -Name "simple-hello-world-container2" -ResourceCpu 0.25 -ResourceMemory "0.5Gi" -Command "/bin/sh" -Arg "-c","while true; do echo hello; sleep 10;done"

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.InitContainer
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ENV <IEnvironmentVar[]>: Container environment variables.
  [Name <String>]: Environment variable name.
  [SecretRef <String>]: Name of the Container App secret from which to pull the environment variable value.
  [Value <String>]: Non-secret environment variable value.

VOLUMEMOUNT <IVolumeMount[]>: Container volume mounts.
  [MountPath <String>]: Path within the container at which the volume should be mounted.Must not contain ':'.
  [SubPath <String>]: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
  [VolumeName <String>]: This must match the Name of a Volume.
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappinitcontainertemplateobject
#>
function New-AzContainerAppInitContainerTemplateObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.InitContainer])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # Container start command arguments.
    ${Arg},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # Container start command.
    ${Command},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IEnvironmentVar[]]
    # Container environment variables.
    # To construct, see NOTES section for ENV properties and create a hash table.
    ${Env},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Container image tag.
    ${Image},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Custom container name.
    ${Name},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Double]
    # Required CPU in cores, e.g.
    # 0.5.
    ${ResourceCpu},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Required memory, e.g.
    # "250Mb".
    ${ResourceMemory},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IVolumeMount[]]
    # Container volume mounts.
    # To construct, see NOTES section for VOLUMEMOUNT properties and create a hash table.
    ${VolumeMount}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppInitContainerTemplateObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for IPSecurityRestrictionRule.
.Description
Create an in-memory object for IPSecurityRestrictionRule.
.Example
New-AzContainerAppIPSecurityRestrictionRuleObject -Action "Allow" -IPAddressRange "192.168.1.1/32" -Name "Allow work IP A subnet"

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.IPSecurityRestrictionRule
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappipsecurityrestrictionruleobject
#>
function New-AzContainerAppIPSecurityRestrictionRuleObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.IPSecurityRestrictionRule])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("Allow", "Deny")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Allow or Deny rules to determine for incoming IP.
    # Note: Rules can only consist of ALL Allow or ALL Deny.
    ${Action},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # CIDR notation to match incoming IP address.
    ${IPAddressRange},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Name for the IP restriction rule.
    ${Name},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Describe the IP restriction rule that is being sent to the container-app.
    # This is an optional field.
    ${Description}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppIPSecurityRestrictionRuleObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for JobExecutionContainer.
.Description
Create an in-memory object for JobExecutionContainer.
.Example
New-AzContainerAppJobExecutionContainerObject -Image "mcr.microsoft.com/k8se/quickstart-jobs:latest" -Name "simple-hello-world-container2" -ResourceCpu 0.25 -ResourceMemory "0.5Gi" -Command "/bin/sh" -Arg "-c","echo hello; sleep 10;"

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.JobExecutionContainer
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ENV <IEnvironmentVar[]>: Container environment variables.
  [Name <String>]: Environment variable name.
  [SecretRef <String>]: Name of the Container App secret from which to pull the environment variable value.
  [Value <String>]: Non-secret environment variable value.
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappjobexecutioncontainerobject
#>
function New-AzContainerAppJobExecutionContainerObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.JobExecutionContainer])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # Container start command arguments.
    ${Arg},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # Container start command.
    ${Command},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IEnvironmentVar[]]
    # Container environment variables.
    # To construct, see NOTES section for ENV properties and create a hash table.
    ${Env},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Container image tag.
    ${Image},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Custom container name.
    ${Name},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Double]
    # Required CPU in cores, e.g.
    # 0.5.
    ${ResourceCpu},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Required memory, e.g.
    # "250Mb".
    ${ResourceMemory}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppJobExecutionContainerObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for JobScaleRule.
.Description
Create an in-memory object for JobScaleRule.
.Example
$scaleRuleAuth = New-AzContainerAppScaleRuleAuthObject -SecretRef "redis-secret" -TriggerParameter "TriggerParameter"
New-AzContainerAppJobScaleRuleObject -Auth $scaleRuleAuth -Name azps-job-scale -Type azure-servicebus

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.JobScaleRule
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

AUTH <IScaleRuleAuth[]>: Authentication secrets for the scale rule.
  [SecretRef <String>]: Name of the secret from which to pull the auth params.
  [TriggerParameter <String>]: Trigger Parameter that uses the secret
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappjobscaleruleobject
#>
function New-AzContainerAppJobScaleRuleObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.JobScaleRule])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IScaleRuleAuth[]]
    # Authentication secrets for the scale rule.
    # To construct, see NOTES section for AUTH properties and create a hash table.
    ${Auth},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAny]
    # Metadata properties to describe the scale rule.
    ${Metadata},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Scale Rule Name.
    ${Name},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Type of the scale rule
    #         eg: azure-servicebus, redis etc.
    ${Type}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppJobScaleRuleObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for ContainerAppProbeHttpGetHttpHeadersItem.
.Description
Create an in-memory object for ContainerAppProbeHttpGetHttpHeadersItem.
.Example
New-AzContainerAppProbeHeaderObject -Name Custom-Header -Value Awesome

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ContainerAppProbeHttpGetHttpHeadersItem
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappprobeheaderobject
#>
function New-AzContainerAppProbeHeaderObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ContainerAppProbeHttpGetHttpHeadersItem])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The header field name.
    ${Name},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The header field value.
    ${Value}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppProbeHeaderObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for ContainerAppProbe.
.Description
Create an in-memory object for ContainerAppProbe.
.Example
$probeHttpGetHttpHeader = New-AzContainerAppProbeHeaderObject -Name "Custom-Header" -Value "Awesome"

New-AzContainerAppProbeObject -Type "Liveness" -HttpGetPath "/health" -HttpGetPort 8080 -InitialDelaySecond 3 -PeriodSecond 3 -HttpGetHttpHeader $probeHttpGetHttpHeader

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ContainerAppProbe
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

HTTPGETHTTPHEADER <IContainerAppProbeHttpGetHttpHeadersItem[]>: Custom headers to set in the request. HTTP allows repeated headers.
  Name <String>: The header field name
  Value <String>: The header field value
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappprobeobject
#>
function New-AzContainerAppProbeObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ContainerAppProbe])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Minimum consecutive failures for the probe to be considered failed after having succeeded.
    # Defaults to 3.
    # Minimum value is 1.
    # Maximum value is 10.
    ${FailureThreshold},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Host name to connect to, defaults to the pod IP.
    # You probably want to set "Host" in httpHeaders instead.
    ${HttpGetHost},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainerAppProbeHttpGetHttpHeadersItem[]]
    # Custom headers to set in the request.
    # HTTP allows repeated headers.
    # To construct, see NOTES section for HTTPGETHTTPHEADER properties and create a hash table.
    ${HttpGetHttpHeader},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path to access on the HTTP server.
    ${HttpGetPath},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Name or number of the port to access on the container.
    # Number must be in the range 1 to 65535.
    # Name must be an IANA_SVC_NAME.
    ${HttpGetPort},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("HTTP", "HTTPS")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Scheme to use for connecting to the host.
    # Defaults to HTTP.
    ${HttpGetScheme},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Number of seconds after the container has started before liveness probes are initiated.
    # Minimum value is 1.
    # Maximum value is 60.
    ${InitialDelaySecond},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # How often (in seconds) to perform the probe.
    # Default to 10 seconds.
    # Minimum value is 1.
    # Maximum value is 240.
    ${PeriodSecond},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Minimum consecutive successes for the probe to be considered successful after having failed.
    # Defaults to 1.
    # Must be 1 for liveness and startup.
    # Minimum value is 1.
    # Maximum value is 10.
    ${SuccessThreshold},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Optional: Host name to connect to, defaults to the pod IP.
    ${TcpSocketHost},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Number or name of the port to access on the container.
    # Number must be in the range 1 to 65535.
    # Name must be an IANA_SVC_NAME.
    ${TcpSocketPort},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int64]
    # Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
    # The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal.
    # Set this value longer than the expected cleanup time for your process.
    # If this value is nil, the pod's terminationGracePeriodSeconds will be used.
    # Otherwise, this value overrides the value provided by the pod spec.
    # Value must be non-negative integer.
    # The value zero indicates stop immediately via the kill signal (no opportunity to shut down).
    # This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate.
    # Maximum value is 3600 seconds (1 hour).
    ${TerminationGracePeriodSecond},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Number of seconds after which the probe times out.
    # Defaults to 1 second.
    # Minimum value is 1.
    # Maximum value is 240.
    ${TimeoutSecond},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("Liveness", "Readiness", "Startup")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The type of probe.
    ${Type}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppProbeObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for RegistryCredentials.
.Description
Create an in-memory object for RegistryCredentials.
.Example
New-AzContainerAppRegistryCredentialObject -Identity system -PasswordSecretRef "myloginpassword" -Server azps-containerapp-1 -Username azps-container-user

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.RegistryCredentials
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappregistrycredentialobject
#>
function New-AzContainerAppRegistryCredentialObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.RegistryCredentials])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # A Managed Identity to use to authenticate with Azure Container Registry.
    # For user-assigned identities, use the full user-assigned identity Resource ID.
    # For system-assigned identities, use 'system'.
    ${Identity},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # The name of the Secret that contains the registry login password.
    ${PasswordSecretRef},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Container Registry Server.
    ${Server},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Container Registry Username.
    ${Username}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppRegistryCredentialObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for ScaleRuleAuth.
.Description
Create an in-memory object for ScaleRuleAuth.
.Example
New-AzContainerAppScaleRuleAuthObject -SecretRef "redis-secret" -TriggerParameter "TriggerParameter"

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ScaleRuleAuth
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappscaleruleauthobject
#>
function New-AzContainerAppScaleRuleAuthObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ScaleRuleAuth])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Name of the secret from which to pull the auth params.
    ${SecretRef},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Trigger Parameter that uses the secret.
    ${TriggerParameter}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppScaleRuleAuthObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for ScaleRule.
.Description
Create an in-memory object for ScaleRule.
.Example
New-AzContainerAppScaleRuleObject -Name "httpscalingrule" -CustomType "http" -AzureQueueLength 30 -AzureQueueName azps-containerapp

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ScaleRule
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

AZUREQUEUEAUTH <IScaleRuleAuth[]>: Authentication secrets for the queue scale rule.
  [SecretRef <String>]: Name of the secret from which to pull the auth params.
  [TriggerParameter <String>]: Trigger Parameter that uses the secret

CUSTOMAUTH <IScaleRuleAuth[]>: Authentication secrets for the custom scale rule.
  [SecretRef <String>]: Name of the secret from which to pull the auth params.
  [TriggerParameter <String>]: Trigger Parameter that uses the secret

CUSTOMMETADATA <ICustomScaleRuleMetadata>: Metadata properties to describe custom scale rule.
  [(Any) <String>]: This indicates any property can be added to this object.

HTTPAUTH <IScaleRuleAuth[]>: Authentication secrets for the custom scale rule.
  [SecretRef <String>]: Name of the secret from which to pull the auth params.
  [TriggerParameter <String>]: Trigger Parameter that uses the secret

HTTPMETADATA <IHttpScaleRuleMetadata>: Metadata properties to describe http scale rule.
  [(Any) <String>]: This indicates any property can be added to this object.

TCPAUTH <IScaleRuleAuth[]>: Authentication secrets for the tcp scale rule.
  [SecretRef <String>]: Name of the secret from which to pull the auth params.
  [TriggerParameter <String>]: Trigger Parameter that uses the secret

TCPMETADATA <ITcpScaleRuleMetadata>: Metadata properties to describe tcp scale rule.
  [(Any) <String>]: This indicates any property can be added to this object.
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappscaleruleobject
#>
function New-AzContainerAppScaleRuleObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ScaleRule])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IScaleRuleAuth[]]
    # Authentication secrets for the queue scale rule.
    # To construct, see NOTES section for AZUREQUEUEAUTH properties and create a hash table.
    ${AzureQueueAuth},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Queue length.
    ${AzureQueueLength},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Queue name.
    ${AzureQueueName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IScaleRuleAuth[]]
    # Authentication secrets for the custom scale rule.
    # To construct, see NOTES section for CUSTOMAUTH properties and create a hash table.
    ${CustomAuth},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICustomScaleRuleMetadata]
    # Metadata properties to describe custom scale rule.
    # To construct, see NOTES section for CUSTOMMETADATA properties and create a hash table.
    ${CustomMetadata},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Type of the custom scale rule
    #         eg: azure-servicebus, redis etc.
    ${CustomType},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IScaleRuleAuth[]]
    # Authentication secrets for the custom scale rule.
    # To construct, see NOTES section for HTTPAUTH properties and create a hash table.
    ${HttpAuth},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IHttpScaleRuleMetadata]
    # Metadata properties to describe http scale rule.
    # To construct, see NOTES section for HTTPMETADATA properties and create a hash table.
    ${HttpMetadata},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Scale Rule Name.
    ${Name},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IScaleRuleAuth[]]
    # Authentication secrets for the tcp scale rule.
    # To construct, see NOTES section for TCPAUTH properties and create a hash table.
    ${TcpAuth},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.ITcpScaleRuleMetadata]
    # Metadata properties to describe tcp scale rule.
    # To construct, see NOTES section for TCPMETADATA properties and create a hash table.
    ${TcpMetadata}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppScaleRuleObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for Secret.
.Description
Create an in-memory object for Secret.
.Example
New-AzContainerAppSecretObject -Name "redis-secret" -Value "redis-password"

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.Secret
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappsecretobject
#>
function New-AzContainerAppSecretObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.Secret])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Resource ID of a managed identity to authenticate with Azure Key Vault, or System to use a system-assigned identity.
    ${Identity},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Azure Key Vault URL pointing to the secret referenced by the container app.
    ${KeyVaultUrl},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Secret Name.
    ${Name},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Secret Value.
    ${Value}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppSecretObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for SecretVolumeItem.
.Description
Create an in-memory object for SecretVolumeItem.
.Example
New-AzContainerAppSecretVolumeItemObject -Path "secretVolumePath" -SecretRef "redis-secret"

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.SecretVolumeItem
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappsecretvolumeitemobject
#>
function New-AzContainerAppSecretVolumeItemObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.SecretVolumeItem])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path to project secret to.
    # If no path is provided, path defaults to name of secret listed in secretRef.
    ${Path},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Name of the Container App secret from which to pull the secret value.
    ${SecretRef}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppSecretVolumeItemObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for ServiceBind.
.Description
Create an in-memory object for ServiceBind.
.Example
New-AzContainerAppServiceBindObject -Name "redisService" -ServiceId "/subscriptions/{subId}/resourceGroups/azps_test_group_app/providers/Microsoft.App/containerApps/azps-containerapp-1"

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.ServiceBind
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappservicebindobject
#>
function New-AzContainerAppServiceBindObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.ServiceBind])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Name of the service bind.
    ${Name},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Resource id of the target service.
    ${ServiceId}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppServiceBindObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for Container.
.Description
Create an in-memory object for Container.
.Example
$probeHttpGetHttpHeader = New-AzContainerAppProbeHeaderObject -Name "Custom-Header" -Value "Awesome"
$probe = New-AzContainerAppProbeObject -Type "Liveness" -HttpGetPath "/health" -HttpGetPort 8080 -InitialDelaySecond 3 -PeriodSecond 3 -HttpGetHttpHeader $probeHttpGetHttpHeader

New-AzContainerAppTemplateObject -Image "repo/testcontainerApp0:v1" -Name "testcontainerApp0" -Probe $probe

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.Container
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ENV <IEnvironmentVar[]>: Container environment variables.
  [Name <String>]: Environment variable name.
  [SecretRef <String>]: Name of the Container App secret from which to pull the environment variable value.
  [Value <String>]: Non-secret environment variable value.

PROBE <IContainerAppProbe[]>: List of probes for the container.
  [FailureThreshold <Int32?>]: Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1. Maximum value is 10.
  [HttpGetHost <String>]: Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
  [HttpGetHttpHeader <List<IContainerAppProbeHttpGetHttpHeadersItem>>]: Custom headers to set in the request. HTTP allows repeated headers.
    Name <String>: The header field name
    Value <String>: The header field value
  [HttpGetPath <String>]: Path to access on the HTTP server.
  [HttpGetPort <Int32?>]: Name or number of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
  [HttpGetScheme <String>]: Scheme to use for connecting to the host. Defaults to HTTP.
  [InitialDelaySecond <Int32?>]: Number of seconds after the container has started before liveness probes are initiated. Minimum value is 1. Maximum value is 60.
  [PeriodSecond <Int32?>]: How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1. Maximum value is 240.
  [SuccessThreshold <Int32?>]: Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1. Maximum value is 10.
  [TcpSocketHost <String>]: Optional: Host name to connect to, defaults to the pod IP.
  [TcpSocketPort <Int32?>]: Number or name of the port to access on the container. Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
  [TerminationGracePeriodSecond <Int64?>]: Optional duration in seconds the pod needs to terminate gracefully upon probe failure. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this value overrides the value provided by the pod spec. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). This is an alpha field and requires enabling ProbeTerminationGracePeriod feature gate. Maximum value is 3600 seconds (1 hour)
  [TimeoutSecond <Int32?>]: Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. Maximum value is 240.
  [Type <String>]: The type of probe.

VOLUMEMOUNT <IVolumeMount[]>: Container volume mounts.
  [MountPath <String>]: Path within the container at which the volume should be mounted.Must not contain ':'.
  [SubPath <String>]: Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
  [VolumeName <String>]: This must match the Name of a Volume.
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerapptemplateobject
#>
function New-AzContainerAppTemplateObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.Container])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IContainerAppProbe[]]
    # List of probes for the container.
    # To construct, see NOTES section for PROBE properties and create a hash table.
    ${Probe},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # Container start command arguments.
    ${Arg},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String[]]
    # Container start command.
    ${Command},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IEnvironmentVar[]]
    # Container environment variables.
    # To construct, see NOTES section for ENV properties and create a hash table.
    ${Env},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Container image tag.
    ${Image},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Custom container name.
    ${Name},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Double]
    # Required CPU in cores, e.g.
    # 0.5.
    ${ResourceCpu},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Required memory, e.g.
    # "250Mb".
    ${ResourceMemory},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.IVolumeMount[]]
    # Container volume mounts.
    # To construct, see NOTES section for VOLUMEMOUNT properties and create a hash table.
    ${VolumeMount}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppTemplateObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for TrafficWeight.
.Description
Create an in-memory object for TrafficWeight.
.Example
New-AzContainerAppTrafficWeightObject -Label "production" -Weight 100 -LatestRevision:$True

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.TrafficWeight
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerapptrafficweightobject
#>
function New-AzContainerAppTrafficWeightObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.TrafficWeight])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Associates a traffic label with a revision.
    ${Label},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Boolean]
    # Indicates that the traffic weight belongs to a latest stable revision.
    ${LatestRevision},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Name of a revision.
    ${RevisionName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # Traffic weight assigned to a revision.
    ${Weight}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppTrafficWeightObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for VolumeMount.
.Description
Create an in-memory object for VolumeMount.
.Example
New-AzContainerAppVolumeMountObject -MountPath "/mountPath" -VolumeName "VolumeName"

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.VolumeMount
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappvolumemountobject
#>
function New-AzContainerAppVolumeMountObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.VolumeMount])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path within the container at which the volume should be mounted.Must not contain ':'.
    ${MountPath},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Path within the volume from which the container's volume should be mounted.
    # Defaults to "" (volume's root).
    ${SubPath},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # This must match the Name of a Volume.
    ${VolumeName}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppVolumeMountObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for Volume.
.Description
Create an in-memory object for Volume.
.Example
New-AzContainerAppVolumeObject -Name "volumeName" -StorageName "azpssa"

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.Volume
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

SECRET <ISecretVolumeItem[]>: List of secrets to be added in volume. If no secrets are provided, all secrets in collection will be added to volume.
  [Path <String>]: Path to project secret to. If no path is provided, path defaults to name of secret listed in secretRef.
  [SecretRef <String>]: Name of the Container App secret from which to pull the secret value.
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappvolumeobject
#>
function New-AzContainerAppVolumeObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.Volume])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Mount options used while mounting the AzureFile.
    # Must be a comma-separated string.
    ${MountOption},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Volume name.
    ${Name},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISecretVolumeItem[]]
    # List of secrets to be added in volume.
    # If no secrets are provided, all secrets in collection will be added to volume.
    # To construct, see NOTES section for SECRET properties and create a hash table.
    ${Secret},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Name of storage resource.
    # No need to provide for EmptyDir and Secret.
    ${StorageName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("AzureFile", "EmptyDir", "Secret")]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Storage type for the volume.
    # If not provided, use EmptyDir.
    ${StorageType}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppVolumeObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for WorkloadProfile.
.Description
Create an in-memory object for WorkloadProfile.
.Example
New-AzContainerAppWorkloadProfileObject -Name "Consumption" -Type "Consumption"

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.App.Models.WorkloadProfile
.Link
https://learn.microsoft.com/powershell/module/Az.App/new-azcontainerappworkloadprofileobject
#>
function New-AzContainerAppWorkloadProfileObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.App.Models.WorkloadProfile])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Workload profile type for the workloads to run on.
    ${Name},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.String]
    # Workload profile type for the workloads to run on.
    ${Type},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # The maximum capacity.
    ${MaximumCount},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.App.Category('Body')]
    [System.Int32]
    # The minimum capacity.
    ${MinimumCount}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.App.custom\New-AzContainerAppWorkloadProfileObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.App.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}
