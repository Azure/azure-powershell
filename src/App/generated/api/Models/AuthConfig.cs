// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.App.Models
{
    using static Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Extensions;

    /// <summary>
    /// Configuration settings for the Azure ContainerApp Service Authentication / Authorization feature.
    /// </summary>
    public partial class AuthConfig :
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfig,
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigInternal,
        Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.IValidates
    {
        /// <summary>
        /// Backing field for Inherited model <see cref= "Microsoft.Azure.PowerShell.Cmdlets.App.Models.IProxyResource" />
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.App.Models.IProxyResource __proxyResource = new Microsoft.Azure.PowerShell.Cmdlets.App.Models.ProxyResource();

        /// <summary>The convention used when determining the session cookie's expiration.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public string CookieExpirationConvention { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).CookieExpirationConvention; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).CookieExpirationConvention = value ?? null; }

        /// <summary>The time after the request is made when the session cookie should expire.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public string CookieExpirationTimeToExpiration { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).CookieExpirationTimeToExpiration; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).CookieExpirationTimeToExpiration = value ?? null; }

        /// <summary>The convention used to determine the url of the request made.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public string ForwardProxyConvention { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).ForwardProxyConvention; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).ForwardProxyConvention = value ?? null; }

        /// <summary>The name of the header containing the host of the request.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public string ForwardProxyCustomHostHeaderName { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).ForwardProxyCustomHostHeaderName; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).ForwardProxyCustomHostHeaderName = value ?? null; }

        /// <summary>The name of the header containing the scheme of the request.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public string ForwardProxyCustomProtoHeaderName { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).ForwardProxyCustomProtoHeaderName; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).ForwardProxyCustomProtoHeaderName = value ?? null; }

        /// <summary>
        /// The paths for which unauthenticated flow would not be redirected to the login page.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public System.Collections.Generic.List<string> GlobalValidationExcludedPath { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).GlobalValidationExcludedPath; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).GlobalValidationExcludedPath = value ?? null /* arrayOf */; }

        /// <summary>
        /// The default authentication provider to use when multiple providers are configured.
        /// This setting is only needed if multiple providers are configured and the unauthenticated client
        /// action is set to "RedirectToLoginPage".
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public string GlobalValidationRedirectToProvider { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).GlobalValidationRedirectToProvider; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).GlobalValidationRedirectToProvider = value ?? null; }

        /// <summary>The action to take when an unauthenticated client attempts to access the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public string GlobalValidationUnauthenticatedClientAction { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).GlobalValidationUnauthenticatedClientAction; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).GlobalValidationUnauthenticatedClientAction = value ?? null; }

        /// <summary>
        /// <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise,
        /// <code>true</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public bool? HttpSettingRequireHttps { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).HttpSettingRequireHttps; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).HttpSettingRequireHttps = value ?? default(bool); }

        /// <summary>
        /// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inherited)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public string Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).Id; }

        /// <summary>
        /// The configuration settings of each of the identity providers used to configure ContainerApp Service Authentication/Authorization.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public Microsoft.Azure.PowerShell.Cmdlets.App.Models.IIdentityProviders IdentityProvider { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).IdentityProvider; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).IdentityProvider = value ?? null /* model class */; }

        /// <summary>
        /// External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part
        /// of the URL is ignored.
        /// This is an advanced setting typically only needed by Windows Store application backends.
        /// Note that URLs within the current domain are always implicitly allowed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public System.Collections.Generic.List<string> LoginAllowedExternalRedirectUrl { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).LoginAllowedExternalRedirectUrl; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).LoginAllowedExternalRedirectUrl = value ?? null /* arrayOf */; }

        /// <summary>
        /// <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public bool? LoginPreserveUrlFragmentsForLogin { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).LoginPreserveUrlFragmentsForLogin; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).LoginPreserveUrlFragmentsForLogin = value ?? default(bool); }

        /// <summary>Internal Acessors for GlobalValidation</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IGlobalValidation Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigInternal.GlobalValidation { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).GlobalValidation; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).GlobalValidation = value; }

        /// <summary>Internal Acessors for HttpSetting</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IHttpSettings Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigInternal.HttpSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).HttpSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).HttpSetting = value; }

        /// <summary>Internal Acessors for HttpSettingForwardProxy</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IForwardProxy Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigInternal.HttpSettingForwardProxy { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).HttpSettingForwardProxy; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).HttpSettingForwardProxy = value; }

        /// <summary>Internal Acessors for HttpSettingRoute</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IHttpSettingsRoutes Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigInternal.HttpSettingRoute { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).HttpSettingRoute; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).HttpSettingRoute = value; }

        /// <summary>Internal Acessors for Login</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.ILogin Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigInternal.Login { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).Login; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).Login = value; }

        /// <summary>Internal Acessors for LoginCookieExpiration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICookieExpiration Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigInternal.LoginCookieExpiration { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).LoginCookieExpiration; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).LoginCookieExpiration = value; }

        /// <summary>Internal Acessors for LoginNonce</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.INonce Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigInternal.LoginNonce { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).LoginNonce; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).LoginNonce = value; }

        /// <summary>Internal Acessors for LoginRoute</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.ILoginRoutes Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigInternal.LoginRoute { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).LoginRoute; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).LoginRoute = value; }

        /// <summary>Internal Acessors for Platform</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthPlatform Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigInternal.Platform { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).Platform; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).Platform = value; }

        /// <summary>Internal Acessors for Property</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigProperties Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigInternal.Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.App.Models.AuthConfigProperties()); set { {_property = value;} } }

        /// <summary>Internal Acessors for Id</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal.Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).Id = value; }

        /// <summary>Internal Acessors for Name</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal.Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).Name = value; }

        /// <summary>Internal Acessors for SystemData</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISystemData Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal.SystemData { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).SystemData; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).SystemData = value; }

        /// <summary>Internal Acessors for Type</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal.Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).Type = value; }

        /// <summary>The name of the resource</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inherited)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.FormatTable(Index = 0)]
        public string Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).Name; }

        /// <summary>The time after the request is made when the nonce should expire.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public string NonceExpirationInterval { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).NonceExpirationInterval; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).NonceExpirationInterval = value ?? null; }

        /// <summary>
        /// <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public bool? NonceValidateNonce { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).NonceValidateNonce; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).NonceValidateNonce = value ?? default(bool); }

        /// <summary>
        /// <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.FormatTable(Index = 1)]
        public bool? PlatformEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).PlatformEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).PlatformEnabled = value ?? default(bool); }

        /// <summary>
        /// The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
        /// The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public string PlatformRuntimeVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).PlatformRuntimeVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).PlatformRuntimeVersion = value ?? null; }

        /// <summary>Backing field for <see cref="Property" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigProperties _property;

        /// <summary>AuthConfig resource specific properties</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Owned)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        internal Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigProperties Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.App.Models.AuthConfigProperties()); set => this._property = value; }

        /// <summary>Gets the resource group name</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Owned)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.FormatTable(Index = 2)]
        public string ResourceGroupName { get => (new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(this.Id).Success ? new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(this.Id).Groups["resourceGroupName"].Value : null); }

        /// <summary>The prefix that should precede all the authentication/authorization paths.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public string RouteApiPrefix { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).RouteApiPrefix; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).RouteApiPrefix = value ?? null; }

        /// <summary>The endpoint at which a logout request should be made.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public string RouteLogoutEndpoint { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).RouteLogoutEndpoint; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigPropertiesInternal)Property).RouteLogoutEndpoint = value ?? null; }

        /// <summary>
        /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inherited)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        internal Microsoft.Azure.PowerShell.Cmdlets.App.Models.ISystemData SystemData { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).SystemData; }

        /// <summary>The timestamp of resource creation (UTC).</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inherited)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public global::System.DateTime? SystemDataCreatedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).SystemDataCreatedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).SystemDataCreatedAt = value ?? default(global::System.DateTime); }

        /// <summary>The identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inherited)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public string SystemDataCreatedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).SystemDataCreatedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).SystemDataCreatedBy = value ?? null; }

        /// <summary>The type of identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inherited)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public string SystemDataCreatedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).SystemDataCreatedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).SystemDataCreatedByType = value ?? null; }

        /// <summary>The timestamp of resource last modification (UTC)</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inherited)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public global::System.DateTime? SystemDataLastModifiedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).SystemDataLastModifiedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).SystemDataLastModifiedAt = value ?? default(global::System.DateTime); }

        /// <summary>The identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inherited)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public string SystemDataLastModifiedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).SystemDataLastModifiedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).SystemDataLastModifiedBy = value ?? null; }

        /// <summary>The type of identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inherited)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public string SystemDataLastModifiedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).SystemDataLastModifiedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).SystemDataLastModifiedByType = value ?? null; }

        /// <summary>
        /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inherited)]
        [Microsoft.Azure.PowerShell.Cmdlets.App.DoNotFormat]
        public string Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.IResourceInternal)__proxyResource).Type; }

        /// <summary>Creates an new <see cref="AuthConfig" /> instance.</summary>
        public AuthConfig()
        {

        }

        /// <summary>Validates that this object meets the validation criteria.</summary>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.IEventListener" /> instance that will receive validation
        /// events.</param>
        /// <returns>
        /// A <see cref = "global::System.Threading.Tasks.Task" /> that will be complete when validation is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task Validate(Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.IEventListener eventListener)
        {
            await eventListener.AssertNotNull(nameof(__proxyResource), __proxyResource);
            await eventListener.AssertObjectIsValid(nameof(__proxyResource), __proxyResource);
        }
    }
    /// Configuration settings for the Azure ContainerApp Service Authentication / Authorization feature.
    public partial interface IAuthConfig :
        Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.IJsonSerializable,
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IProxyResource
    {
        /// <summary>The convention used when determining the session cookie's expiration.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The convention used when determining the session cookie's expiration.",
        SerializedName = @"convention",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("FixedTime", "IdentityProviderDerived")]
        string CookieExpirationConvention { get; set; }
        /// <summary>The time after the request is made when the session cookie should expire.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The time after the request is made when the session cookie should expire.",
        SerializedName = @"timeToExpiration",
        PossibleTypes = new [] { typeof(string) })]
        string CookieExpirationTimeToExpiration { get; set; }
        /// <summary>The convention used to determine the url of the request made.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The convention used to determine the url of the request made.",
        SerializedName = @"convention",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("NoProxy", "Standard", "Custom")]
        string ForwardProxyConvention { get; set; }
        /// <summary>The name of the header containing the host of the request.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The name of the header containing the host of the request.",
        SerializedName = @"customHostHeaderName",
        PossibleTypes = new [] { typeof(string) })]
        string ForwardProxyCustomHostHeaderName { get; set; }
        /// <summary>The name of the header containing the scheme of the request.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The name of the header containing the scheme of the request.",
        SerializedName = @"customProtoHeaderName",
        PossibleTypes = new [] { typeof(string) })]
        string ForwardProxyCustomProtoHeaderName { get; set; }
        /// <summary>
        /// The paths for which unauthenticated flow would not be redirected to the login page.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The paths for which unauthenticated flow would not be redirected to the login page.",
        SerializedName = @"excludedPaths",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> GlobalValidationExcludedPath { get; set; }
        /// <summary>
        /// The default authentication provider to use when multiple providers are configured.
        /// This setting is only needed if multiple providers are configured and the unauthenticated client
        /// action is set to "RedirectToLoginPage".
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The default authentication provider to use when multiple providers are configured.
        This setting is only needed if multiple providers are configured and the unauthenticated client
        action is set to ""RedirectToLoginPage"".",
        SerializedName = @"redirectToProvider",
        PossibleTypes = new [] { typeof(string) })]
        string GlobalValidationRedirectToProvider { get; set; }
        /// <summary>The action to take when an unauthenticated client attempts to access the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The action to take when an unauthenticated client attempts to access the app.",
        SerializedName = @"unauthenticatedClientAction",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("RedirectToLoginPage", "AllowAnonymous", "Return401", "Return403")]
        string GlobalValidationUnauthenticatedClientAction { get; set; }
        /// <summary>
        /// <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise,
        /// <code>true</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"<code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.",
        SerializedName = @"requireHttps",
        PossibleTypes = new [] { typeof(bool) })]
        bool? HttpSettingRequireHttps { get; set; }
        /// <summary>
        /// The configuration settings of each of the identity providers used to configure ContainerApp Service Authentication/Authorization.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The configuration settings of each of the identity providers used to configure ContainerApp Service Authentication/Authorization.",
        SerializedName = @"identityProviders",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.App.Models.IIdentityProviders) })]
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IIdentityProviders IdentityProvider { get; set; }
        /// <summary>
        /// External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part
        /// of the URL is ignored.
        /// This is an advanced setting typically only needed by Windows Store application backends.
        /// Note that URLs within the current domain are always implicitly allowed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
        This is an advanced setting typically only needed by Windows Store application backends.
        Note that URLs within the current domain are always implicitly allowed.",
        SerializedName = @"allowedExternalRedirectUrls",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> LoginAllowedExternalRedirectUrl { get; set; }
        /// <summary>
        /// <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"<code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.",
        SerializedName = @"preserveUrlFragmentsForLogins",
        PossibleTypes = new [] { typeof(bool) })]
        bool? LoginPreserveUrlFragmentsForLogin { get; set; }
        /// <summary>The time after the request is made when the nonce should expire.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The time after the request is made when the nonce should expire.",
        SerializedName = @"nonceExpirationInterval",
        PossibleTypes = new [] { typeof(string) })]
        string NonceExpirationInterval { get; set; }
        /// <summary>
        /// <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"<code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.",
        SerializedName = @"validateNonce",
        PossibleTypes = new [] { typeof(bool) })]
        bool? NonceValidateNonce { get; set; }
        /// <summary>
        /// <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"<code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? PlatformEnabled { get; set; }
        /// <summary>
        /// The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
        /// The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
        The setting in this value can control the behavior of certain features in the Authentication / Authorization module.",
        SerializedName = @"runtimeVersion",
        PossibleTypes = new [] { typeof(string) })]
        string PlatformRuntimeVersion { get; set; }
        /// <summary>The prefix that should precede all the authentication/authorization paths.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The prefix that should precede all the authentication/authorization paths.",
        SerializedName = @"apiPrefix",
        PossibleTypes = new [] { typeof(string) })]
        string RouteApiPrefix { get; set; }
        /// <summary>The endpoint at which a logout request should be made.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The endpoint at which a logout request should be made.",
        SerializedName = @"logoutEndpoint",
        PossibleTypes = new [] { typeof(string) })]
        string RouteLogoutEndpoint { get; set; }

    }
    /// Configuration settings for the Azure ContainerApp Service Authentication / Authorization feature.
    internal partial interface IAuthConfigInternal :
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IProxyResourceInternal
    {
        /// <summary>The convention used when determining the session cookie's expiration.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("FixedTime", "IdentityProviderDerived")]
        string CookieExpirationConvention { get; set; }
        /// <summary>The time after the request is made when the session cookie should expire.</summary>
        string CookieExpirationTimeToExpiration { get; set; }
        /// <summary>The convention used to determine the url of the request made.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("NoProxy", "Standard", "Custom")]
        string ForwardProxyConvention { get; set; }
        /// <summary>The name of the header containing the host of the request.</summary>
        string ForwardProxyCustomHostHeaderName { get; set; }
        /// <summary>The name of the header containing the scheme of the request.</summary>
        string ForwardProxyCustomProtoHeaderName { get; set; }
        /// <summary>
        /// The configuration settings that determines the validation flow of users using Service Authentication/Authorization.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IGlobalValidation GlobalValidation { get; set; }
        /// <summary>
        /// The paths for which unauthenticated flow would not be redirected to the login page.
        /// </summary>
        System.Collections.Generic.List<string> GlobalValidationExcludedPath { get; set; }
        /// <summary>
        /// The default authentication provider to use when multiple providers are configured.
        /// This setting is only needed if multiple providers are configured and the unauthenticated client
        /// action is set to "RedirectToLoginPage".
        /// </summary>
        string GlobalValidationRedirectToProvider { get; set; }
        /// <summary>The action to take when an unauthenticated client attempts to access the app.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("RedirectToLoginPage", "AllowAnonymous", "Return401", "Return403")]
        string GlobalValidationUnauthenticatedClientAction { get; set; }
        /// <summary>
        /// The configuration settings of the HTTP requests for authentication and authorization requests made against ContainerApp
        /// Service Authentication/Authorization.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IHttpSettings HttpSetting { get; set; }
        /// <summary>The configuration settings of a forward proxy used to make the requests.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IForwardProxy HttpSettingForwardProxy { get; set; }
        /// <summary>
        /// <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise,
        /// <code>true</code>.
        /// </summary>
        bool? HttpSettingRequireHttps { get; set; }
        /// <summary>The configuration settings of the paths HTTP requests.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IHttpSettingsRoutes HttpSettingRoute { get; set; }
        /// <summary>
        /// The configuration settings of each of the identity providers used to configure ContainerApp Service Authentication/Authorization.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IIdentityProviders IdentityProvider { get; set; }
        /// <summary>
        /// The configuration settings of the login flow of users using ContainerApp Service Authentication/Authorization.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.ILogin Login { get; set; }
        /// <summary>
        /// External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part
        /// of the URL is ignored.
        /// This is an advanced setting typically only needed by Windows Store application backends.
        /// Note that URLs within the current domain are always implicitly allowed.
        /// </summary>
        System.Collections.Generic.List<string> LoginAllowedExternalRedirectUrl { get; set; }
        /// <summary>The configuration settings of the session cookie's expiration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICookieExpiration LoginCookieExpiration { get; set; }
        /// <summary>The configuration settings of the nonce used in the login flow.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.INonce LoginNonce { get; set; }
        /// <summary>
        /// <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        /// </summary>
        bool? LoginPreserveUrlFragmentsForLogin { get; set; }
        /// <summary>The routes that specify the endpoints used for login and logout requests.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.ILoginRoutes LoginRoute { get; set; }
        /// <summary>The time after the request is made when the nonce should expire.</summary>
        string NonceExpirationInterval { get; set; }
        /// <summary>
        /// <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        /// </summary>
        bool? NonceValidateNonce { get; set; }
        /// <summary>
        /// The configuration settings of the platform of ContainerApp Service Authentication/Authorization.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthPlatform Platform { get; set; }
        /// <summary>
        /// <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        /// </summary>
        bool? PlatformEnabled { get; set; }
        /// <summary>
        /// The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
        /// The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        /// </summary>
        string PlatformRuntimeVersion { get; set; }
        /// <summary>AuthConfig resource specific properties</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.IAuthConfigProperties Property { get; set; }
        /// <summary>The prefix that should precede all the authentication/authorization paths.</summary>
        string RouteApiPrefix { get; set; }
        /// <summary>The endpoint at which a logout request should be made.</summary>
        string RouteLogoutEndpoint { get; set; }

    }
}