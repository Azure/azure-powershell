// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.App.Models
{
    using static Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Extensions;

    /// <summary>
    /// The configuration settings of the login flow of users using ContainerApp Service Authentication/Authorization.
    /// </summary>
    public partial class Login :
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.ILogin,
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.ILoginInternal
    {

        /// <summary>Backing field for <see cref="AllowedExternalRedirectUrl" /> property.</summary>
        private System.Collections.Generic.List<string> _allowedExternalRedirectUrl;

        /// <summary>
        /// External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part
        /// of the URL is ignored.
        /// This is an advanced setting typically only needed by Windows Store application backends.
        /// Note that URLs within the current domain are always implicitly allowed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Owned)]
        public System.Collections.Generic.List<string> AllowedExternalRedirectUrl { get => this._allowedExternalRedirectUrl; set => this._allowedExternalRedirectUrl = value; }

        /// <summary>Backing field for <see cref="CookieExpiration" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICookieExpiration _cookieExpiration;

        /// <summary>The configuration settings of the session cookie's expiration.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICookieExpiration CookieExpiration { get => (this._cookieExpiration = this._cookieExpiration ?? new Microsoft.Azure.PowerShell.Cmdlets.App.Models.CookieExpiration()); set => this._cookieExpiration = value; }

        /// <summary>The convention used when determining the session cookie's expiration.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        public string CookieExpirationConvention { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICookieExpirationInternal)CookieExpiration).Convention; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICookieExpirationInternal)CookieExpiration).Convention = value ?? null; }

        /// <summary>The time after the request is made when the session cookie should expire.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        public string CookieExpirationTimeToExpiration { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICookieExpirationInternal)CookieExpiration).TimeToExpiration; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICookieExpirationInternal)CookieExpiration).TimeToExpiration = value ?? null; }

        /// <summary>Internal Acessors for CookieExpiration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICookieExpiration Microsoft.Azure.PowerShell.Cmdlets.App.Models.ILoginInternal.CookieExpiration { get => (this._cookieExpiration = this._cookieExpiration ?? new Microsoft.Azure.PowerShell.Cmdlets.App.Models.CookieExpiration()); set { {_cookieExpiration = value;} } }

        /// <summary>Internal Acessors for Nonce</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.INonce Microsoft.Azure.PowerShell.Cmdlets.App.Models.ILoginInternal.Nonce { get => (this._nonce = this._nonce ?? new Microsoft.Azure.PowerShell.Cmdlets.App.Models.Nonce()); set { {_nonce = value;} } }

        /// <summary>Internal Acessors for Route</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.ILoginRoutes Microsoft.Azure.PowerShell.Cmdlets.App.Models.ILoginInternal.Route { get => (this._route = this._route ?? new Microsoft.Azure.PowerShell.Cmdlets.App.Models.LoginRoutes()); set { {_route = value;} } }

        /// <summary>Backing field for <see cref="Nonce" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.App.Models.INonce _nonce;

        /// <summary>The configuration settings of the nonce used in the login flow.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.App.Models.INonce Nonce { get => (this._nonce = this._nonce ?? new Microsoft.Azure.PowerShell.Cmdlets.App.Models.Nonce()); set => this._nonce = value; }

        /// <summary>The time after the request is made when the nonce should expire.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        public string NonceExpirationInterval { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.INonceInternal)Nonce).ExpirationInterval; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.INonceInternal)Nonce).ExpirationInterval = value ?? null; }

        /// <summary>
        /// <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        public bool? NonceValidateNonce { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.INonceInternal)Nonce).ValidateNonce; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.INonceInternal)Nonce).ValidateNonce = value ?? default(bool); }

        /// <summary>Backing field for <see cref="PreserveUrlFragmentsForLogin" /> property.</summary>
        private bool? _preserveUrlFragmentsForLogin;

        /// <summary>
        /// <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Owned)]
        public bool? PreserveUrlFragmentsForLogin { get => this._preserveUrlFragmentsForLogin; set => this._preserveUrlFragmentsForLogin = value; }

        /// <summary>Backing field for <see cref="Route" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.App.Models.ILoginRoutes _route;

        /// <summary>The routes that specify the endpoints used for login and logout requests.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.App.Models.ILoginRoutes Route { get => (this._route = this._route ?? new Microsoft.Azure.PowerShell.Cmdlets.App.Models.LoginRoutes()); set => this._route = value; }

        /// <summary>The endpoint at which a logout request should be made.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Origin(Microsoft.Azure.PowerShell.Cmdlets.App.PropertyOrigin.Inlined)]
        public string RouteLogoutEndpoint { get => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.ILoginRoutesInternal)Route).LogoutEndpoint; set => ((Microsoft.Azure.PowerShell.Cmdlets.App.Models.ILoginRoutesInternal)Route).LogoutEndpoint = value ?? null; }

        /// <summary>Creates an new <see cref="Login" /> instance.</summary>
        public Login()
        {

        }
    }
    /// The configuration settings of the login flow of users using ContainerApp Service Authentication/Authorization.
    public partial interface ILogin :
        Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.IJsonSerializable
    {
        /// <summary>
        /// External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part
        /// of the URL is ignored.
        /// This is an advanced setting typically only needed by Windows Store application backends.
        /// Note that URLs within the current domain are always implicitly allowed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
        This is an advanced setting typically only needed by Windows Store application backends.
        Note that URLs within the current domain are always implicitly allowed.",
        SerializedName = @"allowedExternalRedirectUrls",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> AllowedExternalRedirectUrl { get; set; }
        /// <summary>The convention used when determining the session cookie's expiration.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The convention used when determining the session cookie's expiration.",
        SerializedName = @"convention",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("FixedTime", "IdentityProviderDerived")]
        string CookieExpirationConvention { get; set; }
        /// <summary>The time after the request is made when the session cookie should expire.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The time after the request is made when the session cookie should expire.",
        SerializedName = @"timeToExpiration",
        PossibleTypes = new [] { typeof(string) })]
        string CookieExpirationTimeToExpiration { get; set; }
        /// <summary>The time after the request is made when the nonce should expire.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The time after the request is made when the nonce should expire.",
        SerializedName = @"nonceExpirationInterval",
        PossibleTypes = new [] { typeof(string) })]
        string NonceExpirationInterval { get; set; }
        /// <summary>
        /// <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"<code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.",
        SerializedName = @"validateNonce",
        PossibleTypes = new [] { typeof(bool) })]
        bool? NonceValidateNonce { get; set; }
        /// <summary>
        /// <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"<code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.",
        SerializedName = @"preserveUrlFragmentsForLogins",
        PossibleTypes = new [] { typeof(bool) })]
        bool? PreserveUrlFragmentsForLogin { get; set; }
        /// <summary>The endpoint at which a logout request should be made.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.App.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The endpoint at which a logout request should be made.",
        SerializedName = @"logoutEndpoint",
        PossibleTypes = new [] { typeof(string) })]
        string RouteLogoutEndpoint { get; set; }

    }
    /// The configuration settings of the login flow of users using ContainerApp Service Authentication/Authorization.
    internal partial interface ILoginInternal

    {
        /// <summary>
        /// External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part
        /// of the URL is ignored.
        /// This is an advanced setting typically only needed by Windows Store application backends.
        /// Note that URLs within the current domain are always implicitly allowed.
        /// </summary>
        System.Collections.Generic.List<string> AllowedExternalRedirectUrl { get; set; }
        /// <summary>The configuration settings of the session cookie's expiration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.ICookieExpiration CookieExpiration { get; set; }
        /// <summary>The convention used when determining the session cookie's expiration.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.App.PSArgumentCompleterAttribute("FixedTime", "IdentityProviderDerived")]
        string CookieExpirationConvention { get; set; }
        /// <summary>The time after the request is made when the session cookie should expire.</summary>
        string CookieExpirationTimeToExpiration { get; set; }
        /// <summary>The configuration settings of the nonce used in the login flow.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.INonce Nonce { get; set; }
        /// <summary>The time after the request is made when the nonce should expire.</summary>
        string NonceExpirationInterval { get; set; }
        /// <summary>
        /// <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        /// </summary>
        bool? NonceValidateNonce { get; set; }
        /// <summary>
        /// <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        /// </summary>
        bool? PreserveUrlFragmentsForLogin { get; set; }
        /// <summary>The routes that specify the endpoints used for login and logout requests.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.App.Models.ILoginRoutes Route { get; set; }
        /// <summary>The endpoint at which a logout request should be made.</summary>
        string RouteLogoutEndpoint { get; set; }

    }
}