// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.Api20230501
{
    using static Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Extensions;

    /// <summary>
    /// Rule to place restrictions on portions of the cache namespace being presented to clients.
    /// </summary>
    public partial class NfsAccessRule :
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.Api20230501.INfsAccessRule,
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.Api20230501.INfsAccessRuleInternal
    {

        /// <summary>Backing field for <see cref="Access" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Support.NfsAccessRuleAccess _access;

        /// <summary>Access allowed by this rule.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Support.NfsAccessRuleAccess Access { get => this._access; set => this._access = value; }

        /// <summary>Backing field for <see cref="AnonymousGid" /> property.</summary>
        private string _anonymousGid;

        /// <summary>
        /// GID value that replaces 0 when rootSquash is true. This will use the value of anonymousUID if not provided.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        public string AnonymousGid { get => this._anonymousGid; set => this._anonymousGid = value; }

        /// <summary>Backing field for <see cref="AnonymousUid" /> property.</summary>
        private string _anonymousUid;

        /// <summary>
        /// UID value that replaces 0 when rootSquash is true. 65534 will be used if not provided.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        public string AnonymousUid { get => this._anonymousUid; set => this._anonymousUid = value; }

        /// <summary>Backing field for <see cref="Filter" /> property.</summary>
        private string _filter;

        /// <summary>
        /// Filter applied to the scope for this rule. The filter's format depends on its scope. 'default' scope matches all clients
        /// and has no filter value. 'network' scope takes a filter in CIDR format (for example, 10.99.1.0/24). 'host' takes an IP
        /// address or fully qualified domain name as filter. If a client does not match any filter rule and there is no default rule,
        /// access is denied.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        public string Filter { get => this._filter; set => this._filter = value; }

        /// <summary>Backing field for <see cref="RootSquash" /> property.</summary>
        private bool? _rootSquash;

        /// <summary>Map root accesses to anonymousUID and anonymousGID.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        public bool? RootSquash { get => this._rootSquash; set => this._rootSquash = value; }

        /// <summary>Backing field for <see cref="Scope" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Support.NfsAccessRuleScope _scope;

        /// <summary>
        /// Scope for this rule. The scope and filter determine which clients match the rule.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Support.NfsAccessRuleScope Scope { get => this._scope; set => this._scope = value; }

        /// <summary>Backing field for <see cref="SubmountAccess" /> property.</summary>
        private bool? _submountAccess;

        /// <summary>
        /// For the default policy, allow access to subdirectories under the root export. If this is set to no, clients can only mount
        /// the path '/'. If set to yes, clients can mount a deeper path, like '/a/b'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        public bool? SubmountAccess { get => this._submountAccess; set => this._submountAccess = value; }

        /// <summary>Backing field for <see cref="Suid" /> property.</summary>
        private bool? _suid;

        /// <summary>Allow SUID semantics.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        public bool? Suid { get => this._suid; set => this._suid = value; }

        /// <summary>Creates an new <see cref="NfsAccessRule" /> instance.</summary>
        public NfsAccessRule()
        {

        }
    }
    /// Rule to place restrictions on portions of the cache namespace being presented to clients.
    public partial interface INfsAccessRule :
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.IJsonSerializable
    {
        /// <summary>Access allowed by this rule.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"Access allowed by this rule.",
        SerializedName = @"access",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Support.NfsAccessRuleAccess) })]
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Support.NfsAccessRuleAccess Access { get; set; }
        /// <summary>
        /// GID value that replaces 0 when rootSquash is true. This will use the value of anonymousUID if not provided.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"GID value that replaces 0 when rootSquash is true. This will use the value of anonymousUID if not provided.",
        SerializedName = @"anonymousGID",
        PossibleTypes = new [] { typeof(string) })]
        string AnonymousGid { get; set; }
        /// <summary>
        /// UID value that replaces 0 when rootSquash is true. 65534 will be used if not provided.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"UID value that replaces 0 when rootSquash is true. 65534 will be used if not provided.",
        SerializedName = @"anonymousUID",
        PossibleTypes = new [] { typeof(string) })]
        string AnonymousUid { get; set; }
        /// <summary>
        /// Filter applied to the scope for this rule. The filter's format depends on its scope. 'default' scope matches all clients
        /// and has no filter value. 'network' scope takes a filter in CIDR format (for example, 10.99.1.0/24). 'host' takes an IP
        /// address or fully qualified domain name as filter. If a client does not match any filter rule and there is no default rule,
        /// access is denied.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Filter applied to the scope for this rule. The filter's format depends on its scope. 'default' scope matches all clients and has no filter value. 'network' scope takes a filter in CIDR format (for example, 10.99.1.0/24). 'host' takes an IP address or fully qualified domain name as filter. If a client does not match any filter rule and there is no default rule, access is denied.",
        SerializedName = @"filter",
        PossibleTypes = new [] { typeof(string) })]
        string Filter { get; set; }
        /// <summary>Map root accesses to anonymousUID and anonymousGID.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Map root accesses to anonymousUID and anonymousGID.",
        SerializedName = @"rootSquash",
        PossibleTypes = new [] { typeof(bool) })]
        bool? RootSquash { get; set; }
        /// <summary>
        /// Scope for this rule. The scope and filter determine which clients match the rule.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"Scope for this rule. The scope and filter determine which clients match the rule.",
        SerializedName = @"scope",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Support.NfsAccessRuleScope) })]
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Support.NfsAccessRuleScope Scope { get; set; }
        /// <summary>
        /// For the default policy, allow access to subdirectories under the root export. If this is set to no, clients can only mount
        /// the path '/'. If set to yes, clients can mount a deeper path, like '/a/b'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For the default policy, allow access to subdirectories under the root export. If this is set to no, clients can only mount the path '/'. If set to yes, clients can mount a deeper path, like '/a/b'.",
        SerializedName = @"submountAccess",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SubmountAccess { get; set; }
        /// <summary>Allow SUID semantics.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Allow SUID semantics.",
        SerializedName = @"suid",
        PossibleTypes = new [] { typeof(bool) })]
        bool? Suid { get; set; }

    }
    /// Rule to place restrictions on portions of the cache namespace being presented to clients.
    internal partial interface INfsAccessRuleInternal

    {
        /// <summary>Access allowed by this rule.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Support.NfsAccessRuleAccess Access { get; set; }
        /// <summary>
        /// GID value that replaces 0 when rootSquash is true. This will use the value of anonymousUID if not provided.
        /// </summary>
        string AnonymousGid { get; set; }
        /// <summary>
        /// UID value that replaces 0 when rootSquash is true. 65534 will be used if not provided.
        /// </summary>
        string AnonymousUid { get; set; }
        /// <summary>
        /// Filter applied to the scope for this rule. The filter's format depends on its scope. 'default' scope matches all clients
        /// and has no filter value. 'network' scope takes a filter in CIDR format (for example, 10.99.1.0/24). 'host' takes an IP
        /// address or fully qualified domain name as filter. If a client does not match any filter rule and there is no default rule,
        /// access is denied.
        /// </summary>
        string Filter { get; set; }
        /// <summary>Map root accesses to anonymousUID and anonymousGID.</summary>
        bool? RootSquash { get; set; }
        /// <summary>
        /// Scope for this rule. The scope and filter determine which clients match the rule.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Support.NfsAccessRuleScope Scope { get; set; }
        /// <summary>
        /// For the default policy, allow access to subdirectories under the root export. If this is set to no, clients can only mount
        /// the path '/'. If set to yes, clients can mount a deeper path, like '/a/b'.
        /// </summary>
        bool? SubmountAccess { get; set; }
        /// <summary>Allow SUID semantics.</summary>
        bool? Suid { get; set; }

    }
}