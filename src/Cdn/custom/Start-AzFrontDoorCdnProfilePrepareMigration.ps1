# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Code generated by Microsoft (R) AutoRest Code Generator.Changes may cause incorrect behavior and will be lost if the code
# is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Migrate the CDN profile to Azure Frontdoor(Standard/Premium) profile.
The change need to be committed after this.
.Description
Migrate the CDN profile to Azure Frontdoor(Standard/Premium) profile.
The change need to be committed after this.
.Example
PS C:\> {{ Add code here }}
{{ Add output here }}
.Example
PS C:\> {{ Add code here }}
{{ Add output here }}
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Cdn.Models.Api20221101Preview.IMigrateResult

MIGRATIONPARAMETER <IMigrationParameters>: Request body for Migrate operation.
  ProfileName <String>: Name of the new profile that need to be created.
  [ClassicResourceReferenceId <String>]: Resource ID.
  [MigrationWebApplicationFirewallMapping <IMigrationWebApplicationFirewallMapping[]>]: Waf mapping for the migrated profile
    [MigratedFromId <String>]: Resource ID.
    [MigratedToId <String>]: Resource ID.
  [SkuName <SkuName?>]: Name of the pricing tier.

MIGRATIONWEBAPPLICATIONFIREWALLMAPPING <IMigrationWebApplicationFirewallMapping[]>: Waf mapping for the migrated profile
  [MigratedFromId <String>]: Resource ID.
  [MigratedToId <String>]: Resource ID.
  
.Link
https://docs.microsoft.com/powershell/module/az.cdn/start-azfrontdoorcdnprofilepreparemigration
#>
function Start-AzFrontDoorCdnProfilePrepareMigration {
    [OutputType([Microsoft.Azure.PowerShell.Cmdlets.Cdn.Models.Api20221101Preview.IMigrateResult])]
    [CmdletBinding(DefaultParameterSetName='MigrateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
    param(
        [Parameter(Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Path')]
        [System.String]
        # Name of the Resource group within the Azure subscription.
        ${ResourceGroupName},

        [Parameter(ParameterSetName='MigrateExpanded', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Body')]
        [System.String]
        # Resource ID.
        ${ClassicResourceReferenceId},

        [Parameter(ParameterSetName='MigrateExpanded', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Body')]
        [System.String]
        # Name of the new profile that need to be created.
        ${ProfileName},

        [Parameter(ParameterSetName='MigrateExpanded', Mandatory)]
        [ValidateNotNull()]
        [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.Cdn.Support.SkuName])]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Support.SkuName]
        # Name of the pricing tier.
        ${SkuName},

        [Parameter(ParameterSetName='MigrateExpanded')]
        [AllowEmptyCollection()]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Models.Api20221101Preview.IMigrationWebApplicationFirewallMapping[]]
        # Waf mapping for the migrated profile
        # To construct, see NOTES section for MIGRATIONWEBAPPLICATIONFIREWALLMAPPING properties and create a hash table.
        ${MigrationWebApplicationFirewallMapping},

        [Parameter(ParameterSetName='Migrate', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Models.Api20221101Preview.IMigrationParameters]
        # Request body for Migrate operation.
        # To construct, see NOTES section for MIGRATIONPARAMETER properties and create a hash table.
        ${MigrationParameter},

        [Parameter(HelpMessage='The subscription ID that identifies an Azure subscription.')]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
        [System.String]
        # Azure Subscription ID.
        ${SubscriptionId},

        [Parameter()]
        [Alias('AzureRMContext', 'AzureCredential')]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Azure')]
        [System.Management.Automation.PSObject]
        # The credentials, account, tenant, and subscription used for communication with Azure.
        ${DefaultProfile},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Run the command as a job
        ${AsJob},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Wait for .NET debugger to attach
        ${Break},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be appended to the front of the pipeline
        ${HttpPipelineAppend},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be prepended to the front of the pipeline
        ${HttpPipelinePrepend},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Run the command asynchronously
        ${NoWait},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Runtime')]
        [System.Uri]
        # The URI for the proxy server to use
        ${Proxy},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Runtime')]
        [System.Management.Automation.PSCredential]
        # Credentials for a proxy server to use for the remote call
        ${ProxyCredential},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Use the default credentials for the proxy
        ${ProxyUseDefaultCredentials}
    )

    process {
        if($PSBoundParameters.ContainsKey('MigrationWebApplicationFirewallMapping')) {
            if(!(Get-Module -ListAvailable -Name Az.FrontDoor)) {
                throw 'Please install Az.FrontDoor module by entering "Install-Module -Name Az.FrontDoor"'
            }
            else {
                Import-Module -Name Az.FrontDoor
            }

            $wafPolicies = $PSBoundParameters.MigrationWebApplicationFirewallMapping

            if($wafPolicies.count -gt 0) {
                # 1. Validate whether there is any waf policy associated with the profile.
                $frontDoorName = ${ClassicResourceReferenceId}.split("/")[-1]
                $frontDoorInfos = Get-AzFrontDoorFrontendEndpoint -ResourceGroupName ${ResourceGroupName} -FrontDoorName $frontDoorName
                $hasWafpolicy = $false
                $existManagedMigrateFromWaf = $false
                $allWafPolicies = @()

                foreach ($info in $frontDoorInfos) {
                    if($info.WebApplicationFirewallPolicyLink) {
                        $hasWafpolicy = $true
                        $allWafPolicies += $info.WebApplicationFirewallPolicyLink
                    }
                }

                if ($hasWafpolicy -eq $false) {
                    throw 'No waf policy associated with the profile. Please check your profile.'
                }

                Write-Debug("Waf Policy parameter ok now and enter validation the format of waf Id.")

                # 2. Validate the format of the waf policy and the migrateFrom.Id whether exists in the profile.
                # 3. Validate the Sku argument, if a managed waf associated, then the profile only can migrated to Premium tier. 
                # /subscriptions/*******/resourceGroups/****/providers/Microsoft.Network/frontdoorWebApplicationFirewallPolicies/******
                foreach ($policy in $wafPolicies) {
                    $migrateFromId = $policy.MigratedFromId
                    ParseWafPolicyResourceId -WafResourceId $migrateFromId
                    if ($allWafPolicies -NotContains $migrateFromId)
                    {
                        throw 'Waf policy: $policy.MigratedFromId, not exists in the profile. Waf policy provided should exist in the profile.'
                    }

                    # Validate the Sku argument 
                    $migrateFromWafPreperty = GetMigrateFromWafProperty -MigrateWafResourceId $migrateFromId
                    if ($migrateFromWafPreperty.ManagedRules) {
                        $existManagedMigrateFromWaf = $true
                        if (${SkuName} -ne "Premium_AzureFrontDoor") {
                            Throw 'Please check parameter SkuName: ${SkuName}. The AFD (classic) instance has managed WAF rules associated, and it can only be migrated to Premium tier. If you want to migrate to Standard tier, please remove the association on AFD (classic) and migrate afterwards '
                        }
                    }

                    # Validate the format of the migrateToId
                    ParseWafPolicyResourceId -WafResourceId $policy.MigratedToId
                }

                # 4. Validate whether MigratedToId policy already exists in the subsrciption or not; If not existed, then create a new waf policy.
                # 5. If exists, validate the MigrateToId waf policy whether meets the requirements.
                foreach ($policy in $wafPolicies) {
                    $migrateToWafId = $policy.MigratedToId
                    $migrateToWafResourceGroup = $migrateToWafId.split("/")[4]
                    $migrateToWafName = $migrateToWafId.split("/")[8]

                    try {
                        $existed = Get-AzFrontDoorWafPolicy -ResourceGroupName $migrateToWafResourceGroup -Name $migrateToWafName
                    }
                    # Not exists, create a new waf policy. Corrpesonding to "Copy to a new one" on Portal side.
                    catch {
                        # $migrateFromWafId = $policy.MigratedFromId
                        # $migrateFromWafResourceGroup = $migrateFromWafId.split("/")[4]
                        # $migrateFromWafName = $migrateFromWafId.split("/")[8]
                        # $migrateFromWafProperty = Get-AzFrontDoorWafPolicy -ResourceGroupName $migrateFromWafResourceGroup -Name $migrateFromWafName

                        # Create a new waf policy. 
                        $migrateFromWafPreperty = GetMigrateFromWafProperty -MigrateWafResourceId $policy.MigratedFromId
                        CreateNewWafPolicy -ResourceGroupName $migrateToWafResourceGroup -Name $migrateToWafName -WafProperty $migrateFromWafProperty
                    }

                    # Corrpesonding to "Select an exsiting one" on Portal side.
                    if ($existed -and $existManagedMigrateFromWaf) { 
                        if (!$existed.ManagedRules) {
                            Throw 'Please check parameter migrateToId: $migrateToWafId. The AFD (classic) instance has managed WAF rules associated, and it can only be migrated to Premium tier.'
                        }
                    }
                }
            }
        }
        Az.Cdn.internal\Move-AzCdnProfile @PSBoundParameters
    }
}

# Parse the format of the waf reource id. 
function ParseWafPolicyResourceId {
    param (
        [string]$WafResourceId
    )

    Write-Debug("Validate the resource ID")
    $array = $WafResourceId.ToLower().split('/')
    if ($array.Length -ne 9){
        throw "The Format of WebApplicationFirewallMapping is supposed to be like '/subscriptions/******/resourceGroups/******/providers/Microsoft.Network/frontdoorWebApplicationFirewallPolicies/******'"
    }
    if ($array[1] -gt "subscriptions" -or $array[3] -gt "resourcegroups" -or $array[5] -gt "providers" -or $array[6] -gt "microsoft.network" -or $array[7] -gt "frontdoorwebapplicationfirewallpolicies") {
        throw "The Format of WebApplicationFirewallMapping is supposed to be like '/subscriptions/******/resourceGroups/******/providers/Microsoft.Network/frontdoorWebApplicationFirewallPolicies/******'"
    }
}

function GetMigrateWafProperty {
    param (
        [string]$MigrateWafResourceId
    )

    Write-Debug("Get the property of the ID")
    return Get-AzFrontDoorWafPolicy -ResourceGroupName $MigrateWafResourceId.split("/")[4] -Name $MigrateWafResourceId.split("/")[8]
}


# Corresponding to "Copy to a new waf policy"
function CreateNewWafPolicy {
    param (
        [string]$ResourceGroupName,
        [string]$Name,
        [Microsoft.Azure.Commands.FrontDoor.Models.PSTrackedResource]$WafProperty
    )

    $skuName = "Standard_AzureFrontDoor"
    if (!$WafProperty.ManagedRules) {
        $skuName = "Premium_AzureFrontDoor"
    }

    # Remove the null/empty property
    $validatedWafProperty = ValidateWafPolicyProperty $WafProperty

    # New a waf policy, copied from the Migrtae
    New-AzFrontDoorWafPolicy -ResourceGroupName $ResourceGroupName -Name $Name -Sku $skuName @validatedWafProperty
}

# Validate the property of a waf policy
function ValidateWafPolicyProperty {
    param (
        [Microsoft.Azure.Commands.FrontDoor.Models.PSTrackedResource]$WafProperty
    )

    $wafPropertHash = @{}
    $wafPropertHash.Add('EnabledState', $WafProperty.PolicyEnabledState)
    $wafPropertHash.Add('Mode', $WafProperty.PolicyMode)
    $wafPropertHash.Add('Customrule', $WafProperty.CustomRules)
    $wafPropertHash.Add('ManagedRule', $WafProperty.ManagedRules)
    $wafPropertHash.Add('RedirectUrl', $WafProperty.RedirectUrl)
    $wafPropertHash.Add('CustomBlockResponseStatusCode', $WafProperty.CustomBlockResponseStatusCode)
    $wafPropertHash.Add('CustomBlockResponseBody', $WafProperty.CustomBlockResponseBody)
    $wafPropertHash.Add('RequestBodyCheck', $WafProperty.RequestBodyCheck)

    # If the propery is null, then remove from the hash table.
    $null = $wafPropertHash.Remove('PolicyEnabledState')
    $null = $wafPropertHash.Remove('PolicyMode')
    $null = $wafPropertHash.Remove('CustomRules')
    $null = $wafPropertHash.Remove('ManagedRules')
    $null = $wafPropertHash.Remove('RedirectUrl')
    $null = $wafPropertHash.Remove('CustomBlockResponseStatusCode')
    $null = $wafPropertHash.Remove('CustomBlockResponseBody')
    $null = $wafPropertHash.Remove('RequestBodyCheck')

    return $wafPropertHash
}