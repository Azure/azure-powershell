# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Code generated by Microsoft (R) AutoRest Code Generator.Changes may cause incorrect behavior and will be lost if the code
# is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Migrate the CDN profile to Azure Frontdoor(Standard/Premium) profile.
The change need to be committed after this.
.Description
Migrate the CDN profile to Azure Frontdoor(Standard/Premium) profile.
The change need to be committed after this.
.Example
PS C:\> {{ Add code here }}
{{ Add output here }}
.Example
PS C:\> {{ Add code here }}
{{ Add output here }}
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Cdn.Models.Api20221101Preview.IMigrateResult

MIGRATIONPARAMETER <IMigrationParameters>: Request body for Migrate operation.
  ProfileName <String>: Name of the new profile that need to be created.
  [ClassicResourceReferenceId <String>]: Resource ID.
  [MigrationWebApplicationFirewallMapping <IMigrationWebApplicationFirewallMapping[]>]: Waf mapping for the migrated profile
    [MigratedFromId <String>]: Resource ID.
    [MigratedToId <String>]: Resource ID.
  [SkuName <SkuName?>]: Name of the pricing tier.

MIGRATIONWEBAPPLICATIONFIREWALLMAPPING <IMigrationWebApplicationFirewallMapping[]>: Waf mapping for the migrated profile
  [MigratedFromId <String>]: Resource ID.
  [MigratedToId <String>]: Resource ID.
  
.Link
https://docs.microsoft.com/powershell/module/az.cdn/start-azfrontdoorcdnprofilepreparemigration
#>
function Start-AzFrontDoorCdnProfilePrepareMigration {
    [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Runtime.PreviewMessageAttribute("This cmdlet is using a preview API version and is subject to breaking change in a future release.")]
    [OutputType([Microsoft.Azure.PowerShell.Cmdlets.Cdn.Models.Api20221101Preview.IMigrateResult])]
    [CmdletBinding(DefaultParameterSetName='MigrateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
    param(
        [Parameter(Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Path')]
        [System.String]
        # Name of the Resource group within the Azure subscription.
        ${ResourceGroupName},

        [Parameter(ParameterSetName='MigrateExpanded', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Body')]
        [System.String]
        # Resource ID.
        ${ClassicResourceReferenceId},

        [Parameter(ParameterSetName='MigrateExpanded', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Body')]
        [System.String]
        # Name of the new profile that need to be created.
        ${ProfileName},

        [Parameter(ParameterSetName='MigrateExpanded', Mandatory)]
        [ValidateNotNull()]
        [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.Cdn.Support.SkuName])]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Support.SkuName]
        # Name of the pricing tier.
        ${SkuName},

        [Parameter(ParameterSetName='MigrateExpanded')]
        [AllowEmptyCollection()]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Models.Api20221101Preview.IMigrationWebApplicationFirewallMapping[]]
        # Waf mapping for the migrated profile
        # To construct, see NOTES section for MIGRATIONWEBAPPLICATIONFIREWALLMAPPING properties and create a hash table.
        ${MigrationWebApplicationFirewallMapping},

        [Parameter(ParameterSetName='Migrate', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Models.Api20221101Preview.IMigrationParameters]
        # Request body for Migrate operation.
        # To construct, see NOTES section for MIGRATIONPARAMETER properties and create a hash table.
        ${MigrationParameter},

        [Parameter(HelpMessage='The subscription ID that identifies an Azure subscription.')]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
        [System.String]
        # Azure Subscription ID.
        ${SubscriptionId},

        [Parameter()]
        [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.Cdn.Support.ManagedServiceIdentityType])]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Support.ManagedServiceIdentityType]
        # Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        ${IdentityType},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.Cdn.Models.Api40.IUserAssignedIdentities]))]
        [System.Collections.Hashtable]
        # The set of user assigned identities associated with the resource.
        # The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
        # The dictionary values can be empty objects ({}) in requests.
        ${IdentityUserAssignedIdentity},

        [Parameter()]
        [Alias('AzureRMContext', 'AzureCredential')]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Azure')]
        [System.Management.Automation.PSObject]
        # The credentials, account, tenant, and subscription used for communication with Azure.
        ${DefaultProfile},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Run the command as a job
        ${AsJob},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Wait for .NET debugger to attach
        ${Break},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be appended to the front of the pipeline
        ${HttpPipelineAppend},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be prepended to the front of the pipeline
        ${HttpPipelinePrepend},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Run the command asynchronously
        ${NoWait},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Runtime')]
        [System.Uri]
        # The URI for the proxy server to use
        ${Proxy},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Runtime')]
        [System.Management.Automation.PSCredential]
        # Credentials for a proxy server to use for the remote call
        ${ProxyCredential},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.Cdn.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Use the default credentials for the proxy
        ${ProxyUseDefaultCredentials}
    )

    process {
        if($PSBoundParameters.ContainsKey('MigrationWebApplicationFirewallMapping')) {
            if(!(Get-Module -ListAvailable -Name Az.FrontDoor)) {
                throw 'Please install Az.FrontDoor module by entering "Install-Module -Name Az.FrontDoor"'
            }
            else {
                Import-Module -Name Az.FrontDoor
            }

            $wafPolicies = $PSBoundParameters.MigrationWebApplicationFirewallMapping

            
            if($wafPolicies.count -gt 0) {
                # 1. Validate whether there is any waf policy associated with the profile.
                $frontDoorName = ${ClassicResourceReferenceId}.split("/")[-1]
                $frontDoorInfos = Get-AzFrontDoorFrontendEndpoint -ResourceGroupName ${ResourceGroupName} -FrontDoorName $frontDoorName
                $hasWafpolicy = $false
                $existManagedRuleMigrateFromWaf = $false
                $allWafPolicies = [System.Collections.ArrayList]@()

                foreach ($info in $frontDoorInfos) {
                    if($info.WebApplicationFirewallPolicyLink) {
                        $hasWafpolicy = $true
                        $allWafPolicies.Add($info.WebApplicationFirewallPolicyLink)
                    }
                }

                if ($hasWafpolicy -eq $false) {
                    throw 'No waf policy associated with the profile. Please check your profile.'
                }

                Write-Debug("Waf Policy parameter ok now and enter validation the format of waf Id.")
                $validateWafId = "^/subscriptions/(?<subscriptionId>[^/]+)/resourcegroups/(?<resourceGroupName>[^/]+)/providers/microsoft.network/frontdoorwebapplicationfirewallpolicies/(?<policyName>[^/]+)$"

                # 2. Validate the format of the waf policy and the migrateFrom.Id whether exists in the profile.
                # 3. Validate the Sku argument, if a managed waf associated, then the profile only can migrated to Premium tier. 
                foreach ($policy in $wafPolicies) {
                    $migrateFromId = $policy.MigratedFromId
                    if ($migrateFromId.ToLower() -notmatch $validateWafId) {
                        throw "The format of Waf policy id is supposed to be like '/subscriptions/*******/resourceGroups/****/providers/Microsoft.Network/frontdoorWebApplicationFirewallPolicies/******' "
                    }

                    # ParseWafPolicyResourceId -WafResourceId $migrateFromId
                    if ($allWafPolicies -NotContains $migrateFromId)
                    {
                        throw "Waf policy: '$migrateFromId' does not exist in the profile. Waf policy provided should exist in the profile."
                    }

                    # Validate the Sku argument 
                    $migrateFromWafPreperty = GetMigrateWafProperty -MigrateWafResourceId $migrateFromId
                    if ($migrateFromWafPreperty.ManagedRules) {
                        $existManagedRuleMigrateFromWaf = $true
                        if (${SkuName} -ne "Premium_AzureFrontDoor") {
                            throw "The AFD (classic) instance has managed WAF rules associated, and it can only be migrated to Premium tier. If you want to migrate to Standard tier, please remove the association on AFD (classic) and migrate afterwards."
                        }
                    }

                    # Validate the format of the migrateToId
                    # ParseWafPolicyResourceId -WafResourceId $policy.MigratedToId
                    if ($policy.MigratedToId.ToLower() -notmatch $validateWafId) {
                        throw "The format of Waf policy id is supposed to be like '/subscriptions/*******/resourceGroups/****/providers/Microsoft.Network/frontdoorWebApplicationFirewallPolicies/******' "
                    }
                }

                # 4. Validate whether MigratedToId policy already exists in the subsrciption or not; If not existed, then create a new waf policy.
                # 5. If exists, validate the MigrateToId waf policy whether meets the requirements.
                foreach ($policy in $wafPolicies) {
                    $migrateToWafId = $policy.MigratedToId
                    $migrateToWafResourceGroup = $migrateToWafId.split("/")[4]
                    $migrateToWafName = $migrateToWafId.split("/")[8]

                    try {
                        $existed = Get-AzFrontDoorWafPolicy -ResourceGroupName $migrateToWafResourceGroup -Name $migrateToWafName
                    }
                    # Not exists, create a new waf policy. Corrpesonding to "Copy to a new one" on Portal side.
                    catch {
                        # Create a new waf policy. 
                        $migrateFromWafPreperty = GetMigrateWafProperty -MigrateWafResourceId $policy.MigratedFromId
                        Write-Host("existManagedRuleMigrateFromWaf: " + $existManagedRuleMigrateFromWaf)
                        CreateNewWafPolicy -ResourceGroupName $migrateToWafResourceGroup -Name $migrateToWafName -WafProperty $migrateFromWafPreperty -ManagedRuleMigrateFromWaf $existManagedRuleMigrateFromWaf
                    }

                    # Corrpesonding to "Select an exsiting one" on Portal side.
                    if ($existed -and $existManagedRuleMigrateFromWaf) { 
                        if (!$existed.ManagedRules) {
                            throw "Please check parameter migrateToId: '$migrateToWafId'. The AFD (classic) instance has managed WAF rules associated, and it can only be migrated to Premium tier."
                        }
                    }
                }
            }
        }

        # MSI 
        if ($PSBoundParameters.ContainsKey('IdentityType')) {
            $identityTypeLower = ${IdentityType}.ToString().ToLower()
            Write-Debug("Before lower:" + ${IdentityType})
            Write-Debug("ToLower:" + $identityTypeLower)
            if($identityTypeLower -eq "none") {
                Update-AzFrontDoorCdnProfile -ResourceGroupName ${ResourceGroupName} -Name ${ProfileName} -IdentityType $identityTypeLower
                return
            }

            # Validate the value of the IdentityType 
            $validIdentityType = @("systemassigned", "userAssigned", "systemassigned, userAssigned", "userAssigned, systemassigned")
            if($validIdentityType -NotContains $identityTypeLower) {
                Throw "The Identity Type 'NotSpecified' is invalid. The supported types are 'SystemAssigned,UserAssigned,None'."
            }

            if(!(Get-Module -ListAvailable -Name Az.FrontDoor)) {
                throw 'Please install Az.FrontDoor module by entering "Install-Module -Name Az.FrontDoor"'
            }
            else {
                Import-Module -Name Az.FrontDoor
            }

            if(!(Get-Module -ListAvailable -Name Az.KeyVault)) {
                throw 'Please install Az.KeyVault module by entering "Install-Module -Name Az.KeyVault"'
            }
            else {
                Import-Module -Name Az.KeyVault
            }

            $identityUserAssignedIdentityValue = ${IdentityUserAssignedIdentity}

            # Create AFDx Profile
            $null = $PSBoundParameters.Remove('IdentityType')
            $null = $PSBoundParameters.Remove('IdentityUserAssignedIdentity')

            Write-Debug("Start: Before calling Move-AzCdnProfile command...")
            Az.Cdn.internal\Move-AzCdnProfile @PSBoundParameters

            Write-Debug("Begin to MSI...")
            # 1. Get "principalId" from RP
            if($identityTypeLower -eq "systemassigned") {
                Write-Debug("System Assigend...")
                $profileIdentity = Update-AzFrontDoorCdnProfile -ResourceGroupName ${ResourceGroupName} -Name ${ProfileName} -IdentityType $identityTypeLower
            }
            else {
                $profileIdentity = Update-AzFrontDoorCdnProfile -ResourceGroupName ${ResourceGroupName} -Name ${ProfileName} -IdentityType $identityTypeLower -IdentityUserAssignedIdentity ${IdentityUserAssignedIdentity}
            }
            
            $systemAssigendPrincipalIndentity = $profileIdentity.IdentityPrincipalId
            $userAssignedPrincipalIndentity = $profileIdentity.IdentityUserAssignedIdentity.Values.PrincipalId

            Write-Debug("Begin to grant...")
            # 2. Grant Key Vault permission: Get all the BYOC key vaults of the fronted endpoint in the classic AFD.
            $frontDoorName = ${ClassicResourceReferenceId}.split("/")[-1]
            $frontDoorInfos = Get-AzFrontDoorFrontendEndpoint -ResourceGroupName ${ResourceGroupName} -FrontDoorName $frontDoorName
            $vaultArray = [System.Collections.ArrayList]@()
            foreach ($info in $frontDoorInfos) {
                if ($info.Vault) {
                    $vaultName = $info.Vault.split("/")[-1]
                    $vaultArray.Add($vaultName)
                }
            }

            Start-Sleep -Seconds 5

            if ($identityTypeLower -eq "systemAssigned" ) {
                # 3. Call Key Vault module: Grant key vault accsee policys
                foreach ($vault in $vaultArray) {
                    Set-AzKeyVaultAccessPolicy -VaultName $vault -ObjectId $systemAssigendPrincipalIndentity -PermissionsToSecrets Get -PermissionsToCertificates Get
                }

            } elseif ($identityTypeLower -eq "userAssigned") {
                # 3. Call Key Vault module: Grant key vault accsee policys
                foreach ($vault in $vaultArray) {
                    foreach ($principal in $userAssignedPrincipalIndentity) {
                        Set-AzKeyVaultAccessPolicy -VaultName $vault -ObjectId $principal -PermissionsToSecrets Get -PermissionsToCertificates Get
                    }
                }
            } else {
                # 3. Call Key Vault module: Grant key vault accsee policys
                foreach ($vault in $vaultArray) {
                    Set-AzKeyVaultAccessPolicy -VaultName $vault -ObjectId $systemAssigendPrincipalIndentity -PermissionsToSecrets Get -PermissionsToCertificates Get
                    foreach ($principal in $userAssignedPrincipalIndentity) {
                        Set-AzKeyVaultAccessPolicy -VaultName $vault -ObjectId $principal -PermissionsToSecrets Get -PermissionsToCertificates Get
                    }
                }
            }
        }
        else {
            $null = $PSBoundParameters.Remove('IdentityType')
            $null = $PSBoundParameters.Remove('IdentityUserAssignedIdentity')

            Write-Debug("Before calling Move-AzCdnProfile command...")
            Az.Cdn.internal\Move-AzCdnProfile @PSBoundParameters
        }
    }
}
function GetMigrateWafProperty {
    param (
        [string]$MigrateWafResourceId
    )

    Write-Debug("Get the property of the ID")
    return Get-AzFrontDoorWafPolicy -ResourceGroupName $MigrateWafResourceId.split("/")[4] -Name $MigrateWafResourceId.split("/")[8]
}


# Corresponding to "Copy to a new waf policy"
function CreateNewWafPolicy {
    param (
        [string]$ResourceGroupName,
        [string]$Name,
        [Microsoft.Azure.Commands.FrontDoor.Models.PSTrackedResource]$WafProperty,
        [bool]$ManagedRuleMigrateFromWaf
    )

    Write-Host("existManagedRuleMigrateFromWaf: " + $ManagedRuleMigrateFromWaf)
    if (${SkuName} -eq "Premium_AzureFrontDoor") {
        $sku = "Premium_AzureFrontDoor"
    } elseif ($ManagedRuleMigrateFromWaf) {
        $sku = "Premium_AzureFrontDoor"
    } else {
        $sku = "Standard_AzureFrontDoor"
    }

    # Remove the null/empty property
    $validatedWafProperty = ValidateMigrationWafPolicyProperty -WafProperty $WafProperty

    Write-Debug("begin new waf policy......")
    # New a waf policy, copied from the Migrtae
    New-AzFrontDoorWafPolicy -ResourceGroupName $ResourceGroupName -Name $Name -Sku $sku @validatedWafProperty
}

# Validate the property of a waf policy
function ValidateMigrationWafPolicyProperty {
    param (
        [Microsoft.Azure.Commands.FrontDoor.Models.PSTrackedResource]$WafProperty
    )

    Write-Host("WafProperty: " + $WafProperty)
    Write-Host("WafProperty custom rule: " + $WafProperty.CustomRules)
    Write-Host("wafProperty manage rule: " + $WafProperty.ManagedRules)

    $wafHash = @{}
    if ($WafProperty.PolicyEnabledState) {
        $wafHash.Add('EnabledState', $WafProperty.PolicyEnabledState)
    } 
    if ($WafProperty.PolicyMode) {
        $wafHash.Add('Mode', $WafProperty.PolicyMode)
    }
    if ($WafProperty.CustomRules) {
        $wafHash.Add('Customrule', $WafProperty.CustomRules)
    }
    if ($WafProperty.ManagedRules) {
        $wafHash.Add('ManagedRule', $WafProperty.ManagedRules)
    }
    if ($WafProperty.RedirectUrl) {
        $wafHash.Add('RedirectUrl', $WafProperty.RedirectUrl)
    }
    if ($WafProperty.CustomBlockResponseStatusCode) {
        $wafHash.Add('CustomBlockResponseStatusCode', $WafProperty.CustomBlockResponseStatusCode)
    }
    if ($WafProperty.CustomBlockResponseBody) {
        $wafHash.Add('CustomBlockResponseBody', $WafProperty.CustomBlockResponseBody)
    }
    if ($WafProperty.RequestBodyCheck) {
        $wafHash.Add('RequestBodyCheck', $WafProperty.RequestBodyCheck)
    }
    
    Write-Host("wafHash: " + $wafHash)
    Write-Host("wafHash custom rule: " + $wafHash.Customrule)
    Write-Host("wafHash manage rule: " + $wafHash.ManagedRule)

    return $wafHash
}
