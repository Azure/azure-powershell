// ----------------------------------------------------------------------------------
//
// Copyright Microsoft Corporation
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------------------------------------------------------------

namespace Microsoft.WindowsAzure.Commands.ServiceManagement.IaaS.Extensions.MicrosoftAntimalware
{
    using Microsoft.WindowsAzure.Commands.Common.Storage;
    using System;
    using System.IO;
    using System.Linq;
    using System.Management.Automation;
    using System.Text;
    using System.Xml;
    using WindowsAzure.Storage;
    using WindowsAzure.Storage.Auth;
    using Newtonsoft.Json.Schema;
    using Newtonsoft.Json.Linq;
    using Microsoft.WindowsAzure.Management.Storage;

    public class VirtualMachineMicrosoftAntimalwareExtensionCmdletBase : VirtualMachineExtensionCmdletBase
    {
        // Microsoft Antimalware 
        protected const string VirtualMachineMicrosoftAntimalwareExtensionNoun = "AzureVMMicrosoftAntimalwareExtension";
        protected const string MicrosoftAntimalwareExtensionNamespace = "Microsoft.Azure.Security";
        protected const string MicrosoftAntimalwareExtensionName = "IaaSAntimalware";
        protected const string MicrosoftAntimalwareExtensionReferenceName = "IaaSAntimalware";
        protected const string MicrosoftAntimalwareExtensionDefaultVersion = "1.*";
        protected const string MicrosoftAntimalwareExtensionPublicConfigurationTemplate = "{{ \"xmlCfg\": \"{0}\" }}";
        public virtual string AntimalwareConfigFile { get; set; }
        public virtual string AntimalwareConfiguration { get; set; }
        protected const string MicrosoftAntimalwareConfigJsonSchema = @"
{
    ""runtimeSettings"": [{
        ""handlerSettings"": {
            ""publicSettings"": {
                ""title"": ""MicrosoftAntimalwareConfig"",
                ""description"": ""Microsoft Antimalware Configuration"",
                ""type"": ""object"",
                ""properties"": {
                    ""AntimalwareEnabled"": { ""type"": ""boolean"", ""required"" : true },
                    ""RealtimeProtectionEnabled"": { ""type"": ""boolean"" },
                    ""ScheduledScanSettings"": {
                        ""type"": ""object"",
                        ""properties"": {
                            ""isEnabled"": { ""type"": ""boolean""},
                            ""day"": {""type"": ""integer""},
                            ""time"": {""type"": ""integer""},
                            ""scanType"": {""type"": ""string""}
                            },
                        ""additionalProperties"": false
                    },
                    ""Exclusions"": {
                        ""type"": ""object"",
                        ""properties"": {
                            ""Extensions"": {""type"": ""string""},
                            ""Paths"": {""type"": ""string""},
                            ""Processes"": {""type"": ""string""}
                        },
                        ""additionalProperties"": false
                    },
                }, 
                ""additionalProperties"": false
            }
        }		
    }]
}";

        // Microsoft Diagnostics
        protected const string DiagnosticsExtensionNamespace = "Microsoft.Azure.Diagnostics";
        protected const string DiagnosticsExtensionName = "IaaSDiagnostics";
        protected const string DiagnosticsExtensionReferenceName = "IaaSDiagnostics";
        protected const string DiagnosticsExtensionDefaultVersion = "1.*";
        protected const string DiagnosticsConfigXmlNamespace = @"http://schemas.microsoft.com/ServiceHosting/2010/10/DiagnosticsConfiguration";
        protected const string DiagnosticsConfigNodeName = "DiagnosticMonitorConfiguration";
        protected const string DiagnosticsConfigAntimalwareProviderToken = @"Microsoft Antimalware";
        protected const string DiagnosticsConfigWindowsEventLogNodeName = @"WindowsEventLog";
        protected const string StorageNameAttrStr = "name";

        protected const string DiagnosticsDefaultConfigNewXmlStr = @"<WadCfg><DiagnosticMonitorConfiguration><WindowsEventLog scheduledTransferPeriod=""PT1M""><DataSource name=""System!*[System[Provider[@Name='Microsoft Antimalware']]]"" /></WindowsEventLog></DiagnosticMonitorConfiguration></WadCfg>";
        protected const string DiagnosticsDefaultConfigMergeXmlWithoutExistingEventLogNode = @"<WindowsEventLog scheduledTransferPeriod=""PT1M""><DataSource name=""System!*[System[Provider[@Name='Microsoft Antimalware']]]"" /></WindowsEventLog>";
        protected const string DiagnosticsDefaultConfigMergeXmlWithExistingEventLogNode = @"<DataSource name=""System!*[System[Provider[@Name='Microsoft Antimalware']]]"" />";

        protected const string DiagnosticsPublicConfigFormatStr = @"{{ ""xmlCfg"":""{0}"", ""StorageAccount"":""{1}"" }}";
        protected const string DiagnosticsPrivateConfigFormatStr = @"{{ ""storageAccountName"":""{0}"",""storageAccountKey"":""{1}"",""storageAccountEndPoint"":""{2}""}}";
        public virtual XmlDocument AntimalwareMonitoringConfig { get; set; }
        public virtual AzureStorageContext StorageContext { get; set; }
        protected string monitoringStorageAccountName; // temporarily stores account name if provided in config file

        // NoConfig parameter allows the caller to turn monitoring on or off without specifying a config
        public virtual SwitchParameter NoConfig { get; set; }

        protected void InitializeAntimalwareSettings()
        {
            Publisher = MicrosoftAntimalwareExtensionNamespace;
            ExtensionName = MicrosoftAntimalwareExtensionName;
            ReferenceName = MicrosoftAntimalwareExtensionReferenceName;
            Version = this.Version ?? MicrosoftAntimalwareExtensionDefaultVersion;

            PublicConfiguration = AntimalwareConfiguration;
            PrivateConfiguration = null;
        }

        protected void InitializeMonitoringSettings()
        {
            Publisher = DiagnosticsExtensionNamespace;
            ExtensionName = DiagnosticsExtensionName;
            ReferenceName = DiagnosticsExtensionReferenceName;
            Version = this.Version ?? DiagnosticsExtensionDefaultVersion;
            PublicConfiguration = GetJsonEncodedDiagnosticsPublicConfig();
            PrivateConfiguration = GetJsonEncodedDiagnosticsPrivateConfig();
        }

        protected string GetJsonEncodedDiagnosticsPublicConfig()
        {
            return GetJsonEncodedDiagnosticsPublicConfig(DiagnosticsDefaultConfigNewXmlStr);
        }

        protected string GetJsonEncodedDiagnosticsPublicConfig(string wadCfgXml)
        {
            if (!string.IsNullOrWhiteSpace(wadCfgXml))
            {
                // initialize storage context
                if (!IsValidStorageContext() && !string.IsNullOrWhiteSpace(monitoringStorageAccountName))
                {
                    // try to initialize using monitoringStorageAccountName
                    InitializeStorageContext(monitoringStorageAccountName);
                }

                if (IsValidStorageContext())
                {
                    string wadCfgB64 = Convert.ToBase64String(Encoding.UTF8.GetBytes(wadCfgXml));
                    return string.Format(DiagnosticsPublicConfigFormatStr, wadCfgB64, StorageContext.StorageAccountName);
                }
                else
                {
                    // unable to obtain valid storage account name
                    return null;
                }
            }
            else
            {
                return null;
            }
        }

        protected string GetJsonEncodedDiagnosticsPrivateConfig()
        {
            if (IsValidStorageContext())
            {
                return string.Format(DiagnosticsPrivateConfigFormatStr,
                                        StorageContext.StorageAccountName,
                                        StorageContext.StorageAccount.Credentials.ExportBase64EncodedKey(),
                                        "https://" + StorageContext.EndPointSuffix);
            }
            else
            {
                return null;
            }
        }

        public VirtualMachineMicrosoftAntimalwareExtensionCmdletBase()
        {
            base.publisherName = MicrosoftAntimalwareExtensionNamespace;
            base.extensionName = MicrosoftAntimalwareExtensionName;
            base.ReferenceName = MicrosoftAntimalwareExtensionReferenceName;
        }

        protected string GetXmlCfgFromJson(string jsonConfig)
        {
            string xmlString = null;
            if (!string.IsNullOrWhiteSpace(jsonConfig))
            {
                try
                {
                    Newtonsoft.Json.Linq.JObject jObject = Newtonsoft.Json.Linq.JObject.Parse(jsonConfig);
                    string base64EncodedXml = (string)jObject["xmlCfg"];
                    if (!string.IsNullOrWhiteSpace(base64EncodedXml))
                    {
                        byte[] data = Convert.FromBase64String(base64EncodedXml);
                        xmlString = Encoding.UTF8.GetString(data);
                    }
                }
                catch (Exception)
                {
                }
            }
            return xmlString;
        }

        protected string GetStorageAccountNameFromJson(string jsonConfig)
        {
            string storageAccountName = null;
            if (!string.IsNullOrWhiteSpace(jsonConfig))
            {
                try
                {
                    Newtonsoft.Json.Linq.JObject jObject = Newtonsoft.Json.Linq.JObject.Parse(jsonConfig);
                    storageAccountName = (string)jObject["StorageAccount"];
                }
                catch (Exception)
                {
                }
            }
            return storageAccountName;
        }

        protected VirtualMachineMicrosoftAntimalwareExtensionContext GetDiagnosticsExtensionContext()
        {
            var extensionRefs =
                string.IsNullOrEmpty(ReferenceName) && string.IsNullOrEmpty(ExtensionName) ?
                ResourceExtensionReferences : GetPredicateExtensionList();

            return extensionRefs == null ? null : extensionRefs.Select(
                r => new VirtualMachineMicrosoftAntimalwareExtensionContext
                {
                    ExtensionName = r.Name,
                    Publisher = r.Publisher,
                    ReferenceName = r.ReferenceName,
                    Version = r.Version,
                    PublicConfiguration = IsLegacyExtension(r.Name, r.Publisher, r.Version) ? GetConfiguration(r) : GetConfiguration(r, PublicTypeStr),
                    State = r.State,
                    AntimalwareMonitoringConfiguration = GetXmlCfgFromJson(IsLegacyExtension(r.Name, r.Publisher, r.Version) ? GetConfiguration(r) : GetConfiguration(r, PublicTypeStr))
                }).Where(
                    r => r.ExtensionName == VirtualMachineMicrosoftAntimalwareExtensionCmdletBase.DiagnosticsExtensionName
                ).FirstOrDefault();
        }

        protected void RemoveExistingAntimalwareMonitoringConfig()
        {
            // this does not remove the diagnostics extension entirely, it only removes the portion of the 
            // diagnostics configuration that monitors antimalware events- everything else will remain 
            // in order to avoid doing harm to any other users who may be sharing the diagnostics extension 

            var ext = GetDiagnosticsExtensionContext();

            if (ext != null)
            {
                // add root element back to xml string (not preserved by diagnostics extension)
                string tmpXmlString = string.Format("<PublicConfig xmlns=\"{0}\">{1}</PublicConfig>", DiagnosticsConfigXmlNamespace, ext.AntimalwareMonitoringConfiguration);
                string AntimalwareDataSourceName = "System!*[System[Provider[@Name='Microsoft Antimalware']]]";

                XmlDocument tmpXmlDoc = new XmlDocument();
                tmpXmlDoc.LoadXml(tmpXmlString);

                // retrieve storage account name from public configuration
                monitoringStorageAccountName = GetStorageAccountNameFromJson(ext.PublicConfiguration);
                if (string.IsNullOrWhiteSpace(monitoringStorageAccountName))
                {
                    // do not modify diagnostics config without including the storage account
                    // throw terminating exception since it is not possible to preserve the 
                    // existing storage account with the configuration if it doesn't have a  
                    // hint to what the last storage account was in the public configuration 
                    ThrowTerminatingError(new ErrorRecord(
                        new Exception("ServiceExtensionExistingMonitoringConfigurationIsMissingStorageAccountNameElement"),
                        string.Empty,
                        ErrorCategory.InvalidData,
                        null));

                    return;
                }
                else
                {
                    InitializeStorageContext(monitoringStorageAccountName);
                }

                // locate the antimalware data source node in the document 
                string antimalwareDataSourceXPath = string.Format(@"//*[local-name()='{0}' and @name=""{1}"" and namespace-uri()='{2}']", "DataSource", AntimalwareDataSourceName, DiagnosticsConfigXmlNamespace);
                XmlNode antimalwareDataSourceNode = tmpXmlDoc.DocumentElement.SelectSingleNode(antimalwareDataSourceXPath);
                if (antimalwareDataSourceNode != null)
                {
                    XmlNode windowsEventLogNode = antimalwareDataSourceNode.ParentNode;
                    if (windowsEventLogNode.RemoveChild(antimalwareDataSourceNode) != null)
                    {
                        // remove the windows event log if there are no other child data sources present
                        // as will be required for schema validation to succeed when sending the new config
                        // any other data sources outside of the windows event log are left untouched 
                        if (!windowsEventLogNode.HasChildNodes)
                        {
                            windowsEventLogNode.ParentNode.RemoveChild(windowsEventLogNode);
                        }
                    }

                    // convert back to xml fragment, set configuration fields accordingly, add the extension
                    string configFrag = tmpXmlDoc.DocumentElement.InnerXml;
                    configFrag = configFrag.Replace(" xmlns=\"http://schemas.microsoft.com/ServiceHosting/2010/10/DiagnosticsConfiguration\"", "");
                    PublicConfiguration = GetJsonEncodedDiagnosticsPublicConfig(configFrag);
                    PrivateConfiguration = GetJsonEncodedDiagnosticsPrivateConfig();
                    RemovePredicateExtensions();
                    AddResourceExtension();
                }
                else
                {
                    // no existing antimalware data source was found needing removal
                    return;
                }
            }
        }

        protected void InitializeStorageContext(string storageAccountName)
        {
            // lookup storage account by name and retrieve key 
            var storageService = this.StorageClient.StorageAccounts.Get(storageAccountName);
            if (storageService == null)
            {
                ThrowTerminatingError(new ErrorRecord(
                    new Exception("ServiceExtensionCannotFindStorageAccountName"),
                    string.Empty,
                    ErrorCategory.InvalidData,
                    null));
            }
            var storageKeys = this.StorageClient.StorageAccounts.GetKeys(storageService.StorageAccount.Name);
            if (storageKeys == null || storageKeys.PrimaryKey == null || storageKeys.SecondaryKey == null)
            {
                ThrowTerminatingError(new ErrorRecord(
                    new Exception("ServiceExtensionCannotFindStorageAccountKey"),
                    string.Empty,
                    ErrorCategory.InvalidData,
                    null));
            }
            string storageAccountKey = storageKeys.PrimaryKey != null ? storageKeys.PrimaryKey : storageKeys.SecondaryKey;

            // now that key has been retrieved, initialize context and return
            StorageCredentials creds = new StorageCredentials(storageAccountName, storageAccountKey);
            CloudStorageAccount csa = new WindowsAzure.Storage.CloudStorageAccount(creds, true);
            StorageContext = new AzureStorageContext(csa);
        }


        protected bool IsValidStorageContext()
        {
            return ((StorageContext != null) &&
                      (!string.IsNullOrWhiteSpace(StorageContext.StorageAccountName)) &&
                      (!string.IsNullOrWhiteSpace(StorageContext.TableEndPoint)) &&
                      (!string.IsNullOrWhiteSpace(StorageContext.StorageAccount.Credentials.ExportBase64EncodedKey())));
        }

    }
}
