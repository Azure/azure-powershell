// ----------------------------------------------------------------------------------
//
// Copyright Microsoft Corporation
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------------------------------------------------------------

using System;
using System.Linq;
using System.Management.Automation;
using System.Xml;
using System.Xml.Linq;
using Microsoft.WindowsAzure.Commands.Common.Storage;
using Microsoft.WindowsAzure.Commands.ServiceManagement.Properties;
using Microsoft.WindowsAzure.Management.Compute;
using Microsoft.WindowsAzure.Management.Compute.Models;
using Microsoft.WindowsAzure.Storage;
using Microsoft.WindowsAzure.Storage.Auth;
using Microsoft.WindowsAzure.Management.Storage;

namespace Microsoft.WindowsAzure.Commands.ServiceManagement.Extensions
{
    public abstract class BaseAzureServiceAntimalwareExtensionCmdlet : BaseAzureServiceExtensionCmdlet
    {
        // this cmdlet sets the antimalware extension that the user requests to enable and use via config setting
        // if monitoring is set to "on", the diagnostics extension will also configure monitoring of antimalware event data

        // shared
        protected ExtensionConfigurationInput AntimalwareExtensionConfigurationInput { get; set; }
        protected ExtensionConfigurationInput AntimalwareMonitoringExtensionConfigurationInput { get; set; }

        // antimalware
        protected const string AntimalwareConfigElementName = "AntimalwareConfig";
        protected const string AntimalwareExtensionProviderNamespace = "Microsoft.Azure.Security";
        protected const string AntimalwareExtensionName = "PaaSAntimalware";
        public virtual XmlDocument AntimalwareConfiguration { get; set; }

        protected const string AntimalwareConfigurationXsd =
@"<?xml version=""1.0"" encoding=""utf-8""?>
<xs:schema xmlns:xs=""http://www.w3.org/2001/XMLSchema"">
    <xs:element name=""AntimalwareConfig"">
        <xs:complexType>
            <xs:all>
                <xs:element name=""AntimalwareEnabled"" type=""xs:boolean"" minOccurs=""0""/>
                <xs:element name=""RealtimeProtectionEnabled"" type=""xs:boolean"" minOccurs=""0""/>
                <xs:element name=""ScheduledScanSettings"" minOccurs=""0"" maxOccurs=""1"">
                    <xs:complexType>
                        <xs:attribute name=""isEnabled"" type=""xs:boolean""/>
                        <xs:attribute name=""day"" type=""xs:int""/>
                        <xs:attribute name=""time"" type=""xs:int""/>
                        <xs:attribute name=""scanType"">
                            <xs:simpleType>
                                <xs:restriction base=""xs:string"">
                                    <xs:enumeration value=""Quick""/>
                                    <xs:enumeration value=""Full""/>
                                </xs:restriction>
                            </xs:simpleType>
                        </xs:attribute>
                    </xs:complexType>
                </xs:element>
                <xs:element name=""Exclusions"" minOccurs=""0"" maxOccurs=""1"">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name=""Extensions"" minOccurs=""0"" maxOccurs=""1"">
                                <xs:complexType>
                                    <xs:sequence>
                                        <xs:element name=""Extension"" nillable=""true"" minOccurs=""0"" maxOccurs=""unbounded"">
                                            <xs:complexType>
                                                <xs:simpleContent>
                                                    <xs:extension base=""xs:string"">
                                                    </xs:extension>
                                                </xs:simpleContent>
                                            </xs:complexType>
                                        </xs:element>
                                    </xs:sequence>
                                </xs:complexType>
                            </xs:element>
                            <xs:element name=""Paths"" minOccurs=""0"" maxOccurs=""1"">
                                <xs:complexType>
                                    <xs:sequence>
                                        <xs:element name=""Path"" nillable=""true"" minOccurs=""0"" maxOccurs=""unbounded"">
                                            <xs:complexType>
                                                <xs:simpleContent>
                                                    <xs:extension base=""xs:string"">
                                                    </xs:extension>
                                                </xs:simpleContent>
                                            </xs:complexType>
                                        </xs:element>
                                    </xs:sequence>
                                </xs:complexType>
                            </xs:element>
                            <xs:element name=""Processes"" minOccurs=""0"" maxOccurs=""1"">
                                <xs:complexType>
                                    <xs:sequence>
                                        <xs:element name=""Process"" nillable=""true"" minOccurs=""0"" maxOccurs=""unbounded"">
                                            <xs:complexType>
                                                <xs:simpleContent>
                                                    <xs:extension base=""xs:string"">
                                                    </xs:extension>
                                                </xs:simpleContent>
                                            </xs:complexType>
                                        </xs:element>
                                    </xs:sequence>
                                </xs:complexType>
                            </xs:element>
                        </xs:sequence>
                    </xs:complexType>
                </xs:element>
                <xs:element name=""StorageAccountName"" type=""xs:string"" minOccurs=""0""/>
                <xs:element name=""Monitoring"" type=""xs:string"" minOccurs=""0""/>
            </xs:all>
        </xs:complexType>
    </xs:element>
</xs:schema>";

        // diagnostics
        protected const string StorageAccountElemStr = "StorageAccount";
        protected const string AntimalwareDiagnosticsExtensionNamespace = "Microsoft.Azure.Diagnostics";
        protected const string AntimalwareDiagnosticsExtensionName = "PaaSDiagnostics";
        protected const string DiagnosticsConfigXmlNamespace = @"http://schemas.microsoft.com/ServiceHosting/2010/10/DiagnosticsConfiguration";
        protected const string DiagnosticsConfigElementName = "WadCfg";
        protected const string DiagnosticsConfigNodeName = "DiagnosticMonitorConfiguration";
        protected const string DiagnosticsConfigAntimalwareProviderToken = @"Microsoft Antimalware";
        protected const string DiagnosticsConfigWindowsEventLogNodeName = @"WindowsEventLog";
        protected const string StorageNameAttrStr = "name";

        protected const string DiagnosticsDefaultConfigNewXmlStr = @"<DiagnosticMonitorConfiguration><WindowsEventLog scheduledTransferPeriod=""PT1M""><DataSource name=""System!*[System[Provider[@Name='Microsoft Antimalware']]]"" /></WindowsEventLog></DiagnosticMonitorConfiguration>";
        protected const string DiagnosticsDefaultConfigMergeXmlWithoutExistingEventLogNode = @"<WindowsEventLog scheduledTransferPeriod=""PT1M""><DataSource name=""System!*[System[Provider[@Name='Microsoft Antimalware']]]"" /></WindowsEventLog>";
        protected const string DiagnosticsDefaultConfigMergeXmlWithExistingEventLogNode = @"<DataSource name=""System!*[System[Provider[@Name='Microsoft Antimalware']]]"" />";
        public virtual XmlDocument AntimalwareMonitoringConfig { get; set; }
        
        public virtual AzureStorageContext StorageContext { get; set; }

        public BaseAzureServiceAntimalwareExtensionCmdlet()
            : base()
        {
        }

        protected void InitializeAntimalwareSettings()
        {
            ProviderNamespace = AntimalwareExtensionProviderNamespace;
            ExtensionName = AntimalwareExtensionName;

            // public configuration 
            if (AntimalwareConfiguration != null)
            {
                PublicConfiguration = AntimalwareConfiguration.OuterXml;
            }
            else
            {
                PublicConfiguration = null;
            }
        }

        protected void InitializeStorageContext(string storageAccountName)
        {
            // lookup storage account by name and retrieve key 
            var storageService = this.StorageClient.StorageAccounts.Get(storageAccountName);
            if (storageService == null)
            {
                ThrowTerminatingError(new ErrorRecord(
                    new Exception("ServiceExtensionCannotFindStorageAccountName"),
                    string.Empty,
                    ErrorCategory.InvalidData,
                    null));
            }
            var storageKeys = this.StorageClient.StorageAccounts.GetKeys(storageService.StorageAccount.Name);
            if (storageKeys == null || storageKeys.PrimaryKey == null || storageKeys.SecondaryKey == null)
            {
                ThrowTerminatingError(new ErrorRecord(
                    new Exception("ServiceExtensionCannotFindStorageAccountKey"),
                    string.Empty,
                    ErrorCategory.InvalidData,
                    null));
            }
            string storageAccountKey = storageKeys.PrimaryKey != null ? storageKeys.PrimaryKey : storageKeys.SecondaryKey;

            // now that key has been retrieved, initialize context and return
            StorageCredentials creds = new StorageCredentials(storageAccountName, storageAccountKey);
            CloudStorageAccount csa = new WindowsAzure.Storage.CloudStorageAccount(creds, true);
            StorageContext = new AzureStorageContext(csa);
        }

        protected void InitializeDiagnosticsSettings()
        {
            ProviderNamespace = AntimalwareDiagnosticsExtensionNamespace;
            ExtensionName = AntimalwareDiagnosticsExtensionName;

            // public configuration 
            XNamespace configNameSpace = DiagnosticsConfigXmlNamespace;
            PublicConfigurationXml = new XDocument(
                new XDeclaration("1.0", "utf-8", null),
                    new XElement(configNameSpace + PublicConfigStr,
                        new XElement(configNameSpace + DiagnosticsConfigElementName, string.Empty),
                        new XElement(configNameSpace + StorageAccountElemStr, StorageContext.StorageAccountName)
                )
            );

            if (AntimalwareMonitoringConfig == null)
            {
                XmlDocument amCfgXmlDoc = new XmlDocument();
                amCfgXmlDoc.LoadXml(DiagnosticsDefaultConfigNewXmlStr);
                AntimalwareMonitoringConfig = amCfgXmlDoc;
            }

            SetPublicConfigValue(DiagnosticsConfigElementName, AntimalwareMonitoringConfig);
            PublicConfiguration = PublicConfigurationXml.ToString();

            // add storage account name to private configuration if applicable
            if (IsValidStorageContext())
            {
                PrivateConfigurationXml = new XDocument(
                    new XDeclaration("1.0", "utf-8", null),
                    new XElement(configNameSpace + PrivateConfigStr,
                        new XElement(configNameSpace + StorageAccountElemStr,
                        new XAttribute("name", StorageContext.StorageAccountName),
                        new XAttribute("key", StorageContext.StorageAccount.Credentials.ExportBase64EncodedKey())
                    ))
                );
            }
            else
            {
                // provide custom endpoint suffix to diagnostics extension
                PrivateConfigurationXml = new XDocument(
                    new XDeclaration("1.0", "utf-8", null),
                    new XElement(configNameSpace + PrivateConfigStr,
                        new XElement(configNameSpace + StorageAccountElemStr,
                        new XAttribute("name", StorageContext.StorageAccountName),
                        new XAttribute("key", StorageContext.StorageAccount.Credentials.ExportBase64EncodedKey()),
                        new XAttribute("endpoint", "https://" + StorageContext.EndPointSuffix)
                    ))
                );
            }
            PrivateConfiguration = PrivateConfigurationXml.ToString();
        }

        protected bool IsValidStorageContext()
        {
            return ((StorageContext != null) &&
                      (!string.IsNullOrWhiteSpace(StorageContext.StorageAccountName)) &&
                      (!string.IsNullOrWhiteSpace(StorageContext.TableEndPoint)) &&
                      (!string.IsNullOrWhiteSpace(StorageContext.StorageAccount.Credentials.ExportBase64EncodedKey())));
        }

        protected void RemoveAntimalwareExtension()
        {
            ProviderNamespace = AntimalwareExtensionProviderNamespace;
            ExtensionName = AntimalwareExtensionName;

            ExtensionConfigurationBuilder configBuilder = ExtensionManager.GetBuilder(Deployment != null ? Deployment.ExtensionConfiguration : null);
            if (UninstallConfiguration && configBuilder.ExistAny(ProviderNamespace, ExtensionName))
            {
                configBuilder.RemoveAny(ProviderNamespace, ExtensionName);
                WriteWarning(string.Format(Resources.ServiceExtensionRemovingFromAllRoles, ExtensionName, ServiceName));
                ChangeDeployment(configBuilder.ToConfiguration());
            }
            else if (configBuilder.Exist(Role, ProviderNamespace, ExtensionName))
            {
                configBuilder.Remove(Role, ProviderNamespace, ExtensionName);
                if (Role == null || !Role.Any())
                {
                    WriteWarning(string.Format(Resources.ServiceExtensionRemovingFromAllRoles, ExtensionName, ServiceName));
                }
                else
                {
                    bool defaultExists = configBuilder.ExistDefault(ProviderNamespace, ExtensionName);
                    foreach (var r in Role)
                    {
                        WriteWarning(string.Format(Resources.ServiceExtensionRemovingFromSpecificRoles, ExtensionName, r, ServiceName));
                        if (defaultExists)
                        {
                            WriteWarning(string.Format(Resources.ServiceExtensionRemovingSpecificAndApplyingDefault, ExtensionName, r));
                        }
                    }
                }

                ChangeDeployment(configBuilder.ToConfiguration());
            }
            else
            {
                WriteWarning(string.Format(Resources.ServiceExtensionNoExistingExtensionsEnabledOnRoles, ProviderNamespace, ExtensionName));
            }
        }

        protected HostedServiceListExtensionsResponse.Extension GetDiagnosticsExtension()
        {
            return (from e in this.ComputeClient.HostedServices.ListExtensions(ServiceName).Extensions
                    where
                        e.ProviderNamespace == AntimalwareDiagnosticsExtensionNamespace
                        && e.Type == AntimalwareDiagnosticsExtensionName
                    select e).LastOrDefault();
        }

        protected HostedServiceListExtensionsResponse.Extension GetAntimalwareExtension()
        {
            return (from e in this.ComputeClient.HostedServices.ListExtensions(ServiceName).Extensions
                    where
                        e.ProviderNamespace == AntimalwareExtensionProviderNamespace
                        && e.Type == AntimalwareExtensionName
                    select e).LastOrDefault();
        }

        protected void RemoveExistingAntimalwareMonitoringConfig()
        {
            // this does not remove the diagnostics extension entirely, it only removes the portion of the 
            // diagnostics configuration that monitors antimalware events- everything else will remain 
            // in order to avoid doing harm to any other users who may be sharing the diagnostics extension 

            var ext = GetDiagnosticsExtension();
            if (ext != null)
            {
                string tmpXmlString = ext.PublicConfiguration;
                string AntimalwareDataSourceName = "System!*[System[Provider[@Name='Microsoft Antimalware']]]";
                string DiagnosticsConfigXmlNamespace = @"http://schemas.microsoft.com/ServiceHosting/2010/10/DiagnosticsConfiguration";
                string monitoringStorageAccountName = null; // for temporarily retrieving storage account name when specified in config file

                // remove the data source element with the antimalware event provider 
                XmlDocument tmpXmlDoc = new XmlDocument();
                tmpXmlDoc.LoadXml(tmpXmlString);

                // retrieve storage account name from public configuration
                string stgAcctNameXPath = string.Format(@"//*[local-name()='{0}' and namespace-uri()='{1}']", StorageAccountElemStr, DiagnosticsConfigXmlNamespace);
                XmlNode stgAcctNameNode = tmpXmlDoc.DocumentElement.SelectSingleNode(stgAcctNameXPath);
                if (stgAcctNameNode != null)
                {
                    monitoringStorageAccountName = stgAcctNameNode.InnerText;
                }
                if (string.IsNullOrWhiteSpace(monitoringStorageAccountName))
                {
                    // do not modify diagnostics config without including the storage account
                    // throw terminating exception since it is not possible to preserve the 
                    // existing storage account with the configuration if it doesn't have a  
                    // hint to what the last storage account was in the public configuration 
                    ThrowTerminatingError(new ErrorRecord(
                        new Exception(Resources.ServiceExtensionCannotFindStorageAccountName),
                        string.Empty,
                        ErrorCategory.InvalidData,
                        null));

                    return;
                }
                else
                {
                    // check the storage account and initialize for use
                    InitializeStorageContext(monitoringStorageAccountName);
                }

                // locate the antimalware data source node in the document 
                string antimalwareDataSourceXPath = string.Format(@"//*[local-name()='{0}' and @name=""{1}"" and namespace-uri()='{2}']", "DataSource", AntimalwareDataSourceName, DiagnosticsConfigXmlNamespace);
                XmlNode antimalwareDataSourceNode = tmpXmlDoc.DocumentElement.SelectSingleNode(antimalwareDataSourceXPath);
                if (antimalwareDataSourceNode != null)
                {
                    XmlNode windowsEventLogNode = antimalwareDataSourceNode.ParentNode;
                    if (windowsEventLogNode.RemoveChild(antimalwareDataSourceNode) != null)
                    {
                        // remove the windows event log if there are no other child data sources present
                        // as will be required for schema validation to succeed when sending the new config
                        // any other data sources outside of the windows event log are left untouched 
                        if (!windowsEventLogNode.HasChildNodes)
                        {
                            windowsEventLogNode.ParentNode.RemoveChild(windowsEventLogNode);
                        }
                    }

                    // now reinstall the diagnostics extension with the updated configuration
                    InitializeDiagnosticsSettings();
                    ExtensionConfigurationInput diagExtConfigInput = new ExtensionConfigurationInput
                    {
                        ProviderNameSpace = ProviderNamespace,
                        Type = ExtensionName,
                        CertificateThumbprint = CertificateThumbprint,
                        ThumbprintAlgorithm = ThumbprintAlgorithm,
                        X509Certificate = X509Certificate,
                        PublicConfiguration = tmpXmlDoc.OuterXml,
                        PrivateConfiguration = PrivateConfiguration,
                        Roles = new ExtensionRoleList(Role != null && Role.Any() ? Role.Select(r => new ExtensionRole(r)) : Enumerable.Repeat(new ExtensionRole(), 1))
                    };
                    AntimalwareMonitoringExtensionConfigurationInput = diagExtConfigInput;
                }
                else
                {
                    // no existing antimalware data source was found needing removal
                    return;
                }
            }
        }
    }
}
