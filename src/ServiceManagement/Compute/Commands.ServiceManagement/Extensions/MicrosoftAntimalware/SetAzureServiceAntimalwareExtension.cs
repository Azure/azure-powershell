// ----------------------------------------------------------------------------------
//
// Copyright Microsoft Corporation
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------------------------------------------------------------

using System;
using System.IO;
using System.Linq;
using System.Management.Automation;
using System.Xml;
using System.Xml.Schema;
using Microsoft.WindowsAzure.Commands.Common.Storage;
using Microsoft.WindowsAzure.Commands.ServiceManagement.Properties;
using Microsoft.WindowsAzure.Commands.Utilities.Common;
using Microsoft.WindowsAzure.Management.Compute.Models;

namespace Microsoft.WindowsAzure.Commands.ServiceManagement.Extensions
{
    // to invoke script from within cmdlet 
    using PVM = Model;

    /// <summary>
    /// Set Microsoft Azure Service Antimalware Extension.
    /// </summary>
    [Cmdlet(VerbsCommon.Set, "AzureServiceAntimalwareExtension", DefaultParameterSetName = SetExtensionParameterSetName), OutputType(typeof(ManagementOperationContext))]
    public class SetAzureServiceAntimalwareExtensionCommand : BaseAzureServiceAntimalwareExtensionCmdlet
    {
        [Parameter(Position = 0, ValueFromPipelineByPropertyName = true, Mandatory = true, ParameterSetName = SetExtensionParameterSetName, HelpMessage = ExtensionParameterPropertyHelper.ServiceNameHelpMessage)]
        [Parameter(Position = 0, ValueFromPipelineByPropertyName = true, Mandatory = true, ParameterSetName = SetExtensionUsingThumbprintParameterSetName, HelpMessage = ExtensionParameterPropertyHelper.ServiceNameHelpMessage)]
        [ValidateNotNullOrEmpty]
        public override string ServiceName { get; set; }

        [Parameter(Position = 1, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = SetExtensionParameterSetName, HelpMessage = ExtensionParameterPropertyHelper.SlotHelpMessage)]
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = SetExtensionUsingThumbprintParameterSetName, HelpMessage = ExtensionParameterPropertyHelper.SlotHelpMessage)]
        [ValidateSet(PVM.DeploymentSlotType.Production, PVM.DeploymentSlotType.Staging, IgnoreCase = true)]
        public override string Slot { get; set; }

        [Parameter(Position = 2, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = SetExtensionParameterSetName, HelpMessage = ExtensionParameterPropertyHelper.RoleHelpMessage)]
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = SetExtensionUsingThumbprintParameterSetName, HelpMessage = ExtensionParameterPropertyHelper.RoleHelpMessage)]
        [ValidateNotNullOrEmpty]
        public override string[] Role { get; set; }

        [Parameter(Position = 3, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = SetExtensionParameterSetName, HelpMessage = "The Antimalware Configuration cannot be null or empty and must include at a minimum <AntimalwareConfig><AntimalwareEnabled>true</AntimalwareEnabled></AntimalwareConfig> to enable Microsoft Antimalware.")]
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = SetExtensionUsingThumbprintParameterSetName, HelpMessage = "The Antimalware Configuration cannot be null or empty and must include at a minimum <AntimalwareConfig><AntimalwareEnabled>true</AntimalwareEnabled></AntimalwareConfig> to enable Microsoft Antimalware.")]
        [ValidateNotNullOrEmpty]
        public override XmlDocument AntimalwareConfiguration { get; set; }

        [Parameter(Position = 4, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = SetExtensionParameterSetName, HelpMessage = "Monitoring (ON = antimalware events logged to storage, OFF = no event logging)")]
        [Parameter(Position = 4, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = SetExtensionUsingThumbprintParameterSetName, HelpMessage = "Monitoring (ON = antimalware events logged to storage, OFF = no event logging)")]
        [ValidateSet("ON", "OFF", IgnoreCase = true)]
        public string Monitoring { get; set; }

        [Parameter(Position = 5, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = SetExtensionParameterSetName, HelpMessage = "Microsoft Antimalware Monitoring Storage Context")]
        [Parameter(Position = 5, ValueFromPipelineByPropertyName = true, Mandatory = false, ParameterSetName = SetExtensionUsingThumbprintParameterSetName, HelpMessage = "Microsoft Antimalware Monitoring Storage Context")]
        [ValidateNotNullOrEmpty]
        public override AzureStorageContext StorageContext { get; set; }

        private bool isAntimalwareEnabled = false;   // do not enable antimalware unless specified in configuration or parameters
        private enum MonitoringActionType { Enable, Disable, NoActionRequested } ;
        private MonitoringActionType monitoringAction = MonitoringActionType.NoActionRequested; // default to no action requested until identified in config or parameter

        private string monitoringStorageAccountName; // for retrieving storage account name when specified in config file

        protected override void ValidateParameters()
        {
            base.ValidateParameters();
            ValidateService();
            ValidateDeployment();
            ValidateRoles();
            ValidateThumbprint(true);
            ValidateConfiguration();
        }

        private void AddNewAntimalwareMonitoringConfig()
        {
            // install diagnostics provider with a new antimalware event monitoring config
            InitializeDiagnosticsSettings();
            ExtensionConfigurationInput diagExtConfigInput = new ExtensionConfigurationInput
            {
                ProviderNameSpace = ProviderNamespace,
                Type = ExtensionName,
                CertificateThumbprint = CertificateThumbprint,
                ThumbprintAlgorithm = ThumbprintAlgorithm,
                X509Certificate = X509Certificate,
                PublicConfiguration = PublicConfiguration,
                PrivateConfiguration = PrivateConfiguration,
                Roles = new ExtensionRoleList(Role != null && Role.Any() ? Role.Select(r => new ExtensionRole(r)) : Enumerable.Repeat(new ExtensionRole(), 1))
            };
            AntimalwareMonitoringExtensionConfigurationInput = diagExtConfigInput;
        }

        private void MergeAntimalwareMonitoringIntoExistingConfig(string existingConfigXmlStr)
        {
            // prepare a new xml document to hold the merged config
            XmlDocument mergedConfig = new XmlDocument();
            mergedConfig.LoadXml(existingConfigXmlStr);

            // check if old config already contains a WindowsEventLog section
            string targetNode;
            string mergeXmlStr;
            if (existingConfigXmlStr.Contains(DiagnosticsConfigWindowsEventLogNodeName))
            {
                // inject into the existing windows event log section 
                targetNode = DiagnosticsConfigWindowsEventLogNodeName;
                mergeXmlStr = DiagnosticsDefaultConfigMergeXmlWithExistingEventLogNode;
            }
            else
            {
                // inject a windows event log section with antimalware monitoring into the diagnostics config 
                targetNode = DiagnosticsConfigNodeName;
                mergeXmlStr = DiagnosticsDefaultConfigMergeXmlWithoutExistingEventLogNode;
            }

            // locate the desired target using xpath 
            string diagXPathStr = String.Format("//*[local-name()='{0}' and namespace-uri()='{1}']", targetNode, DiagnosticsConfigXmlNamespace);
            XmlNode diagNode = mergedConfig.DocumentElement.SelectSingleNode(diagXPathStr);

            // create an import node and then append to the correct location
            XmlDocument diagnosticsConfigXml = new XmlDocument();
            diagnosticsConfigXml.LoadXml(mergeXmlStr);

            XmlNode importNode = mergedConfig.ImportNode(diagnosticsConfigXml.DocumentElement, true);
            diagNode.AppendChild(importNode);

            // Note : Currently any pre-existing user of the diagnostics configuration will be expected 
            // to follow convention of specifying storage account name in the xml configuration so that 
            // it can be persisted across configuration changes being made by multiple users. 

            // remove any stray xmlns="" attribute from xml string prior to use 
            string mergedConfiguration = mergedConfig.OuterXml.Replace(@"xmlns=""""", "");

            // set up for reinstall of the extension with the new configuration
            InitializeDiagnosticsSettings();
            AntimalwareMonitoringExtensionConfigurationInput = new ExtensionConfigurationInput
            {
                ProviderNameSpace = ProviderNamespace,
                Type = ExtensionName,
                CertificateThumbprint = CertificateThumbprint,
                ThumbprintAlgorithm = ThumbprintAlgorithm,
                X509Certificate = X509Certificate,
                PublicConfiguration = mergedConfiguration,
                PrivateConfiguration = PrivateConfiguration,
                Roles = new ExtensionRoleList(Role != null && Role.Any() ? Role.Select(r => new ExtensionRole(r)) : Enumerable.Repeat(new ExtensionRole(), 1))
            };

        }

        protected void SaveMonitoringConfiguration(string publicConfiguration)
        {
            // load the public configuration xml string for parsing
            StringReader stringReader = new StringReader(publicConfiguration);
            XmlReaderSettings settings = new XmlReaderSettings();
            settings.DtdProcessing = DtdProcessing.Prohibit;
            settings.XmlResolver = null;
            XmlReader xmlReader = XmlReader.Create(stringReader, settings);
            XmlDocument currCfg = new XmlDocument();
            currCfg.Load(xmlReader);

            // extract the monitoring config portion, convert to string, strip namespace 
            string xpath = String.Format("//*[local-name()='{0}' and namespace-uri()='{1}']", DiagnosticsConfigElementName, DiagnosticsConfigXmlNamespace);
            string monCfgStr = currCfg.DocumentElement.SelectSingleNode(xpath).InnerXml;
            monCfgStr = monCfgStr.Replace(" xmlns=\"" + DiagnosticsConfigXmlNamespace + "\"", "");

            // load the extracted configuration into AntimalwareMonitoringConfig
            stringReader = new StringReader(monCfgStr);
            xmlReader = XmlReader.Create(stringReader, settings);
            AntimalwareMonitoringConfig = new XmlDocument();
            AntimalwareMonitoringConfig.Load(xmlReader);
        }

        protected void EnableMonitoring()
        {
            // retrieve any pre-existing diagnostics extension
            var ext = GetDiagnosticsExtension();

            if ( (ext == null) && 
                 ((monitoringAction==MonitoringActionType.Disable) || (monitoringAction == MonitoringActionType.NoActionRequested)) )
            {
                // if there was no pre-existing diagnostics extension there is 
                // nothing to do in either of these two cases so exit early 

                // note the user may not have provided a storage account either
                // so this check is performed prior to storage account validation                
                return;   
            }

            // establish the storage account name to be associated with monitoring
            if (!IsValidStorageContext() && (!string.IsNullOrWhiteSpace(monitoringStorageAccountName)))
            {
                // no valid storage context exists, try to initialize storage context using provided account name
                InitializeStorageContext(monitoringStorageAccountName);
            }

            if (!IsValidStorageContext())
            {
                // still unable to associate the storage account name with a valid storage context
                ThrowTerminatingError(new ErrorRecord(
                            new Exception("Required storage context is missing or invalid"),
                            string.Empty,
                            ErrorCategory.InvalidData,
                            null));
            }

            if (ext != null)
            {
                // save the current configuration of the diagnostics extension
                // in the event we do not end up needing to modify it but need
                // to persist the config in the final call to change deployment 
                InitializeDiagnosticsSettings();
                AntimalwareMonitoringExtensionConfigurationInput = new ExtensionConfigurationInput
                {
                    ProviderNameSpace = ProviderNamespace,
                    Type = ExtensionName,
                    CertificateThumbprint = CertificateThumbprint,
                    ThumbprintAlgorithm = ThumbprintAlgorithm,
                    X509Certificate = X509Certificate,
                    PublicConfiguration = ext.PublicConfiguration,
                    PrivateConfiguration = PrivateConfiguration,
                    Roles = new ExtensionRoleList(Role != null && Role.Any() ? Role.Select(r => new ExtensionRole(r)) : Enumerable.Repeat(new ExtensionRole(), 1))
                };
            }

            switch (monitoringAction)
            {
                case (MonitoringActionType.Enable) :
                    if (ext == null)
                    {
                        AddNewAntimalwareMonitoringConfig();
                    }
                    else
                    {
                        // extension already exists, check to see if it already contains antimalware data source
                        if (!ext.PublicConfiguration.Contains(DiagnosticsConfigAntimalwareProviderToken))
                        {
                            // antimalware data source is not already in the configuration, merge it 
                            // with existing config (tracking perf counters, other event logs, etc.)
                            MergeAntimalwareMonitoringIntoExistingConfig(ext.PublicConfiguration);
                        }
                        else
                        {
                            // in this case we preserve monitoring configuration but
                            // apply any changes to storage context that may be needed

                            SaveMonitoringConfiguration(ext.PublicConfiguration);
                            InitializeDiagnosticsSettings();
                            AntimalwareMonitoringExtensionConfigurationInput = new ExtensionConfigurationInput
                            {
                                ProviderNameSpace = ProviderNamespace,
                                Type = ExtensionName,
                                CertificateThumbprint = CertificateThumbprint,
                                ThumbprintAlgorithm = ThumbprintAlgorithm,
                                X509Certificate = X509Certificate,
                                PublicConfiguration = PublicConfiguration,
                                PrivateConfiguration = PrivateConfiguration,
                                Roles = new ExtensionRoleList(Role != null && Role.Any() ? Role.Select(r => new ExtensionRole(r)) : Enumerable.Repeat(new ExtensionRole(), 1))
                            };
                        }
                    }
                    break;

                case (MonitoringActionType.Disable) :
                    if (ext != null)
                    {
                        RemoveExistingAntimalwareMonitoringConfig();
                    }
                    break;

                case (MonitoringActionType.NoActionRequested) :
                    break;

                default: 
                    break;
            }
        }

        private void ValidateAntimalwareConfigToXsd()
        {
            if ((AntimalwareConfiguration != null) && (!string.IsNullOrWhiteSpace(AntimalwareConfiguration.OuterXml)))
            {
                // load the xsd
                StringReader xsdStringReader = new StringReader(AntimalwareConfigurationXsd);
                XmlSchema antimalwareXsd = XmlSchema.Read(xsdStringReader, ValidationHandler);
                string testXml = AntimalwareConfiguration.OuterXml;

                XmlReaderSettings settings = new XmlReaderSettings();
                settings.DtdProcessing = DtdProcessing.Prohibit;
                settings.XmlResolver = null;
                settings.CloseInput = true;
                settings.ValidationEventHandler += ValidationHandler;
                settings.ValidationType = ValidationType.Schema;
                settings.Schemas.Add(antimalwareXsd);
                settings.ValidationFlags =
                     XmlSchemaValidationFlags.ReportValidationWarnings |
                XmlSchemaValidationFlags.ProcessIdentityConstraints |
                XmlSchemaValidationFlags.ProcessInlineSchema |
                XmlSchemaValidationFlags.ProcessSchemaLocation;

                StringReader r = new StringReader(testXml);
                using (XmlReader validatingReader = XmlReader.Create(r, settings))
                {
                    while (validatingReader.Read()) { /* just loop through document */ }
                }
            }
        }

        private void ValidationHandler(object sender, ValidationEventArgs e)
        {            
            if (e.Severity == XmlSeverityType.Error || e.Severity == XmlSeverityType.Warning)
            {
                string validationErrorText = String.Format("XML Schema Validation Failed - Line: {0}, Position: {1} \"{2}\"",e.Exception.LineNumber, e.Exception.LinePosition, e.Exception.Message);
                ThrowTerminatingError(new ErrorRecord(
                    new Exception(validationErrorText),
                    string.Empty,
                    ErrorCategory.InvalidData,
                    null));
            }
        }

        protected override void ValidateConfiguration()
        {
            // read values from xml file if provided
            if (AntimalwareConfiguration != null)
            {
                // validate conformance to schema
                ValidateAntimalwareConfigToXsd();

                // check for antimalware enabled 
                XmlNode antimalwareEnabledNode = AntimalwareConfiguration.SelectSingleNode("//AntimalwareConfig/AntimalwareEnabled");
                if ((antimalwareEnabledNode != null) && (antimalwareEnabledNode.InnerText != null))
                {
                    isAntimalwareEnabled = antimalwareEnabledNode.InnerText.ToUpperInvariant().Equals("TRUE");
                }

                // check for monitoring enabled 
                XmlNode monitoringNode = AntimalwareConfiguration.SelectSingleNode("//AntimalwareConfig/Monitoring");
                if (monitoringNode != null)
                {
                    if (monitoringNode.InnerText != null)
                    {
                        switch (monitoringNode.InnerText.ToUpperInvariant())
                        {
                            case "ON": monitoringAction = MonitoringActionType.Enable; break;
                            case "OFF": monitoringAction = MonitoringActionType.Disable; break;
                            default: break;
                        }    
                    }

                    // now remove the monitoring node from the xml document since it 
                    // is not recognized by the schema used by the antimalware extension
                    monitoringNode.ParentNode.RemoveChild(monitoringNode);
                }

                // check for storage account name if present in the config file
                XmlNode storageAccountNameNode = AntimalwareConfiguration.SelectSingleNode("//AntimalwareConfig/StorageAccountName");
                if (storageAccountNameNode != null)
                {
                    if (storageAccountNameNode.InnerText != null)
                    {
                        monitoringStorageAccountName = storageAccountNameNode.InnerText;
                    }
                    // strip this node from the xml prior to passing to antimalware extension
                    storageAccountNameNode.ParentNode.RemoveChild(storageAccountNameNode);
                }

                // error if configuration does not opt in to enable antimalware 
                if (!isAntimalwareEnabled)
                {
                    ThrowTerminatingError(new ErrorRecord(
                                new Exception(Resources.ServiceExtensionCannotFindAntimalwareEnableSetting),
                                string.Empty,
                                ErrorCategory.InvalidData,
                                null));
                }
            }

            // process Monitoring parameter if specified (will override any setting in xml config)
            if (Monitoring != null)
            {
                switch (Monitoring.ToUpperInvariant())
                {
                    case "ON": monitoringAction = MonitoringActionType.Enable; break;
                    case "OFF": monitoringAction = MonitoringActionType.Disable; break;
                    default: break;
                }                
            }

        }

        public void ExecuteCommand()
        {
            ValidateParameters();

            // prepare diagnostics extension
            switch (monitoringAction)
            {
                case MonitoringActionType.Enable : EnableMonitoring(); break;
                case MonitoringActionType.Disable : RemoveExistingAntimalwareMonitoringConfig(); break;
                default: break;
            }

            // prepare antimalware extension
            if (isAntimalwareEnabled)
            {
                InitializeAntimalwareSettings();
                ExtensionConfigurationInput amExtConfigInput = new ExtensionConfigurationInput
                {
                    ProviderNameSpace = ProviderNamespace,
                    Type = ExtensionName,
                    PublicConfiguration = PublicConfiguration,
                    PrivateConfiguration = PrivateConfiguration,
                    Roles = new ExtensionRoleList(Role != null && Role.Any() ? Role.Select(r => new ExtensionRole(r)) : Enumerable.Repeat(new ExtensionRole(), 1))
                };
                AntimalwareExtensionConfigurationInput = amExtConfigInput;
            }

            // update extensions as appropriate
            ExtensionConfigurationInput[] extConfigInputs = null;
            if (AntimalwareExtensionConfigurationInput != null && AntimalwareMonitoringExtensionConfigurationInput != null)
            {
                extConfigInputs = new ExtensionConfigurationInput[2];
                extConfigInputs[0] = AntimalwareMonitoringExtensionConfigurationInput;
                extConfigInputs[1] = AntimalwareExtensionConfigurationInput;
            }
            else if (AntimalwareExtensionConfigurationInput != null)
            {
                extConfigInputs = new ExtensionConfigurationInput[1];
                extConfigInputs[0] = AntimalwareExtensionConfigurationInput;
            }
            else if (AntimalwareMonitoringExtensionConfigurationInput!=null)
            {
                extConfigInputs = new ExtensionConfigurationInput[1];
                extConfigInputs[0] = AntimalwareMonitoringExtensionConfigurationInput;
            }

            // process any pending deployment changes
            if (extConfigInputs != null)
            {
                ExtensionConfiguration newExtConfig = ExtensionManager.Add(Deployment, PeerDeployment, extConfigInputs, Slot);
                ChangeDeployment(newExtConfig);
            }
        }

        protected override void OnProcessRecord()
        {
            ExecuteCommand();
        }
    }
}
