// ----------------------------------------------------------------------------------
//
// Copyright Microsoft Corporation
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------------------------------------------------------------

using System;
using Microsoft.Azure.Commands.Common.Authentication.Abstractions;
using Microsoft.Azure.Commands.Sql.Common;
using Microsoft.Azure.Commands.Sql.VulnerabilityAssessment.Model;
using Microsoft.Azure.Management.Sql.Models;

namespace Microsoft.Azure.Commands.Sql.VulnerabilityAssessment.Services
{
    /// <summary>
    /// The SqlVulnerabilityAssessmentAdapter class is responsible for transforming the data that was received form the endpoints to the cmdlets model of vulnerability assessment settings and vice versa
    /// </summary>
    public class SqlVulnerabilityAssessmentAdapter : BaseSqlVulnerabilityAssessmentAdapter
    {
        /// <summary>
        /// The Azure endpoints communicator used by this adapter
        /// </summary>
        private AzureEndpointsCommunicator AzureCommunicator { get; set; }


        public SqlVulnerabilityAssessmentAdapter(IAzureContext context) : base(context)
        {
            Context = context;
            Subscription = context?.Subscription;
            VulnerabilityAssessmentCommunicator = new VulnerabilityAssessmentEndpointsCommunicator(Context);
            AzureCommunicator = new AzureEndpointsCommunicator(Context);
        }

        /// <summary>
        /// Remove the Vulnerability Assessment
        /// </summary>
        public void ClearVulnerabilityAssessmentSettings(VulnerabilityAssessmentSettingsModel model, string serverName, string databaseName, ApplyToType applyToType)
        {
            switch (applyToType)
            {
                case ApplyToType.Database:
                    VulnerabilityAssessmentCommunicator.ClearDatabaseVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName, databaseName);
                    break;
                case ApplyToType.ManagedDatabase:
                    VulnerabilityAssessmentCommunicator.ClearManagedDatabaseVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName, databaseName);
                    break;
                case ApplyToType.Server:
                    VulnerabilityAssessmentCommunicator.ClearServerVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName);
                    break;
                case ApplyToType.ManagedInstance:
                    VulnerabilityAssessmentCommunicator.ClearManagedInstanceVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName);
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(applyToType), applyToType, null);
            }
        }

        /// <summary>
        /// Set settings with storage SAS key
        /// </summary>
        public VulnerabilityAssessmentSettingsModel SetVulnerabilityAssessmentSettingsWithStorageSasKey(VulnerabilityAssessmentSettingsModel model, string storageContainerPath,
            string storageAccountSasKey, string serverName, string databaseName, ApplyToType applyToType)
        {
            switch (applyToType)
            {
                case ApplyToType.Database:
                    DatabaseVulnerabilityAssessment vaDbSettings = new DatabaseVulnerabilityAssessment
                    {
                        StorageContainerPath = storageContainerPath,
                        StorageContainerSasKey = storageAccountSasKey,

                        RecurringScans = new VulnerabilityAssessmentRecurringScansProperties()
                        {
                            IsEnabled = model.RecurringScansInterval != RecurringScansInterval.None,
                            EmailSubscriptionAdmins = model.EmailAdmins,
                            Emails = model.NotificationEmail
                        }
                    };
                    vaDbSettings = VulnerabilityAssessmentCommunicator.SetDatabaseVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName, databaseName, vaDbSettings);
                    return ConvertSettingsToModel(model.ResourceGroupName, vaDbSettings.RecurringScans, vaDbSettings.StorageContainerPath);
                case ApplyToType.ManagedDatabase:
                    DatabaseVulnerabilityAssessment vaManagedDbSettings = new DatabaseVulnerabilityAssessment
                    {
                        StorageContainerPath = storageContainerPath,
                        StorageContainerSasKey = storageAccountSasKey,

                        RecurringScans = new VulnerabilityAssessmentRecurringScansProperties()
                        {
                            IsEnabled = model.RecurringScansInterval != RecurringScansInterval.None,
                            EmailSubscriptionAdmins = model.EmailAdmins,
                            Emails = model.NotificationEmail
                        }
                    };
                    vaManagedDbSettings = VulnerabilityAssessmentCommunicator.SetManagedDatabaseVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName, databaseName, vaManagedDbSettings);
                    return ConvertSettingsToModel(model.ResourceGroupName, vaManagedDbSettings.RecurringScans, vaManagedDbSettings.StorageContainerPath);
                case ApplyToType.Server:
                    ServerVulnerabilityAssessment vaServerSettings = new ServerVulnerabilityAssessment
                    {
                        StorageContainerPath = storageContainerPath,
                        StorageContainerSasKey = storageAccountSasKey,

                        RecurringScans = new VulnerabilityAssessmentRecurringScansProperties()
                        {
                            IsEnabled = model.RecurringScansInterval != RecurringScansInterval.None,
                            EmailSubscriptionAdmins = model.EmailAdmins,
                            Emails = model.NotificationEmail
                        }
                    };
                    vaServerSettings = VulnerabilityAssessmentCommunicator.SetServerVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName, vaServerSettings);
                    return ConvertSettingsToModel(model.ResourceGroupName, vaServerSettings.RecurringScans, vaServerSettings.StorageContainerPath);
                case ApplyToType.ManagedInstance:
                    ManagedInstanceVulnerabilityAssessment vaManagedInstanceSettings = new ManagedInstanceVulnerabilityAssessment
                    {
                        StorageContainerPath = storageContainerPath,
                        StorageContainerSasKey = storageAccountSasKey,

                        RecurringScans = new VulnerabilityAssessmentRecurringScansProperties()
                        {
                            IsEnabled = model.RecurringScansInterval != RecurringScansInterval.None,
                            EmailSubscriptionAdmins = model.EmailAdmins,
                            Emails = model.NotificationEmail
                        }
                    };
                    vaManagedInstanceSettings = VulnerabilityAssessmentCommunicator.SetManagedInstanceVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName, vaManagedInstanceSettings);
                    return ConvertSettingsToModel(model.ResourceGroupName, vaManagedInstanceSettings.RecurringScans, vaManagedInstanceSettings.StorageContainerPath);
                default:
                    throw new ArgumentOutOfRangeException(nameof(applyToType), applyToType, null);
            }
        }

        /// <summary>
        /// Set settings with storage access key
        /// </summary>
        public VulnerabilityAssessmentSettingsModel SetVulnerabilityAssessmentSettingsWithStorageAccessKey(VulnerabilityAssessmentSettingsModel model, string serverName, string databaseName, ApplyToType applyToType)
        {
            var resourceGroupName = AzureCommunicator.GetStorageResourceGroup(model.StorageAccountName);
            var storageContainerInfo = VulnerabilityAssessmentCommunicator.GetStorageContainerInfo(resourceGroupName, model.StorageAccountName, model.ScanResultsContainerName);

            switch (applyToType)
            {
                case ApplyToType.Database:
                    DatabaseVulnerabilityAssessment vaDbSettings = new DatabaseVulnerabilityAssessment
                    {
                        StorageContainerPath = storageContainerInfo.StorageContainerPath,
                        StorageAccountAccessKey = storageContainerInfo.StorageAccountAccessKey,

                        RecurringScans = new VulnerabilityAssessmentRecurringScansProperties()
                        {
                            IsEnabled = model.RecurringScansInterval != RecurringScansInterval.None,
                            EmailSubscriptionAdmins = model.EmailAdmins,
                            Emails = model.NotificationEmail
                        }
                    };
                    vaDbSettings = VulnerabilityAssessmentCommunicator.SetDatabaseVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName, databaseName, vaDbSettings);
                    return ConvertSettingsToModel(model.ResourceGroupName, vaDbSettings.RecurringScans, vaDbSettings.StorageContainerPath);
                case ApplyToType.ManagedDatabase:
                    DatabaseVulnerabilityAssessment vaManagedDbSettings = new DatabaseVulnerabilityAssessment
                    {
                        StorageContainerPath = storageContainerInfo.StorageContainerPath,
                        StorageAccountAccessKey = storageContainerInfo.StorageAccountAccessKey,

                        RecurringScans = new VulnerabilityAssessmentRecurringScansProperties()
                        {
                            IsEnabled = model.RecurringScansInterval != RecurringScansInterval.None,
                            EmailSubscriptionAdmins = model.EmailAdmins,
                            Emails = model.NotificationEmail
                        }
                    };
                    vaManagedDbSettings = VulnerabilityAssessmentCommunicator.SetManagedDatabaseVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName, databaseName, vaManagedDbSettings);
                    return ConvertSettingsToModel(model.ResourceGroupName, vaManagedDbSettings.RecurringScans, vaManagedDbSettings.StorageContainerPath);
                case ApplyToType.Server:
                    ServerVulnerabilityAssessment vaServerSettings = new ServerVulnerabilityAssessment
                    {
                        StorageContainerPath = storageContainerInfo.StorageContainerPath,
                        StorageAccountAccessKey = storageContainerInfo.StorageAccountAccessKey,

                        RecurringScans = new VulnerabilityAssessmentRecurringScansProperties()
                        {
                            IsEnabled = model.RecurringScansInterval != RecurringScansInterval.None,
                            EmailSubscriptionAdmins = model.EmailAdmins,
                            Emails = model.NotificationEmail
                        }
                    };
                    vaServerSettings = VulnerabilityAssessmentCommunicator.SetServerVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName, vaServerSettings);
                    return ConvertSettingsToModel(model.ResourceGroupName, vaServerSettings.RecurringScans, vaServerSettings.StorageContainerPath);
                case ApplyToType.ManagedInstance:
                    ManagedInstanceVulnerabilityAssessment vaManagedInstanceSettings = new ManagedInstanceVulnerabilityAssessment
                    {
                        StorageContainerPath = storageContainerInfo.StorageContainerPath,
                        StorageAccountAccessKey = storageContainerInfo.StorageAccountAccessKey,

                        RecurringScans = new VulnerabilityAssessmentRecurringScansProperties()
                        {
                            IsEnabled = model.RecurringScansInterval != RecurringScansInterval.None,
                            EmailSubscriptionAdmins = model.EmailAdmins,
                            Emails = model.NotificationEmail
                        }
                    };
                    vaManagedInstanceSettings = VulnerabilityAssessmentCommunicator.SetManagedInstanceVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName, vaManagedInstanceSettings);
                    return ConvertSettingsToModel(model.ResourceGroupName, vaManagedInstanceSettings.RecurringScans, vaManagedInstanceSettings.StorageContainerPath);
                default:
                    throw new ArgumentOutOfRangeException(nameof(applyToType), applyToType, null);
            }
        }
    }
}
