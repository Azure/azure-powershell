// ----------------------------------------------------------------------------------
//
// Copyright Microsoft Corporation
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------------------------------------------------------------

using Microsoft.Azure.Commands.Common.Authentication.Abstractions;
using Microsoft.Azure.Commands.Sql.Common;
using Microsoft.Azure.Commands.Sql.VulnerabilityAssessment.Model;
using Microsoft.Azure.Management.Sql.Models;

namespace Microsoft.Azure.Commands.Sql.VulnerabilityAssessment.Services
{
    /// <summary>
    /// The SqlVulnerabilityAssessmentAdapter class is responsible for transforming the data that was received form the endpoints to the cmdlets model of vulnerability assessment settings and vice versa
    /// </summary>
    public class SqlVulnerabilityAssessmentAdapter : BaseSqlVulnerabilityAssessmentAdapter
    {
        /// <summary>
        /// The Azure endpoints communicator used by this adapter
        /// </summary>
        private AzureEndpointsCommunicator AzureCommunicator { get; set; }


        public SqlVulnerabilityAssessmentAdapter(IAzureContext context) : base(context)
        {
            Context = context;
            Subscription = context?.Subscription;
            VulnerabilityAssessmentCommunicator = new VulnerabilityAssessmentEndpointsCommunicator(Context);
            AzureCommunicator = new AzureEndpointsCommunicator(Context);
        }

        /// <summary>
        /// Remove the Vulnerability Assessment
        /// </summary>
        public void ClearVulnerabilityAssessmentSettings(VulnerabilityAssessmentSettingsModel model, string serverName, string databaseName, ApplyToType applyToType)
        {
            if (applyToType == ApplyToType.Database)
            {
                VulnerabilityAssessmentCommunicator.ClearDatabaseVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName, databaseName);
            }
            else
            {
                VulnerabilityAssessmentCommunicator.ClearManagedDatabaseVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName, databaseName);
            }
        }

        /// <summary>
        /// Set settings with storage SAS key
        /// </summary>
        public VulnerabilityAssessmentSettingsModel SetVulnerabilityAssessmentSettingsWithStorageSasKey(VulnerabilityAssessmentSettingsModel model, string storageContainerPath,
            string storageAccountSasKey, string serverName, string databaseName, ApplyToType applyToType)
        {
            DatabaseVulnerabilityAssessment settings = new DatabaseVulnerabilityAssessment
            {
                StorageContainerPath = storageContainerPath,
                StorageContainerSasKey = storageAccountSasKey,

                RecurringScans = new VulnerabilityAssessmentRecurringScansProperties()
                {
                    IsEnabled = model.RecurringScansInterval != RecurringScansInterval.None,
                    EmailSubscriptionAdmins = model.EmailAdmins,
                    Emails = model.NotificationEmail
                }
            };

            var vulnerabilityAssessmentSettings = (applyToType == ApplyToType.Database) ?
                VulnerabilityAssessmentCommunicator.SetDatabaseVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName, databaseName, settings) :
                VulnerabilityAssessmentCommunicator.SetManagedDatabaseVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName, databaseName, settings);

            return ConvertSettingsToModel(model.ResourceGroupName, serverName, databaseName, vulnerabilityAssessmentSettings);

        }

        /// <summary>
        /// Set settings with storage access key
        /// </summary>
        public VulnerabilityAssessmentSettingsModel SetVulnerabilityAssessmentSettingsWithStorageAccessKey(VulnerabilityAssessmentSettingsModel model, string serverName, string databaseName, ApplyToType applyToType)
        {
            var resourceGroupName = AzureCommunicator.GetStorageResourceGroup(model.StorageAccountName);
            var storageContainerInfo = VulnerabilityAssessmentCommunicator.GetStorageContainerInfo(resourceGroupName, model.StorageAccountName,
                model.ScanResultsContainerName);

            DatabaseVulnerabilityAssessment settings = new DatabaseVulnerabilityAssessment
            {
                StorageContainerPath = storageContainerInfo.StorageContainerPath,
                StorageAccountAccessKey = storageContainerInfo.StorageAccountAccessKey,

                RecurringScans = new VulnerabilityAssessmentRecurringScansProperties()
                {
                    IsEnabled = model.RecurringScansInterval != RecurringScansInterval.None,
                    EmailSubscriptionAdmins = model.EmailAdmins,
                    Emails = model.NotificationEmail
                }
            };

            var vulnerabilityAssessmentSettings = (applyToType == ApplyToType.Database) ?
                VulnerabilityAssessmentCommunicator.SetDatabaseVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName, databaseName, settings) :
                VulnerabilityAssessmentCommunicator.SetManagedDatabaseVulnerabilityAssessmentSettings(model.ResourceGroupName, serverName, databaseName, settings);

            return ConvertSettingsToModel(model.ResourceGroupName, serverName, databaseName, vulnerabilityAssessmentSettings);
        }
    }
}
