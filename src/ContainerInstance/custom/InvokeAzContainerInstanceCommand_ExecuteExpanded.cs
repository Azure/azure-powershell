// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.ContainerInstance.Cmdlets
{
    using static Microsoft.Azure.PowerShell.Cmdlets.ContainerInstance.Runtime.Extensions;
    using System;
    using System.Net.WebSockets;
    using System.Text;
    using System.Collections.Generic;

    public partial class InvokeAzContainerInstanceCommand_ExecuteExpanded : global::System.Management.Automation.PSCmdlet,
        Microsoft.Azure.PowerShell.Cmdlets.ContainerInstance.Runtime.IEventListener
    {
        /// <summary>
        /// <c>overrideOnOk</c> will be called before the regular onOk has been processed, allowing customization of what happens
        /// on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerInstance.Models.Api20210301.IContainerExecResponse"
        /// /> from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onOk method should be processed, or if the method should return
        /// immediately (set to true to skip further processing )</param>

        partial void overrideOnOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ContainerInstance.Models.Api20210301.IContainerExecResponse> response, ref global::System.Threading.Tasks.Task<bool> returnNow)
        {
            var containerExecResponse = response.ConfigureAwait(false).GetAwaiter().GetResult();
            var socket = new System.Net.WebSockets.ClientWebSocket();
            var uri = new System.Uri(containerExecResponse.WebSocketUri);
            var token = ((Microsoft.Azure.PowerShell.Cmdlets.ContainerInstance.Runtime.IEventListener)this).Token;

            try
            {
                socket.ConnectAsync(uri, token).ConfigureAwait(false).GetAwaiter().GetResult();
                // Send Password
                socket.SendAsync(new ArraySegment<byte>(Encoding.UTF8.GetBytes(containerExecResponse.Password)), WebSocketMessageType.Text, false, token).ConfigureAwait(false).GetAwaiter().GetResult();

                var allBytes = new List<byte>();
                var rcvBuffer = WebSocket.CreateClientBuffer(4096, 4096);
                while (socket.State == WebSocketState.Open)
                {
                    WebSocketReceiveResult webSocketReceiveResult = socket.ReceiveAsync(rcvBuffer, token).ConfigureAwait(false).GetAwaiter().GetResult();
                    allBytes.AddRange(new List<byte>(rcvBuffer).GetRange(0, webSocketReceiveResult.Count));
                }

                var result = Encoding.UTF8.GetString(allBytes.ToArray(), 0, allBytes.Count);
                WriteObject(result);
            }
            finally
            {
                socket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Done", token).ConfigureAwait(false).GetAwaiter().GetResult();
                returnNow = global::System.Threading.Tasks.Task.FromResult(true);
            }
        }
    }
}