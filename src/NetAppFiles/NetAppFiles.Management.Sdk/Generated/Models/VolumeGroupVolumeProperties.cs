// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.Management.NetApp.Models
{
    using System.Linq;

    /// <summary>
    /// Volume resource
    /// </summary>
    [Microsoft.Rest.Serialization.JsonTransformation]
    public partial class VolumeGroupVolumeProperties : Microsoft.Rest.Azure.IResource
    {
        /// <summary>
        /// Initializes a new instance of the VolumeGroupVolumeProperties class.
        /// </summary>
        public VolumeGroupVolumeProperties()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the VolumeGroupVolumeProperties class.
        /// </summary>

        /// <param name="id">Resource Id
        /// </param>

        /// <param name="name">Resource name
        /// </param>

        /// <param name="type">Resource type
        /// </param>

        /// <param name="tags">Resource tags
        /// </param>

        /// <param name="zones">Availability Zone
        /// </param>

        /// <param name="serviceLevel">The service level of the file system
        /// Possible values include: &#39;Standard&#39;, &#39;Premium&#39;, &#39;Ultra&#39;, &#39;StandardZRS&#39;</param>

        /// <param name="networkFeatures">Network features available to the volume, or current state of update.
        /// Possible values include: &#39;Basic&#39;, &#39;Standard&#39;, &#39;Basic_Standard&#39;,
        /// &#39;Standard_Basic&#39;</param>

        /// <param name="securityStyle">The security style of volume, default unix, defaults to ntfs for dual
        /// protocol or CIFS protocol
        /// Possible values include: &#39;ntfs&#39;, &#39;unix&#39;</param>

        /// <param name="enableSubvolumes">Flag indicating whether subvolume operations are enabled on the volume
        /// Possible values include: &#39;Enabled&#39;, &#39;Disabled&#39;</param>

        /// <param name="fileSystemId">Unique FileSystem Identifier.
        /// </param>

        /// <param name="creationToken">A unique file path for the volume. Used when creating mount targets
        /// </param>

        /// <param name="usageThreshold">Maximum storage quota allowed for a file system in bytes. This is a soft
        /// quota used for alerting only. Minimum size is 100 GiB. Upper limit is
        /// 100TiB, 500Tib for LargeVolume or 2400Tib for LargeVolume on exceptional
        /// basis. Specified in bytes.
        /// </param>

        /// <param name="exportPolicy">Set of export policy rules
        /// </param>

        /// <param name="protocolTypes">Set of protocol types, default NFSv3, CIFS for SMB protocol
        /// </param>

        /// <param name="provisioningState">Azure lifecycle management
        /// </param>

        /// <param name="snapshotId">Resource identifier used to identify the Snapshot.
        /// </param>

        /// <param name="deleteBaseSnapshot">If enabled (true) the snapshot the volume was created from will be
        /// automatically deleted after the volume create operation has finished. 
        /// Defaults to false
        /// </param>

        /// <param name="backupId">Resource identifier used to identify the Backup.
        /// </param>

        /// <param name="baremetalTenantId">Unique Baremetal Tenant Identifier.
        /// </param>

        /// <param name="subnetId">The Azure Resource URI for a delegated subnet. Must have the delegation
        /// Microsoft.NetApp/volumes
        /// </param>

        /// <param name="networkSiblingSetId">Network Sibling Set ID for the the group of volumes sharing networking
        /// resources.
        /// </param>

        /// <param name="storageToNetworkProximity">Provides storage to network proximity information for the volume.
        /// Possible values include: &#39;Default&#39;, &#39;T1&#39;, &#39;T2&#39;, &#39;AcrossT2&#39;</param>

        /// <param name="mountTargets">List of mount targets
        /// </param>

        /// <param name="volumeType">What type of volume is this. For destination volumes in Cross Region
        /// Replication, set type to DataProtection
        /// </param>

        /// <param name="dataProtection">DataProtection type volumes include an object containing details of the
        /// replication
        /// </param>

        /// <param name="isRestoring">Restoring
        /// </param>

        /// <param name="snapshotDirectoryVisible">If enabled (true) the volume will contain a read-only snapshot directory
        /// which provides access to each of the volume&#39;s snapshots (defaults to true).
        /// </param>

        /// <param name="kerberosEnabled">Describe if a volume is KerberosEnabled. To be use with swagger version
        /// 2020-05-01 or later
        /// </param>

        /// <param name="smbEncryption">Enables encryption for in-flight smb3 data. Only applicable for
        /// SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or
        /// later
        /// </param>

        /// <param name="smbAccessBasedEnumeration">Enables access-based enumeration share property for SMB Shares. Only
        /// applicable for SMB/DualProtocol volume
        /// Possible values include: &#39;Disabled&#39;, &#39;Enabled&#39;</param>

        /// <param name="smbNonBrowsable">Enables non-browsable property for SMB Shares. Only applicable for
        /// SMB/DualProtocol volume
        /// Possible values include: &#39;Disabled&#39;, &#39;Enabled&#39;</param>

        /// <param name="smbContinuouslyAvailable">Enables continuously available share property for smb volume. Only
        /// applicable for SMB volume
        /// </param>

        /// <param name="throughputMibps">Maximum throughput in MiB/s that can be achieved by this volume and this
        /// will be accepted as input only for manual qosType volume
        /// </param>

        /// <param name="actualThroughputMibps">Actual throughput in MiB/s for auto qosType volumes calculated based on
        /// size and serviceLevel
        /// </param>

        /// <param name="encryptionKeySource">Source of key used to encrypt data in volume. Applicable if NetApp account
        /// has encryption.keySource = &#39;Microsoft.KeyVault&#39;. Possible values
        /// (case-insensitive) are: &#39;Microsoft.NetApp, Microsoft.KeyVault&#39;
        /// Possible values include: &#39;Microsoft.NetApp&#39;, &#39;Microsoft.KeyVault&#39;</param>

        /// <param name="keyVaultPrivateEndpointResourceId">The resource ID of private endpoint for KeyVault. It must reside in the
        /// same VNET as the volume. Only applicable if encryptionKeySource =
        /// &#39;Microsoft.KeyVault&#39;.
        /// </param>

        /// <param name="ldapEnabled">Specifies whether LDAP is enabled or not for a given NFS volume.
        /// </param>

        /// <param name="coolAccess">Specifies whether Cool Access(tiering) is enabled for the volume.
        /// </param>

        /// <param name="coolnessPeriod">Specifies the number of days after which data that is not accessed by
        /// clients will be tiered.
        /// </param>

        /// <param name="coolAccessRetrievalPolicy">coolAccessRetrievalPolicy determines the data retrieval behavior from the
        /// cool tier to standard storage based on the read pattern for cool access
        /// enabled volumes. The possible values for this field are:
        /// Default - Data will be pulled from cool tier to standard storage on random
        /// reads. This policy is the default.
        /// OnRead - All client-driven data read is pulled from cool tier to standard
        /// storage on both sequential and random reads.
        /// Never - No client-driven data is pulled from cool tier to standard storage.
        /// Possible values include: &#39;Default&#39;, &#39;OnRead&#39;, &#39;Never&#39;</param>

        /// <param name="unixPermissions">UNIX permissions for NFS volume accepted in octal 4 digit format. First
        /// digit selects the set user ID(4), set group ID (2) and sticky (1)
        /// attributes. Second digit selects permission for the owner of the file: read
        /// (4), write (2) and execute (1). Third selects permissions for other users
        /// in the same group. the fourth for other users not in the group. 0755 -
        /// gives read/write/execute permissions to owner and read/execute to group and
        /// other users.
        /// </param>

        /// <param name="cloneProgress">When a volume is being restored from another volume&#39;s snapshot, will show
        /// the percentage completion of this cloning process. When this value is
        /// empty/null there is no cloning process currently happening on this volume.
        /// This value will update every 5 minutes during cloning.
        /// </param>

        /// <param name="fileAccessLogs">Flag indicating whether file access logs are enabled for the volume, based
        /// on active diagnostic settings present on the volume.
        /// Possible values include: &#39;Enabled&#39;, &#39;Disabled&#39;</param>

        /// <param name="avsDataStore">Specifies whether the volume is enabled for Azure VMware Solution (AVS)
        /// datastore purpose
        /// Possible values include: &#39;Enabled&#39;, &#39;Disabled&#39;</param>

        /// <param name="dataStoreResourceId">Data store resource unique identifier
        /// </param>

        /// <param name="isDefaultQuotaEnabled">Specifies if default quota is enabled for the volume.
        /// </param>

        /// <param name="defaultUserQuotaInKiBs">Default user quota for volume in KiBs. If isDefaultQuotaEnabled is set, the
        /// minimum value of 4 KiBs applies .
        /// </param>

        /// <param name="defaultGroupQuotaInKiBs">Default group quota for volume in KiBs. If isDefaultQuotaEnabled is set,
        /// the minimum value of 4 KiBs applies.
        /// </param>

        /// <param name="maximumNumberOfFiles">Maximum number of files allowed. Needs a service request in order to be
        /// changed. Only allowed to be changed if volume quota is more than 4TiB.
        /// </param>

        /// <param name="volumeGroupName">Volume Group Name
        /// </param>

        /// <param name="capacityPoolResourceId">Pool Resource Id used in case of creating a volume through volume group
        /// </param>

        /// <param name="proximityPlacementGroup">Proximity placement group associated with the volume
        /// </param>

        /// <param name="t2Network">T2 network information
        /// </param>

        /// <param name="volumeSpecName">Volume spec name is the application specific designation or identifier for
        /// the particular volume in a volume group for e.g. data, log
        /// </param>

        /// <param name="encrypted">Specifies if the volume is encrypted or not. Only available on volumes
        /// created or updated after 2022-01-01.
        /// </param>

        /// <param name="placementRules">Application specific placement rules for the particular volume
        /// </param>

        /// <param name="provisionedAvailabilityZone">The availability zone where the volume is provisioned. This refers to the
        /// logical availability zone where the volume resides.
        /// </param>

        /// <param name="isLargeVolume">Specifies whether volume is a Large Volume or Regular Volume.
        /// </param>

        /// <param name="originatingResourceId">Id of the snapshot or backup that the volume is restored from.
        /// </param>
        public VolumeGroupVolumeProperties(string creationToken, long usageThreshold, string subnetId, string id = default(string), string name = default(string), string type = default(string), System.Collections.Generic.IDictionary<string, string> tags = default(System.Collections.Generic.IDictionary<string, string>), System.Collections.Generic.IList<string> zones = default(System.Collections.Generic.IList<string>), string serviceLevel = default(string), string networkFeatures = default(string), string securityStyle = default(string), string enableSubvolumes = default(string), string fileSystemId = default(string), VolumePropertiesExportPolicy exportPolicy = default(VolumePropertiesExportPolicy), System.Collections.Generic.IList<string> protocolTypes = default(System.Collections.Generic.IList<string>), string provisioningState = default(string), string snapshotId = default(string), bool? deleteBaseSnapshot = default(bool?), string backupId = default(string), string baremetalTenantId = default(string), string networkSiblingSetId = default(string), string storageToNetworkProximity = default(string), System.Collections.Generic.IList<MountTargetProperties> mountTargets = default(System.Collections.Generic.IList<MountTargetProperties>), string volumeType = default(string), VolumePropertiesDataProtection dataProtection = default(VolumePropertiesDataProtection), bool? isRestoring = default(bool?), bool? snapshotDirectoryVisible = default(bool?), bool? kerberosEnabled = default(bool?), bool? smbEncryption = default(bool?), string smbAccessBasedEnumeration = default(string), string smbNonBrowsable = default(string), bool? smbContinuouslyAvailable = default(bool?), double? throughputMibps = default(double?), double? actualThroughputMibps = default(double?), string encryptionKeySource = default(string), string keyVaultPrivateEndpointResourceId = default(string), bool? ldapEnabled = default(bool?), bool? coolAccess = default(bool?), int? coolnessPeriod = default(int?), string coolAccessRetrievalPolicy = default(string), string unixPermissions = default(string), int? cloneProgress = default(int?), string fileAccessLogs = default(string), string avsDataStore = default(string), System.Collections.Generic.IList<string> dataStoreResourceId = default(System.Collections.Generic.IList<string>), bool? isDefaultQuotaEnabled = default(bool?), long? defaultUserQuotaInKiBs = default(long?), long? defaultGroupQuotaInKiBs = default(long?), long? maximumNumberOfFiles = default(long?), string volumeGroupName = default(string), string capacityPoolResourceId = default(string), string proximityPlacementGroup = default(string), string t2Network = default(string), string volumeSpecName = default(string), bool? encrypted = default(bool?), System.Collections.Generic.IList<PlacementKeyValuePairs> placementRules = default(System.Collections.Generic.IList<PlacementKeyValuePairs>), string provisionedAvailabilityZone = default(string), bool? isLargeVolume = default(bool?), string originatingResourceId = default(string))

        {
            this.Id = id;
            this.Name = name;
            this.Type = type;
            this.Tags = tags;
            this.Zones = zones;
            this.ServiceLevel = serviceLevel;
            this.NetworkFeatures = networkFeatures;
            this.SecurityStyle = securityStyle;
            this.EnableSubvolumes = enableSubvolumes;
            this.FileSystemId = fileSystemId;
            this.CreationToken = creationToken;
            this.UsageThreshold = usageThreshold;
            this.ExportPolicy = exportPolicy;
            this.ProtocolTypes = protocolTypes;
            this.ProvisioningState = provisioningState;
            this.SnapshotId = snapshotId;
            this.DeleteBaseSnapshot = deleteBaseSnapshot;
            this.BackupId = backupId;
            this.BaremetalTenantId = baremetalTenantId;
            this.SubnetId = subnetId;
            this.NetworkSiblingSetId = networkSiblingSetId;
            this.StorageToNetworkProximity = storageToNetworkProximity;
            this.MountTargets = mountTargets;
            this.VolumeType = volumeType;
            this.DataProtection = dataProtection;
            this.IsRestoring = isRestoring;
            this.SnapshotDirectoryVisible = snapshotDirectoryVisible;
            this.KerberosEnabled = kerberosEnabled;
            this.SmbEncryption = smbEncryption;
            this.SmbAccessBasedEnumeration = smbAccessBasedEnumeration;
            this.SmbNonBrowsable = smbNonBrowsable;
            this.SmbContinuouslyAvailable = smbContinuouslyAvailable;
            this.ThroughputMibps = throughputMibps;
            this.ActualThroughputMibps = actualThroughputMibps;
            this.EncryptionKeySource = encryptionKeySource;
            this.KeyVaultPrivateEndpointResourceId = keyVaultPrivateEndpointResourceId;
            this.LdapEnabled = ldapEnabled;
            this.CoolAccess = coolAccess;
            this.CoolnessPeriod = coolnessPeriod;
            this.CoolAccessRetrievalPolicy = coolAccessRetrievalPolicy;
            this.UnixPermissions = unixPermissions;
            this.CloneProgress = cloneProgress;
            this.FileAccessLogs = fileAccessLogs;
            this.AvsDataStore = avsDataStore;
            this.DataStoreResourceId = dataStoreResourceId;
            this.IsDefaultQuotaEnabled = isDefaultQuotaEnabled;
            this.DefaultUserQuotaInKiBs = defaultUserQuotaInKiBs;
            this.DefaultGroupQuotaInKiBs = defaultGroupQuotaInKiBs;
            this.MaximumNumberOfFiles = maximumNumberOfFiles;
            this.VolumeGroupName = volumeGroupName;
            this.CapacityPoolResourceId = capacityPoolResourceId;
            this.ProximityPlacementGroup = proximityPlacementGroup;
            this.T2Network = t2Network;
            this.VolumeSpecName = volumeSpecName;
            this.Encrypted = encrypted;
            this.PlacementRules = placementRules;
            this.ProvisionedAvailabilityZone = provisionedAvailabilityZone;
            this.IsLargeVolume = isLargeVolume;
            this.OriginatingResourceId = originatingResourceId;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();


        /// <summary>
        /// Gets resource Id
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "id")]
        public string Id {get; private set; }

        /// <summary>
        /// Gets or sets resource name
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "name")]
        public string Name {get; set; }

        /// <summary>
        /// Gets resource type
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "type")]
        public string Type {get; private set; }

        /// <summary>
        /// Gets or sets resource tags
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "tags")]
        public System.Collections.Generic.IDictionary<string, string> Tags {get; set; }

        /// <summary>
        /// Gets or sets availability Zone
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "zones")]
        public System.Collections.Generic.IList<string> Zones {get; set; }

        /// <summary>
        /// Gets or sets the service level of the file system Possible values include: &#39;Standard&#39;, &#39;Premium&#39;, &#39;Ultra&#39;, &#39;StandardZRS&#39;
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.serviceLevel")]
        public string ServiceLevel {get; set; }

        /// <summary>
        /// Gets or sets network features available to the volume, or current state of
        /// update. Possible values include: &#39;Basic&#39;, &#39;Standard&#39;, &#39;Basic_Standard&#39;, &#39;Standard_Basic&#39;
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.networkFeatures")]
        public string NetworkFeatures {get; set; }

        /// <summary>
        /// Gets or sets the security style of volume, default unix, defaults to ntfs
        /// for dual protocol or CIFS protocol Possible values include: &#39;ntfs&#39;, &#39;unix&#39;
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.securityStyle")]
        public string SecurityStyle {get; set; }

        /// <summary>
        /// Gets or sets flag indicating whether subvolume operations are enabled on
        /// the volume Possible values include: &#39;Enabled&#39;, &#39;Disabled&#39;
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.enableSubvolumes")]
        public string EnableSubvolumes {get; set; }

        /// <summary>
        /// Gets unique FileSystem Identifier.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.fileSystemId")]
        public string FileSystemId {get; private set; }

        /// <summary>
        /// Gets or sets a unique file path for the volume. Used when creating mount
        /// targets
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.creationToken")]
        public string CreationToken {get; set; }

        /// <summary>
        /// Gets or sets maximum storage quota allowed for a file system in bytes. This
        /// is a soft quota used for alerting only. Minimum size is 100 GiB. Upper
        /// limit is 100TiB, 500Tib for LargeVolume or 2400Tib for LargeVolume on
        /// exceptional basis. Specified in bytes.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.usageThreshold")]
        public long UsageThreshold {get; set; }

        /// <summary>
        /// Gets or sets set of export policy rules
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.exportPolicy")]
        public VolumePropertiesExportPolicy ExportPolicy {get; set; }

        /// <summary>
        /// Gets or sets set of protocol types, default NFSv3, CIFS for SMB protocol
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.protocolTypes")]
        public System.Collections.Generic.IList<string> ProtocolTypes {get; set; }

        /// <summary>
        /// Gets azure lifecycle management
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.provisioningState")]
        public string ProvisioningState {get; private set; }

        /// <summary>
        /// Gets or sets resource identifier used to identify the Snapshot.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.snapshotId")]
        public string SnapshotId {get; set; }

        /// <summary>
        /// Gets or sets if enabled (true) the snapshot the volume was created from
        /// will be automatically deleted after the volume create operation has
        /// finished.  Defaults to false
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.deleteBaseSnapshot")]
        public bool? DeleteBaseSnapshot {get; set; }

        /// <summary>
        /// Gets or sets resource identifier used to identify the Backup.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.backupId")]
        public string BackupId {get; set; }

        /// <summary>
        /// Gets unique Baremetal Tenant Identifier.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.baremetalTenantId")]
        public string BaremetalTenantId {get; private set; }

        /// <summary>
        /// Gets or sets the Azure Resource URI for a delegated subnet. Must have the
        /// delegation Microsoft.NetApp/volumes
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.subnetId")]
        public string SubnetId {get; set; }

        /// <summary>
        /// Gets network Sibling Set ID for the the group of volumes sharing networking
        /// resources.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.networkSiblingSetId")]
        public string NetworkSiblingSetId {get; private set; }

        /// <summary>
        /// Gets provides storage to network proximity information for the volume. Possible values include: &#39;Default&#39;, &#39;T1&#39;, &#39;T2&#39;, &#39;AcrossT2&#39;
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.storageToNetworkProximity")]
        public string StorageToNetworkProximity {get; private set; }

        /// <summary>
        /// Gets list of mount targets
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.mountTargets")]
        public System.Collections.Generic.IList<MountTargetProperties> MountTargets {get; private set; }

        /// <summary>
        /// Gets or sets what type of volume is this. For destination volumes in Cross
        /// Region Replication, set type to DataProtection
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.volumeType")]
        public string VolumeType {get; set; }

        /// <summary>
        /// Gets or sets dataProtection type volumes include an object containing
        /// details of the replication
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.dataProtection")]
        public VolumePropertiesDataProtection DataProtection {get; set; }

        /// <summary>
        /// Gets or sets restoring
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.isRestoring")]
        public bool? IsRestoring {get; set; }

        /// <summary>
        /// Gets or sets if enabled (true) the volume will contain a read-only snapshot
        /// directory which provides access to each of the volume&#39;s snapshots (defaults
        /// to true).
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.snapshotDirectoryVisible")]
        public bool? SnapshotDirectoryVisible {get; set; }

        /// <summary>
        /// Gets or sets describe if a volume is KerberosEnabled. To be use with
        /// swagger version 2020-05-01 or later
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.kerberosEnabled")]
        public bool? KerberosEnabled {get; set; }

        /// <summary>
        /// Gets or sets enables encryption for in-flight smb3 data. Only applicable
        /// for SMB/DualProtocol volume. To be used with swagger version 2020-08-01 or
        /// later
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.smbEncryption")]
        public bool? SmbEncryption {get; set; }

        /// <summary>
        /// Gets or sets enables access-based enumeration share property for SMB
        /// Shares. Only applicable for SMB/DualProtocol volume Possible values include: &#39;Disabled&#39;, &#39;Enabled&#39;
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.smbAccessBasedEnumeration")]
        public string SmbAccessBasedEnumeration {get; set; }

        /// <summary>
        /// Gets or sets enables non-browsable property for SMB Shares. Only applicable
        /// for SMB/DualProtocol volume Possible values include: &#39;Disabled&#39;, &#39;Enabled&#39;
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.smbNonBrowsable")]
        public string SmbNonBrowsable {get; set; }

        /// <summary>
        /// Gets or sets enables continuously available share property for smb volume.
        /// Only applicable for SMB volume
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.smbContinuouslyAvailable")]
        public bool? SmbContinuouslyAvailable {get; set; }

        /// <summary>
        /// Gets or sets maximum throughput in MiB/s that can be achieved by this
        /// volume and this will be accepted as input only for manual qosType volume
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.throughputMibps")]
        public double? ThroughputMibps {get; set; }

        /// <summary>
        /// Gets actual throughput in MiB/s for auto qosType volumes calculated based
        /// on size and serviceLevel
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.actualThroughputMibps")]
        public double? ActualThroughputMibps {get; private set; }

        /// <summary>
        /// Gets or sets source of key used to encrypt data in volume. Applicable if
        /// NetApp account has encryption.keySource = &#39;Microsoft.KeyVault&#39;. Possible
        /// values (case-insensitive) are: &#39;Microsoft.NetApp, Microsoft.KeyVault&#39; Possible values include: &#39;Microsoft.NetApp&#39;, &#39;Microsoft.KeyVault&#39;
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.encryptionKeySource")]
        public string EncryptionKeySource {get; set; }

        /// <summary>
        /// Gets or sets the resource ID of private endpoint for KeyVault. It must
        /// reside in the same VNET as the volume. Only applicable if
        /// encryptionKeySource = &#39;Microsoft.KeyVault&#39;.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.keyVaultPrivateEndpointResourceId")]
        public string KeyVaultPrivateEndpointResourceId {get; set; }

        /// <summary>
        /// Gets or sets specifies whether LDAP is enabled or not for a given NFS
        /// volume.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.ldapEnabled")]
        public bool? LdapEnabled {get; set; }

        /// <summary>
        /// Gets or sets specifies whether Cool Access(tiering) is enabled for the
        /// volume.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.coolAccess")]
        public bool? CoolAccess {get; set; }

        /// <summary>
        /// Gets or sets specifies the number of days after which data that is not
        /// accessed by clients will be tiered.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.coolnessPeriod")]
        public int? CoolnessPeriod {get; set; }

        /// <summary>
        /// Gets or sets coolAccessRetrievalPolicy determines the data retrieval
        /// behavior from the cool tier to standard storage based on the read pattern
        /// for cool access enabled volumes. The possible values for this field are:
        /// Default - Data will be pulled from cool tier to standard storage on random
        /// reads. This policy is the default.
        /// OnRead - All client-driven data read is pulled from cool tier to standard
        /// storage on both sequential and random reads.
        /// Never - No client-driven data is pulled from cool tier to standard storage. Possible values include: &#39;Default&#39;, &#39;OnRead&#39;, &#39;Never&#39;
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.coolAccessRetrievalPolicy")]
        public string CoolAccessRetrievalPolicy {get; set; }

        /// <summary>
        /// Gets or sets uNIX permissions for NFS volume accepted in octal 4 digit
        /// format. First digit selects the set user ID(4), set group ID (2) and sticky
        /// (1) attributes. Second digit selects permission for the owner of the file:
        /// read (4), write (2) and execute (1). Third selects permissions for other
        /// users in the same group. the fourth for other users not in the group. 0755
        /// - gives read/write/execute permissions to owner and read/execute to group
        /// and other users.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.unixPermissions")]
        public string UnixPermissions {get; set; }

        /// <summary>
        /// Gets when a volume is being restored from another volume&#39;s snapshot, will
        /// show the percentage completion of this cloning process. When this value is
        /// empty/null there is no cloning process currently happening on this volume.
        /// This value will update every 5 minutes during cloning.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.cloneProgress")]
        public int? CloneProgress {get; private set; }

        /// <summary>
        /// Gets flag indicating whether file access logs are enabled for the volume,
        /// based on active diagnostic settings present on the volume. Possible values include: &#39;Enabled&#39;, &#39;Disabled&#39;
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.fileAccessLogs")]
        public string FileAccessLogs {get; private set; }

        /// <summary>
        /// Gets or sets specifies whether the volume is enabled for Azure VMware
        /// Solution (AVS) datastore purpose Possible values include: &#39;Enabled&#39;, &#39;Disabled&#39;
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.avsDataStore")]
        public string AvsDataStore {get; set; }

        /// <summary>
        /// Gets data store resource unique identifier
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.dataStoreResourceId")]
        public System.Collections.Generic.IList<string> DataStoreResourceId {get; private set; }

        /// <summary>
        /// Gets or sets specifies if default quota is enabled for the volume.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.isDefaultQuotaEnabled")]
        public bool? IsDefaultQuotaEnabled {get; set; }

        /// <summary>
        /// Gets or sets default user quota for volume in KiBs. If
        /// isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies .
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.defaultUserQuotaInKiBs")]
        public long? DefaultUserQuotaInKiBs {get; set; }

        /// <summary>
        /// Gets or sets default group quota for volume in KiBs. If
        /// isDefaultQuotaEnabled is set, the minimum value of 4 KiBs applies.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.defaultGroupQuotaInKiBs")]
        public long? DefaultGroupQuotaInKiBs {get; set; }

        /// <summary>
        /// Gets maximum number of files allowed. Needs a service request in order to
        /// be changed. Only allowed to be changed if volume quota is more than 4TiB.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.maximumNumberOfFiles")]
        public long? MaximumNumberOfFiles {get; private set; }

        /// <summary>
        /// Gets volume Group Name
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.volumeGroupName")]
        public string VolumeGroupName {get; private set; }

        /// <summary>
        /// Gets or sets pool Resource Id used in case of creating a volume through
        /// volume group
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.capacityPoolResourceId")]
        public string CapacityPoolResourceId {get; set; }

        /// <summary>
        /// Gets or sets proximity placement group associated with the volume
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.proximityPlacementGroup")]
        public string ProximityPlacementGroup {get; set; }

        /// <summary>
        /// Gets t2 network information
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.t2Network")]
        public string T2Network {get; private set; }

        /// <summary>
        /// Gets or sets volume spec name is the application specific designation or
        /// identifier for the particular volume in a volume group for e.g. data, log
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.volumeSpecName")]
        public string VolumeSpecName {get; set; }

        /// <summary>
        /// Gets specifies if the volume is encrypted or not. Only available on volumes
        /// created or updated after 2022-01-01.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.encrypted")]
        public bool? Encrypted {get; private set; }

        /// <summary>
        /// Gets or sets application specific placement rules for the particular volume
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.placementRules")]
        public System.Collections.Generic.IList<PlacementKeyValuePairs> PlacementRules {get; set; }

        /// <summary>
        /// Gets the availability zone where the volume is provisioned. This refers to
        /// the logical availability zone where the volume resides.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.provisionedAvailabilityZone")]
        public string ProvisionedAvailabilityZone {get; private set; }

        /// <summary>
        /// Gets or sets specifies whether volume is a Large Volume or Regular Volume.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.isLargeVolume")]
        public bool? IsLargeVolume {get; set; }

        /// <summary>
        /// Gets id of the snapshot or backup that the volume is restored from.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "properties.originatingResourceId")]
        public string OriginatingResourceId {get; private set; }
        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="Microsoft.Rest.ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (this.CreationToken == null)
            {
                throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.CannotBeNull, "CreationToken");
            }
            if (this.SubnetId == null)
            {
                throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.CannotBeNull, "SubnetId");
            }









            if (this.FileSystemId != null)
            {
                if (this.FileSystemId.Length > 36)
                {
                    throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.MaxLength, "FileSystemId", 36);
                }
                if (this.FileSystemId.Length < 36)
                {
                    throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.MinLength, "FileSystemId", 36);
                }
                if (!System.Text.RegularExpressions.Regex.IsMatch(this.FileSystemId, "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"))
                {
                    throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.Pattern, "FileSystemId", "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$");
                }
            }
            if (this.CreationToken != null)
            {
                if (this.CreationToken.Length > 80)
                {
                    throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.MaxLength, "CreationToken", 80);
                }
                if (this.CreationToken.Length < 1)
                {
                    throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.MinLength, "CreationToken", 1);
                }
                if (!System.Text.RegularExpressions.Regex.IsMatch(this.CreationToken, "^[a-zA-Z][a-zA-Z0-9\\-]{0,79}$"))
                {
                    throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.Pattern, "CreationToken", "^[a-zA-Z][a-zA-Z0-9\\-]{0,79}$");
                }
            }
            if (this.UsageThreshold > 2638827906662400)
            {
                throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.InclusiveMaximum, "UsageThreshold", 2638827906662400);
            }
            if (this.UsageThreshold < 107374182400)
            {
                throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.InclusiveMinimum, "UsageThreshold", 107374182400);
            }







            if (this.NetworkSiblingSetId != null)
            {
                if (this.NetworkSiblingSetId.Length > 36)
                {
                    throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.MaxLength, "NetworkSiblingSetId", 36);
                }
                if (this.NetworkSiblingSetId.Length < 36)
                {
                    throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.MinLength, "NetworkSiblingSetId", 36);
                }
                if (!System.Text.RegularExpressions.Regex.IsMatch(this.NetworkSiblingSetId, "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"))
                {
                    throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.Pattern, "NetworkSiblingSetId", "^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$");
                }
            }

            if (this.MountTargets != null)
            {
                foreach (var element in this.MountTargets)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }

            if (this.DataProtection != null)
            {
                this.DataProtection.Validate();
            }




            if (this.CoolnessPeriod != null)
            {
                if (this.CoolnessPeriod > 183)
                {
                    throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.InclusiveMaximum, "CoolnessPeriod", 183);
                }
                if (this.CoolnessPeriod < 7)
                {
                    throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.InclusiveMinimum, "CoolnessPeriod", 7);
                }
            }

            if (this.UnixPermissions != null)
            {
                if (this.UnixPermissions.Length > 4)
                {
                    throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.MaxLength, "UnixPermissions", 4);
                }
                if (this.UnixPermissions.Length < 4)
                {
                    throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.MinLength, "UnixPermissions", 4);
                }
            }








            if (this.PlacementRules != null)
            {
                foreach (var element in this.PlacementRules)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }


        }
    }
}