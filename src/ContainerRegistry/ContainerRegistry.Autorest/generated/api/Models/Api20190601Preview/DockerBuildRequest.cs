// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview
{
    using static Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.Extensions;

    /// <summary>The parameters for a docker quick build.</summary>
    public partial class DockerBuildRequest :
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IDockerBuildRequest,
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IDockerBuildRequestInternal,
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.IValidates
    {
        /// <summary>
        /// Backing field for Inherited model <see cref= "Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IRunRequest"
        /// />
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IRunRequest __runRequest = new Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.RunRequest();

        /// <summary>Backing field for <see cref="AgentConfiguration" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IAgentProperties _agentConfiguration;

        /// <summary>The machine configuration of the run agent.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IAgentProperties AgentConfiguration { get => (this._agentConfiguration = this._agentConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.AgentProperties()); set => this._agentConfiguration = value; }

        /// <summary>The CPU configuration in terms of number of cores required for the run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Inlined)]
        public int? AgentConfigurationCpu { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IAgentPropertiesInternal)AgentConfiguration).Cpu; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IAgentPropertiesInternal)AgentConfiguration).Cpu = value ?? default(int); }

        /// <summary>The dedicated agent pool for the run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Inherited)]
        public string AgentPoolName { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IRunRequestInternal)__runRequest).AgentPoolName; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IRunRequestInternal)__runRequest).AgentPoolName = value ?? null; }

        /// <summary>Backing field for <see cref="Argument" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IArgument[] _argument;

        /// <summary>The collection of override arguments to be used when executing the run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IArgument[] Argument { get => this._argument; set => this._argument = value; }

        /// <summary>Backing field for <see cref="Credentials" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.ICredentials _credentials;

        /// <summary>
        /// The properties that describes a set of credentials that will be used when this run is invoked.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.ICredentials Credentials { get => (this._credentials = this._credentials ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.Credentials()); set => this._credentials = value; }

        /// <summary>
        /// Describes the credential parameters for accessing other custom registries. The key
        /// for the dictionary item will be the registry login server (myregistry.azurecr.io) and
        /// the value of the item will be the registry credentials for accessing the registry.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.ICredentialsCustomRegistries CredentialsCustomRegistry { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.ICredentialsInternal)Credentials).CustomRegistry; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.ICredentialsInternal)Credentials).CustomRegistry = value ?? null /* model class */; }

        /// <summary>Backing field for <see cref="DockerFilePath" /> property.</summary>
        private string _dockerFilePath;

        /// <summary>The Docker file path relative to the source location.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Owned)]
        public string DockerFilePath { get => this._dockerFilePath; set => this._dockerFilePath = value; }

        /// <summary>Backing field for <see cref="ImageName" /> property.</summary>
        private string[] _imageName;

        /// <summary>The fully qualified image names including the repository and tag.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Owned)]
        public string[] ImageName { get => this._imageName; set => this._imageName = value; }

        /// <summary>The value that indicates whether archiving is enabled for the run or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Inherited)]
        public bool? IsArchiveEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IRunRequestInternal)__runRequest).IsArchiveEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IRunRequestInternal)__runRequest).IsArchiveEnabled = value ?? default(bool); }

        /// <summary>Backing field for <see cref="IsPushEnabled" /> property.</summary>
        private bool? _isPushEnabled;

        /// <summary>
        /// The value of this property indicates whether the image built should be pushed to the registry or not.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Owned)]
        public bool? IsPushEnabled { get => this._isPushEnabled; set => this._isPushEnabled = value; }

        /// <summary>
        /// The template that describes the repository and tag information for run log artifact.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Inherited)]
        public string LogTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IRunRequestInternal)__runRequest).LogTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IRunRequestInternal)__runRequest).LogTemplate = value ?? null; }

        /// <summary>Internal Acessors for AgentConfiguration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IAgentProperties Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IDockerBuildRequestInternal.AgentConfiguration { get => (this._agentConfiguration = this._agentConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.AgentProperties()); set { {_agentConfiguration = value;} } }

        /// <summary>Internal Acessors for Credentials</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.ICredentials Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IDockerBuildRequestInternal.Credentials { get => (this._credentials = this._credentials ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.Credentials()); set { {_credentials = value;} } }

        /// <summary>Internal Acessors for CredentialsSourceRegistry</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.ISourceRegistryCredentials Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IDockerBuildRequestInternal.CredentialsSourceRegistry { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.ICredentialsInternal)Credentials).SourceRegistry; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.ICredentialsInternal)Credentials).SourceRegistry = value; }

        /// <summary>Internal Acessors for Platform</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IPlatformProperties Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IDockerBuildRequestInternal.Platform { get => (this._platform = this._platform ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.PlatformProperties()); set { {_platform = value;} } }

        /// <summary>Backing field for <see cref="NoCache" /> property.</summary>
        private bool? _noCache;

        /// <summary>The value of this property indicates whether the image cache is enabled or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Owned)]
        public bool? NoCache { get => this._noCache; set => this._noCache = value; }

        /// <summary>Backing field for <see cref="Platform" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IPlatformProperties _platform;

        /// <summary>The platform properties against which the run has to happen.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IPlatformProperties Platform { get => (this._platform = this._platform ?? new Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.PlatformProperties()); set => this._platform = value; }

        /// <summary>The OS architecture.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.Architecture? PlatformArchitecture { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IPlatformPropertiesInternal)Platform).Architecture; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IPlatformPropertiesInternal)Platform).Architecture = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.Architecture)""); }

        /// <summary>The operating system type required for the run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.OS PlatformOS { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IPlatformPropertiesInternal)Platform).OS; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IPlatformPropertiesInternal)Platform).OS = value ; }

        /// <summary>Variant of the CPU.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.Variant? PlatformVariant { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IPlatformPropertiesInternal)Platform).Variant; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IPlatformPropertiesInternal)Platform).Variant = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.Variant)""); }

        /// <summary>Backing field for <see cref="SourceLocation" /> property.</summary>
        private string _sourceLocation;

        /// <summary>
        /// The URL(absolute or relative) of the source context. It can be an URL to a tar or git repository.
        /// If it is relative URL, the relative path should be obtained from calling listBuildSourceUploadUrl API.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Owned)]
        public string SourceLocation { get => this._sourceLocation; set => this._sourceLocation = value; }

        /// <summary>
        /// The authentication mode which determines the source registry login scope. The credentials for the source registry
        /// will be generated using the given scope. These credentials will be used to login to
        /// the source registry during the run.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.SourceRegistryLoginMode? SourceRegistryLoginMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.ICredentialsInternal)Credentials).SourceRegistryLoginMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.ICredentialsInternal)Credentials).SourceRegistryLoginMode = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.SourceRegistryLoginMode)""); }

        /// <summary>Backing field for <see cref="Target" /> property.</summary>
        private string _target;

        /// <summary>The name of the target build stage for the docker build.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Owned)]
        public string Target { get => this._target; set => this._target = value; }

        /// <summary>Backing field for <see cref="Timeout" /> property.</summary>
        private int? _timeout;

        /// <summary>Run timeout in seconds.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Owned)]
        public int? Timeout { get => this._timeout; set => this._timeout = value; }

        /// <summary>The type of the run request.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Origin(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.PropertyOrigin.Inherited)]
        public string Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IRunRequestInternal)__runRequest).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IRunRequestInternal)__runRequest).Type = value ; }

        /// <summary>Creates an new <see cref="DockerBuildRequest" /> instance.</summary>
        public DockerBuildRequest()
        {

        }

        /// <summary>Validates that this object meets the validation criteria.</summary>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.IEventListener" /> instance that will receive validation
        /// events.</param>
        /// <returns>
        /// A <see cref = "global::System.Threading.Tasks.Task" /> that will be complete when validation is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task Validate(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.IEventListener eventListener)
        {
            await eventListener.AssertNotNull(nameof(__runRequest), __runRequest);
            await eventListener.AssertObjectIsValid(nameof(__runRequest), __runRequest);
        }
    }
    /// The parameters for a docker quick build.
    public partial interface IDockerBuildRequest :
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.IJsonSerializable,
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IRunRequest
    {
        /// <summary>The CPU configuration in terms of number of cores required for the run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The CPU configuration in terms of number of cores required for the run.",
        SerializedName = @"cpu",
        PossibleTypes = new [] { typeof(int) })]
        int? AgentConfigurationCpu { get; set; }
        /// <summary>The collection of override arguments to be used when executing the run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The collection of override arguments to be used when executing the run.",
        SerializedName = @"arguments",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IArgument) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IArgument[] Argument { get; set; }
        /// <summary>
        /// Describes the credential parameters for accessing other custom registries. The key
        /// for the dictionary item will be the registry login server (myregistry.azurecr.io) and
        /// the value of the item will be the registry credentials for accessing the registry.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describes the credential parameters for accessing other custom registries. The key
        for the dictionary item will be the registry login server (myregistry.azurecr.io) and
        the value of the item will be the registry credentials for accessing the registry.",
        SerializedName = @"customRegistries",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.ICredentialsCustomRegistries) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.ICredentialsCustomRegistries CredentialsCustomRegistry { get; set; }
        /// <summary>The Docker file path relative to the source location.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The Docker file path relative to the source location.",
        SerializedName = @"dockerFilePath",
        PossibleTypes = new [] { typeof(string) })]
        string DockerFilePath { get; set; }
        /// <summary>The fully qualified image names including the repository and tag.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The fully qualified image names including the repository and tag.",
        SerializedName = @"imageNames",
        PossibleTypes = new [] { typeof(string) })]
        string[] ImageName { get; set; }
        /// <summary>
        /// The value of this property indicates whether the image built should be pushed to the registry or not.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The value of this property indicates whether the image built should be pushed to the registry or not.",
        SerializedName = @"isPushEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? IsPushEnabled { get; set; }
        /// <summary>The value of this property indicates whether the image cache is enabled or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The value of this property indicates whether the image cache is enabled or not.",
        SerializedName = @"noCache",
        PossibleTypes = new [] { typeof(bool) })]
        bool? NoCache { get; set; }
        /// <summary>The OS architecture.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The OS architecture.",
        SerializedName = @"architecture",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.Architecture) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.Architecture? PlatformArchitecture { get; set; }
        /// <summary>The operating system type required for the run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The operating system type required for the run.",
        SerializedName = @"os",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.OS) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.OS PlatformOS { get; set; }
        /// <summary>Variant of the CPU.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Variant of the CPU.",
        SerializedName = @"variant",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.Variant) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.Variant? PlatformVariant { get; set; }
        /// <summary>
        /// The URL(absolute or relative) of the source context. It can be an URL to a tar or git repository.
        /// If it is relative URL, the relative path should be obtained from calling listBuildSourceUploadUrl API.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The URL(absolute or relative) of the source context. It can be an URL to a tar or git repository.
        If it is relative URL, the relative path should be obtained from calling listBuildSourceUploadUrl API.",
        SerializedName = @"sourceLocation",
        PossibleTypes = new [] { typeof(string) })]
        string SourceLocation { get; set; }
        /// <summary>
        /// The authentication mode which determines the source registry login scope. The credentials for the source registry
        /// will be generated using the given scope. These credentials will be used to login to
        /// the source registry during the run.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The authentication mode which determines the source registry login scope. The credentials for the source registry
        will be generated using the given scope. These credentials will be used to login to
        the source registry during the run.",
        SerializedName = @"loginMode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.SourceRegistryLoginMode) })]
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.SourceRegistryLoginMode? SourceRegistryLoginMode { get; set; }
        /// <summary>The name of the target build stage for the docker build.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the target build stage for the docker build.",
        SerializedName = @"target",
        PossibleTypes = new [] { typeof(string) })]
        string Target { get; set; }
        /// <summary>Run timeout in seconds.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Run timeout in seconds.",
        SerializedName = @"timeout",
        PossibleTypes = new [] { typeof(int) })]
        int? Timeout { get; set; }

    }
    /// The parameters for a docker quick build.
    internal partial interface IDockerBuildRequestInternal :
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IRunRequestInternal
    {
        /// <summary>The machine configuration of the run agent.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IAgentProperties AgentConfiguration { get; set; }
        /// <summary>The CPU configuration in terms of number of cores required for the run.</summary>
        int? AgentConfigurationCpu { get; set; }
        /// <summary>The collection of override arguments to be used when executing the run.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IArgument[] Argument { get; set; }
        /// <summary>
        /// The properties that describes a set of credentials that will be used when this run is invoked.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.ICredentials Credentials { get; set; }
        /// <summary>
        /// Describes the credential parameters for accessing other custom registries. The key
        /// for the dictionary item will be the registry login server (myregistry.azurecr.io) and
        /// the value of the item will be the registry credentials for accessing the registry.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.ICredentialsCustomRegistries CredentialsCustomRegistry { get; set; }
        /// <summary>Describes the credential parameters for accessing the source registry.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.ISourceRegistryCredentials CredentialsSourceRegistry { get; set; }
        /// <summary>The Docker file path relative to the source location.</summary>
        string DockerFilePath { get; set; }
        /// <summary>The fully qualified image names including the repository and tag.</summary>
        string[] ImageName { get; set; }
        /// <summary>
        /// The value of this property indicates whether the image built should be pushed to the registry or not.
        /// </summary>
        bool? IsPushEnabled { get; set; }
        /// <summary>The value of this property indicates whether the image cache is enabled or not.</summary>
        bool? NoCache { get; set; }
        /// <summary>The platform properties against which the run has to happen.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Models.Api20190601Preview.IPlatformProperties Platform { get; set; }
        /// <summary>The OS architecture.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.Architecture? PlatformArchitecture { get; set; }
        /// <summary>The operating system type required for the run.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.OS PlatformOS { get; set; }
        /// <summary>Variant of the CPU.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.Variant? PlatformVariant { get; set; }
        /// <summary>
        /// The URL(absolute or relative) of the source context. It can be an URL to a tar or git repository.
        /// If it is relative URL, the relative path should be obtained from calling listBuildSourceUploadUrl API.
        /// </summary>
        string SourceLocation { get; set; }
        /// <summary>
        /// The authentication mode which determines the source registry login scope. The credentials for the source registry
        /// will be generated using the given scope. These credentials will be used to login to
        /// the source registry during the run.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ContainerRegistry.Support.SourceRegistryLoginMode? SourceRegistryLoginMode { get; set; }
        /// <summary>The name of the target build stage for the docker build.</summary>
        string Target { get; set; }
        /// <summary>Run timeout in seconds.</summary>
        int? Timeout { get; set; }

    }
}