
# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Code generated by Microsoft (R) AutoRest Code Generator.Changes may cause incorrect behavior and will be lost if the code
# is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Enables a frontendEndpoint for HTTPS traffic
.Description
Enables a frontendEndpoint for HTTPS traffic
.Example
Enable-AzFrontDoorCustomDomainHttps -ResourceGroupName "resourcegroup1" -FrontDoorName "frontdoor1" -FrontendEndpointName "frontendpointname1-custom-xyz" -MinimumTlsVersion "1.2"
.Example
$vaultId = (Get-AzKeyVault -VaultName $vaultName).ResourceId
Enable-AzFrontDoorCustomDomainHttps -ResourceGroupName "resourcegroup1" -FrontDoorName "frontdoor1" -FrontendEndpointName "frontendpointname1-custom-xyz" -VaultId $vaultId -secretName $secretName -SecretVersion $secretVersion -MinimumTlsVersion "1.0"
.Example
Get-AzFrontDoorFrontendEndpoint -ResourceGroupName "resourcegroup1" -FrontDoorName "frontdoor1" -Name "frontendpointname1-custom-xyz" | Enable-AzFrontDoorCustomDomainHttps 
.Example
Enable-AzFrontDoorCustomDomainHttps -ResourceId $resourceId
.Example
$vaultId = (Get-AzKeyVault -VaultName $vaultName).ResourceId
Enable-AzFrontDoorCustomDomainHttps -ResourceGroupName "resourcegroup1" -FrontDoorName "frontdoor1" -FrontendEndpointName "frontendpointname1-custom-xyz" -VaultId $vaultId -secretName $secretName -MinimumTlsVersion "1.0"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.ICustomHttpsConfiguration
.Inputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontDoorIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CUSTOMHTTPSCONFIGURATION <ICustomHttpsConfiguration>: Https settings for a domain
  CertificateSource <String>: Defines the source of the SSL certificate
  MinimumTlsVersion <String>: The minimum TLS version required from the clients to establish an SSL handshake with Front Door.
  [FrontDoorCertificateSourceParameterCertificateType <String>]: Defines the type of the certificate used for secure connections to a frontendEndpoint
  [KeyVaultCertificateSourceParameterSecretName <String>]: The name of the Key Vault secret representing the full certificate PFX
  [KeyVaultCertificateSourceParameterSecretVersion <String>]: The version of the Key Vault secret representing the full certificate PFX
  [VaultId <String>]: Resource ID.

FRONTDOORINPUTOBJECT <IFrontDoorIdentity>: Identity Parameter
  [FrontDoorName <String>]: Name of the Front Door which is globally unique.
  [FrontendEndpointName <String>]: Name of the Frontend endpoint which is unique within the Front Door.
  [Id <String>]: Resource identity path
  [PolicyName <String>]: The name of the Web Application Firewall Policy.
  [ResourceGroupName <String>]: Name of the Resource group within the Azure subscription.
  [RulesEngineName <String>]: Name of the Rules Engine which is unique within the Front Door.
  [SubscriptionId <String>]: The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.

INPUTOBJECT <IFrontDoorIdentity>: Identity Parameter
  [FrontDoorName <String>]: Name of the Front Door which is globally unique.
  [FrontendEndpointName <String>]: Name of the Frontend endpoint which is unique within the Front Door.
  [Id <String>]: Resource identity path
  [PolicyName <String>]: The name of the Web Application Firewall Policy.
  [ResourceGroupName <String>]: Name of the Resource group within the Azure subscription.
  [RulesEngineName <String>]: Name of the Rules Engine which is unique within the Front Door.
  [SubscriptionId <String>]: The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.
.Link
https://learn.microsoft.com/powershell/module/az.frontdoor/enable-azfrontdoorcustomdomainhttps
#>
function Enable-AzFrontDoorCustomDomainHttps {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='EnableExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Parameter(ParameterSetName='EnableExpanded', Mandatory)]
    [Parameter(ParameterSetName='EnableViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='EnableViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Front Door which is globally unique.
    ${FrontDoorName},

    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Parameter(ParameterSetName='EnableExpanded', Mandatory)]
    [Parameter(ParameterSetName='EnableViaIdentityFrontDoor', Mandatory)]
    [Parameter(ParameterSetName='EnableViaIdentityFrontDoorExpanded', Mandatory)]
    [Parameter(ParameterSetName='EnableViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='EnableViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Frontend endpoint which is unique within the Front Door.
    ${FrontendEndpointName},

    [Parameter(ParameterSetName='Enable', Mandatory)]
    [Parameter(ParameterSetName='EnableExpanded', Mandatory)]
    [Parameter(ParameterSetName='EnableViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='EnableViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Resource group within the Azure subscription.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Enable')]
    [Parameter(ParameterSetName='EnableExpanded')]
    [Parameter(ParameterSetName='EnableViaJsonFilePath')]
    [Parameter(ParameterSetName='EnableViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The subscription credentials which uniquely identify the Microsoft Azure subscription.
    # The subscription ID forms part of the URI for every service call.
    ${SubscriptionId},

    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EnableViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontDoorIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='EnableViaIdentityFrontDoor', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EnableViaIdentityFrontDoorExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontDoorIdentity]
    # Identity Parameter
    ${FrontDoorInputObject},

    [Parameter(ParameterSetName='Enable', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EnableViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='EnableViaIdentityFrontDoor', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.ICustomHttpsConfiguration]
    # Https settings for a domain
    ${CustomHttpsConfiguration},

    [Parameter(ParameterSetName='EnableExpanded', Mandatory)]
    [Parameter(ParameterSetName='EnableViaIdentityExpanded', Mandatory)]
    [Parameter(ParameterSetName='EnableViaIdentityFrontDoorExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.PSArgumentCompleterAttribute("AzureKeyVault", "FrontDoor")]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Defines the source of the SSL certificate
    ${CertificateSource},

    [Parameter(ParameterSetName='EnableExpanded')]
    [Parameter(ParameterSetName='EnableViaIdentityExpanded')]
    [Parameter(ParameterSetName='EnableViaIdentityFrontDoorExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.PSArgumentCompleterAttribute("1.0", "1.2")]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.DefaultInfo(Script='1.2')]
    [System.String]
    # The minimum TLS version required from the clients to establish an SSL handshake with Front Door.
    ${MinimumTlsVersion},

    [Parameter(ParameterSetName='EnableExpanded')]
    [Parameter(ParameterSetName='EnableViaIdentityExpanded')]
    [Parameter(ParameterSetName='EnableViaIdentityFrontDoorExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.PSArgumentCompleterAttribute("Dedicated")]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Defines the type of the certificate used for secure connections to a frontendEndpoint
    ${CertificateType},

    [Parameter(ParameterSetName='EnableExpanded')]
    [Parameter(ParameterSetName='EnableViaIdentityExpanded')]
    [Parameter(ParameterSetName='EnableViaIdentityFrontDoorExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # The name of the Key Vault secret representing the full certificate PFX
    ${SecretName},

    [Parameter(ParameterSetName='EnableExpanded')]
    [Parameter(ParameterSetName='EnableViaIdentityExpanded')]
    [Parameter(ParameterSetName='EnableViaIdentityFrontDoorExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # The version of the Key Vault secret representing the full certificate PFX
    ${SecretVersion},

    [Parameter(ParameterSetName='EnableExpanded')]
    [Parameter(ParameterSetName='EnableViaIdentityExpanded')]
    [Parameter(ParameterSetName='EnableViaIdentityFrontDoorExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Resource ID.
    ${VaultId},

    [Parameter(ParameterSetName='EnableViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Enable operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='EnableViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Json string supplied to the Enable operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $mapping = @{
            Enable = 'Az.FrontDoor.private\Enable-AzFrontDoorCustomDomainHttps_Enable';
            EnableExpanded = 'Az.FrontDoor.private\Enable-AzFrontDoorCustomDomainHttps_EnableExpanded';
            EnableViaIdentity = 'Az.FrontDoor.private\Enable-AzFrontDoorCustomDomainHttps_EnableViaIdentity';
            EnableViaIdentityExpanded = 'Az.FrontDoor.private\Enable-AzFrontDoorCustomDomainHttps_EnableViaIdentityExpanded';
            EnableViaIdentityFrontDoor = 'Az.FrontDoor.private\Enable-AzFrontDoorCustomDomainHttps_EnableViaIdentityFrontDoor';
            EnableViaIdentityFrontDoorExpanded = 'Az.FrontDoor.private\Enable-AzFrontDoorCustomDomainHttps_EnableViaIdentityFrontDoorExpanded';
            EnableViaJsonFilePath = 'Az.FrontDoor.private\Enable-AzFrontDoorCustomDomainHttps_EnableViaJsonFilePath';
            EnableViaJsonString = 'Az.FrontDoor.private\Enable-AzFrontDoorCustomDomainHttps_EnableViaJsonString';
        }
        if (('Enable', 'EnableExpanded', 'EnableViaJsonFilePath', 'EnableViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        if (('EnableExpanded', 'EnableViaIdentityExpanded', 'EnableViaIdentityFrontDoorExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('MinimumTlsVersion') ) {
            $PSBoundParameters['MinimumTlsVersion'] = 1.2
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Create policy with specified rule set name within a resource group.
.Description
Create policy with specified rule set name within a resource group.
.Example
New-AzFrontDoorWafPolicy -Name $policyName -ResourceGroupName $resourceGroupName -Customrule $customRule1,$customRule2 -ManagedRule $managedRule1 -EnabledState Enabled -Mode Prevention -RedirectUrl "https://www.bing.com/" -CustomBlockResponseStatusCode 405 -CustomBlockResponseBody "<html><head><title>You are blocked!</title></head><body></body></html>"

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IWebApplicationFirewallPolicy
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CUSTOMRULE <ICustomRule[]>: List of rules
  Action <String>: Describes what action to be applied when rule matches.
  MatchCondition <List<IMatchCondition>>: List of match conditions.
    MatchValue <List<String>>: List of possible match values.
    MatchVariable <String>: Request variable to compare with.
    OperatorProperty <String>: Comparison type to use for matching with the variable value.
    [NegateCondition <Boolean?>]: Describes if the result of this condition should be negated.
    [Selector <String>]: Match against a specific key from the QueryString, PostArgs, RequestHeader or Cookies variables. Default is null.
    [Transform <List<String>>]: List of transforms.
  Priority <Int32>: Describes priority of the rule. Rules with a lower value will be evaluated before rules with a higher value.
  RuleType <String>: Describes type of rule.
  [EnabledState <String>]: Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
  [GroupBy <List<IGroupByVariable>>]: Describes the list of variables to group the rate limit requests
    VariableName <String>: Describes the supported variable for group by
  [Name <String>]: Describes the name of the rule.
  [RateLimitDurationInMinutes <Int32?>]: Time window for resetting the rate limit count. Default is 1 minute.
  [RateLimitThreshold <Int32?>]: Number of allowed requests per client within the time window.

MANAGEDRULESET <IManagedRuleSet[]>: List of rule sets.
  Type <String>: Defines the rule set type to use.
  Version <String>: Defines the version of the rule set to use.
  [Exclusion <List<IManagedRuleExclusion>>]: Describes the exclusions that are applied to all rules in the set.
    Operator <String>: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to.
    Selector <String>: Selector value for which elements in the collection this exclusion applies to.
    Variable <String>: The variable type to be excluded.
  [RuleGroupOverride <List<IManagedRuleGroupOverride>>]: Defines the rule group overrides to apply to the rule set.
    RuleGroupName <String>: Describes the managed rule group to override.
    [Exclusion <List<IManagedRuleExclusion>>]: Describes the exclusions that are applied to all rules in the group.
    [ManagedRuleOverride <List<IManagedRuleOverride>>]: List of rules that will be disabled. If none specified, all rules in the group will be disabled.
      RuleId <String>: Identifier for the managed rule.
      [Action <String>]: Describes the override action to be applied when rule matches.
      [EnabledState <String>]: Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
      [Exclusion <List<IManagedRuleExclusion>>]: Describes the exclusions that are applied to this specific rule.
  [RuleSetAction <String>]: Defines the rule set action.

POLICYSETTING <IPolicySettings>: Describes settings for the policy.
  [CustomBlockResponseBody <String>]: If the action type is block, customer can override the response body. The body must be specified in base64 encoding.
  [CustomBlockResponseStatusCode <Int32?>]: If the action type is block, customer can override the response status code.
  [EnabledState <String>]: Describes if the policy is in enabled or disabled state. Defaults to Enabled if not specified.
  [JavascriptChallengeExpirationInMinutes <Int32?>]: Defines the JavaScript challenge cookie validity lifetime in minutes. This setting is only applicable to Premium_AzureFrontDoor. Value must be an integer between 5 and 1440 with the default value being 30.
  [LogScrubbingSetting <IPolicySettingsLogScrubbing>]: Defines rules that scrub sensitive fields in the Web Application Firewall logs.
    [ScrubbingRule <List<IWebApplicationFirewallScrubbingRules>>]: List of log scrubbing rules applied to the Web Application Firewall logs.
      MatchVariable <String>: The variable to be scrubbed from the logs.
      SelectorMatchOperator <String>: When matchVariable is a collection, operate on the selector to specify which elements in the collection this rule applies to.
      [Selector <String>]: When matchVariable is a collection, operator used to specify which elements in the collection this rule applies to.
      [State <String>]: Defines the state of a log scrubbing rule. Default value is enabled.
    [State <String>]: State of the log scrubbing config. Default value is Enabled.
  [Mode <String>]: Describes if it is in detection mode or prevention mode at policy level.
  [RedirectUrl <String>]: If action type is redirect, this field represents redirect URL for the client.
  [RequestBodyCheck <String>]: Describes if policy managed rules will inspect the request body content.
.Link
https://learn.microsoft.com/powershell/module/az.frontdoor/new-azfrontdoorwafpolicy
#>
function New-AzFrontDoorWafPolicy {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IWebApplicationFirewallPolicy])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('PolicyName')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # The name of the Web Application Firewall Policy.
    ${Name},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Resource group within the Azure subscription.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The subscription credentials which uniquely identify the Microsoft Azure subscription.
    # The subscription ID forms part of the URI for every service call.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.ICustomRule[]]
    # List of rules
    ${CustomRule},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Gets a unique read-only string that changes whenever the resource is updated.
    ${Etag},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IManagedRuleSet[]]
    # List of rule sets.
    ${ManagedRuleSet},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IPolicySettings]
    # Describes settings for the policy.
    ${PolicySetting},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.PSArgumentCompleterAttribute("Classic_AzureFrontDoor", "Standard_AzureFrontDoor", "Premium_AzureFrontDoor")]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Name of the pricing tier.
    ${SkuName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $mapping = @{
            CreateExpanded = 'Az.FrontDoor.private\New-AzFrontDoorWafPolicy_CreateExpanded';
            CreateViaJsonFilePath = 'Az.FrontDoor.private\New-AzFrontDoorWafPolicy_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.FrontDoor.private\New-AzFrontDoorWafPolicy_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        if (('CreateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('Location') ) {
            $PSBoundParameters['Location'] = "global"
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Create a new Front Door with a Front Door name under the specified subscription and resource group.
.Description
Create a new Front Door with a Front Door name under the specified subscription and resource group.
.Example
New-AzFrontDoor -Name "frontDoor1" -ResourceGroupName "rg1" -RoutingRule $routingrule1 -BackendPool $backendpool1 -FrontendEndpoint $frontendEndpoint1 -LoadBalancingSetting $loadBalancingSetting1 -HealthProbeSetting $healthProbeSetting1 -BackendPoolsSetting $backendPoolsSetting1

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontDoor
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BACKENDPOOL <IBackendPool[]>: Backend pools available to routing rules.
  [Id <String>]: Resource ID.
  [Backend <List<IBackend>>]: The set of backends for this pool
    [Address <String>]: Location of the backend (IP address or FQDN)
    [BackendHostHeader <String>]: The value to use as the host header sent to the backend. If blank or unspecified, this defaults to the incoming host.
    [EnabledState <String>]: Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled'
    [HttpPort <Int32?>]: The HTTP TCP port number. Must be between 1 and 65535.
    [HttpsPort <Int32?>]: The HTTPS TCP port number. Must be between 1 and 65535.
    [Priority <Int32?>]: Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy.
    [PrivateLinkAlias <String>]: The Alias of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
    [PrivateLinkApprovalMessage <String>]: A custom message to be included in the approval request to connect to the Private Link
    [PrivateLinkLocation <String>]: The location of the Private Link resource. Required only if 'privateLinkResourceId' is populated
    [PrivateLinkResourceId <String>]: The Resource Id of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
    [Weight <Int32?>]: Weight of this endpoint for load balancing purposes.
  [HealthProbeSettingId <String>]: Resource ID.
  [LoadBalancingSettingId <String>]: Resource ID.
  [Name <String>]: Resource name.

BACKENDPOOLSSETTING <IBackendPoolsSettings>: Settings for all backendPools
  [EnforceCertificateNameCheck <String>]: Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests.
  [SendRecvTimeoutInSeconds <Int32?>]: Send and receive timeout on forwarding request to the backend. When timeout is reached, the request fails and returns.

FRONTENDENDPOINT <IFrontendEndpoint[]>: Frontend endpoints available to routing rules.
  [Id <String>]: Resource ID.
  [CertificateSource <String>]: Defines the source of the SSL certificate
  [CertificateType <String>]: Defines the type of the certificate used for secure connections to a frontendEndpoint
  [HostName <String>]: The host name of the frontendEndpoint. Must be a domain name.
  [MinimumTlsVersion <String>]: The minimum TLS version required from the clients to establish an SSL handshake with Front Door.
  [Name <String>]: Resource name.
  [SecretName <String>]: The name of the Key Vault secret representing the full certificate PFX
  [SecretVersion <String>]: The version of the Key Vault secret representing the full certificate PFX
  [SessionAffinityEnabledState <String>]: Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
  [SessionAffinityTtlInSeconds <Int32?>]: UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if applicable.
  [Vault <String>]: Resource ID.
  [WebApplicationFirewallPolicyLinkId <String>]: Resource ID.

HEALTHPROBESETTING <IHealthProbeSettingsModel[]>: Health probe settings associated with this Front Door instance.
  [Id <String>]: Resource ID.
  [EnabledState <String>]: Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool.
  [HealthProbeMethod <String>]: Configures which HTTP method to use to probe the backends defined under backendPools.
  [IntervalInSeconds <Int32?>]: The number of seconds between health probes.
  [Name <String>]: Resource name.
  [Path <String>]: The path to use for the health probe. Default is /
  [Protocol <String>]: Protocol scheme to use for this probe

LOADBALANCINGSETTING <ILoadBalancingSettingsModel[]>: Load balancing settings associated with this Front Door instance.
  [Id <String>]: Resource ID.
  [AdditionalLatencyInMilliseconds <Int32?>]: The additional latency in milliseconds for probes to fall into the lowest latency bucket
  [Name <String>]: Resource name.
  [SampleSize <Int32?>]: The number of samples to consider for load balancing decisions
  [SuccessfulSamplesRequired <Int32?>]: The number of samples within the sample period that must succeed

ROUTINGRULE <IRoutingRule[]>: Routing rules associated with this Front Door.
  [Id <String>]: Resource ID.
  [AcceptedProtocol <List<String>>]: Protocol schemes to match for this rule
  [EnabledState <String>]: Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
  [FrontendEndpoint <List<ISubResource>>]: Frontend endpoints associated with this rule
    [Id <String>]: Resource ID.
  [Name <String>]: Resource name.
  [PatternsToMatch <List<String>>]: The route patterns of the rule.
  [RouteConfiguration <IRouteConfiguration>]: A reference to the routing configuration.
    OdataType <String>: 
  [RuleEngineId <String>]: Resource ID.
  [WebApplicationFirewallPolicyLinkId <String>]: Resource ID.
.Link
https://learn.microsoft.com/powershell/module/az.frontdoor/new-azfrontdoor
#>
function New-AzFrontDoor {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontDoor])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('FrontDoorName')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Front Door which is globally unique.
    ${Name},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Resource group within the Azure subscription.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The subscription credentials which uniquely identify the Microsoft Azure subscription.
    # The subscription ID forms part of the URI for every service call.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IBackendPool[]]
    # Backend pools available to routing rules.
    ${BackendPool},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IBackendPoolsSettings]
    # Settings for all backendPools
    ${BackendPoolsSetting},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.PSArgumentCompleterAttribute("Enabled", "Disabled")]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.DefaultInfo(Script='"Enabled"')]
    [System.String]
    # Operational status of the Front Door load balancer.
    # Permitted values are 'Enabled' or 'Disabled'
    ${EnabledState},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # A friendly name for the frontDoor
    ${FriendlyName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontendEndpoint[]]
    # Frontend endpoints available to routing rules.
    ${FrontendEndpoint},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IHealthProbeSettingsModel[]]
    # Health probe settings associated with this Front Door instance.
    ${HealthProbeSetting},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.ILoadBalancingSettingsModel[]]
    # Load balancing settings associated with this Front Door instance.
    ${LoadBalancingSetting},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IRoutingRule[]]
    # Routing rules associated with this Front Door.
    ${RoutingRule},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $mapping = @{
            CreateExpanded = 'Az.FrontDoor.private\New-AzFrontDoor_CreateExpanded';
            CreateViaJsonFilePath = 'Az.FrontDoor.private\New-AzFrontDoor_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.FrontDoor.private\New-AzFrontDoor_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        if (('CreateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('EnabledState') ) {
            $PSBoundParameters['EnabledState'] = "Enabled"
        }
        if (('CreateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('Location') ) {
            $PSBoundParameters['Location'] = "global"
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Update a new Rules Engine Configuration with the specified name within the specified Front Door.
.Description
Update a new Rules Engine Configuration with the specified name within the specified Front Door.
.Example
Get-AzFrontDoorRulesEngine -ResourceGroupName $resourceGroupName -FrontDoorName $frontDoorName -Name myRulesEngine

Name          RulesEngineRules
----          ----------------
myRulesEngine {rules1}

$rulesEngineRule2 = New-AzFrontDoorRulesEngineRuleObject -Name rules2 -Priority 3 -Action $rulesEngineAction
Set-AzFrontDoorRulesEngine -ResourceGroupName $resourceGroupName -FrontDoorName $frontDoorName -Name myRulesEngine -Rule $rulesEngineRule1, $rulesEngineRule2

Name          RulesEngineRules
----          ----------------
myRulesEngine {rules1, rules2}

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IRulesEngine
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

RULE <IRulesEngineRule[]>: A list of rules that define a particular Rules Engine Configuration.
  Action <IRulesEngineAction>: Actions to perform on the request and response if all of the match conditions are met.
    [RequestHeaderAction <List<IHeaderAction>>]: A list of header actions to apply from the request from AFD to the origin.
      HeaderActionType <String>: Which type of manipulation to apply to the header.
      HeaderName <String>: The name of the header this action will apply to.
      [Value <String>]: The value to update the given header name with. This value is not used if the actionType is Delete.
    [ResponseHeaderAction <List<IHeaderAction>>]: A list of header actions to apply from the response from AFD to the client.
    [RouteConfigurationOverride <IRouteConfiguration>]: Override the route configuration.
      OdataType <String>: 
  Name <String>: A name to refer to this specific rule.
  Priority <Int32>: A priority assigned to this rule. 
  [MatchCondition <List<IRulesEngineMatchCondition>>]: A list of match conditions that must meet in order for the actions of this rule to run. Having no match conditions means the actions will always run.
    MatchValue <List<String>>: Match values to match against. The operator will apply to each value in here with OR semantics. If any of them match the variable with the given operator this match condition is considered a match.
    MatchVariable <String>: Match Variable
    Operator <String>: Describes operator to apply to the match condition.
    [NegateCondition <Boolean?>]: Describes if this is negate condition or not
    [Selector <String>]: Name of selector in RequestHeader or RequestBody to be matched
    [Transform <List<String>>]: List of transforms
  [MatchProcessingBehavior <String>]: If this rule is a match should the rules engine continue running the remaining rules or stop. If not present, defaults to Continue.
.Link
https://learn.microsoft.com/powershell/module/az.frontdoor/set-azfrontdoorrulesengine
#>
function Set-AzFrontDoorRulesEngine {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IRulesEngine])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Front Door which is globally unique.
    ${FrontDoorName},

    [Parameter(Mandatory)]
    [Alias('RulesEngineName')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Rules Engine which is unique within the Front Door.
    ${Name},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Resource group within the Azure subscription.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The subscription credentials which uniquely identify the Microsoft Azure subscription.
    # The subscription ID forms part of the URI for every service call.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IRulesEngineRule[]]
    # A list of rules that define a particular Rules Engine Configuration.
    ${Rule},

    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Update operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Json string supplied to the Update operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $mapping = @{
            UpdateExpanded = 'Az.FrontDoor.private\Set-AzFrontDoorRulesEngine_UpdateExpanded';
            UpdateViaJsonFilePath = 'Az.FrontDoor.private\Set-AzFrontDoorRulesEngine_UpdateViaJsonFilePath';
            UpdateViaJsonString = 'Az.FrontDoor.private\Set-AzFrontDoorRulesEngine_UpdateViaJsonString';
        }
        if (('UpdateExpanded', 'UpdateViaJsonFilePath', 'UpdateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Update policy with specified rule set name within a resource group.
.Description
Update policy with specified rule set name within a resource group.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IWebApplicationFirewallPolicy
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CUSTOMRULE <ICustomRule[]>: List of rules
  Action <String>: Describes what action to be applied when rule matches.
  MatchCondition <List<IMatchCondition>>: List of match conditions.
    MatchValue <List<String>>: List of possible match values.
    MatchVariable <String>: Request variable to compare with.
    OperatorProperty <String>: Comparison type to use for matching with the variable value.
    [NegateCondition <Boolean?>]: Describes if the result of this condition should be negated.
    [Selector <String>]: Match against a specific key from the QueryString, PostArgs, RequestHeader or Cookies variables. Default is null.
    [Transform <List<String>>]: List of transforms.
  Priority <Int32>: Describes priority of the rule. Rules with a lower value will be evaluated before rules with a higher value.
  RuleType <String>: Describes type of rule.
  [EnabledState <String>]: Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
  [GroupBy <List<IGroupByVariable>>]: Describes the list of variables to group the rate limit requests
    VariableName <String>: Describes the supported variable for group by
  [Name <String>]: Describes the name of the rule.
  [RateLimitDurationInMinutes <Int32?>]: Time window for resetting the rate limit count. Default is 1 minute.
  [RateLimitThreshold <Int32?>]: Number of allowed requests per client within the time window.

MANAGEDRULESET <IManagedRuleSet[]>: List of rule sets.
  Type <String>: Defines the rule set type to use.
  Version <String>: Defines the version of the rule set to use.
  [Exclusion <List<IManagedRuleExclusion>>]: Describes the exclusions that are applied to all rules in the set.
    Operator <String>: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to.
    Selector <String>: Selector value for which elements in the collection this exclusion applies to.
    Variable <String>: The variable type to be excluded.
  [RuleGroupOverride <List<IManagedRuleGroupOverride>>]: Defines the rule group overrides to apply to the rule set.
    RuleGroupName <String>: Describes the managed rule group to override.
    [Exclusion <List<IManagedRuleExclusion>>]: Describes the exclusions that are applied to all rules in the group.
    [ManagedRuleOverride <List<IManagedRuleOverride>>]: List of rules that will be disabled. If none specified, all rules in the group will be disabled.
      RuleId <String>: Identifier for the managed rule.
      [Action <String>]: Describes the override action to be applied when rule matches.
      [EnabledState <String>]: Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
      [Exclusion <List<IManagedRuleExclusion>>]: Describes the exclusions that are applied to this specific rule.
  [RuleSetAction <String>]: Defines the rule set action.

POLICYSETTING <IPolicySettings>: Describes settings for the policy.
  [CustomBlockResponseBody <String>]: If the action type is block, customer can override the response body. The body must be specified in base64 encoding.
  [CustomBlockResponseStatusCode <Int32?>]: If the action type is block, customer can override the response status code.
  [EnabledState <String>]: Describes if the policy is in enabled or disabled state. Defaults to Enabled if not specified.
  [JavascriptChallengeExpirationInMinutes <Int32?>]: Defines the JavaScript challenge cookie validity lifetime in minutes. This setting is only applicable to Premium_AzureFrontDoor. Value must be an integer between 5 and 1440 with the default value being 30.
  [LogScrubbingSetting <IPolicySettingsLogScrubbing>]: Defines rules that scrub sensitive fields in the Web Application Firewall logs.
    [ScrubbingRule <List<IWebApplicationFirewallScrubbingRules>>]: List of log scrubbing rules applied to the Web Application Firewall logs.
      MatchVariable <String>: The variable to be scrubbed from the logs.
      SelectorMatchOperator <String>: When matchVariable is a collection, operate on the selector to specify which elements in the collection this rule applies to.
      [Selector <String>]: When matchVariable is a collection, operator used to specify which elements in the collection this rule applies to.
      [State <String>]: Defines the state of a log scrubbing rule. Default value is enabled.
    [State <String>]: State of the log scrubbing config. Default value is Enabled.
  [Mode <String>]: Describes if it is in detection mode or prevention mode at policy level.
  [RedirectUrl <String>]: If action type is redirect, this field represents redirect URL for the client.
  [RequestBodyCheck <String>]: Describes if policy managed rules will inspect the request body content.
.Link
https://learn.microsoft.com/powershell/module/az.frontdoor/set-azfrontdoorwafpolicy
#>
function Set-AzFrontDoorWafPolicy {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IWebApplicationFirewallPolicy])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('PolicyName')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # The name of the Web Application Firewall Policy.
    ${Name},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Resource group within the Azure subscription.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The subscription credentials which uniquely identify the Microsoft Azure subscription.
    # The subscription ID forms part of the URI for every service call.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.ICustomRule[]]
    # List of rules
    ${CustomRule},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Gets a unique read-only string that changes whenever the resource is updated.
    ${Etag},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IManagedRuleSet[]]
    # List of rule sets.
    ${ManagedRuleSet},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IPolicySettings]
    # Describes settings for the policy.
    ${PolicySetting},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.PSArgumentCompleterAttribute("Classic_AzureFrontDoor", "Standard_AzureFrontDoor", "Premium_AzureFrontDoor")]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Name of the pricing tier.
    ${SkuName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Update operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Json string supplied to the Update operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $mapping = @{
            UpdateExpanded = 'Az.FrontDoor.private\Set-AzFrontDoorWafPolicy_UpdateExpanded';
            UpdateViaJsonFilePath = 'Az.FrontDoor.private\Set-AzFrontDoorWafPolicy_UpdateViaJsonFilePath';
            UpdateViaJsonString = 'Az.FrontDoor.private\Set-AzFrontDoorWafPolicy_UpdateViaJsonString';
        }
        if (('UpdateExpanded', 'UpdateViaJsonFilePath', 'UpdateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        if (('UpdateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('Location') ) {
            $PSBoundParameters['Location'] = "global"
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Update a new Front Door with a Front Door name under the specified subscription and resource group.
.Description
Update a new Front Door with a Front Door name under the specified subscription and resource group.
.Example
Set-AzFrontDoor -Name "frontDoor1" -ResourceGroupName "resourceGroup1" -RoutingRule $routingrule1 -BackendPool $backendpool1 -FrontendEndpoint $frontendEndpoint1 -LoadBalancingSetting $loadBalancingSetting1 -HealthProbeSetting $healthProbeSetting1 -BackendPoolsSetting $backendPoolsSetting1
.Example
Set-AzFrontDoor -InputObject $frontDoor1 -RoutingRule $routingrule1 -BackendPool $backendpool1 -FrontendEndpoint $frontendEndpoint1 -LoadBalancingSetting $loadBalancingSetting1 -HealthProbeSetting $healthProbeSetting1 -BackendPoolsSetting $backendPoolsSetting1
.Example
Set-AzFrontDoor -ResourceId $resourceId -RoutingRule $routingrule1 -BackendPool $backendpool1 -FrontendEndpoint $frontendEndpoint1 -LoadBalancingSetting $loadBalancingSetting1 -HealthProbeSetting $healthProbeSetting1 -BackendPoolsSetting $backendPoolsSetting1
.Example
Set-AzFrontDoor -InputObject $frontDoor1 -RoutingRule $routingrule1 -BackendPool $backendpool1 -FrontendEndpoint $frontendEndpoint1 -LoadBalancingSetting $loadBalancingSetting1 -HealthProbeSetting $healthProbeSetting1 -DisableCertificateNameCheck

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontDoor
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BACKENDPOOL <IBackendPool[]>: Backend pools available to routing rules.
  [Id <String>]: Resource ID.
  [Backend <List<IBackend>>]: The set of backends for this pool
    [Address <String>]: Location of the backend (IP address or FQDN)
    [BackendHostHeader <String>]: The value to use as the host header sent to the backend. If blank or unspecified, this defaults to the incoming host.
    [EnabledState <String>]: Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled'
    [HttpPort <Int32?>]: The HTTP TCP port number. Must be between 1 and 65535.
    [HttpsPort <Int32?>]: The HTTPS TCP port number. Must be between 1 and 65535.
    [Priority <Int32?>]: Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy.
    [PrivateLinkAlias <String>]: The Alias of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
    [PrivateLinkApprovalMessage <String>]: A custom message to be included in the approval request to connect to the Private Link
    [PrivateLinkLocation <String>]: The location of the Private Link resource. Required only if 'privateLinkResourceId' is populated
    [PrivateLinkResourceId <String>]: The Resource Id of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
    [Weight <Int32?>]: Weight of this endpoint for load balancing purposes.
  [HealthProbeSettingId <String>]: Resource ID.
  [LoadBalancingSettingId <String>]: Resource ID.
  [Name <String>]: Resource name.

BACKENDPOOLSSETTING <IBackendPoolsSettings>: Settings for all backendPools
  [EnforceCertificateNameCheck <String>]: Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests.
  [SendRecvTimeoutInSeconds <Int32?>]: Send and receive timeout on forwarding request to the backend. When timeout is reached, the request fails and returns.

FRONTENDENDPOINT <IFrontendEndpoint[]>: Frontend endpoints available to routing rules.
  [Id <String>]: Resource ID.
  [CertificateSource <String>]: Defines the source of the SSL certificate
  [CertificateType <String>]: Defines the type of the certificate used for secure connections to a frontendEndpoint
  [HostName <String>]: The host name of the frontendEndpoint. Must be a domain name.
  [MinimumTlsVersion <String>]: The minimum TLS version required from the clients to establish an SSL handshake with Front Door.
  [Name <String>]: Resource name.
  [SecretName <String>]: The name of the Key Vault secret representing the full certificate PFX
  [SecretVersion <String>]: The version of the Key Vault secret representing the full certificate PFX
  [SessionAffinityEnabledState <String>]: Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
  [SessionAffinityTtlInSeconds <Int32?>]: UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if applicable.
  [Vault <String>]: Resource ID.
  [WebApplicationFirewallPolicyLinkId <String>]: Resource ID.

HEALTHPROBESETTING <IHealthProbeSettingsModel[]>: Health probe settings associated with this Front Door instance.
  [Id <String>]: Resource ID.
  [EnabledState <String>]: Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool.
  [HealthProbeMethod <String>]: Configures which HTTP method to use to probe the backends defined under backendPools.
  [IntervalInSeconds <Int32?>]: The number of seconds between health probes.
  [Name <String>]: Resource name.
  [Path <String>]: The path to use for the health probe. Default is /
  [Protocol <String>]: Protocol scheme to use for this probe

LOADBALANCINGSETTING <ILoadBalancingSettingsModel[]>: Load balancing settings associated with this Front Door instance.
  [Id <String>]: Resource ID.
  [AdditionalLatencyInMilliseconds <Int32?>]: The additional latency in milliseconds for probes to fall into the lowest latency bucket
  [Name <String>]: Resource name.
  [SampleSize <Int32?>]: The number of samples to consider for load balancing decisions
  [SuccessfulSamplesRequired <Int32?>]: The number of samples within the sample period that must succeed

ROUTINGRULE <IRoutingRule[]>: Routing rules associated with this Front Door.
  [Id <String>]: Resource ID.
  [AcceptedProtocol <List<String>>]: Protocol schemes to match for this rule
  [EnabledState <String>]: Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
  [FrontendEndpoint <List<ISubResource>>]: Frontend endpoints associated with this rule
    [Id <String>]: Resource ID.
  [Name <String>]: Resource name.
  [PatternsToMatch <List<String>>]: The route patterns of the rule.
  [RouteConfiguration <IRouteConfiguration>]: A reference to the routing configuration.
    OdataType <String>: 
  [RuleEngineId <String>]: Resource ID.
  [WebApplicationFirewallPolicyLinkId <String>]: Resource ID.
.Link
https://learn.microsoft.com/powershell/module/az.frontdoor/set-azfrontdoor
#>
function Set-AzFrontDoor {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontDoor])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('FrontDoorName')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Front Door which is globally unique.
    ${Name},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Resource group within the Azure subscription.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The subscription credentials which uniquely identify the Microsoft Azure subscription.
    # The subscription ID forms part of the URI for every service call.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IBackendPool[]]
    # Backend pools available to routing rules.
    ${BackendPool},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IBackendPoolsSettings]
    # Settings for all backendPools
    ${BackendPoolsSetting},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.PSArgumentCompleterAttribute("Enabled", "Disabled")]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Operational status of the Front Door load balancer.
    # Permitted values are 'Enabled' or 'Disabled'
    ${EnabledState},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # A friendly name for the frontDoor
    ${FriendlyName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontendEndpoint[]]
    # Frontend endpoints available to routing rules.
    ${FrontendEndpoint},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IHealthProbeSettingsModel[]]
    # Health probe settings associated with this Front Door instance.
    ${HealthProbeSetting},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.ILoadBalancingSettingsModel[]]
    # Load balancing settings associated with this Front Door instance.
    ${LoadBalancingSetting},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IRoutingRule[]]
    # Routing rules associated with this Front Door.
    ${RoutingRule},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Update operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Json string supplied to the Update operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $mapping = @{
            UpdateExpanded = 'Az.FrontDoor.private\Set-AzFrontDoor_UpdateExpanded';
            UpdateViaJsonFilePath = 'Az.FrontDoor.private\Set-AzFrontDoor_UpdateViaJsonFilePath';
            UpdateViaJsonString = 'Az.FrontDoor.private\Set-AzFrontDoor_UpdateViaJsonString';
        }
        if (('UpdateExpanded', 'UpdateViaJsonFilePath', 'UpdateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        if (('UpdateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('Location') ) {
            $PSBoundParameters['Location'] = "global"
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Validates the custom domain mapping to ensure it maps to the correct Front Door endpoint in DNS.
.Description
Validates the custom domain mapping to ensure it maps to the correct Front Door endpoint in DNS.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontDoorIdentity
.Inputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IValidateCustomDomainInput
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IValidateCustomDomainOutput
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CUSTOMDOMAINPROPERTY <IValidateCustomDomainInput>: Input of the custom domain to be validated for DNS mapping.
  HostName <String>: The host name of the custom domain. Must be a domain name.

INPUTOBJECT <IFrontDoorIdentity>: Identity Parameter
  [FrontDoorName <String>]: Name of the Front Door which is globally unique.
  [FrontendEndpointName <String>]: Name of the Frontend endpoint which is unique within the Front Door.
  [Id <String>]: Resource identity path
  [PolicyName <String>]: The name of the Web Application Firewall Policy.
  [ResourceGroupName <String>]: Name of the Resource group within the Azure subscription.
  [RulesEngineName <String>]: Name of the Rules Engine which is unique within the Front Door.
  [SubscriptionId <String>]: The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.
.Link
https://learn.microsoft.com/powershell/module/az.frontdoor/test-azfrontdoorcustomdomain
#>
function Test-AzFrontDoorCustomDomain {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IValidateCustomDomainOutput])]
[CmdletBinding(DefaultParameterSetName='ValidateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Validate', Mandatory)]
    [Parameter(ParameterSetName='ValidateExpanded', Mandatory)]
    [Parameter(ParameterSetName='ValidateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='ValidateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Front Door which is globally unique.
    ${FrontDoorName},

    [Parameter(ParameterSetName='Validate', Mandatory)]
    [Parameter(ParameterSetName='ValidateExpanded', Mandatory)]
    [Parameter(ParameterSetName='ValidateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='ValidateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Resource group within the Azure subscription.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Validate')]
    [Parameter(ParameterSetName='ValidateExpanded')]
    [Parameter(ParameterSetName='ValidateViaJsonFilePath')]
    [Parameter(ParameterSetName='ValidateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The subscription credentials which uniquely identify the Microsoft Azure subscription.
    # The subscription ID forms part of the URI for every service call.
    ${SubscriptionId},

    [Parameter(ParameterSetName='ValidateViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ValidateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontDoorIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='Validate', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ValidateViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IValidateCustomDomainInput]
    # Input of the custom domain to be validated for DNS mapping.
    ${CustomDomainProperty},

    [Parameter(ParameterSetName='ValidateExpanded', Mandatory)]
    [Parameter(ParameterSetName='ValidateViaIdentityExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # The host name of the custom domain.
    # Must be a domain name.
    ${HostName},

    [Parameter(ParameterSetName='ValidateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Validate operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='ValidateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Json string supplied to the Validate operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $mapping = @{
            Validate = 'Az.FrontDoor.private\Test-AzFrontDoorCustomDomain_Validate';
            ValidateExpanded = 'Az.FrontDoor.private\Test-AzFrontDoorCustomDomain_ValidateExpanded';
            ValidateViaIdentity = 'Az.FrontDoor.private\Test-AzFrontDoorCustomDomain_ValidateViaIdentity';
            ValidateViaIdentityExpanded = 'Az.FrontDoor.private\Test-AzFrontDoorCustomDomain_ValidateViaIdentityExpanded';
            ValidateViaJsonFilePath = 'Az.FrontDoor.private\Test-AzFrontDoorCustomDomain_ValidateViaJsonFilePath';
            ValidateViaJsonString = 'Az.FrontDoor.private\Test-AzFrontDoorCustomDomain_ValidateViaJsonString';
        }
        if (('Validate', 'ValidateExpanded', 'ValidateViaJsonFilePath', 'ValidateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Check the availability of a Front Door subdomain.
.Description
Check the availability of a Front Door subdomain.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.ICheckNameAvailabilityInput
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.ICheckNameAvailabilityOutput
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CHECKFRONTDOORNAMEAVAILABILITYINPUT <ICheckNameAvailabilityInput>: Input of CheckNameAvailability API.
  Name <String>: The resource name to validate.
  Type <String>: The type of the resource whose name is to be validated.
.Link
https://learn.microsoft.com/powershell/module/az.frontdoor/test-azfrontdoornameavailabilitywithsubscription
#>
function Test-AzFrontDoorNameAvailabilityWithSubscription {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.ICheckNameAvailabilityOutput])]
[CmdletBinding(DefaultParameterSetName='CheckExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The subscription credentials which uniquely identify the Microsoft Azure subscription.
    # The subscription ID forms part of the URI for every service call.
    ${SubscriptionId},

    [Parameter(ParameterSetName='Check', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.ICheckNameAvailabilityInput]
    # Input of CheckNameAvailability API.
    ${CheckFrontDoorNameAvailabilityInput},

    [Parameter(ParameterSetName='CheckExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # The resource name to validate.
    ${Name},

    [Parameter(ParameterSetName='CheckExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.PSArgumentCompleterAttribute("Microsoft.Network/frontDoors", "Microsoft.Network/frontDoors/frontendEndpoints")]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # The type of the resource whose name is to be validated.
    ${Type},

    [Parameter(ParameterSetName='CheckViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Check operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CheckViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Json string supplied to the Check operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $mapping = @{
            Check = 'Az.FrontDoor.private\Test-AzFrontDoorNameAvailabilityWithSubscription_Check';
            CheckExpanded = 'Az.FrontDoor.private\Test-AzFrontDoorNameAvailabilityWithSubscription_CheckExpanded';
            CheckViaJsonFilePath = 'Az.FrontDoor.private\Test-AzFrontDoorNameAvailabilityWithSubscription_CheckViaJsonFilePath';
            CheckViaJsonString = 'Az.FrontDoor.private\Test-AzFrontDoorNameAvailabilityWithSubscription_CheckViaJsonString';
        }
        if (('Check', 'CheckExpanded', 'CheckViaJsonFilePath', 'CheckViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Check the availability of a Front Door resource name.
.Description
Check the availability of a Front Door resource name.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.ICheckNameAvailabilityInput
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.ICheckNameAvailabilityOutput
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CHECKFRONTDOORNAMEAVAILABILITYINPUT <ICheckNameAvailabilityInput>: Input of CheckNameAvailability API.
  Name <String>: The resource name to validate.
  Type <String>: The type of the resource whose name is to be validated.
.Link
https://learn.microsoft.com/powershell/module/az.frontdoor/test-azfrontdoornameavailability
#>
function Test-AzFrontDoorNameAvailability {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.ICheckNameAvailabilityOutput])]
[CmdletBinding(DefaultParameterSetName='CheckExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Check', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.ICheckNameAvailabilityInput]
    # Input of CheckNameAvailability API.
    ${CheckFrontDoorNameAvailabilityInput},

    [Parameter(ParameterSetName='CheckExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # The resource name to validate.
    ${Name},

    [Parameter(ParameterSetName='CheckExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.PSArgumentCompleterAttribute("Microsoft.Network/frontDoors", "Microsoft.Network/frontDoors/frontendEndpoints")]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # The type of the resource whose name is to be validated.
    ${Type},

    [Parameter(ParameterSetName='CheckViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Check operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CheckViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Json string supplied to the Check operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $mapping = @{
            Check = 'Az.FrontDoor.private\Test-AzFrontDoorNameAvailability_Check';
            CheckExpanded = 'Az.FrontDoor.private\Test-AzFrontDoorNameAvailability_CheckExpanded';
            CheckViaJsonFilePath = 'Az.FrontDoor.private\Test-AzFrontDoorNameAvailability_CheckViaJsonFilePath';
            CheckViaJsonString = 'Az.FrontDoor.private\Test-AzFrontDoorNameAvailability_CheckViaJsonString';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Update policy with specified rule set name within a resource group.
.Description
Update policy with specified rule set name within a resource group.
.Example
Update-AzFrontDoorWafPolicy -Name $policyName -ResourceGroupName $resourceGroupName -CustomBlockResponseStatusCode 403
.Example
Update-AzFrontDoorWafPolicy -Name $policyName -ResourceGroupName $resourceGroupName -Mode Detection
.Example
Update-AzFrontDoorWafPolicy -Name $policyName -ResourceGroupName $resourceGroupName -Mode Detection -EnabledState Disabled
.Example
Get-AzFrontDoorWafPolicy -ResourceGroupName $resourceGroupName | Update-AzFrontDoorWafPolicy -Mode Detection -EnabledState Disabled

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontDoorIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IWebApplicationFirewallPolicy
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CUSTOMRULE <ICustomRule[]>: List of rules
  Action <String>: Describes what action to be applied when rule matches.
  MatchCondition <List<IMatchCondition>>: List of match conditions.
    MatchValue <List<String>>: List of possible match values.
    MatchVariable <String>: Request variable to compare with.
    OperatorProperty <String>: Comparison type to use for matching with the variable value.
    [NegateCondition <Boolean?>]: Describes if the result of this condition should be negated.
    [Selector <String>]: Match against a specific key from the QueryString, PostArgs, RequestHeader or Cookies variables. Default is null.
    [Transform <List<String>>]: List of transforms.
  Priority <Int32>: Describes priority of the rule. Rules with a lower value will be evaluated before rules with a higher value.
  RuleType <String>: Describes type of rule.
  [EnabledState <String>]: Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
  [GroupBy <List<IGroupByVariable>>]: Describes the list of variables to group the rate limit requests
    VariableName <String>: Describes the supported variable for group by
  [Name <String>]: Describes the name of the rule.
  [RateLimitDurationInMinutes <Int32?>]: Time window for resetting the rate limit count. Default is 1 minute.
  [RateLimitThreshold <Int32?>]: Number of allowed requests per client within the time window.

INPUTOBJECT <IFrontDoorIdentity>: Identity Parameter
  [FrontDoorName <String>]: Name of the Front Door which is globally unique.
  [FrontendEndpointName <String>]: Name of the Frontend endpoint which is unique within the Front Door.
  [Id <String>]: Resource identity path
  [PolicyName <String>]: The name of the Web Application Firewall Policy.
  [ResourceGroupName <String>]: Name of the Resource group within the Azure subscription.
  [RulesEngineName <String>]: Name of the Rules Engine which is unique within the Front Door.
  [SubscriptionId <String>]: The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.

MANAGEDRULESET <IManagedRuleSet[]>: List of rule sets.
  Type <String>: Defines the rule set type to use.
  Version <String>: Defines the version of the rule set to use.
  [Exclusion <List<IManagedRuleExclusion>>]: Describes the exclusions that are applied to all rules in the set.
    Operator <String>: Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to.
    Selector <String>: Selector value for which elements in the collection this exclusion applies to.
    Variable <String>: The variable type to be excluded.
  [RuleGroupOverride <List<IManagedRuleGroupOverride>>]: Defines the rule group overrides to apply to the rule set.
    RuleGroupName <String>: Describes the managed rule group to override.
    [Exclusion <List<IManagedRuleExclusion>>]: Describes the exclusions that are applied to all rules in the group.
    [ManagedRuleOverride <List<IManagedRuleOverride>>]: List of rules that will be disabled. If none specified, all rules in the group will be disabled.
      RuleId <String>: Identifier for the managed rule.
      [Action <String>]: Describes the override action to be applied when rule matches.
      [EnabledState <String>]: Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified.
      [Exclusion <List<IManagedRuleExclusion>>]: Describes the exclusions that are applied to this specific rule.
  [RuleSetAction <String>]: Defines the rule set action.

POLICYSETTING <IPolicySettings>: Describes settings for the policy.
  [CustomBlockResponseBody <String>]: If the action type is block, customer can override the response body. The body must be specified in base64 encoding.
  [CustomBlockResponseStatusCode <Int32?>]: If the action type is block, customer can override the response status code.
  [EnabledState <String>]: Describes if the policy is in enabled or disabled state. Defaults to Enabled if not specified.
  [JavascriptChallengeExpirationInMinutes <Int32?>]: Defines the JavaScript challenge cookie validity lifetime in minutes. This setting is only applicable to Premium_AzureFrontDoor. Value must be an integer between 5 and 1440 with the default value being 30.
  [LogScrubbingSetting <IPolicySettingsLogScrubbing>]: Defines rules that scrub sensitive fields in the Web Application Firewall logs.
    [ScrubbingRule <List<IWebApplicationFirewallScrubbingRules>>]: List of log scrubbing rules applied to the Web Application Firewall logs.
      MatchVariable <String>: The variable to be scrubbed from the logs.
      SelectorMatchOperator <String>: When matchVariable is a collection, operate on the selector to specify which elements in the collection this rule applies to.
      [Selector <String>]: When matchVariable is a collection, operator used to specify which elements in the collection this rule applies to.
      [State <String>]: Defines the state of a log scrubbing rule. Default value is enabled.
    [State <String>]: State of the log scrubbing config. Default value is Enabled.
  [Mode <String>]: Describes if it is in detection mode or prevention mode at policy level.
  [RedirectUrl <String>]: If action type is redirect, this field represents redirect URL for the client.
  [RequestBodyCheck <String>]: Describes if policy managed rules will inspect the request body content.
.Link
https://learn.microsoft.com/powershell/module/az.frontdoor/update-azfrontdoorwafpolicy
#>
function Update-AzFrontDoorWafPolicy {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IWebApplicationFirewallPolicy])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Alias('PolicyName')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # The name of the Web Application Firewall Policy.
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Resource group within the Azure subscription.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The subscription credentials which uniquely identify the Microsoft Azure subscription.
    # The subscription ID forms part of the URI for every service call.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontDoorIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.ICustomRule[]]
    # List of rules
    ${CustomRule},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Gets a unique read-only string that changes whenever the resource is updated.
    ${Etag},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IManagedRuleSet[]]
    # List of rule sets.
    ${ManagedRuleSet},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IPolicySettings]
    # Describes settings for the policy.
    ${PolicySetting},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.PSArgumentCompleterAttribute("Classic_AzureFrontDoor", "Standard_AzureFrontDoor", "Premium_AzureFrontDoor")]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Name of the pricing tier.
    ${SkuName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $mapping = @{
            UpdateExpanded = 'Az.FrontDoor.private\Update-AzFrontDoorWafPolicy_UpdateExpanded';
            UpdateViaIdentityExpanded = 'Az.FrontDoor.private\Update-AzFrontDoorWafPolicy_UpdateViaIdentityExpanded';
        }
        if (('UpdateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        if (('UpdateExpanded', 'UpdateViaIdentityExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('Location') ) {
            $PSBoundParameters['Location'] = "global"
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Update a new Front Door with a Front Door name under the specified subscription and resource group.
.Description
Update a new Front Door with a Front Door name under the specified subscription and resource group.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontDoorIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontDoor
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BACKENDPOOL <IBackendPool[]>: Backend pools available to routing rules.
  [Id <String>]: Resource ID.
  [Backend <List<IBackend>>]: The set of backends for this pool
    [Address <String>]: Location of the backend (IP address or FQDN)
    [BackendHostHeader <String>]: The value to use as the host header sent to the backend. If blank or unspecified, this defaults to the incoming host.
    [EnabledState <String>]: Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled'
    [HttpPort <Int32?>]: The HTTP TCP port number. Must be between 1 and 65535.
    [HttpsPort <Int32?>]: The HTTPS TCP port number. Must be between 1 and 65535.
    [Priority <Int32?>]: Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy.
    [PrivateLinkAlias <String>]: The Alias of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
    [PrivateLinkApprovalMessage <String>]: A custom message to be included in the approval request to connect to the Private Link
    [PrivateLinkLocation <String>]: The location of the Private Link resource. Required only if 'privateLinkResourceId' is populated
    [PrivateLinkResourceId <String>]: The Resource Id of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
    [Weight <Int32?>]: Weight of this endpoint for load balancing purposes.
  [HealthProbeSettingId <String>]: Resource ID.
  [LoadBalancingSettingId <String>]: Resource ID.
  [Name <String>]: Resource name.

BACKENDPOOLSSETTING <IBackendPoolsSettings>: Settings for all backendPools
  [EnforceCertificateNameCheck <String>]: Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests.
  [SendRecvTimeoutInSeconds <Int32?>]: Send and receive timeout on forwarding request to the backend. When timeout is reached, the request fails and returns.

FRONTENDENDPOINT <IFrontendEndpoint[]>: Frontend endpoints available to routing rules.
  [Id <String>]: Resource ID.
  [CertificateSource <String>]: Defines the source of the SSL certificate
  [CertificateType <String>]: Defines the type of the certificate used for secure connections to a frontendEndpoint
  [HostName <String>]: The host name of the frontendEndpoint. Must be a domain name.
  [MinimumTlsVersion <String>]: The minimum TLS version required from the clients to establish an SSL handshake with Front Door.
  [Name <String>]: Resource name.
  [SecretName <String>]: The name of the Key Vault secret representing the full certificate PFX
  [SecretVersion <String>]: The version of the Key Vault secret representing the full certificate PFX
  [SessionAffinityEnabledState <String>]: Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
  [SessionAffinityTtlInSeconds <Int32?>]: UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if applicable.
  [Vault <String>]: Resource ID.
  [WebApplicationFirewallPolicyLinkId <String>]: Resource ID.

HEALTHPROBESETTING <IHealthProbeSettingsModel[]>: Health probe settings associated with this Front Door instance.
  [Id <String>]: Resource ID.
  [EnabledState <String>]: Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool.
  [HealthProbeMethod <String>]: Configures which HTTP method to use to probe the backends defined under backendPools.
  [IntervalInSeconds <Int32?>]: The number of seconds between health probes.
  [Name <String>]: Resource name.
  [Path <String>]: The path to use for the health probe. Default is /
  [Protocol <String>]: Protocol scheme to use for this probe

INPUTOBJECT <IFrontDoorIdentity>: Identity Parameter
  [FrontDoorName <String>]: Name of the Front Door which is globally unique.
  [FrontendEndpointName <String>]: Name of the Frontend endpoint which is unique within the Front Door.
  [Id <String>]: Resource identity path
  [PolicyName <String>]: The name of the Web Application Firewall Policy.
  [ResourceGroupName <String>]: Name of the Resource group within the Azure subscription.
  [RulesEngineName <String>]: Name of the Rules Engine which is unique within the Front Door.
  [SubscriptionId <String>]: The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.

LOADBALANCINGSETTING <ILoadBalancingSettingsModel[]>: Load balancing settings associated with this Front Door instance.
  [Id <String>]: Resource ID.
  [AdditionalLatencyInMilliseconds <Int32?>]: The additional latency in milliseconds for probes to fall into the lowest latency bucket
  [Name <String>]: Resource name.
  [SampleSize <Int32?>]: The number of samples to consider for load balancing decisions
  [SuccessfulSamplesRequired <Int32?>]: The number of samples within the sample period that must succeed

ROUTINGRULE <IRoutingRule[]>: Routing rules associated with this Front Door.
  [Id <String>]: Resource ID.
  [AcceptedProtocol <List<String>>]: Protocol schemes to match for this rule
  [EnabledState <String>]: Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
  [FrontendEndpoint <List<ISubResource>>]: Frontend endpoints associated with this rule
    [Id <String>]: Resource ID.
  [Name <String>]: Resource name.
  [PatternsToMatch <List<String>>]: The route patterns of the rule.
  [RouteConfiguration <IRouteConfiguration>]: A reference to the routing configuration.
    OdataType <String>: 
  [RuleEngineId <String>]: Resource ID.
  [WebApplicationFirewallPolicyLinkId <String>]: Resource ID.
.Link
https://learn.microsoft.com/powershell/module/az.frontdoor/update-azfrontdoor
#>
function Update-AzFrontDoor {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontDoor])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Alias('FrontDoorName')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Front Door which is globally unique.
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Resource group within the Azure subscription.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The subscription credentials which uniquely identify the Microsoft Azure subscription.
    # The subscription ID forms part of the URI for every service call.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontDoorIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IBackendPool[]]
    # Backend pools available to routing rules.
    ${BackendPool},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IBackendPoolsSettings]
    # Settings for all backendPools
    ${BackendPoolsSetting},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.PSArgumentCompleterAttribute("Enabled", "Disabled")]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Operational status of the Front Door load balancer.
    # Permitted values are 'Enabled' or 'Disabled'
    ${EnabledState},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # A friendly name for the frontDoor
    ${FriendlyName},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontendEndpoint[]]
    # Frontend endpoints available to routing rules.
    ${FrontendEndpoint},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IHealthProbeSettingsModel[]]
    # Health probe settings associated with this Front Door instance.
    ${HealthProbeSetting},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.ILoadBalancingSettingsModel[]]
    # Load balancing settings associated with this Front Door instance.
    ${LoadBalancingSetting},

    [Parameter()]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IRoutingRule[]]
    # Routing rules associated with this Front Door.
    ${RoutingRule},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $mapping = @{
            UpdateExpanded = 'Az.FrontDoor.private\Update-AzFrontDoor_UpdateExpanded';
            UpdateViaIdentityExpanded = 'Az.FrontDoor.private\Update-AzFrontDoor_UpdateViaIdentityExpanded';
        }
        if (('UpdateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        if (('UpdateExpanded', 'UpdateViaIdentityExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('Location') ) {
            $PSBoundParameters['Location'] = "global"
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}
