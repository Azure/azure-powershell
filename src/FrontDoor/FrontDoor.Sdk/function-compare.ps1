param(
    [Parameter(Mandatory,
        HelpMessage = "Set the path of the sdk code generated by autorest.csharp")]
    [string]
    $CsharpSdkPath,

    [Parameter(Mandatory,
        HelpMessage = "Set the path of the sdk code generated by autorest.powershell")]
    [string]$PowerShellSdkPath,

    [Parameter(HelpMessage = "Will save the result to a file if set to true")]
    [switch]$SaveResult
)

class DifferentFunctions {
    [string]$CsharpFunction
    [string]$PowerShellFunction
    [string]$FileName
}

class FunctionElement {
    [string]$ValidContent
    [string]$OriginContent
}
function RemoveNestedBrackets($str) {
    $regex = '<([^<>]*)>'
    while ($str -match $regex) {
        $str = $str -replace $regex, $matches[1]
        $str = RemoveNestedBrackets($str)
    }
    return $str
}

function IsParameterCountSame {
    param (
        [string]
        $CsharpFunction,

        [string]
        $PowerShellFunction
    )
    $CsharpFunction = RemoveNestedBrackets($CsharpFunction);
    $PowerShellFunction = RemoveNestedBrackets($PowerShellFunction);
    $csharpParameterCount = $CsharpFunction.Split("(", 2)[1].Split(",").Count
    $psParameterCount = $PowerShellFunction.Split("(", 2)[1].Split(",").Count
    return $csharpParameterCount -eq $psParameterCount
}
function GetPowerShellFunction {
    param (
        [FunctionElement]
        $CsharpFunction,

        [Object[]]
        $PowerShellContent
    )

    foreach ($content in $PowerShellContent) {
        $functionName = $CsharpFunction.OriginContent.Split("(")[0].Trim();
        $psFunctionName = $content.OriginContent.Split("(")[0].Trim();
        if (($functionName -eq $psFunctionName) -and (IsParameterCountSame -CsharpFunction $CsharpFunction.OriginContent -PowerShellFunction $content.OriginContent)) {
            return $content.OriginContent
        }
    }
}
function CompareSingleSdkFile {
    param (
        [string]
        $CsharpFilePath,

        [string]
        $PowerShellFilePath
    )
    $regex = "^(\s*public\s+(async\s+)?(\S+\s+)?\S+\s*\((\s*(\S+\s+)+\S+\s*(,\s*(\S+\s+)+\S+\s*)*)?\)\s*(\{|$))$";
    $result = New-Object -TypeName 'System.Collections.ArrayList';
    $fileName = Split-Path -Path $CsharpFilePath -Leaf
    $validCsharpContent = ((Get-Content -Path $CsharpFilePath) | ForEach-Object { ([FunctionElement]@{ValidContent = $_ -replace "\s+", ""; OriginContent = $_.Split(":")[0].Trim() }) } `
        | Where-Object { $_.OriginContent -match $regex })

    $validPowerShellContent = ((Get-Content -Path $PowerShellFilePath) | ForEach-Object { ([FunctionElement]@{ValidContent = $_ -replace "\s+", ""; OriginContent = $_.Split(":")[0].Trim() }) } `
        | Where-Object { $_.OriginContent -match $regex })
    
    foreach ($csharpContent in $validCsharpContent) {
        if ($validPowerShellContent.ValidContent -notcontains $csharpContent.ValidContent) {
            $element = [DifferentFunctions]::new();
            $element.CsharpFunction = $csharpContent.OriginContent.Trim();
            $element.PowerShellFunction = GetPowerShellFunction -CsharpFunction $csharpContent -PowerShellContent $validPowerShellContent;
            $element.FileName = $fileName;
            $null = $result.Add($element);
        }
    }

    return $result

}

try {
    $result = New-Object -TypeName 'System.Collections.Generic.List[PSObject]'

    $csharpApiFiles = Get-ChildItem -Path $CsharpSdkPath -File
    $powershellApiFiles = Get-ChildItem -Path $PowerShellSdkPath -File

    # Get files that exist in csharp and powershell exluding the Models folder
    $existCsharpApiFiles = $csharpApiFiles | Where-Object { $powershellApiFiles.Name -contains $_.Name }
    foreach ($existFile in $existCsharpApiFiles) {
        $powershellFile = $powershellApiFiles | Where-Object { $_.Name -eq $existFile.Name }
        $singleResult = CompareSingleSdkFile -CsharpFilePath $existFile.FullName -PowerShellFilePath $powershellFile.FullName
        if ($null -ne $singleResult) {
            if ($singleResult.count -eq 1) {
                $result.Add($singleResult)
            }
            else {
                foreach ($r in $singleResult) {
                    $result.Add($r)
                }
            }
        }
    }

    $csharpModelFiles = Get-ChildItem -Path (Join-Path $CsharpSdkPath "Models") -Recurse -File
    $powershellModelFiles = Get-ChildItem -Path (Join-Path $PowerShellSdkPath "Models") -Recurse -File

    # Get files that exist in csharp and powershell in the Models folder
    $existCsharpModelFiles = $csharpModelFiles | Where-Object { $powershellModelFiles.Name -contains $_.Name }
    foreach ($existFile in $existCsharpModelFiles) {
        $powershellFile = $powershellModelFiles | Where-Object { $_.Name -eq $existFile.Name }
        $singleResult = CompareSingleSdkFile -CsharpFilePath $existFile.FullName -PowerShellFilePath $powershellFile.FullName
        if ($null -ne $singleResult) {
            if ($singleResult.count -eq 1) {
                $result.Add($singleResult)
            }
            else {
                foreach ($r in $singleResult) {
                    $result.Add($r)
                }
            }
        }
    }

    if ($result.Count -gt 0) {
        Write-Host 'The following functions are different between SDK generated by autorest.csharp and SDK generated by autorest.powershell'
        Write-Warning('If you use any of the following {0} functions, please check whether the function is still valid in the new SDK' -f $result.Count)
        $result | Select-Object -Property FileName, CsharpFunction, PowerShellFunction | fl
    }
    else {
        Write-Host 'All functions are the same'
    }
}
catch {
    Write-Error "An error occurred"
    Write-Error ($_ | Out-String)
}
finally {
    #Save test result to csv file
    if ($SaveResult) {
        $resultFilePath = Join-Path $PSScriptRoot "changed-function-details-$((Get-Date).ToString('yyyyMMddHHmmss')).csv"
        Write-Host "The output result to the $resultFilePath"
        $result | Select-Object -Property FileName, CsharpFunction, PowerShellFunction | Export-Csv -Path $resultFilePath -NoClobber
    }
}