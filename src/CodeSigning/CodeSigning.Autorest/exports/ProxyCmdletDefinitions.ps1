
# ----------------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.2, generator: @autorest/powershell@4.0.718)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get details of a certificate profile.
.Description
Get details of a certificate profile.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Sample.API.Models.ICodeSigningIdentity
.Outputs
Sample.API.Models.ICertificateProfile
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICodeSigningIdentity>: Identity Parameter
  [AccountName <String>]: Trusted Signing account name.
  [ProfileName <String>]: Certificate profile name.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
.Link
https://learn.microsoft.com/powershell/module/codesigning/get-certificateprofile
#>
function Get-CertificateProfile {
[OutputType([Sample.API.Models.ICertificateProfile])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # Trusted Signing account name.
    ${AccountName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # Certificate profile name.
    ${ProfileName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Sample.API.Category('Path')]
    [Sample.API.Models.ICodeSigningIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Get = 'CodeSigning.private\Get-CertificateProfile_Get';
            GetViaIdentity = 'CodeSigning.private\Get-CertificateProfile_GetViaIdentity';
            List = 'CodeSigning.private\Get-CertificateProfile_List';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Get a trusted Signing Account.
.Description
Get a trusted Signing Account.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Sample.API.Models.ICodeSigningIdentity
.Outputs
Sample.API.Models.ICodeSigningAccount
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICodeSigningIdentity>: Identity Parameter
  [AccountName <String>]: Trusted Signing account name.
  [ProfileName <String>]: Certificate profile name.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
.Link
https://learn.microsoft.com/powershell/module/codesigning/get-codesigningaccount
#>
function Get-CodeSigningAccount {
[OutputType([Sample.API.Models.ICodeSigningAccount])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # Trusted Signing account name.
    ${AccountName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List1', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Parameter(ParameterSetName='List1', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Sample.API.Category('Path')]
    [Sample.API.Models.ICodeSigningIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Get = 'CodeSigning.private\Get-CodeSigningAccount_Get';
            GetViaIdentity = 'CodeSigning.private\Get-CodeSigningAccount_GetViaIdentity';
            List = 'CodeSigning.private\Get-CodeSigningAccount_List';
            List1 = 'CodeSigning.private\Get-CodeSigningAccount_List1';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
List the operations for the provider
.Description
List the operations for the provider
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Outputs
Sample.API.Models.IOperation
.Link
https://learn.microsoft.com/powershell/module/codesigning/get-operation
#>
function Get-Operation {
[OutputType([Sample.API.Models.IOperation])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            List = 'CodeSigning.private\Get-Operation_List';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
create a certificate profile.
.Description
create a certificate profile.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Sample.API.Models.ICertificateProfile
.Inputs
Sample.API.Models.ICodeSigningIdentity
.Outputs
Sample.API.Models.ICertificateProfile
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICodeSigningIdentity>: Identity Parameter
  [AccountName <String>]: Trusted Signing account name.
  [ProfileName <String>]: Certificate profile name.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.

RESOURCE <ICertificateProfile>: Certificate profile resource.
  [IdentityValidationId <String>]: Identity validation id used for the certificate subject name.
  [IncludeCity <Boolean?>]: Whether to include L in the certificate subject name. Applicable only for private trust, private trust ci profile types
  [IncludeCountry <Boolean?>]: Whether to include C in the certificate subject name. Applicable only for private trust, private trust ci profile types
  [IncludePostalCode <Boolean?>]: Whether to include PC in the certificate subject name.
  [IncludeState <Boolean?>]: Whether to include S in the certificate subject name. Applicable only for private trust, private trust ci profile types
  [IncludeStreetAddress <Boolean?>]: Whether to include STREET in the certificate subject name.
  [ProfileType <String>]: Profile type of the certificate.
  [RetryAfter <Int32?>]: 
.Link
https://learn.microsoft.com/powershell/module/codesigning/new-certificateprofile
#>
function New-CertificateProfile {
[OutputType([Sample.API.Models.ICertificateProfile])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Create', Mandatory)]
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # Trusted Signing account name.
    ${AccountName},

    [Parameter(ParameterSetName='Create', Mandatory)]
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # Certificate profile name.
    ${ProfileName},

    [Parameter(ParameterSetName='Create', Mandatory)]
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Create', Mandatory)]
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Sample.API.Category('Path')]
    [Sample.API.Models.ICodeSigningIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='Create', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='CreateViaIdentity', Mandatory, ValueFromPipeline)]
    [Sample.API.Category('Body')]
    [Sample.API.Models.ICertificateProfile]
    # Certificate profile resource.
    ${Resource},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Sample.API.Category('Body')]
    [System.String]
    # Identity validation id used for the certificate subject name.
    ${IdentityValidationId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Sample.API.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Whether to include L in the certificate subject name.
    # Applicable only for private trust, private trust ci profile types
    ${IncludeCity},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Sample.API.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Whether to include C in the certificate subject name.
    # Applicable only for private trust, private trust ci profile types
    ${IncludeCountry},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Sample.API.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Whether to include PC in the certificate subject name.
    ${IncludePostalCode},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Sample.API.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Whether to include S in the certificate subject name.
    # Applicable only for private trust, private trust ci profile types
    ${IncludeState},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Sample.API.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Whether to include STREET in the certificate subject name.
    ${IncludeStreetAddress},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Sample.API.PSArgumentCompleterAttribute("PublicTrust", "PrivateTrust", "PrivateTrustCIPolicy", "VBSEnclave", "PublicTrustTest")]
    [Sample.API.Category('Body')]
    [System.String]
    # Profile type of the certificate.
    ${ProfileType},

    [Parameter()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Create = 'CodeSigning.private\New-CertificateProfile_Create';
            CreateExpanded = 'CodeSigning.private\New-CertificateProfile_CreateExpanded';
            CreateViaIdentity = 'CodeSigning.private\New-CertificateProfile_CreateViaIdentity';
            CreateViaIdentityExpanded = 'CodeSigning.private\New-CertificateProfile_CreateViaIdentityExpanded';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
create a trusted Signing Account.
.Description
create a trusted Signing Account.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Sample.API.Models.ICodeSigningAccount
.Inputs
Sample.API.Models.ICodeSigningIdentity
.Outputs
Sample.API.Models.ICodeSigningAccount
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICodeSigningIdentity>: Identity Parameter
  [AccountName <String>]: Trusted Signing account name.
  [ProfileName <String>]: Certificate profile name.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.

RESOURCE <ICodeSigningAccount>: Trusted signing account resource.
  Location <String>: The geo-location where the resource lives
  [Tags <ITrackedResourceTags>]: Resource tags.
    [(Any) <String>]: This indicates any property can be added to this object.
  [RetryAfter <Int32?>]: 
  [SkuName <String>]: Name of the SKU.
.Link
https://learn.microsoft.com/powershell/module/codesigning/new-codesigningaccount
#>
function New-CodeSigningAccount {
[OutputType([Sample.API.Models.ICodeSigningAccount])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Create', Mandatory)]
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # Trusted Signing account name.
    ${AccountName},

    [Parameter(ParameterSetName='Create', Mandatory)]
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Create', Mandatory)]
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Sample.API.Category('Path')]
    [Sample.API.Models.ICodeSigningIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='Create', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='CreateViaIdentity', Mandatory, ValueFromPipeline)]
    [Sample.API.Category('Body')]
    [Sample.API.Models.ICodeSigningAccount]
    # Trusted signing account resource.
    ${Resource},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory)]
    [Sample.API.Category('Body')]
    [System.String]
    # The geo-location where the resource lives
    ${Location},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Sample.API.PSArgumentCompleterAttribute("Basic", "Premium")]
    [Sample.API.Category('Body')]
    [System.String]
    # Name of the SKU.
    ${SkuName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
    [Sample.API.Category('Body')]
    [Sample.API.Runtime.Info(PossibleTypes=([Sample.API.Models.ITrackedResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tags},

    [Parameter()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Create = 'CodeSigning.private\New-CodeSigningAccount_Create';
            CreateExpanded = 'CodeSigning.private\New-CodeSigningAccount_CreateExpanded';
            CreateViaIdentity = 'CodeSigning.private\New-CodeSigningAccount_CreateViaIdentity';
            CreateViaIdentityExpanded = 'CodeSigning.private\New-CodeSigningAccount_CreateViaIdentityExpanded';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Delete a certificate profile.
.Description
Delete a certificate profile.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Sample.API.Models.ICodeSigningIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICodeSigningIdentity>: Identity Parameter
  [AccountName <String>]: Trusted Signing account name.
  [ProfileName <String>]: Certificate profile name.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
.Link
https://learn.microsoft.com/powershell/module/codesigning/remove-certificateprofile
#>
function Remove-CertificateProfile {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # Trusted Signing account name.
    ${AccountName},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # Certificate profile name.
    ${ProfileName},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Sample.API.Category('Path')]
    [Sample.API.Models.ICodeSigningIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Delete = 'CodeSigning.private\Remove-CertificateProfile_Delete';
            DeleteViaIdentity = 'CodeSigning.private\Remove-CertificateProfile_DeleteViaIdentity';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Delete a trusted signing account.
.Description
Delete a trusted signing account.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Sample.API.Models.ICodeSigningIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICodeSigningIdentity>: Identity Parameter
  [AccountName <String>]: Trusted Signing account name.
  [ProfileName <String>]: Certificate profile name.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
.Link
https://learn.microsoft.com/powershell/module/codesigning/remove-codesigningaccount
#>
function Remove-CodeSigningAccount {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # Trusted Signing account name.
    ${AccountName},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Sample.API.Category('Path')]
    [Sample.API.Models.ICodeSigningIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Delete = 'CodeSigning.private\Remove-CodeSigningAccount_Delete';
            DeleteViaIdentity = 'CodeSigning.private\Remove-CodeSigningAccount_DeleteViaIdentity';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Revoke a certificate under a certificate profile.
.Description
Revoke a certificate under a certificate profile.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Sample.API.Models.ICodeSigningIdentity
.Inputs
Sample.API.Models.IRevokeCertificate
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IRevokeCertificate>: Defines the certificate revocation properties.
  EffectiveAt <DateTime>: The timestamp when the revocation is effective.
  Reason <String>: Reason for the revocation.
  SerialNumber <String>: Serial number of the certificate.
  Thumbprint <String>: Thumbprint of the certificate.
  [Remarks <String>]: Remarks for the revocation.

INPUTOBJECT <ICodeSigningIdentity>: Identity Parameter
  [AccountName <String>]: Trusted Signing account name.
  [ProfileName <String>]: Certificate profile name.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
.Link
https://learn.microsoft.com/powershell/module/codesigning/revoke-certificateprofilecertificate
#>
function Revoke-CertificateProfileCertificate {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='RevokeExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Revoke', Mandatory)]
    [Parameter(ParameterSetName='RevokeExpanded', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # Trusted Signing account name.
    ${AccountName},

    [Parameter(ParameterSetName='Revoke', Mandatory)]
    [Parameter(ParameterSetName='RevokeExpanded', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # Certificate profile name.
    ${ProfileName},

    [Parameter(ParameterSetName='Revoke', Mandatory)]
    [Parameter(ParameterSetName='RevokeExpanded', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Revoke', Mandatory)]
    [Parameter(ParameterSetName='RevokeExpanded', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='RevokeViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='RevokeViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Sample.API.Category('Path')]
    [Sample.API.Models.ICodeSigningIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='Revoke', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='RevokeViaIdentity', Mandatory, ValueFromPipeline)]
    [Sample.API.Category('Body')]
    [Sample.API.Models.IRevokeCertificate]
    # Defines the certificate revocation properties.
    ${Body},

    [Parameter(ParameterSetName='RevokeExpanded', Mandatory)]
    [Parameter(ParameterSetName='RevokeViaIdentityExpanded', Mandatory)]
    [Sample.API.Category('Body')]
    [System.DateTime]
    # The timestamp when the revocation is effective.
    ${EffectiveAt},

    [Parameter(ParameterSetName='RevokeExpanded', Mandatory)]
    [Parameter(ParameterSetName='RevokeViaIdentityExpanded', Mandatory)]
    [Sample.API.Category('Body')]
    [System.String]
    # Reason for the revocation.
    ${Reason},

    [Parameter(ParameterSetName='RevokeExpanded', Mandatory)]
    [Parameter(ParameterSetName='RevokeViaIdentityExpanded', Mandatory)]
    [Sample.API.Category('Body')]
    [System.String]
    # Serial number of the certificate.
    ${SerialNumber},

    [Parameter(ParameterSetName='RevokeExpanded', Mandatory)]
    [Parameter(ParameterSetName='RevokeViaIdentityExpanded', Mandatory)]
    [Sample.API.Category('Body')]
    [System.String]
    # Thumbprint of the certificate.
    ${Thumbprint},

    [Parameter(ParameterSetName='RevokeExpanded')]
    [Parameter(ParameterSetName='RevokeViaIdentityExpanded')]
    [Sample.API.Category('Body')]
    [System.String]
    # Remarks for the revocation.
    ${Remarks},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Revoke = 'CodeSigning.private\Revoke-CertificateProfileCertificate_Revoke';
            RevokeExpanded = 'CodeSigning.private\Revoke-CertificateProfileCertificate_RevokeExpanded';
            RevokeViaIdentity = 'CodeSigning.private\Revoke-CertificateProfileCertificate_RevokeViaIdentity';
            RevokeViaIdentityExpanded = 'CodeSigning.private\Revoke-CertificateProfileCertificate_RevokeViaIdentityExpanded';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Checks that the trusted signing account name is valid and is not already in use.
.Description
Checks that the trusted signing account name is valid and is not already in use.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Sample.API.Models.ICheckNameAvailability
.Outputs
Sample.API.Models.ICheckNameAvailabilityResult
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ICheckNameAvailability>: The parameters used to check the availability of the trusted signing account name.
  Name <String>: Trusted signing account name.
.Link
https://learn.microsoft.com/powershell/module/codesigning/test-codesigningaccountnameavailability
#>
function Test-CodeSigningAccountNameAvailability {
[OutputType([Sample.API.Models.ICheckNameAvailabilityResult])]
[CmdletBinding(DefaultParameterSetName='CheckExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='Check', Mandatory, ValueFromPipeline)]
    [Sample.API.Category('Body')]
    [Sample.API.Models.ICheckNameAvailability]
    # The parameters used to check the availability of the trusted signing account name.
    ${Body},

    [Parameter(ParameterSetName='CheckExpanded', Mandatory)]
    [Sample.API.Category('Body')]
    [System.String]
    # Trusted signing account name.
    ${Name},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Check = 'CodeSigning.private\Test-CodeSigningAccountNameAvailability_Check';
            CheckExpanded = 'CodeSigning.private\Test-CodeSigningAccountNameAvailability_CheckExpanded';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
update a trusted signing account.
.Description
update a trusted signing account.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Sample.API.Models.ICodeSigningAccountPatch
.Inputs
Sample.API.Models.ICodeSigningIdentity
.Outputs
Sample.API.Models.ICodeSigningAccount
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ICodeSigningIdentity>: Identity Parameter
  [AccountName <String>]: Trusted Signing account name.
  [ProfileName <String>]: Certificate profile name.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.

PROPERTIES <ICodeSigningAccountPatch>: Parameters for creating or updating a trusted signing account.
  [SkuName <String>]: Name of the SKU.
  [Tags <ICodeSigningAccountPatchTags>]: Resource tags.
    [(Any) <String>]: This indicates any property can be added to this object.
.Link
https://learn.microsoft.com/powershell/module/codesigning/update-codesigningaccount
#>
function Update-CodeSigningAccount {
[OutputType([Sample.API.Models.ICodeSigningAccount])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Update', Mandatory)]
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # Trusted Signing account name.
    ${AccountName},

    [Parameter(ParameterSetName='Update', Mandatory)]
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Update', Mandatory)]
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Sample.API.Category('Path')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Sample.API.Category('Path')]
    [Sample.API.Models.ICodeSigningIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='Update', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='UpdateViaIdentity', Mandatory, ValueFromPipeline)]
    [Sample.API.Category('Body')]
    [Sample.API.Models.ICodeSigningAccountPatch]
    # Parameters for creating or updating a trusted signing account.
    ${Properties},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Sample.API.PSArgumentCompleterAttribute("Basic", "Premium")]
    [Sample.API.Category('Body')]
    [System.String]
    # Name of the SKU.
    ${SkuName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Sample.API.Category('Body')]
    [Sample.API.Runtime.Info(PossibleTypes=([Sample.API.Models.ICodeSigningAccountPatchTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tags},

    [Parameter()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [Sample.API.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Sample.API.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Update = 'CodeSigning.private\Update-CodeSigningAccount_Update';
            UpdateExpanded = 'CodeSigning.private\Update-CodeSigningAccount_UpdateExpanded';
            UpdateViaIdentity = 'CodeSigning.private\Update-CodeSigningAccount_UpdateViaIdentity';
            UpdateViaIdentityExpanded = 'CodeSigning.private\Update-CodeSigningAccount_UpdateViaIdentityExpanded';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        [Sample.API.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}
