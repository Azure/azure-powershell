
# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Code generated by Microsoft (R) AutoRest Code Generator.Changes may cause incorrect behavior and will be lost if the code
# is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get ComputeFleet.
.Description
Get ComputeFleet.
.Example
Get-AzComputeFleet

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IFleet
.Link
https://learn.microsoft.com/powershell/module/az.computefleet/get-azcomputefleet
#>
function Get-AzComputeFleet {
    [OutputType([Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IFleet])]
    [CmdletBinding(DefaultParameterSetName = 'ListBySubscriptionId', PositionalBinding = $false)]
    param(
        [Parameter(ParameterSetName='Get', Mandatory)]
        [Parameter(ParameterSetName='GetViaIdentity', Mandatory)]
        [Parameter(ParameterSetName='ListBySubscriptionId', Mandatory)]
        [Parameter(ParameterSetName='ListByResourceGroup', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.DefaultInfo(Script = '(Get-AzContext).Subscription.Id')]
        [System.String]
        # Microsoft Azure subscription id
        ${SubscriptionId},

        [Parameter(ParameterSetName='Get', Mandatory)]
        [Parameter(ParameterSetName='GetViaIdentity', Mandatory)]
        [Parameter(ParameterSetName='ListByResourceGroup', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [System.String]
        # Resource group name
        ${ResourceGroupName},

        [Parameter(ParameterSetName='Get', Mandatory)]
        [Parameter(ParameterSetName='GetViaIdentity', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [System.String]
        # Fleet name
        ${FleetName},

        [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IFleetIdentity]
        # Identity Parameter
        ${InputObject},
        
        [Parameter()]
        [Alias('AzureRMContext', 'AzureCredential')]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Azure')]
        [System.Management.Automation.PSObject]
        # The DefaultProfile parameter is not functional.
        # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
        ${DefaultProfile},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Wait for .NET debugger to attach
        ${Break},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be appended to the front of the pipeline
        ${HttpPipelineAppend},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be prepended to the front of the pipeline
        ${HttpPipelinePrepend},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Uri]
        # The URI for the proxy server to use
        ${Proxy},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.PSCredential]
        # Credentials for a proxy server to use for the remote call
        ${ProxyCredential},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Use the default credentials for the proxy
        ${ProxyUseDefaultCredentials}
    )

    begin {
        try {
            $outBuffer = $null
            if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
                $PSBoundParameters['OutBuffer'] = 1
            }
            $parameterSet = $PSCmdlet.ParameterSetName

            if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
                [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
            }         
            $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
            if ($preTelemetryId -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = (New-Guid).ToString()
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
            }
            else {
                $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
                if ($internalCalledCmdlets -eq '') {
                    [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
                }
                else {
                    [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
                }
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
            }

            $mapping = @{
                Get = 'Az.ComputeFleet.private\Get-Fleet_Get';
                GetViaIdentity = 'Az.ComputeFleet.private\Get-Fleet_GetViaIdentity';
                ListBySubscriptionId = 'Az.ComputeFleet.private\Get-Fleet_List';
                ListByResourceGroup = 'Az.ComputeFleet.private\Get-Fleet_List1';
            }
            $cmdInfo = Get-Command -Name $mapping[$parameterSet]
            [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)) {
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
                [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
            }
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
            $scriptCmd = { & $wrappedCmd @PSBoundParameters }
            $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
            $steppablePipeline.Begin($PSCmdlet)
        }
        catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }
    }

    process {
        try {
            $steppablePipeline.Process($_)
        }
        catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }

        finally {
            $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
            $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }

    }
    end {
        try {
            $steppablePipeline.End()

            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
            if ($preTelemetryId -eq '') {
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

        }
        catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }
    }
}

<#
.Synopsis
Get ComputeFleet Operation.
.Description
Get ComputeFleet Operation.
.Example
Get-AzComputeFleetOperation

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IOperation
.Link
https://learn.microsoft.com/powershell/module/az.computefleet/get-azcomputefleetoperation
#>
function Get-AzComputeFleetOperation {
    [OutputType([Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IOperation])]
    [CmdletBinding(DefaultParameterSetName = 'ListOperation', PositionalBinding = $false)]
    param(
        [Parameter()]
        [Alias('AzureRMContext', 'AzureCredential')]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Azure')]
        [System.Management.Automation.PSObject]
        # The DefaultProfile parameter is not functional.
        # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
        ${DefaultProfile},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Wait for .NET debugger to attach
        ${Break},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be appended to the front of the pipeline
        ${HttpPipelineAppend},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be prepended to the front of the pipeline
        ${HttpPipelinePrepend},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Uri]
        # The URI for the proxy server to use
        ${Proxy},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.PSCredential]
        # Credentials for a proxy server to use for the remote call
        ${ProxyCredential},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Use the default credentials for the proxy
        ${ProxyUseDefaultCredentials}
    )

    begin {
        try {
            $outBuffer = $null
            if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
                $PSBoundParameters['OutBuffer'] = 1
            }
            $parameterSet = $PSCmdlet.ParameterSetName

            if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
                [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
            }         
            $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
            if ($preTelemetryId -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = (New-Guid).ToString()
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
            }
            else {
                $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
                if ($internalCalledCmdlets -eq '') {
                    [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
                }
                else {
                    [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
                }
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
            }

            $mapping = @{
                ListOperation = 'Az.ComputeFleet.private\Get-Operation_List';
            }
            $cmdInfo = Get-Command -Name $mapping[$parameterSet]
            [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)) {
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
                [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
            }
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
            $scriptCmd = { & $wrappedCmd @PSBoundParameters }
            $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
            $steppablePipeline.Begin($PSCmdlet)
        }
        catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }
    }

    process {
        try {
            $steppablePipeline.Process($_)
        }
        catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }

        finally {
            $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
            $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }

    }
    end {
        try {
            $steppablePipeline.End()

            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
            if ($preTelemetryId -eq '') {
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

        }
        catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }
    }
}

<#
.Synopsis
Get ComputeFleet Virtual Machine Scale Set (VMSS).
.Description
Get ComputeFleet Virtual Machine Scale Set (VMSS).
.Example
Get-AzComputeFleetVMSS

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSet
.Link
https://learn.microsoft.com/powershell/module/az.computefleet/get-azcomputefleetvmss
#>
function Get-AzComputeFleetVMSS {
    [OutputType([Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSet])]
    [CmdletBinding(DefaultParameterSetName = 'ListVMSS', PositionalBinding = $false)]
    param(
        [Parameter(ParameterSetName='ListVMSS', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.DefaultInfo(Script = '(Get-AzContext).Subscription.Id')]
        [System.String]
        # Microsoft Azure subscription id
        ${SubscriptionId},

        [Parameter(ParameterSetName='ListVMSS', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [System.String]
        # Resource group name
        ${ResourceGroupName},

        [Parameter(ParameterSetName='ListVMSS', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [System.String]
        # Fleet name
        ${FleetName},
        
        [Parameter()]
        [Alias('AzureRMContext', 'AzureCredential')]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Azure')]
        [System.Management.Automation.PSObject]
        # The DefaultProfile parameter is not functional.
        # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
        ${DefaultProfile},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Wait for .NET debugger to attach
        ${Break},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be appended to the front of the pipeline
        ${HttpPipelineAppend},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be prepended to the front of the pipeline
        ${HttpPipelinePrepend},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Uri]
        # The URI for the proxy server to use
        ${Proxy},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.PSCredential]
        # Credentials for a proxy server to use for the remote call
        ${ProxyCredential},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Use the default credentials for the proxy
        ${ProxyUseDefaultCredentials}
    )

    begin {
        try {
            $outBuffer = $null
            if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
                $PSBoundParameters['OutBuffer'] = 1
            }
            $parameterSet = $PSCmdlet.ParameterSetName

            if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
                [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
            }         
            $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
            if ($preTelemetryId -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = (New-Guid).ToString()
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
            }
            else {
                $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
                if ($internalCalledCmdlets -eq '') {
                    [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
                }
                else {
                    [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
                }
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
            }

            $mapping = @{
                ListVMSS = 'Az.ComputeFleet.private\Get-FleetVirtualMachineScaleSet_List';
            }
            $cmdInfo = Get-Command -Name $mapping[$parameterSet]
            [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)) {
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
                [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
            }
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
            $scriptCmd = { & $wrappedCmd @PSBoundParameters }
            $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
            $steppablePipeline.Begin($PSCmdlet)
        }
        catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }
    }

    process {
        try {
            $steppablePipeline.Process($_)
        }
        catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }

        finally {
            $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
            $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }

    }
    end {
        try {
            $steppablePipeline.End()

            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
            if ($preTelemetryId -eq '') {
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

        }
        catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }
    }
}

<#
.Synopsis
Create Fleet resource
.Description
Create Fleet resource
.Example
New-AzComputeFleet -SubscriptionId "00000000-0000-0000-0000-000000000000" -ResourceGroupName azure-rg-test -FleetName testFleet -Resource <resource>

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IFleet
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IFleet
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IFleet>: Identity Parameter
  [Id <String>]: Resource identity path
  [FleetName <String>]: Fleet resource name
  [ResourceGroupName <String>]: Resource group name
  [SubscriptionId <String>]: Microsoft Azure subscription id
.Link
https://learn.microsoft.com/powershell/module/az.computefleet/new-azcomputefleet
#>
function New-AzComputeFleet {
    [OutputType([Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IFleet])]
    [CmdletBinding(PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
    param(
        [Parameter(ParameterSetName='Create', Mandatory)]
        [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.DefaultInfo(Script = '(Get-AzContext).Subscription.Id')]
        [System.String]
        # Microsoft Azure subscription id
        ${SubscriptionId},

        [Parameter(ParameterSetName='Create', Mandatory)]
        [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [System.String]
        # Resource group name
        ${ResourceGroupName},

        [Parameter(ParameterSetName='Create', Mandatory)]
        [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [System.String]
        # Fleet name
        ${FleetName},

        [Parameter(ParameterSetName='Create', Mandatory, ValueFromPipeline)]
        [Parameter(ParameterSetName='CreateViaIdentity', Mandatory, ValueFromPipeline)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IFleet]
        # An Compute Fleet resource
        ${Resource},

        [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [System.String]
        # The geo-location where the resource lives
        ${Location},
        
        [Parameter(ParameterSetName='CreateViaIdentity', Mandatory, ValueFromPipeline)]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IFleetIdentity]
        # Identity Parameter
        ${InputObject},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ILocationProfile]
        # The list of location profiles
        ${LocationProfiles},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Management.Automation.SwitchParameter]
        # The flag that enables or disables hibernation capability on the VM
        ${HibernationEnabled},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Management.Automation.SwitchParameter]
        # The flag that enables or disables a capability to have one or more managed data disks with UltraSSD_LRS storage account type on the VM or VMSS.Managed disks with storage account type UltraSSD_LRS can be added to a virtual machine or virtual machine scale set only if this property is enabled
        ${UltraSSDEnabled},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfile]
        # Base Virtual Machine Profile Properties to be specified according to \"specification/compute/resource-manager/Microsoft.Compute/ComputeRP/stable/{computeApiVersion}/virtualMachineScaleSet.json#/definitions/VirtualMachineScaleSetVMProfile\"
        ${BaseVirtualMachineProfile},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.String]
        # Specifies the Microsoft.Compute API version to use when creating underlying Virtual Machine scale sets and Virtual Machines.The default value will be the latest supported computeApiVersion by Compute Fleet
        ${ComputeApiVersion},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Int32]
        # Specifies the number of fault domains to use when creating the underlying VMSS.A fault domain is a logical group of hardware within an Azure datacenter.VMs in the same fault domain share a common power source and network switch.If not specified, defaults to 1, which represents \"Max Spreading\" (using as many fault domains as possible).This property cannot be updated.
        ${PlatformFaultDomainCount},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Support.ManagedServiceIdentityType]
        # The type of managed identity assigned to this resource
        ${IdentityType},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IManagedServiceIdentityUpdateUserAssignedIdentities]
        # The identities assigned to this resource by the user
        ${UserAssignedIdentities},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.String]
        # A user defined name of the 3rd Party Artifact that is being procured
        ${PlanName},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.String]
        # The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding
        ${PlanProduct},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.String]
        # A publisher provided promotion code as provisioned in Data Market for the said product/artifact
        ${PlanPromotionCode},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.String]
        # The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        ${PlanPublisher},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.String]
        # The version of the desired product/artifact
        ${PlanVersion},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Support.RegularPriorityAllocationStrategy]
        # Allocation strategy to follow when determining the VM sizes distribution for Regular VMs
        ${RegularPriorityAllocationStrategy},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Int32]
        # Total capacity to achieve. It is currently in terms of number of VMs
        ${RegularPriorityProfileCapacity},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Int32]
        # Minimum capacity to achieve which cannot be updated. If we will not be able to "guarantee" minimum capacity, we will reject the request in the sync path itself
        ${RegularPriorityProfileMinCapacity},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Support.SpotAllocationStrategy]
        # Allocation strategy to follow when determining the VM sizes distribution for Spot VMs
        ${SpotPriorityProfileAllocationStrategy},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Int32]
        # Total capacity to achieve. It is currently in terms of number of VMs
        ${SpotPriorityProfileCapacity},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Support.EvictionPolicy]
        # Eviction Policy to follow when evicting Spot VMs
        ${SpotPriorityProfileEvictionPolicy},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Management.Automation.SwitchParameter]
        # Flag to enable/disable continuous goal seeking for the desired capacity and restoration of evicted Spot VMs.If maintain is enabled, AzureFleetRP will use all VM sizes in vmSizesProfile to create new VMs (if VMs are evicted deleted)or update existing VMs with new VM sizes (if VMs are evicted deallocated or failed to allocate due to capacity constraint) in order to achieve the desired capacity.Maintain is enabled by default
        ${SpotPriorityProfileMaintain},
        
        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Single]
        # Price per hour of each Spot VM will never exceed this
        ${SpotPriorityProfileMaxPricePerVM},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Int32]
        # Minimum capacity to achieve which cannot be updated. If we will not be able to ""guarantee"" minimum capacity, we will reject the request in the sync path itself
        ${SpotPriorityProfileMinCapacity},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IFleetUpdateTags]
        # Resource tags
        ${Tags},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVMAttributes]
        # Attribute based Fleet
        ${VMAttributes},
        
        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVMSizeProfile]
        # List of VM sizes supported for Compute Fleet
        ${VMSizesProfile},

        [Parameter(ParameterSetName='CreateExpanded')]
        [Parameter(ParameterSetName='CreateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.String]
        # Zones in which the Compute Fleet is available
        ${Zones},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Run the command as a job
        ${AsJob},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Wait for .NET debugger to attach
        ${Break},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be appended to the front of the pipeline
        ${HttpPipelineAppend},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be prepended to the front of the pipeline
        ${HttpPipelinePrepend},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Run the command asynchronously
        ${NoWait},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Uri]
        # The URI for the proxy server to use
        ${Proxy},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.PSCredential]
        # Credentials for a proxy server to use for the remote call
        ${ProxyCredential},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Use the default credentials for the proxy
        ${ProxyUseDefaultCredentials}
    )

    begin {
        try {
            $outBuffer = $null
            if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
                $PSBoundParameters['OutBuffer'] = 1
            }
            $parameterSet = $PSCmdlet.ParameterSetName

            if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
                [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
            }         
            $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
            if ($preTelemetryId -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
            } else {
                $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
                if ($internalCalledCmdlets -eq '') {
                    [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
                } else {
                    [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
                }
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
            }

            $mapping = @{
                Create = 'Az.ComputeFleet.private\New-Fleet_Create';
                CreateExpanded = 'Az.ComputeFleet.private\New-Fleet_CreateExpanded';
                CreateViaIdentity = 'Az.ComputeFleet.private\New-Fleet_CreateViaIdentity';
                CreateViaIdentityExpanded = 'Az.ComputeFleet.private\New-Fleet_CreateViaIdentityExpanded';
            }
            $cmdInfo = Get-Command -Name $mapping[$parameterSet]
            [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
                [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
            }
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
            $scriptCmd = {& $wrappedCmd @PSBoundParameters}
            $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
            $steppablePipeline.Begin($PSCmdlet)
        } catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }
    }

    process {
        try {
            $steppablePipeline.Process($_)
        } catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }

        finally {
            $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
            $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }

    }
    end {
        try {
            $steppablePipeline.End()

            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
            if ($preTelemetryId -eq '') {
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

        } catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }
    }
}

<#
.Synopsis
Update Fleet resource
.Description
Update Fleet resource
.Example
Update-AzComputeFleet -SubscriptionId "00000000-0000-0000-0000-000000000000" -ResourceGroupName azure-rg-test -FleetName testFleet

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IFleet
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IFleet
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IFleet>: Identity Parameter
  [Id <String>]: Resource identity path
  [FleetName <String>]: Fleet resource name
  [ResourceGroupName <String>]: Resource group name
  [SubscriptionId <String>]: Microsoft Azure subscription id
.Link
https://learn.microsoft.com/powershell/module/az.computefleet/update-azcomputefleet
#>
function Update-AzComputeFleet {
    [OutputType([Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IFleet])]
    [CmdletBinding(PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
    param(
        [Parameter(ParameterSetName='Update', Mandatory)]
        [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.DefaultInfo(Script = '(Get-AzContext).Subscription.Id')]
        [System.String]
        # Microsoft Azure subscription id
        ${SubscriptionId},

        [Parameter(ParameterSetName='Update', Mandatory)]
        [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [System.String]
        # Resource group name
        ${ResourceGroupName},

        [Parameter(ParameterSetName='Update', Mandatory)]
        [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [System.String]
        # Fleet name
        ${FleetName},

        [Parameter(ParameterSetName='Update', Mandatory)]
        [Parameter(ParameterSetName='UpdateViaIdentity', Mandatory, ValueFromPipeline)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IFleetUpdate]
        # Fleet properties
        ${Properties},
        
        [Parameter(ParameterSetName='UpdateViaIdentity', Mandatory, ValueFromPipeline)]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IFleetIdentity]
        # Identity Parameter
        ${InputObject},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ILocationProfile]
        # The list of location profiles
        ${LocationProfiles},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Management.Automation.SwitchParameter]
        # The flag that enables or disables hibernation capability on the VM
        ${HibernationEnabled},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Management.Automation.SwitchParameter]
        # The flag that enables or disables a capability to have one or more managed data disks with UltraSSD_LRS storage account type on the VM or VMSS.Managed disks with storage account type UltraSSD_LRS can be added to a virtual machine or virtual machine scale set only if this property is enabled
        ${UltraSSDEnabled},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfile]
        # Base Virtual Machine Profile Properties to be specified according to \"specification/compute/resource-manager/Microsoft.Compute/ComputeRP/stable/{computeApiVersion}/virtualMachineScaleSet.json#/definitions/VirtualMachineScaleSetVMProfile\"
        ${BaseVirtualMachineProfile},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.String]
        # Specifies the Microsoft.Compute API version to use when creating underlying Virtual Machine scale sets and Virtual Machines.The default value will be the latest supported computeApiVersion by Compute Fleet
        ${ComputeApiVersion},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Int32]
        # Specifies the number of fault domains to use when creating the underlying VMSS.A fault domain is a logical group of hardware within an Azure datacenter.VMs in the same fault domain share a common power source and network switch.If not specified, defaults to 1, which represents \"Max Spreading\" (using as many fault domains as possible).This property cannot be updated.
        ${PlatformFaultDomainCount},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Support.ManagedServiceIdentityType]
        # The type of managed identity assigned to this resource
        ${IdentityType},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IManagedServiceIdentityUpdateUserAssignedIdentities]
        # The identities assigned to this resource by the user
        ${UserAssignedIdentities},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.String]
        # A user defined name of the 3rd Party Artifact that is being procured
        ${PlanName},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.String]
        # The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding
        ${PlanProduct},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.String]
        # A publisher provided promotion code as provisioned in Data Market for the said product/artifact
        ${PlanPromotionCode},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.String]
        # The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
        ${PlanPublisher},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.String]
        # The version of the desired product/artifact
        ${PlanVersion},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Support.RegularPriorityAllocationStrategy]
        # Allocation strategy to follow when determining the VM sizes distribution for Regular VMs
        ${RegularPriorityAllocationStrategy},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Int32]
        # Total capacity to achieve. It is currently in terms of number of VMs
        ${RegularPriorityProfileCapacity},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Int32]
        # Minimum capacity to achieve which cannot be updated. If we will not be able to "guarantee" minimum capacity, we will reject the request in the sync path itself
        ${RegularPriorityProfileMinCapacity},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Support.SpotAllocationStrategy]
        # Allocation strategy to follow when determining the VM sizes distribution for Spot VMs
        ${SpotPriorityProfileAllocationStrategy},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Int32]
        # Total capacity to achieve. It is currently in terms of number of VMs
        ${SpotPriorityProfileCapacity},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Support.EvictionPolicy]
        # Eviction Policy to follow when evicting Spot VMs
        ${SpotPriorityProfileEvictionPolicy},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Management.Automation.SwitchParameter]
        # Flag to enable/disable continuous goal seeking for the desired capacity and restoration of evicted Spot VMs.If maintain is enabled, AzureFleetRP will use all VM sizes in vmSizesProfile to create new VMs (if VMs are evicted deleted)or update existing VMs with new VM sizes (if VMs are evicted deallocated or failed to allocate due to capacity constraint) in order to achieve the desired capacity.Maintain is enabled by default
        ${SpotPriorityProfileMaintain},
        
        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Single]
        # Price per hour of each Spot VM will never exceed this
        ${SpotPriorityProfileMaxPricePerVM},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [System.Int32]
        # Minimum capacity to achieve which cannot be updated. If we will not be able to ""guarantee"" minimum capacity, we will reject the request in the sync path itself
        ${SpotPriorityProfileMinCapacity},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IFleetUpdateTags]
        # Resource tags
        ${Tags},

        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVMAttributes]
        # Attribute based Fleet
        ${VMAttributes},
        
        [Parameter(ParameterSetName='UpdateExpanded')]
        [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVMSizeProfile]
        # List of VM sizes supported for Compute Fleet
        ${VMSizesProfile},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Run the command as a job
        ${AsJob},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Wait for .NET debugger to attach
        ${Break},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be appended to the front of the pipeline
        ${HttpPipelineAppend},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be prepended to the front of the pipeline
        ${HttpPipelinePrepend},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Run the command asynchronously
        ${NoWait},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Uri]
        # The URI for the proxy server to use
        ${Proxy},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.PSCredential]
        # Credentials for a proxy server to use for the remote call
        ${ProxyCredential},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Use the default credentials for the proxy
        ${ProxyUseDefaultCredentials}
    )

    begin {
        try {
            $outBuffer = $null
            if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
                $PSBoundParameters['OutBuffer'] = 1
            }
            $parameterSet = $PSCmdlet.ParameterSetName

            if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
                [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
            }         
            $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
            if ($preTelemetryId -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
            } else {
                $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
                if ($internalCalledCmdlets -eq '') {
                    [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
                } else {
                    [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
                }
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
            }

            $mapping = @{
                Update = 'Az.ComputeFleet.private\Update-Fleet_Update';
                UpdateExpanded = 'Az.ComputeFleet.private\Update-Fleet_UpdateExpanded';
                UpdateViaIdentity = 'Az.ComputeFleet.private\Update-Fleet_UpdateViaIdentity';
                UpdateViaIdentityExpanded = 'Az.ComputeFleet.private\Update-Fleet_UpdateViaIdentityExpanded';
            }
            $cmdInfo = Get-Command -Name $mapping[$parameterSet]
            [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
                [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
            }
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
            $scriptCmd = {& $wrappedCmd @PSBoundParameters}
            $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
            $steppablePipeline.Begin($PSCmdlet)
        } catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }
    }

    process {
        try {
            $steppablePipeline.Process($_)
        } catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }

        finally {
            $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
            $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }

    }
    end {
        try {
            $steppablePipeline.End()

            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
            if ($preTelemetryId -eq '') {
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

        } catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }
    }
}

<#
.Synopsis
Delete Fleet resource
.Description
Delete Fleet resource
.Example
Remove-AzComputeFleet -SubscriptionId "00000000-0000-0000-0000-000000000000" -ResourceGroupName azure-rg-test -FleetName testFleet

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IFleetIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IFleetIdentity>: Identity Parameter
  [Id <String>]: Resource identity path
  [OrganizationName <String>]: Organization resource name
  [ResourceGroupName <String>]: Resource group name
  [SubscriptionId <String>]: Microsoft Azure subscription id
.Link
https://learn.microsoft.com/powershell/module/az.computefleet/remove-azcomputefleet
#>
function Remove-AzComputeFleet {
    [OutputType([System.Boolean])]
    [CmdletBinding(PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
    param(
        [Parameter(ParameterSetName='Delete', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.DefaultInfo(Script = '(Get-AzContext).Subscription.Id')]
        [System.String]
        # Microsoft Azure subscription id
        ${SubscriptionId},

        [Parameter(ParameterSetName='Delete', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [System.String]
        # Resource group name
        ${ResourceGroupName},

        [Parameter(ParameterSetName='Delete', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [System.String]
        # Fleet name
        ${FleetName},

        [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IFleetIdentity]
        # Identity Parameter
        ${InputObject},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Run the command as a job
        ${AsJob},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Wait for .NET debugger to attach
        ${Break},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be appended to the front of the pipeline
        ${HttpPipelineAppend},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be prepended to the front of the pipeline
        ${HttpPipelinePrepend},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Run the command asynchronously
        ${NoWait},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Returns true when the command succeeds
        ${PassThrough},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Uri]
        # The URI for the proxy server to use
        ${Proxy},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.PSCredential]
        # Credentials for a proxy server to use for the remote call
        ${ProxyCredential},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Use the default credentials for the proxy
        ${ProxyUseDefaultCredentials}
    )

    begin {
        try {
            $outBuffer = $null
            if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
                $PSBoundParameters['OutBuffer'] = 1
            }
            $parameterSet = $PSCmdlet.ParameterSetName

            if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
                [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
            }         
            $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
            if ($preTelemetryId -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
            } else {
                $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
                if ($internalCalledCmdlets -eq '') {
                    [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
                } else {
                    [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
                }
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
            }

            $mapping = @{
                Delete = 'Az.ComputeFleet.custom\Remove-Fleet_Delete';
                DeleteViaIdentity = 'Az.ComputeFleet.custom\Remove-Fleet_DeleteViaIdentity';
            }
            $cmdInfo = Get-Command -Name $mapping[$parameterSet]
            [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
                [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
            }
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
            $scriptCmd = {& $wrappedCmd @PSBoundParameters}
            $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
            $steppablePipeline.Begin($PSCmdlet)
        } catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }
    }

    process {
        try {
            $steppablePipeline.Process($_)
        } catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }

        finally {
            $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
            $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }

    }
    end {
        try {
            $steppablePipeline.End()

            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
            if ($preTelemetryId -eq '') {
                [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

        } catch {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
            throw
        }
    }
}