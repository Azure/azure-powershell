// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview
{
    using static Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Extensions;

    /// <summary>Config to describe the polling config for API poller connector</summary>
    public partial class CodelessConnectorPollingConfigProperties :
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigProperties,
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal
    {

        /// <summary>Backing field for <see cref="Auth" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthProperties _auth;

        /// <summary>Describe the authentication type of the poller</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthProperties Auth { get => (this._auth = this._auth ?? new Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.CodelessConnectorPollingAuthProperties()); set => this._auth = value; }

        /// <summary>A prefix send in the header before the actual token</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthApiKeyIdentifier { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).ApiKeyIdentifier; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).ApiKeyIdentifier = value ?? null; }

        /// <summary>The header name which the token is sent with</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthApiKeyName { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).ApiKeyName; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).ApiKeyName = value ?? null; }

        /// <summary>The endpoint used to authorize the user, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthAuthorizationEndpoint { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).AuthorizationEndpoint; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).AuthorizationEndpoint = value ?? null; }

        /// <summary>The query parameters used in authorization request, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthAuthorizationEndpointQueryParameter { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).AuthorizationEndpointQueryParameter; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).AuthorizationEndpointQueryParameter = value ?? null /* model class */; }

        /// <summary>Describes the flow name, for example 'AuthCode' for Oauth 2.0</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthFlowName { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).FlowName; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).FlowName = value ?? null; }

        /// <summary>Marks if the key should sent in header</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthIsApiKeyInPostPayload { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).IsApiKeyInPostPayload; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).IsApiKeyInPostPayload = value ?? null; }

        /// <summary>
        /// Marks if we should send the client secret in header or payload, used in Oauth 2.0 flow
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public bool? AuthIsClientSecretInHeader { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).IsClientSecretInHeader; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).IsClientSecretInHeader = value ?? default(bool); }

        /// <summary>
        /// The redirect endpoint where we will get the authorization code, used in Oauth 2.0 flow
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthRedirectionEndpoint { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).RedirectionEndpoint; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).RedirectionEndpoint = value ?? null; }

        /// <summary>The OAuth token scope</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthScope { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).Scope; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).Scope = value ?? null; }

        /// <summary>The endpoint used to issue a token, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthTokenEndpoint { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).TokenEndpoint; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).TokenEndpoint = value ?? null; }

        /// <summary>The query headers used in token request, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthTokenEndpointHeader { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).TokenEndpointHeader; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).TokenEndpointHeader = value ?? null /* model class */; }

        /// <summary>The query parameters used in token request, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthTokenEndpointQueryParameter { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).TokenEndpointQueryParameter; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).TokenEndpointQueryParameter = value ?? null /* model class */; }

        /// <summary>The authentication type</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthType { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).AuthType; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthPropertiesInternal)Auth).AuthType = value ; }

        /// <summary>Backing field for <see cref="IsActive" /> property.</summary>
        private bool? _isActive;

        /// <summary>The poller active status</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Owned)]
        public bool? IsActive { get => this._isActive; set => this._isActive = value; }

        /// <summary>Internal Acessors for Auth</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthProperties Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal.Auth { get => (this._auth = this._auth ?? new Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.CodelessConnectorPollingAuthProperties()); set { {_auth = value;} } }

        /// <summary>Internal Acessors for Paging</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingProperties Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal.Paging { get => (this._paging = this._paging ?? new Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.CodelessConnectorPollingPagingProperties()); set { {_paging = value;} } }

        /// <summary>Internal Acessors for Request</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestProperties Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal.Request { get => (this._request = this._request ?? new Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.CodelessConnectorPollingRequestProperties()); set { {_request = value;} } }

        /// <summary>Internal Acessors for Response</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingResponseProperties Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal.Response { get => (this._response = this._response ?? new Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.CodelessConnectorPollingResponseProperties()); set { {_response = value;} } }

        /// <summary>Backing field for <see cref="Paging" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingProperties _paging;

        /// <summary>Describe the poll request paging config of the poller</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingProperties Paging { get => (this._paging = this._paging ?? new Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.CodelessConnectorPollingPagingProperties()); set => this._paging = value; }

        /// <summary>Defines the name of a next page attribute</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string PagingNextPageParaName { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).NextPageParaName; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).NextPageParaName = value ?? null; }

        /// <summary>Defines the path to a next page token JSON</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string PagingNextPageTokenJsonPath { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).NextPageTokenJsonPath; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).NextPageTokenJsonPath = value ?? null; }

        /// <summary>Defines the path to a page count attribute</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string PagingPageCountAttributePath { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).PageCountAttributePath; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).PageCountAttributePath = value ?? null; }

        /// <summary>Defines the paging size</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public int? PagingPageSize { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).PageSize; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).PageSize = value ?? default(int); }

        /// <summary>Defines the name of the page size parameter</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string PagingPageSizeParaName { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).PageSizeParaName; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).PageSizeParaName = value ?? null; }

        /// <summary>Defines the path to a paging time stamp attribute</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string PagingPageTimeStampAttributePath { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).PageTimeStampAttributePath; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).PageTimeStampAttributePath = value ?? null; }

        /// <summary>Defines the path to a page total count attribute</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string PagingPageTotalCountAttributePath { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).PageTotalCountAttributePath; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).PageTotalCountAttributePath = value ?? null; }

        /// <summary>Determines whether to search for the latest time stamp in the events list</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string PagingSearchTheLatestTimeStampFromEventsList { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).SearchTheLatestTimeStampFromEventsList; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).SearchTheLatestTimeStampFromEventsList = value ?? null; }

        /// <summary>Describes the type. could be 'None', 'PageToken', 'PageCount', 'TimeStamp'</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string PagingType { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).PagingType; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingPropertiesInternal)Paging).PagingType = value ?? null; }

        /// <summary>Backing field for <see cref="Request" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestProperties _request;

        /// <summary>Describe the poll request config parameters of the poller</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestProperties Request { get => (this._request = this._request ?? new Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.CodelessConnectorPollingRequestProperties()); set => this._request = value; }

        /// <summary>Describe the endpoint we should pull the data from</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string RequestApiEndpoint { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).ApiEndpoint; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).ApiEndpoint = value ; }

        /// <summary>This will be used the query events from the end of the time window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string RequestEndTimeAttributeName { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).EndTimeAttributeName; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).EndTimeAttributeName = value ?? null; }

        /// <summary>Describe the headers sent in the poll request</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny RequestHeader { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).Header; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).Header = value ?? null /* model class */; }

        /// <summary>The http method type we will use in the poll request, GET or POST</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string RequestHttpMethod { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).HttpMethod; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).HttpMethod = value ; }

        /// <summary>Describe the query parameters sent in the poll request</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny RequestQueryParameter { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).QueryParameter; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).QueryParameter = value ?? null /* model class */; }

        /// <summary>
        /// For advanced scenarios for example user name/password embedded in nested JSON payload
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string RequestQueryParametersTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).QueryParametersTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).QueryParametersTemplate = value ?? null; }

        /// <summary>The time format will be used the query events in a specific window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string RequestQueryTimeFormat { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).QueryTimeFormat; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).QueryTimeFormat = value ; }

        /// <summary>The window interval we will use the pull the data</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public int RequestQueryWindowInMin { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).QueryWindowInMin; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).QueryWindowInMin = value ; }

        /// <summary>Defines the rate limit QPS</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public int? RequestRateLimitQp { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).RateLimitQp; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).RateLimitQp = value ?? default(int); }

        /// <summary>Describe the amount of time we should try and poll the data in case of failure</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public int? RequestRetryCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).RetryCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).RetryCount = value ?? default(int); }

        /// <summary>This will be used the query events from a start of the time window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string RequestStartTimeAttributeName { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).StartTimeAttributeName; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).StartTimeAttributeName = value ?? null; }

        /// <summary>The number of seconds we will consider as a request timeout</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public int? RequestTimeoutInSecond { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).TimeoutInSecond; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestPropertiesInternal)Request).TimeoutInSecond = value ?? default(int); }

        /// <summary>Backing field for <see cref="Response" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingResponseProperties _response;

        /// <summary>Describe the response config parameters of the poller</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingResponseProperties Response { get => (this._response = this._response ?? new Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.CodelessConnectorPollingResponseProperties()); set => this._response = value; }

        /// <summary>Describes the path we should extract the data in the response</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string[] ResponseEventsJsonPath { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingResponsePropertiesInternal)Response).EventsJsonPath; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingResponsePropertiesInternal)Response).EventsJsonPath = value ?? null /* arrayOf */; }

        /// <summary>Describes if the data in the response is Gzip</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public bool? ResponseIsGzipCompressed { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingResponsePropertiesInternal)Response).IsGzipCompressed; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingResponsePropertiesInternal)Response).IsGzipCompressed = value ?? default(bool); }

        /// <summary>Describes the path we should extract the status code in the response</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string ResponseSuccessStatusJsonPath { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingResponsePropertiesInternal)Response).SuccessStatusJsonPath; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingResponsePropertiesInternal)Response).SuccessStatusJsonPath = value ?? null; }

        /// <summary>Describes the path we should extract the status value in the response</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string ResponseSuccessStatusValue { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingResponsePropertiesInternal)Response).SuccessStatusValue; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingResponsePropertiesInternal)Response).SuccessStatusValue = value ?? null; }

        /// <summary>
        /// Creates an new <see cref="CodelessConnectorPollingConfigProperties" /> instance.
        /// </summary>
        public CodelessConnectorPollingConfigProperties()
        {

        }
    }
    /// Config to describe the polling config for API poller connector
    public partial interface ICodelessConnectorPollingConfigProperties :
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.IJsonSerializable
    {
        /// <summary>A prefix send in the header before the actual token</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A prefix send in the header before the actual token",
        SerializedName = @"apiKeyIdentifier",
        PossibleTypes = new [] { typeof(string) })]
        string AuthApiKeyIdentifier { get; set; }
        /// <summary>The header name which the token is sent with</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The header name which the token is sent with",
        SerializedName = @"apiKeyName",
        PossibleTypes = new [] { typeof(string) })]
        string AuthApiKeyName { get; set; }
        /// <summary>The endpoint used to authorize the user, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The endpoint used to authorize the user, used in Oauth 2.0 flow",
        SerializedName = @"authorizationEndpoint",
        PossibleTypes = new [] { typeof(string) })]
        string AuthAuthorizationEndpoint { get; set; }
        /// <summary>The query parameters used in authorization request, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The query parameters used in authorization request, used in Oauth 2.0 flow",
        SerializedName = @"authorizationEndpointQueryParameters",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny) })]
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthAuthorizationEndpointQueryParameter { get; set; }
        /// <summary>Describes the flow name, for example 'AuthCode' for Oauth 2.0</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describes the flow name, for example 'AuthCode' for Oauth 2.0",
        SerializedName = @"flowName",
        PossibleTypes = new [] { typeof(string) })]
        string AuthFlowName { get; set; }
        /// <summary>Marks if the key should sent in header</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Marks if the key should sent in header",
        SerializedName = @"isApiKeyInPostPayload",
        PossibleTypes = new [] { typeof(string) })]
        string AuthIsApiKeyInPostPayload { get; set; }
        /// <summary>
        /// Marks if we should send the client secret in header or payload, used in Oauth 2.0 flow
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Marks if we should send the client secret in header or payload, used in Oauth 2.0 flow",
        SerializedName = @"isClientSecretInHeader",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AuthIsClientSecretInHeader { get; set; }
        /// <summary>
        /// The redirect endpoint where we will get the authorization code, used in Oauth 2.0 flow
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The redirect endpoint where we will get the authorization code, used in Oauth 2.0 flow",
        SerializedName = @"redirectionEndpoint",
        PossibleTypes = new [] { typeof(string) })]
        string AuthRedirectionEndpoint { get; set; }
        /// <summary>The OAuth token scope</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The OAuth token scope",
        SerializedName = @"scope",
        PossibleTypes = new [] { typeof(string) })]
        string AuthScope { get; set; }
        /// <summary>The endpoint used to issue a token, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The endpoint used to issue a token, used in Oauth 2.0 flow",
        SerializedName = @"tokenEndpoint",
        PossibleTypes = new [] { typeof(string) })]
        string AuthTokenEndpoint { get; set; }
        /// <summary>The query headers used in token request, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The query headers used in token request, used in Oauth 2.0 flow",
        SerializedName = @"tokenEndpointHeaders",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny) })]
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthTokenEndpointHeader { get; set; }
        /// <summary>The query parameters used in token request, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The query parameters used in token request, used in Oauth 2.0 flow",
        SerializedName = @"tokenEndpointQueryParameters",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny) })]
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthTokenEndpointQueryParameter { get; set; }
        /// <summary>The authentication type</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The authentication type",
        SerializedName = @"authType",
        PossibleTypes = new [] { typeof(string) })]
        string AuthType { get; set; }
        /// <summary>The poller active status</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The poller active status",
        SerializedName = @"isActive",
        PossibleTypes = new [] { typeof(bool) })]
        bool? IsActive { get; set; }
        /// <summary>Defines the name of a next page attribute</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Defines the name of a next page attribute",
        SerializedName = @"nextPageParaName",
        PossibleTypes = new [] { typeof(string) })]
        string PagingNextPageParaName { get; set; }
        /// <summary>Defines the path to a next page token JSON</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Defines the path to a next page token JSON",
        SerializedName = @"nextPageTokenJsonPath",
        PossibleTypes = new [] { typeof(string) })]
        string PagingNextPageTokenJsonPath { get; set; }
        /// <summary>Defines the path to a page count attribute</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Defines the path to a page count attribute",
        SerializedName = @"pageCountAttributePath",
        PossibleTypes = new [] { typeof(string) })]
        string PagingPageCountAttributePath { get; set; }
        /// <summary>Defines the paging size</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Defines the paging size",
        SerializedName = @"pageSize",
        PossibleTypes = new [] { typeof(int) })]
        int? PagingPageSize { get; set; }
        /// <summary>Defines the name of the page size parameter</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Defines the name of the page size parameter",
        SerializedName = @"pageSizeParaName",
        PossibleTypes = new [] { typeof(string) })]
        string PagingPageSizeParaName { get; set; }
        /// <summary>Defines the path to a paging time stamp attribute</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Defines the path to a paging time stamp attribute",
        SerializedName = @"pageTimeStampAttributePath",
        PossibleTypes = new [] { typeof(string) })]
        string PagingPageTimeStampAttributePath { get; set; }
        /// <summary>Defines the path to a page total count attribute</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Defines the path to a page total count attribute",
        SerializedName = @"pageTotalCountAttributePath",
        PossibleTypes = new [] { typeof(string) })]
        string PagingPageTotalCountAttributePath { get; set; }
        /// <summary>Determines whether to search for the latest time stamp in the events list</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Determines whether to search for the latest time stamp in the events list",
        SerializedName = @"searchTheLatestTimeStampFromEventsList",
        PossibleTypes = new [] { typeof(string) })]
        string PagingSearchTheLatestTimeStampFromEventsList { get; set; }
        /// <summary>Describes the type. could be 'None', 'PageToken', 'PageCount', 'TimeStamp'</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describes the type. could be 'None', 'PageToken', 'PageCount', 'TimeStamp'",
        SerializedName = @"pagingType",
        PossibleTypes = new [] { typeof(string) })]
        string PagingType { get; set; }
        /// <summary>Describe the endpoint we should pull the data from</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"Describe the endpoint we should pull the data from",
        SerializedName = @"apiEndpoint",
        PossibleTypes = new [] { typeof(string) })]
        string RequestApiEndpoint { get; set; }
        /// <summary>This will be used the query events from the end of the time window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This will be used the query events from the end of the time window",
        SerializedName = @"endTimeAttributeName",
        PossibleTypes = new [] { typeof(string) })]
        string RequestEndTimeAttributeName { get; set; }
        /// <summary>Describe the headers sent in the poll request</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describe the headers sent in the poll request",
        SerializedName = @"headers",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny) })]
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny RequestHeader { get; set; }
        /// <summary>The http method type we will use in the poll request, GET or POST</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The http method type we will use in the poll request, GET or POST",
        SerializedName = @"httpMethod",
        PossibleTypes = new [] { typeof(string) })]
        string RequestHttpMethod { get; set; }
        /// <summary>Describe the query parameters sent in the poll request</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describe the query parameters sent in the poll request",
        SerializedName = @"queryParameters",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny) })]
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny RequestQueryParameter { get; set; }
        /// <summary>
        /// For advanced scenarios for example user name/password embedded in nested JSON payload
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For advanced scenarios for example user name/password embedded in nested JSON payload",
        SerializedName = @"queryParametersTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string RequestQueryParametersTemplate { get; set; }
        /// <summary>The time format will be used the query events in a specific window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The time format will be used the query events in a specific window",
        SerializedName = @"queryTimeFormat",
        PossibleTypes = new [] { typeof(string) })]
        string RequestQueryTimeFormat { get; set; }
        /// <summary>The window interval we will use the pull the data</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The window interval we will use the pull the data",
        SerializedName = @"queryWindowInMin",
        PossibleTypes = new [] { typeof(int) })]
        int RequestQueryWindowInMin { get; set; }
        /// <summary>Defines the rate limit QPS</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Defines the rate limit QPS",
        SerializedName = @"rateLimitQps",
        PossibleTypes = new [] { typeof(int) })]
        int? RequestRateLimitQp { get; set; }
        /// <summary>Describe the amount of time we should try and poll the data in case of failure</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describe the amount of time we should try and poll the data in case of failure",
        SerializedName = @"retryCount",
        PossibleTypes = new [] { typeof(int) })]
        int? RequestRetryCount { get; set; }
        /// <summary>This will be used the query events from a start of the time window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This will be used the query events from a start of the time window",
        SerializedName = @"startTimeAttributeName",
        PossibleTypes = new [] { typeof(string) })]
        string RequestStartTimeAttributeName { get; set; }
        /// <summary>The number of seconds we will consider as a request timeout</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The number of seconds we will consider as a request timeout",
        SerializedName = @"timeoutInSeconds",
        PossibleTypes = new [] { typeof(int) })]
        int? RequestTimeoutInSecond { get; set; }
        /// <summary>Describes the path we should extract the data in the response</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describes the path we should extract the data in the response",
        SerializedName = @"eventsJsonPaths",
        PossibleTypes = new [] { typeof(string) })]
        string[] ResponseEventsJsonPath { get; set; }
        /// <summary>Describes if the data in the response is Gzip</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describes if the data in the response is Gzip",
        SerializedName = @"isGzipCompressed",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ResponseIsGzipCompressed { get; set; }
        /// <summary>Describes the path we should extract the status code in the response</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describes the path we should extract the status code in the response",
        SerializedName = @"successStatusJsonPath",
        PossibleTypes = new [] { typeof(string) })]
        string ResponseSuccessStatusJsonPath { get; set; }
        /// <summary>Describes the path we should extract the status value in the response</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describes the path we should extract the status value in the response",
        SerializedName = @"successStatusValue",
        PossibleTypes = new [] { typeof(string) })]
        string ResponseSuccessStatusValue { get; set; }

    }
    /// Config to describe the polling config for API poller connector
    internal partial interface ICodelessConnectorPollingConfigPropertiesInternal

    {
        /// <summary>Describe the authentication type of the poller</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthProperties Auth { get; set; }
        /// <summary>A prefix send in the header before the actual token</summary>
        string AuthApiKeyIdentifier { get; set; }
        /// <summary>The header name which the token is sent with</summary>
        string AuthApiKeyName { get; set; }
        /// <summary>The endpoint used to authorize the user, used in Oauth 2.0 flow</summary>
        string AuthAuthorizationEndpoint { get; set; }
        /// <summary>The query parameters used in authorization request, used in Oauth 2.0 flow</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthAuthorizationEndpointQueryParameter { get; set; }
        /// <summary>Describes the flow name, for example 'AuthCode' for Oauth 2.0</summary>
        string AuthFlowName { get; set; }
        /// <summary>Marks if the key should sent in header</summary>
        string AuthIsApiKeyInPostPayload { get; set; }
        /// <summary>
        /// Marks if we should send the client secret in header or payload, used in Oauth 2.0 flow
        /// </summary>
        bool? AuthIsClientSecretInHeader { get; set; }
        /// <summary>
        /// The redirect endpoint where we will get the authorization code, used in Oauth 2.0 flow
        /// </summary>
        string AuthRedirectionEndpoint { get; set; }
        /// <summary>The OAuth token scope</summary>
        string AuthScope { get; set; }
        /// <summary>The endpoint used to issue a token, used in Oauth 2.0 flow</summary>
        string AuthTokenEndpoint { get; set; }
        /// <summary>The query headers used in token request, used in Oauth 2.0 flow</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthTokenEndpointHeader { get; set; }
        /// <summary>The query parameters used in token request, used in Oauth 2.0 flow</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthTokenEndpointQueryParameter { get; set; }
        /// <summary>The authentication type</summary>
        string AuthType { get; set; }
        /// <summary>The poller active status</summary>
        bool? IsActive { get; set; }
        /// <summary>Describe the poll request paging config of the poller</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingProperties Paging { get; set; }
        /// <summary>Defines the name of a next page attribute</summary>
        string PagingNextPageParaName { get; set; }
        /// <summary>Defines the path to a next page token JSON</summary>
        string PagingNextPageTokenJsonPath { get; set; }
        /// <summary>Defines the path to a page count attribute</summary>
        string PagingPageCountAttributePath { get; set; }
        /// <summary>Defines the paging size</summary>
        int? PagingPageSize { get; set; }
        /// <summary>Defines the name of the page size parameter</summary>
        string PagingPageSizeParaName { get; set; }
        /// <summary>Defines the path to a paging time stamp attribute</summary>
        string PagingPageTimeStampAttributePath { get; set; }
        /// <summary>Defines the path to a page total count attribute</summary>
        string PagingPageTotalCountAttributePath { get; set; }
        /// <summary>Determines whether to search for the latest time stamp in the events list</summary>
        string PagingSearchTheLatestTimeStampFromEventsList { get; set; }
        /// <summary>Describes the type. could be 'None', 'PageToken', 'PageCount', 'TimeStamp'</summary>
        string PagingType { get; set; }
        /// <summary>Describe the poll request config parameters of the poller</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestProperties Request { get; set; }
        /// <summary>Describe the endpoint we should pull the data from</summary>
        string RequestApiEndpoint { get; set; }
        /// <summary>This will be used the query events from the end of the time window</summary>
        string RequestEndTimeAttributeName { get; set; }
        /// <summary>Describe the headers sent in the poll request</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny RequestHeader { get; set; }
        /// <summary>The http method type we will use in the poll request, GET or POST</summary>
        string RequestHttpMethod { get; set; }
        /// <summary>Describe the query parameters sent in the poll request</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny RequestQueryParameter { get; set; }
        /// <summary>
        /// For advanced scenarios for example user name/password embedded in nested JSON payload
        /// </summary>
        string RequestQueryParametersTemplate { get; set; }
        /// <summary>The time format will be used the query events in a specific window</summary>
        string RequestQueryTimeFormat { get; set; }
        /// <summary>The window interval we will use the pull the data</summary>
        int RequestQueryWindowInMin { get; set; }
        /// <summary>Defines the rate limit QPS</summary>
        int? RequestRateLimitQp { get; set; }
        /// <summary>Describe the amount of time we should try and poll the data in case of failure</summary>
        int? RequestRetryCount { get; set; }
        /// <summary>This will be used the query events from a start of the time window</summary>
        string RequestStartTimeAttributeName { get; set; }
        /// <summary>The number of seconds we will consider as a request timeout</summary>
        int? RequestTimeoutInSecond { get; set; }
        /// <summary>Describe the response config parameters of the poller</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingResponseProperties Response { get; set; }
        /// <summary>Describes the path we should extract the data in the response</summary>
        string[] ResponseEventsJsonPath { get; set; }
        /// <summary>Describes if the data in the response is Gzip</summary>
        bool? ResponseIsGzipCompressed { get; set; }
        /// <summary>Describes the path we should extract the status code in the response</summary>
        string ResponseSuccessStatusJsonPath { get; set; }
        /// <summary>Describes the path we should extract the status value in the response</summary>
        string ResponseSuccessStatusValue { get; set; }

    }
}