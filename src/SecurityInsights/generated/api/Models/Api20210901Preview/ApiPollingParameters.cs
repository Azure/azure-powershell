// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview
{
    using static Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Extensions;

    /// <summary>Represents Codeless API Polling data connector</summary>
    public partial class ApiPollingParameters :
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IApiPollingParameters,
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IApiPollingParametersInternal
    {

        /// <summary>A prefix send in the header before the actual token</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthApiKeyIdentifier { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthApiKeyIdentifier; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthApiKeyIdentifier = value ?? null; }

        /// <summary>The header name which the token is sent with</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthApiKeyName { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthApiKeyName; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthApiKeyName = value ?? null; }

        /// <summary>The endpoint used to authorize the user, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthAuthorizationEndpoint { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthAuthorizationEndpoint; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthAuthorizationEndpoint = value ?? null; }

        /// <summary>The query parameters used in authorization request, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthAuthorizationEndpointQueryParameter { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthAuthorizationEndpointQueryParameter; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthAuthorizationEndpointQueryParameter = value ?? null /* model class */; }

        /// <summary>Describes the flow name, for example 'AuthCode' for Oauth 2.0</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthFlowName { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthFlowName; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthFlowName = value ?? null; }

        /// <summary>Marks if the key should sent in header</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthIsApiKeyInPostPayload { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthIsApiKeyInPostPayload; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthIsApiKeyInPostPayload = value ?? null; }

        /// <summary>
        /// Marks if we should send the client secret in header or payload, used in Oauth 2.0 flow
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public bool? AuthIsClientSecretInHeader { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthIsClientSecretInHeader; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthIsClientSecretInHeader = value ?? default(bool); }

        /// <summary>
        /// The redirect endpoint where we will get the authorization code, used in Oauth 2.0 flow
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthRedirectionEndpoint { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthRedirectionEndpoint; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthRedirectionEndpoint = value ?? null; }

        /// <summary>The OAuth token scope</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthScope { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthScope; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthScope = value ?? null; }

        /// <summary>The endpoint used to issue a token, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthTokenEndpoint { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthTokenEndpoint; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthTokenEndpoint = value ?? null; }

        /// <summary>The query headers used in token request, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthTokenEndpointHeader { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthTokenEndpointHeader; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthTokenEndpointHeader = value ?? null /* model class */; }

        /// <summary>The query parameters used in token request, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthTokenEndpointQueryParameter { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthTokenEndpointQueryParameter; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthTokenEndpointQueryParameter = value ?? null /* model class */; }

        /// <summary>The authentication type</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string AuthType { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthType; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).AuthType = value ?? null; }

        /// <summary>Set connector as preview</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public bool? AvailabilityIsPreview { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).AvailabilityIsPreview; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).AvailabilityIsPreview = value ?? default(bool); }

        /// <summary>The connector Availability Status</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public int? AvailabilityStatus { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).AvailabilityStatus; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).AvailabilityStatus = value ?? default(int); }

        /// <summary>Backing field for <see cref="ConnectorUiConfig" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigProperties _connectorUiConfig;

        /// <summary>Config to describe the instructions blade</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigProperties ConnectorUiConfig { get => (this._connectorUiConfig = this._connectorUiConfig ?? new Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.CodelessUiConnectorConfigProperties()); set => this._connectorUiConfig = value; }

        /// <summary>Define the way the connector check connectivity</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IConnectivityCriteria[] ConnectorUiConfigConnectivityCriterion { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).ConnectivityCriterion; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).ConnectivityCriterion = value ?? null /* arrayOf */; }

        /// <summary>
        /// An optional custom image to be used when displaying the connector within Azure Sentinel's connector's gallery
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string ConnectorUiConfigCustomImage { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).CustomImage; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).CustomImage = value ?? null; }

        /// <summary>Data types to check for last data received</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ILastDataReceivedDataType[] ConnectorUiConfigDataType { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).DataType; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).DataType = value ?? null /* arrayOf */; }

        /// <summary>Connector description</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string ConnectorUiConfigDescriptionMarkdown { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).DescriptionMarkdown; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).DescriptionMarkdown = value ?? null; }

        /// <summary>Name of the table the connector will insert the data to</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string ConnectorUiConfigGraphQueriesTableName { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).GraphQueriesTableName; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).GraphQueriesTableName = value ?? null; }

        /// <summary>The graph query to show the current data status</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IGraphQueries[] ConnectorUiConfigGraphQuery { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).GraphQuery; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).GraphQuery = value ?? null /* arrayOf */; }

        /// <summary>Instruction steps to enable the connector</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IInstructionSteps[] ConnectorUiConfigInstructionStep { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).InstructionStep; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).InstructionStep = value ?? null /* arrayOf */; }

        /// <summary>Connector publisher name</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string ConnectorUiConfigPublisher { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).Publisher; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).Publisher = value ?? null; }

        /// <summary>The sample queries for the connector</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ISampleQueries[] ConnectorUiConfigSampleQuery { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).SampleQuery; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).SampleQuery = value ?? null /* arrayOf */; }

        /// <summary>Connector blade title</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string ConnectorUiConfigTitle { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).Title; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).Title = value ?? null; }

        /// <summary>Internal Acessors for ConnectorUiConfig</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigProperties Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IApiPollingParametersInternal.ConnectorUiConfig { get => (this._connectorUiConfig = this._connectorUiConfig ?? new Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.CodelessUiConnectorConfigProperties()); set { {_connectorUiConfig = value;} } }

        /// <summary>Internal Acessors for ConnectorUiConfigAvailability</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IAvailability Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IApiPollingParametersInternal.ConnectorUiConfigAvailability { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).Availability; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).Availability = value; }

        /// <summary>Internal Acessors for ConnectorUiConfigPermission</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IPermissions Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IApiPollingParametersInternal.ConnectorUiConfigPermission { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).Permission; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).Permission = value; }

        /// <summary>Internal Acessors for PollingConfig</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigProperties Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IApiPollingParametersInternal.PollingConfig { get => (this._pollingConfig = this._pollingConfig ?? new Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.CodelessConnectorPollingConfigProperties()); set { {_pollingConfig = value;} } }

        /// <summary>Internal Acessors for PollingConfigAuth</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthProperties Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IApiPollingParametersInternal.PollingConfigAuth { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).Auth; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).Auth = value; }

        /// <summary>Internal Acessors for PollingConfigPaging</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingProperties Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IApiPollingParametersInternal.PollingConfigPaging { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).Paging; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).Paging = value; }

        /// <summary>Internal Acessors for PollingConfigRequest</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestProperties Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IApiPollingParametersInternal.PollingConfigRequest { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).Request; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).Request = value; }

        /// <summary>Internal Acessors for PollingConfigResponse</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingResponseProperties Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IApiPollingParametersInternal.PollingConfigResponse { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).Response; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).Response = value; }

        /// <summary>Defines the name of a next page attribute</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string PagingNextPageParaName { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingNextPageParaName; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingNextPageParaName = value ?? null; }

        /// <summary>Defines the path to a next page token JSON</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string PagingNextPageTokenJsonPath { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingNextPageTokenJsonPath; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingNextPageTokenJsonPath = value ?? null; }

        /// <summary>Defines the path to a page count attribute</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string PagingPageCountAttributePath { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingPageCountAttributePath; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingPageCountAttributePath = value ?? null; }

        /// <summary>Defines the paging size</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public int? PagingPageSize { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingPageSize; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingPageSize = value ?? default(int); }

        /// <summary>Defines the name of the page size parameter</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string PagingPageSizeParaName { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingPageSizeParaName; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingPageSizeParaName = value ?? null; }

        /// <summary>Defines the path to a paging time stamp attribute</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string PagingPageTimeStampAttributePath { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingPageTimeStampAttributePath; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingPageTimeStampAttributePath = value ?? null; }

        /// <summary>Defines the path to a page total count attribute</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string PagingPageTotalCountAttributePath { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingPageTotalCountAttributePath; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingPageTotalCountAttributePath = value ?? null; }

        /// <summary>Determines whether to search for the latest time stamp in the events list</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string PagingSearchTheLatestTimeStampFromEventsList { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingSearchTheLatestTimeStampFromEventsList; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingSearchTheLatestTimeStampFromEventsList = value ?? null; }

        /// <summary>Describes the type. could be 'None', 'PageToken', 'PageCount', 'TimeStamp'</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string PagingType { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingType; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).PagingType = value ?? null; }

        /// <summary>Customs permissions required for the connector</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICustomsPermission[] PermissionCustom { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).PermissionCustom; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).PermissionCustom = value ?? null /* arrayOf */; }

        /// <summary>Resource provider permissions required for the connector</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IResourceProvider[] PermissionResourceProvider { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).PermissionResourceProvider; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigPropertiesInternal)ConnectorUiConfig).PermissionResourceProvider = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="PollingConfig" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigProperties _pollingConfig;

        /// <summary>Config to describe the polling instructions</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigProperties PollingConfig { get => (this._pollingConfig = this._pollingConfig ?? new Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.CodelessConnectorPollingConfigProperties()); set => this._pollingConfig = value; }

        /// <summary>The poller active status</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public bool? PollingConfigIsActive { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).IsActive; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).IsActive = value ?? default(bool); }

        /// <summary>Describe the endpoint we should pull the data from</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string RequestApiEndpoint { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestApiEndpoint; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestApiEndpoint = value ?? null; }

        /// <summary>This will be used the query events from the end of the time window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string RequestEndTimeAttributeName { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestEndTimeAttributeName; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestEndTimeAttributeName = value ?? null; }

        /// <summary>Describe the headers sent in the poll request</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny RequestHeader { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestHeader; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestHeader = value ?? null /* model class */; }

        /// <summary>The http method type we will use in the poll request, GET or POST</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string RequestHttpMethod { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestHttpMethod; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestHttpMethod = value ?? null; }

        /// <summary>Describe the query parameters sent in the poll request</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny RequestQueryParameter { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestQueryParameter; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestQueryParameter = value ?? null /* model class */; }

        /// <summary>
        /// For advanced scenarios for example user name/password embedded in nested JSON payload
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string RequestQueryParametersTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestQueryParametersTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestQueryParametersTemplate = value ?? null; }

        /// <summary>The time format will be used the query events in a specific window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string RequestQueryTimeFormat { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestQueryTimeFormat; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestQueryTimeFormat = value ?? null; }

        /// <summary>The window interval we will use the pull the data</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public int? RequestQueryWindowInMin { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestQueryWindowInMin; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestQueryWindowInMin = value ?? default(int); }

        /// <summary>Defines the rate limit QPS</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public int? RequestRateLimitQp { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestRateLimitQp; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestRateLimitQp = value ?? default(int); }

        /// <summary>Describe the amount of time we should try and poll the data in case of failure</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public int? RequestRetryCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestRetryCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestRetryCount = value ?? default(int); }

        /// <summary>This will be used the query events from a start of the time window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string RequestStartTimeAttributeName { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestStartTimeAttributeName; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestStartTimeAttributeName = value ?? null; }

        /// <summary>The number of seconds we will consider as a request timeout</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public int? RequestTimeoutInSecond { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestTimeoutInSecond; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).RequestTimeoutInSecond = value ?? default(int); }

        /// <summary>Describes the path we should extract the data in the response</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string[] ResponseEventsJsonPath { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).ResponseEventsJsonPath; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).ResponseEventsJsonPath = value ?? null /* arrayOf */; }

        /// <summary>Describes if the data in the response is Gzip</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public bool? ResponseIsGzipCompressed { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).ResponseIsGzipCompressed; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).ResponseIsGzipCompressed = value ?? default(bool); }

        /// <summary>Describes the path we should extract the status code in the response</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string ResponseSuccessStatusJsonPath { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).ResponseSuccessStatusJsonPath; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).ResponseSuccessStatusJsonPath = value ?? null; }

        /// <summary>Describes the path we should extract the status value in the response</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Origin(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.PropertyOrigin.Inlined)]
        public string ResponseSuccessStatusValue { get => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).ResponseSuccessStatusValue; set => ((Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigPropertiesInternal)PollingConfig).ResponseSuccessStatusValue = value ?? null; }

        /// <summary>Creates an new <see cref="ApiPollingParameters" /> instance.</summary>
        public ApiPollingParameters()
        {

        }
    }
    /// Represents Codeless API Polling data connector
    public partial interface IApiPollingParameters :
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.IJsonSerializable
    {
        /// <summary>A prefix send in the header before the actual token</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A prefix send in the header before the actual token",
        SerializedName = @"apiKeyIdentifier",
        PossibleTypes = new [] { typeof(string) })]
        string AuthApiKeyIdentifier { get; set; }
        /// <summary>The header name which the token is sent with</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The header name which the token is sent with",
        SerializedName = @"apiKeyName",
        PossibleTypes = new [] { typeof(string) })]
        string AuthApiKeyName { get; set; }
        /// <summary>The endpoint used to authorize the user, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The endpoint used to authorize the user, used in Oauth 2.0 flow",
        SerializedName = @"authorizationEndpoint",
        PossibleTypes = new [] { typeof(string) })]
        string AuthAuthorizationEndpoint { get; set; }
        /// <summary>The query parameters used in authorization request, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The query parameters used in authorization request, used in Oauth 2.0 flow",
        SerializedName = @"authorizationEndpointQueryParameters",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny) })]
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthAuthorizationEndpointQueryParameter { get; set; }
        /// <summary>Describes the flow name, for example 'AuthCode' for Oauth 2.0</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describes the flow name, for example 'AuthCode' for Oauth 2.0",
        SerializedName = @"flowName",
        PossibleTypes = new [] { typeof(string) })]
        string AuthFlowName { get; set; }
        /// <summary>Marks if the key should sent in header</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Marks if the key should sent in header",
        SerializedName = @"isApiKeyInPostPayload",
        PossibleTypes = new [] { typeof(string) })]
        string AuthIsApiKeyInPostPayload { get; set; }
        /// <summary>
        /// Marks if we should send the client secret in header or payload, used in Oauth 2.0 flow
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Marks if we should send the client secret in header or payload, used in Oauth 2.0 flow",
        SerializedName = @"isClientSecretInHeader",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AuthIsClientSecretInHeader { get; set; }
        /// <summary>
        /// The redirect endpoint where we will get the authorization code, used in Oauth 2.0 flow
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The redirect endpoint where we will get the authorization code, used in Oauth 2.0 flow",
        SerializedName = @"redirectionEndpoint",
        PossibleTypes = new [] { typeof(string) })]
        string AuthRedirectionEndpoint { get; set; }
        /// <summary>The OAuth token scope</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The OAuth token scope",
        SerializedName = @"scope",
        PossibleTypes = new [] { typeof(string) })]
        string AuthScope { get; set; }
        /// <summary>The endpoint used to issue a token, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The endpoint used to issue a token, used in Oauth 2.0 flow",
        SerializedName = @"tokenEndpoint",
        PossibleTypes = new [] { typeof(string) })]
        string AuthTokenEndpoint { get; set; }
        /// <summary>The query headers used in token request, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The query headers used in token request, used in Oauth 2.0 flow",
        SerializedName = @"tokenEndpointHeaders",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny) })]
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthTokenEndpointHeader { get; set; }
        /// <summary>The query parameters used in token request, used in Oauth 2.0 flow</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The query parameters used in token request, used in Oauth 2.0 flow",
        SerializedName = @"tokenEndpointQueryParameters",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny) })]
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthTokenEndpointQueryParameter { get; set; }
        /// <summary>The authentication type</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The authentication type",
        SerializedName = @"authType",
        PossibleTypes = new [] { typeof(string) })]
        string AuthType { get; set; }
        /// <summary>Set connector as preview</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Set connector as preview",
        SerializedName = @"isPreview",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AvailabilityIsPreview { get; set; }
        /// <summary>The connector Availability Status</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The connector Availability Status",
        SerializedName = @"status",
        PossibleTypes = new [] { typeof(int) })]
        int? AvailabilityStatus { get; set; }
        /// <summary>Define the way the connector check connectivity</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Define the way the connector check connectivity",
        SerializedName = @"connectivityCriteria",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IConnectivityCriteria) })]
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IConnectivityCriteria[] ConnectorUiConfigConnectivityCriterion { get; set; }
        /// <summary>
        /// An optional custom image to be used when displaying the connector within Azure Sentinel's connector's gallery
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"An optional custom image to be used when displaying the connector within Azure Sentinel's connector's gallery",
        SerializedName = @"customImage",
        PossibleTypes = new [] { typeof(string) })]
        string ConnectorUiConfigCustomImage { get; set; }
        /// <summary>Data types to check for last data received</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Data types to check for last data received",
        SerializedName = @"dataTypes",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ILastDataReceivedDataType) })]
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ILastDataReceivedDataType[] ConnectorUiConfigDataType { get; set; }
        /// <summary>Connector description</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Connector description",
        SerializedName = @"descriptionMarkdown",
        PossibleTypes = new [] { typeof(string) })]
        string ConnectorUiConfigDescriptionMarkdown { get; set; }
        /// <summary>Name of the table the connector will insert the data to</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Name of the table the connector will insert the data to",
        SerializedName = @"graphQueriesTableName",
        PossibleTypes = new [] { typeof(string) })]
        string ConnectorUiConfigGraphQueriesTableName { get; set; }
        /// <summary>The graph query to show the current data status</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The graph query to show the current data status",
        SerializedName = @"graphQueries",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IGraphQueries) })]
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IGraphQueries[] ConnectorUiConfigGraphQuery { get; set; }
        /// <summary>Instruction steps to enable the connector</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Instruction steps to enable the connector",
        SerializedName = @"instructionSteps",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IInstructionSteps) })]
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IInstructionSteps[] ConnectorUiConfigInstructionStep { get; set; }
        /// <summary>Connector publisher name</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Connector publisher name",
        SerializedName = @"publisher",
        PossibleTypes = new [] { typeof(string) })]
        string ConnectorUiConfigPublisher { get; set; }
        /// <summary>The sample queries for the connector</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The sample queries for the connector",
        SerializedName = @"sampleQueries",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ISampleQueries) })]
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ISampleQueries[] ConnectorUiConfigSampleQuery { get; set; }
        /// <summary>Connector blade title</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Connector blade title",
        SerializedName = @"title",
        PossibleTypes = new [] { typeof(string) })]
        string ConnectorUiConfigTitle { get; set; }
        /// <summary>Defines the name of a next page attribute</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Defines the name of a next page attribute",
        SerializedName = @"nextPageParaName",
        PossibleTypes = new [] { typeof(string) })]
        string PagingNextPageParaName { get; set; }
        /// <summary>Defines the path to a next page token JSON</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Defines the path to a next page token JSON",
        SerializedName = @"nextPageTokenJsonPath",
        PossibleTypes = new [] { typeof(string) })]
        string PagingNextPageTokenJsonPath { get; set; }
        /// <summary>Defines the path to a page count attribute</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Defines the path to a page count attribute",
        SerializedName = @"pageCountAttributePath",
        PossibleTypes = new [] { typeof(string) })]
        string PagingPageCountAttributePath { get; set; }
        /// <summary>Defines the paging size</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Defines the paging size",
        SerializedName = @"pageSize",
        PossibleTypes = new [] { typeof(int) })]
        int? PagingPageSize { get; set; }
        /// <summary>Defines the name of the page size parameter</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Defines the name of the page size parameter",
        SerializedName = @"pageSizeParaName",
        PossibleTypes = new [] { typeof(string) })]
        string PagingPageSizeParaName { get; set; }
        /// <summary>Defines the path to a paging time stamp attribute</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Defines the path to a paging time stamp attribute",
        SerializedName = @"pageTimeStampAttributePath",
        PossibleTypes = new [] { typeof(string) })]
        string PagingPageTimeStampAttributePath { get; set; }
        /// <summary>Defines the path to a page total count attribute</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Defines the path to a page total count attribute",
        SerializedName = @"pageTotalCountAttributePath",
        PossibleTypes = new [] { typeof(string) })]
        string PagingPageTotalCountAttributePath { get; set; }
        /// <summary>Determines whether to search for the latest time stamp in the events list</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Determines whether to search for the latest time stamp in the events list",
        SerializedName = @"searchTheLatestTimeStampFromEventsList",
        PossibleTypes = new [] { typeof(string) })]
        string PagingSearchTheLatestTimeStampFromEventsList { get; set; }
        /// <summary>Describes the type. could be 'None', 'PageToken', 'PageCount', 'TimeStamp'</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describes the type. could be 'None', 'PageToken', 'PageCount', 'TimeStamp'",
        SerializedName = @"pagingType",
        PossibleTypes = new [] { typeof(string) })]
        string PagingType { get; set; }
        /// <summary>Customs permissions required for the connector</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Customs permissions required for the connector",
        SerializedName = @"customs",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICustomsPermission) })]
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICustomsPermission[] PermissionCustom { get; set; }
        /// <summary>Resource provider permissions required for the connector</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource provider permissions required for the connector",
        SerializedName = @"resourceProvider",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IResourceProvider) })]
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IResourceProvider[] PermissionResourceProvider { get; set; }
        /// <summary>The poller active status</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The poller active status",
        SerializedName = @"isActive",
        PossibleTypes = new [] { typeof(bool) })]
        bool? PollingConfigIsActive { get; set; }
        /// <summary>Describe the endpoint we should pull the data from</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describe the endpoint we should pull the data from",
        SerializedName = @"apiEndpoint",
        PossibleTypes = new [] { typeof(string) })]
        string RequestApiEndpoint { get; set; }
        /// <summary>This will be used the query events from the end of the time window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This will be used the query events from the end of the time window",
        SerializedName = @"endTimeAttributeName",
        PossibleTypes = new [] { typeof(string) })]
        string RequestEndTimeAttributeName { get; set; }
        /// <summary>Describe the headers sent in the poll request</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describe the headers sent in the poll request",
        SerializedName = @"headers",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny) })]
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny RequestHeader { get; set; }
        /// <summary>The http method type we will use in the poll request, GET or POST</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The http method type we will use in the poll request, GET or POST",
        SerializedName = @"httpMethod",
        PossibleTypes = new [] { typeof(string) })]
        string RequestHttpMethod { get; set; }
        /// <summary>Describe the query parameters sent in the poll request</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describe the query parameters sent in the poll request",
        SerializedName = @"queryParameters",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny) })]
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny RequestQueryParameter { get; set; }
        /// <summary>
        /// For advanced scenarios for example user name/password embedded in nested JSON payload
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For advanced scenarios for example user name/password embedded in nested JSON payload",
        SerializedName = @"queryParametersTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string RequestQueryParametersTemplate { get; set; }
        /// <summary>The time format will be used the query events in a specific window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The time format will be used the query events in a specific window",
        SerializedName = @"queryTimeFormat",
        PossibleTypes = new [] { typeof(string) })]
        string RequestQueryTimeFormat { get; set; }
        /// <summary>The window interval we will use the pull the data</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The window interval we will use the pull the data",
        SerializedName = @"queryWindowInMin",
        PossibleTypes = new [] { typeof(int) })]
        int? RequestQueryWindowInMin { get; set; }
        /// <summary>Defines the rate limit QPS</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Defines the rate limit QPS",
        SerializedName = @"rateLimitQps",
        PossibleTypes = new [] { typeof(int) })]
        int? RequestRateLimitQp { get; set; }
        /// <summary>Describe the amount of time we should try and poll the data in case of failure</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describe the amount of time we should try and poll the data in case of failure",
        SerializedName = @"retryCount",
        PossibleTypes = new [] { typeof(int) })]
        int? RequestRetryCount { get; set; }
        /// <summary>This will be used the query events from a start of the time window</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This will be used the query events from a start of the time window",
        SerializedName = @"startTimeAttributeName",
        PossibleTypes = new [] { typeof(string) })]
        string RequestStartTimeAttributeName { get; set; }
        /// <summary>The number of seconds we will consider as a request timeout</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The number of seconds we will consider as a request timeout",
        SerializedName = @"timeoutInSeconds",
        PossibleTypes = new [] { typeof(int) })]
        int? RequestTimeoutInSecond { get; set; }
        /// <summary>Describes the path we should extract the data in the response</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describes the path we should extract the data in the response",
        SerializedName = @"eventsJsonPaths",
        PossibleTypes = new [] { typeof(string) })]
        string[] ResponseEventsJsonPath { get; set; }
        /// <summary>Describes if the data in the response is Gzip</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describes if the data in the response is Gzip",
        SerializedName = @"isGzipCompressed",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ResponseIsGzipCompressed { get; set; }
        /// <summary>Describes the path we should extract the status code in the response</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describes the path we should extract the status code in the response",
        SerializedName = @"successStatusJsonPath",
        PossibleTypes = new [] { typeof(string) })]
        string ResponseSuccessStatusJsonPath { get; set; }
        /// <summary>Describes the path we should extract the status value in the response</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Describes the path we should extract the status value in the response",
        SerializedName = @"successStatusValue",
        PossibleTypes = new [] { typeof(string) })]
        string ResponseSuccessStatusValue { get; set; }

    }
    /// Represents Codeless API Polling data connector
    internal partial interface IApiPollingParametersInternal

    {
        /// <summary>A prefix send in the header before the actual token</summary>
        string AuthApiKeyIdentifier { get; set; }
        /// <summary>The header name which the token is sent with</summary>
        string AuthApiKeyName { get; set; }
        /// <summary>The endpoint used to authorize the user, used in Oauth 2.0 flow</summary>
        string AuthAuthorizationEndpoint { get; set; }
        /// <summary>The query parameters used in authorization request, used in Oauth 2.0 flow</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthAuthorizationEndpointQueryParameter { get; set; }
        /// <summary>Describes the flow name, for example 'AuthCode' for Oauth 2.0</summary>
        string AuthFlowName { get; set; }
        /// <summary>Marks if the key should sent in header</summary>
        string AuthIsApiKeyInPostPayload { get; set; }
        /// <summary>
        /// Marks if we should send the client secret in header or payload, used in Oauth 2.0 flow
        /// </summary>
        bool? AuthIsClientSecretInHeader { get; set; }
        /// <summary>
        /// The redirect endpoint where we will get the authorization code, used in Oauth 2.0 flow
        /// </summary>
        string AuthRedirectionEndpoint { get; set; }
        /// <summary>The OAuth token scope</summary>
        string AuthScope { get; set; }
        /// <summary>The endpoint used to issue a token, used in Oauth 2.0 flow</summary>
        string AuthTokenEndpoint { get; set; }
        /// <summary>The query headers used in token request, used in Oauth 2.0 flow</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthTokenEndpointHeader { get; set; }
        /// <summary>The query parameters used in token request, used in Oauth 2.0 flow</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny AuthTokenEndpointQueryParameter { get; set; }
        /// <summary>The authentication type</summary>
        string AuthType { get; set; }
        /// <summary>Set connector as preview</summary>
        bool? AvailabilityIsPreview { get; set; }
        /// <summary>The connector Availability Status</summary>
        int? AvailabilityStatus { get; set; }
        /// <summary>Config to describe the instructions blade</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessUiConnectorConfigProperties ConnectorUiConfig { get; set; }
        /// <summary>Connector Availability Status</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IAvailability ConnectorUiConfigAvailability { get; set; }
        /// <summary>Define the way the connector check connectivity</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IConnectivityCriteria[] ConnectorUiConfigConnectivityCriterion { get; set; }
        /// <summary>
        /// An optional custom image to be used when displaying the connector within Azure Sentinel's connector's gallery
        /// </summary>
        string ConnectorUiConfigCustomImage { get; set; }
        /// <summary>Data types to check for last data received</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ILastDataReceivedDataType[] ConnectorUiConfigDataType { get; set; }
        /// <summary>Connector description</summary>
        string ConnectorUiConfigDescriptionMarkdown { get; set; }
        /// <summary>Name of the table the connector will insert the data to</summary>
        string ConnectorUiConfigGraphQueriesTableName { get; set; }
        /// <summary>The graph query to show the current data status</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IGraphQueries[] ConnectorUiConfigGraphQuery { get; set; }
        /// <summary>Instruction steps to enable the connector</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IInstructionSteps[] ConnectorUiConfigInstructionStep { get; set; }
        /// <summary>Permissions required for the connector</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IPermissions ConnectorUiConfigPermission { get; set; }
        /// <summary>Connector publisher name</summary>
        string ConnectorUiConfigPublisher { get; set; }
        /// <summary>The sample queries for the connector</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ISampleQueries[] ConnectorUiConfigSampleQuery { get; set; }
        /// <summary>Connector blade title</summary>
        string ConnectorUiConfigTitle { get; set; }
        /// <summary>Defines the name of a next page attribute</summary>
        string PagingNextPageParaName { get; set; }
        /// <summary>Defines the path to a next page token JSON</summary>
        string PagingNextPageTokenJsonPath { get; set; }
        /// <summary>Defines the path to a page count attribute</summary>
        string PagingPageCountAttributePath { get; set; }
        /// <summary>Defines the paging size</summary>
        int? PagingPageSize { get; set; }
        /// <summary>Defines the name of the page size parameter</summary>
        string PagingPageSizeParaName { get; set; }
        /// <summary>Defines the path to a paging time stamp attribute</summary>
        string PagingPageTimeStampAttributePath { get; set; }
        /// <summary>Defines the path to a page total count attribute</summary>
        string PagingPageTotalCountAttributePath { get; set; }
        /// <summary>Determines whether to search for the latest time stamp in the events list</summary>
        string PagingSearchTheLatestTimeStampFromEventsList { get; set; }
        /// <summary>Describes the type. could be 'None', 'PageToken', 'PageCount', 'TimeStamp'</summary>
        string PagingType { get; set; }
        /// <summary>Customs permissions required for the connector</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICustomsPermission[] PermissionCustom { get; set; }
        /// <summary>Resource provider permissions required for the connector</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.IResourceProvider[] PermissionResourceProvider { get; set; }
        /// <summary>Config to describe the polling instructions</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingConfigProperties PollingConfig { get; set; }
        /// <summary>Describe the authentication type of the poller</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingAuthProperties PollingConfigAuth { get; set; }
        /// <summary>The poller active status</summary>
        bool? PollingConfigIsActive { get; set; }
        /// <summary>Describe the poll request paging config of the poller</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingPagingProperties PollingConfigPaging { get; set; }
        /// <summary>Describe the poll request config parameters of the poller</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingRequestProperties PollingConfigRequest { get; set; }
        /// <summary>Describe the response config parameters of the poller</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.Api20210901Preview.ICodelessConnectorPollingResponseProperties PollingConfigResponse { get; set; }
        /// <summary>Describe the endpoint we should pull the data from</summary>
        string RequestApiEndpoint { get; set; }
        /// <summary>This will be used the query events from the end of the time window</summary>
        string RequestEndTimeAttributeName { get; set; }
        /// <summary>Describe the headers sent in the poll request</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny RequestHeader { get; set; }
        /// <summary>The http method type we will use in the poll request, GET or POST</summary>
        string RequestHttpMethod { get; set; }
        /// <summary>Describe the query parameters sent in the poll request</summary>
        Microsoft.Azure.PowerShell.Cmdlets.SecurityInsights.Models.IAny RequestQueryParameter { get; set; }
        /// <summary>
        /// For advanced scenarios for example user name/password embedded in nested JSON payload
        /// </summary>
        string RequestQueryParametersTemplate { get; set; }
        /// <summary>The time format will be used the query events in a specific window</summary>
        string RequestQueryTimeFormat { get; set; }
        /// <summary>The window interval we will use the pull the data</summary>
        int? RequestQueryWindowInMin { get; set; }
        /// <summary>Defines the rate limit QPS</summary>
        int? RequestRateLimitQp { get; set; }
        /// <summary>Describe the amount of time we should try and poll the data in case of failure</summary>
        int? RequestRetryCount { get; set; }
        /// <summary>This will be used the query events from a start of the time window</summary>
        string RequestStartTimeAttributeName { get; set; }
        /// <summary>The number of seconds we will consider as a request timeout</summary>
        int? RequestTimeoutInSecond { get; set; }
        /// <summary>Describes the path we should extract the data in the response</summary>
        string[] ResponseEventsJsonPath { get; set; }
        /// <summary>Describes if the data in the response is Gzip</summary>
        bool? ResponseIsGzipCompressed { get; set; }
        /// <summary>Describes the path we should extract the status code in the response</summary>
        string ResponseSuccessStatusJsonPath { get; set; }
        /// <summary>Describes the path we should extract the status value in the response</summary>
        string ResponseSuccessStatusValue { get; set; }

    }
}