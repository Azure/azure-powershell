// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

using static Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.Extensions;

namespace Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime
{
    public class ProxyEventListener : Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.IEventListener
    {
         /// <summary>
        /// The <see cref="global::System.Threading.CancellationTokenSource" /> for this operation.
        /// </summary>
        private global::System.Threading.CancellationTokenSource _cancellationTokenSource;
        
        /// <summary><see cref="IEventListener" /> cancellation token.</summary>
        global::System.Threading.CancellationToken Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.IEventListener.Token => _cancellationTokenSource.Token;
        
        /// <summary>
        /// <see cref="IEventListener" /> cancellation delegate. Stops the cmdlet when called.
        /// </summary>
        global::System.Action Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.IEventListener.Cancel => _cancellationTokenSource.Cancel;

        global::System.Management.Automation.PSCmdlet _cmdlet;

        async global::System.Threading.Tasks.Task Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.IEventListener.Signal(string id, global::System.Threading.CancellationToken token, global::System.Func<Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.EventData> messageData)
        {
            using( NoSynchronizationContext )
            {
                if (token.IsCancellationRequested)
                {
                    return ;
                }

                switch ( id )
                {
                    case Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.Events.Verbose:
                    {
                        _cmdlet.WriteVerbose($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.Events.Warning:
                    {
                        _cmdlet.WriteWarning($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.Events.Information:
                    {
                        var data = messageData();
                        _cmdlet.WriteInformation(data.Message, new string[]{});
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.Events.Debug:
                    {
                        _cmdlet.WriteDebug($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.Events.Error:
                    {
                        _cmdlet.WriteError(new global::System.Management.Automation.ErrorRecord( new global::System.Exception(messageData().Message), string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null ) );
                        return ;
                    }
                }
                await Microsoft.Azure.PowerShell.Cmdlets.Monitor.Module.Instance.Signal(id, token, messageData, (i,t,m) => ((Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.IEventListener)this).Signal(i,t,()=> Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.EventDataConverter.ConvertFrom( m() ) as Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.EventData ));
                if (token.IsCancellationRequested)
                {
                    return ;
                }
            }
        }

        private ProxyEventListener (System.Management.Automation.PSCmdlet cmdlet) 
        {
            _cmdlet = cmdlet;
            _cancellationTokenSource = new global::System.Threading.CancellationTokenSource();
        }

        public static Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.ProxyEventListener CreateProxyEventListener(System.Management.Automation.PSCmdlet cmdlet) => new Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.ProxyEventListener(cmdlet);
    }

}