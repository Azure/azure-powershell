// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

using static Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.Extensions;

namespace Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime
{
    public class ProxyEventListener<T> : Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.IEventListener, global::System.IDisposable
    {
        /// <summary>The reference to the client API class.</summary>
        public Microsoft.Azure.PowerShell.Cmdlets.Monitor.Monitor Client => Microsoft.Azure.PowerShell.Cmdlets.Monitor.Module.Instance.ClientAPI;

        private T _result;

        public T GetResult => _result;

         /// <summary>
        /// The <see cref="global::System.Threading.CancellationTokenSource" /> for this operation.
        /// </summary>
        private global::System.Threading.CancellationTokenSource _cancellationTokenSource = new global::System.Threading.CancellationTokenSource();
        
        /// <summary><see cref="IEventListener" /> cancellation token.</summary>
        global::System.Threading.CancellationToken Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.IEventListener.Token => _cancellationTokenSource.Token;
        
        /// <summary>
        /// <see cref="IEventListener" /> cancellation delegate. Stops the cmdlet when called.
        /// </summary>
        global::System.Action Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.IEventListener.Cancel => _cancellationTokenSource.Cancel;

        
        async global::System.Threading.Tasks.Task Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.IEventListener.Signal(string id, global::System.Threading.CancellationToken token, global::System.Func<Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.EventData> messageData)
        {
        
        }

        private ProxyEventListener () {}

        public static Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.ProxyEventListener<T> CreateProxyEventListener() => new Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.ProxyEventListener<T>();

        public async global::System.Threading.Tasks.Task GetAsync (global::System.String viaIdentity, 
                                                                                global::System.Func<
                                                                                global::System.String,
                                                                                global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<T>, global::System.Threading.Tasks.Task>,
                                                                                global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Monitor.Models.Api20201001.IErrorResponse>, global::System.Threading.Tasks.Task>, 
                                                                                Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.IEventListener,
                                                                                Microsoft.Azure.PowerShell.Cmdlets.Monitor.Runtime.ISendAsync,
                                                                                global::System.Threading.Tasks.Task> operation) 
        {
            using( NoSynchronizationContext ) 
            {
                try
                {
                    await operation.Invoke(viaIdentity, onOk, onDefault, this, Microsoft.Azure.PowerShell.Cmdlets.Monitor.Module.Instance.CreateProxyPipeline());
                } catch {

                }
            }
            
        }

        /// <summary>
        /// a delegate that is called when the remote service returns default (any response code not handled elsewhere).
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.Monitor.Models.Api20201001.IErrorResponse"
        /// /> from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onDefault(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Monitor.Models.Api20201001.IErrorResponse> response)
        {

        }

        /// <summary>a delegate that is called when the remote service returns 200 (OK).</summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.Monitor.Models.Api20201001.IActivityLogAlertResource"
        /// /> from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<T> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                _result = await response;
            }
        }

        public void Dispose() {}
    }

}