
# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Code generated by Microsoft (R) AutoRest Code Generator.Changes may cause incorrect behavior and will be lost if the code
# is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create an in-memory object for ScaleRule.
.Description
Create an in-memory object for ScaleRule.

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Monitor.Autoscale.Models.Api20221001.ScaleRule
.Link
https://docs.microsoft.com/powershell/module/az.Autoscale/new-AzAutoscaleScaleRuleObject
#>
function New-AzAutoscaleScaleRuleObject {
    [OutputType('Microsoft.Azure.PowerShell.Cmdlets.Monitor.Autoscale.Models.Api20221001.ScaleRule')]
    [CmdletBinding(PositionalBinding=$false)]
    Param(

        [Parameter(HelpMessage="List of dimension conditions. For example: [{`"DimensionName`":`"AppName`",`"Operator`":`"Equals`",`"Values`":[`"App1`"]},{`"DimensionName`":`"Deployment`",`"Operator`":`"Equals`",`"Values`":[`"default`"]}].")]
        [Microsoft.Azure.PowerShell.Cmdlets.Monitor.Autoscale.Models.Api20221001.IScaleRuleMetricDimension[]]
        $MetricTriggerDimension,
        [Parameter(HelpMessage="a value indicating whether metric should divide per instance.")]
        [bool]
        $MetricTriggerDividePerInstance,
        [Parameter(Mandatory, HelpMessage="the name of the metric that defines what the rule monitors.")]
        [string]
        $MetricTriggerMetricName,
        [Parameter(HelpMessage="the namespace of the metric that defines what the rule monitors.")]
        [string]
        $MetricTriggerMetricNamespace,
        [Parameter(HelpMessage="the location of the resource the rule monitors.")]
        [string]
        $MetricTriggerMetricResourceLocation,
        [Parameter(Mandatory, HelpMessage="the resource identifier of the resource the rule monitors.")]
        [string]
        $MetricTriggerMetricResourceUri,
        [Parameter(Mandatory, HelpMessage="the operator that is used to compare the metric data and the threshold.")]
        [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.Monitor.Autoscale.Support.ComparisonOperationType])]
        [Microsoft.Azure.PowerShell.Cmdlets.Monitor.Autoscale.Support.ComparisonOperationType]
        $MetricTriggerOperator,
        [Parameter(Mandatory, HelpMessage="the metric statistic type. How the metrics from multiple instances are combined.")]
        [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.Monitor.Autoscale.Support.MetricStatisticType])]
        [Microsoft.Azure.PowerShell.Cmdlets.Monitor.Autoscale.Support.MetricStatisticType]
        $MetricTriggerStatistic,
        [Parameter(Mandatory, HelpMessage="the threshold of the metric that triggers the scale action.")]
        [double]
        $MetricTriggerThreshold,
        [Parameter(Mandatory, HelpMessage="time aggregation type. How the data that is collected should be combined over time. The default value is Average.")]
        [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.Monitor.Autoscale.Support.TimeAggregationType])]
        [Microsoft.Azure.PowerShell.Cmdlets.Monitor.Autoscale.Support.TimeAggregationType]
        $MetricTriggerTimeAggregation,
        [Parameter(Mandatory, HelpMessage="the granularity of metrics the rule monitors. Must be one of the predefined values returned from metric definitions for the metric. Must be between 12 hours and 1 minute.")]
        [System.TimeSpan]
        $MetricTriggerTimeGrain,
        [Parameter(Mandatory, HelpMessage="the range of time in which instance data is collected. This value must be greater than the delay in metric collection, which can vary from resource-to-resource. Must be between 12 hours and 5 minutes.")]
        [System.TimeSpan]
        $MetricTriggerTimeWindow,
        [Parameter(Mandatory, HelpMessage="the amount of time to wait since the last scaling action before this action occurs. It must be between 1 week and 1 minute in ISO 8601 format.")]
        [System.TimeSpan]
        $ScaleActionCooldown,
        [Parameter(Mandatory, HelpMessage="the scale direction. Whether the scaling action increases or decreases the number of instances.")]
        [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.Monitor.Autoscale.Support.ScaleDirection])]
        [Microsoft.Azure.PowerShell.Cmdlets.Monitor.Autoscale.Support.ScaleDirection]
        $ScaleActionDirection,
        [Parameter(Mandatory, HelpMessage="the type of action that should occur when the scale rule fires.")]
        [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.Monitor.Autoscale.Support.ScaleType])]
        [Microsoft.Azure.PowerShell.Cmdlets.Monitor.Autoscale.Support.ScaleType]
        $ScaleActionType,
        [Parameter(HelpMessage="the number of instances that are involved in the scaling action. This value must be 1 or greater. The default value is 1.")]
        [string]
        $ScaleActionValue
    )

    process {
        $Object = [Microsoft.Azure.PowerShell.Cmdlets.Monitor.Autoscale.Models.Api20221001.ScaleRule]::New()

        if ($PSBoundParameters.ContainsKey('MetricTriggerDimension')) {
            $Object.MetricTriggerDimension = $MetricTriggerDimension
        }
        if ($PSBoundParameters.ContainsKey('MetricTriggerDividePerInstance')) {
            $Object.MetricTriggerDividePerInstance = $MetricTriggerDividePerInstance
        }
        if ($PSBoundParameters.ContainsKey('MetricTriggerMetricName')) {
            $Object.MetricTriggerMetricName = $MetricTriggerMetricName
        }
        if ($PSBoundParameters.ContainsKey('MetricTriggerMetricNamespace')) {
            $Object.MetricTriggerMetricNamespace = $MetricTriggerMetricNamespace
        }
        if ($PSBoundParameters.ContainsKey('MetricTriggerMetricResourceLocation')) {
            $Object.MetricTriggerMetricResourceLocation = $MetricTriggerMetricResourceLocation
        }
        if ($PSBoundParameters.ContainsKey('MetricTriggerMetricResourceUri')) {
            $Object.MetricTriggerMetricResourceUri = $MetricTriggerMetricResourceUri
        }
        if ($PSBoundParameters.ContainsKey('MetricTriggerOperator')) {
            $Object.MetricTriggerOperator = $MetricTriggerOperator
        }
        if ($PSBoundParameters.ContainsKey('MetricTriggerStatistic')) {
            $Object.MetricTriggerStatistic = $MetricTriggerStatistic
        }
        if ($PSBoundParameters.ContainsKey('MetricTriggerThreshold')) {
            $Object.MetricTriggerThreshold = $MetricTriggerThreshold
        }
        if ($PSBoundParameters.ContainsKey('MetricTriggerTimeAggregation')) {
            $Object.MetricTriggerTimeAggregation = $MetricTriggerTimeAggregation
        }
        if ($PSBoundParameters.ContainsKey('MetricTriggerTimeGrain')) {
            $Object.MetricTriggerTimeGrain = $MetricTriggerTimeGrain
        }
        if ($PSBoundParameters.ContainsKey('MetricTriggerTimeWindow')) {
            $Object.MetricTriggerTimeWindow = $MetricTriggerTimeWindow
        }
        if ($PSBoundParameters.ContainsKey('ScaleActionCooldown')) {
            $Object.ScaleActionCooldown = $ScaleActionCooldown
        }
        if ($PSBoundParameters.ContainsKey('ScaleActionDirection')) {
            $Object.ScaleActionDirection = $ScaleActionDirection
        }
        if ($PSBoundParameters.ContainsKey('ScaleActionType')) {
            $Object.ScaleActionType = $ScaleActionType
        }
        if ($PSBoundParameters.ContainsKey('ScaleActionValue')) {
            $Object.ScaleActionValue = $ScaleActionValue
        }
        return $Object
    }
}

