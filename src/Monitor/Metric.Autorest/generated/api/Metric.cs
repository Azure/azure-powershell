// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Metric
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Extensions;

    /// <summary>
    /// Low-level API implementation for the Metric service.
    /// Provides APIs for getting the metric metadata for Azure resources.
    /// </summary>
    public partial class Metric
    {

        /// <summary>Lists the metric definitions for the resource.</summary>
        /// <param name="resourceUri">The identifier of the resource.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MetricDefinitionsList(string resourceUri, string metricnamespace, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IMetricDefinitionCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/"
                        + (resourceUri)
                        + "/providers/Microsoft.Insights/metricDefinitions"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (string.IsNullOrEmpty(metricnamespace) ? global::System.String.Empty : "metricnamespace=" + global::System.Uri.EscapeDataString(metricnamespace))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MetricDefinitionsList_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists the metric definitions for the subscription.</summary>
        /// <param name="subscriptionId">The ID of the target subscription.</param>
        /// <param name="region">The region where the metrics you want reside.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MetricDefinitionsListAtSubscriptionScope(string subscriptionId, string region, string metricnamespace, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ISubscriptionScopeMetricDefinitionCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorContract>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/providers/Microsoft.Insights/metricDefinitions"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + "region=" + global::System.Uri.EscapeDataString(region)
                        + "&"
                        + (string.IsNullOrEmpty(metricnamespace) ? global::System.String.Empty : "metricnamespace=" + global::System.Uri.EscapeDataString(metricnamespace))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MetricDefinitionsListAtSubscriptionScope_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists the metric definitions for the subscription.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="region">The region where the metrics you want reside.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MetricDefinitionsListAtSubscriptionScopeViaIdentity(global::System.String viaIdentity, string region, string metricnamespace, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ISubscriptionScopeMetricDefinitionCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorContract>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/providers/Microsoft.Insights/metricDefinitions$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/providers/Microsoft.Insights/metricDefinitions'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/providers/Microsoft.Insights/metricDefinitions"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + "region=" + global::System.Uri.EscapeDataString(region)
                        + "&"
                        + (string.IsNullOrEmpty(metricnamespace) ? global::System.String.Empty : "metricnamespace=" + global::System.Uri.EscapeDataString(metricnamespace))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MetricDefinitionsListAtSubscriptionScope_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists the metric definitions for the subscription.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="region">The region where the metrics you want reside.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ISubscriptionScopeMetricDefinitionCollection>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ISubscriptionScopeMetricDefinitionCollection> MetricDefinitionsListAtSubscriptionScopeViaIdentityWithResult(global::System.String viaIdentity, string region, string metricnamespace, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/providers/Microsoft.Insights/metricDefinitions$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/providers/Microsoft.Insights/metricDefinitions'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/providers/Microsoft.Insights/metricDefinitions"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + "region=" + global::System.Uri.EscapeDataString(region)
                        + "&"
                        + (string.IsNullOrEmpty(metricnamespace) ? global::System.String.Empty : "metricnamespace=" + global::System.Uri.EscapeDataString(metricnamespace))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.MetricDefinitionsListAtSubscriptionScopeWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Lists the metric definitions for the subscription.</summary>
        /// <param name="subscriptionId">The ID of the target subscription.</param>
        /// <param name="region">The region where the metrics you want reside.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ISubscriptionScopeMetricDefinitionCollection>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ISubscriptionScopeMetricDefinitionCollection> MetricDefinitionsListAtSubscriptionScopeWithResult(string subscriptionId, string region, string metricnamespace, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/providers/Microsoft.Insights/metricDefinitions"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + "region=" + global::System.Uri.EscapeDataString(region)
                        + "&"
                        + (string.IsNullOrEmpty(metricnamespace) ? global::System.String.Empty : "metricnamespace=" + global::System.Uri.EscapeDataString(metricnamespace))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.MetricDefinitionsListAtSubscriptionScopeWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref= "MetricDefinitionsListAtSubscriptionScopeWithResult" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ISubscriptionScopeMetricDefinitionCollection>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ISubscriptionScopeMetricDefinitionCollection> MetricDefinitionsListAtSubscriptionScopeWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.SubscriptionScopeMetricDefinitionCollection.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) );
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ErrorContract.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.Message;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorContract>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Actual wire call for <see cref= "MetricDefinitionsListAtSubscriptionScope" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MetricDefinitionsListAtSubscriptionScope_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ISubscriptionScopeMetricDefinitionCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorContract>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.SubscriptionScopeMetricDefinitionCollection.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ErrorContract.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MetricDefinitionsListAtSubscriptionScope" /> method. Call this like the actual call,
        /// but you will get validation events back.
        /// </summary>
        /// <param name="subscriptionId">The ID of the target subscription.</param>
        /// <param name="region">The region where the metrics you want reside.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MetricDefinitionsListAtSubscriptionScope_Validate(string subscriptionId, string region, string metricnamespace, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertMinimumLength(nameof(subscriptionId),subscriptionId,1);
                await eventListener.AssertNotNull(nameof(region),region);
                await eventListener.AssertNotNull(nameof(metricnamespace),metricnamespace);
            }
        }

        /// <summary>Lists the metric definitions for the resource.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MetricDefinitionsListViaIdentity(global::System.String viaIdentity, string metricnamespace, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IMetricDefinitionCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/(?<resourceUri>[^/]+)/providers/Microsoft.Insights/metricDefinitions$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/{resourceUri}/providers/Microsoft.Insights/metricDefinitions'");
                }

                // replace URI parameters with values from identity
                var resourceUri = _match.Groups["resourceUri"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/"
                        + resourceUri
                        + "/providers/Microsoft.Insights/metricDefinitions"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (string.IsNullOrEmpty(metricnamespace) ? global::System.String.Empty : "metricnamespace=" + global::System.Uri.EscapeDataString(metricnamespace))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MetricDefinitionsList_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists the metric definitions for the resource.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IMetricDefinitionCollection>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IMetricDefinitionCollection> MetricDefinitionsListViaIdentityWithResult(global::System.String viaIdentity, string metricnamespace, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/(?<resourceUri>[^/]+)/providers/Microsoft.Insights/metricDefinitions$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/{resourceUri}/providers/Microsoft.Insights/metricDefinitions'");
                }

                // replace URI parameters with values from identity
                var resourceUri = _match.Groups["resourceUri"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/"
                        + resourceUri
                        + "/providers/Microsoft.Insights/metricDefinitions"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (string.IsNullOrEmpty(metricnamespace) ? global::System.String.Empty : "metricnamespace=" + global::System.Uri.EscapeDataString(metricnamespace))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.MetricDefinitionsListWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Lists the metric definitions for the resource.</summary>
        /// <param name="resourceUri">The identifier of the resource.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IMetricDefinitionCollection>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IMetricDefinitionCollection> MetricDefinitionsListWithResult(string resourceUri, string metricnamespace, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/"
                        + (resourceUri)
                        + "/providers/Microsoft.Insights/metricDefinitions"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (string.IsNullOrEmpty(metricnamespace) ? global::System.String.Empty : "metricnamespace=" + global::System.Uri.EscapeDataString(metricnamespace))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.MetricDefinitionsListWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "MetricDefinitionsListWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IMetricDefinitionCollection>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IMetricDefinitionCollection> MetricDefinitionsListWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.MetricDefinitionCollection.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) );
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.Message;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorResponse>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "MetricDefinitionsList" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MetricDefinitionsList_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IMetricDefinitionCollection>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.MetricDefinitionCollection.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MetricDefinitionsList" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="resourceUri">The identifier of the resource.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MetricDefinitionsList_Validate(string resourceUri, string metricnamespace, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(resourceUri),resourceUri);
                await eventListener.AssertNotNull(nameof(metricnamespace),metricnamespace);
            }
        }

        /// <summary>**Lists the metric values for a resource**.</summary>
        /// <param name="resourceUri">The identifier of the resource.</param>
        /// <param name="timespan">The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'.</param>
        /// <param name="interval">The interval (i.e. timegrain) of the query in ISO 8601 duration format. Defaults to PT1M. Special
        /// case for 'FULL' value that returns single datapoint for entire time span requested.
        /// *Examples: PT15M, PT1H, P1D, FULL*</param>
        /// <param name="metricnames">The names of the metrics (comma separated) to retrieve.</param>
        /// <param name="aggregation">The list of aggregation types (comma separated) to retrieve.
        /// *Examples: average, minimum, maximum*</param>
        /// <param name="top">The maximum number of records to retrieve per resource ID in the request.
        /// Valid only if filter is specified.
        /// Defaults to 10.</param>
        /// <param name="orderby">The aggregation to use for sorting results and the direction of the sort.
        /// Only one order can be specified.
        /// *Examples: sum asc*</param>
        /// <param name="Filter">The **$filter** is used to reduce the set of metric data returned.<br>Example:<br>Metric contains
        /// metadata A, B and C.<br>- Return all time series of C where A = a1 and B = b1 or b2<br>**$filter=A eq ‘a1’ and B eq ‘b1’
        /// or B eq ‘b2’ and C eq ‘*’**<br>- Invalid variant:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘*’ or B = ‘b2’**<br>This
        /// is invalid because the logical or operator cannot separate two different metadata names.<br>- Return all time series where
        /// A = a1, B = b1 and C = c1:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘c1’**<br>- Return all time series where A =
        /// a1<br>**$filter=A eq ‘a1’ and B eq ‘*’ and C eq ‘*’**.</param>
        /// <param name="resultType">Reduces the set of data collected. The syntax allowed depends on the operation. See the operation's
        /// description for details.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="autoAdjustTimegrain">When set to true, if the timespan passed in is not supported by this metric, the API
        /// will return the result using the closest supported timespan. When set to false, an error is returned for invalid timespan
        /// parameters. Defaults to false.</param>
        /// <param name="validateDimensions">When set to false, invalid filter parameter values will be ignored. When set to true,
        /// an error is returned for invalid filter parameters. Defaults to true.</param>
        /// <param name="rollupby">Dimension name(s) to rollup results by. For example if you only want to see metric values with
        /// a filter like 'City eq Seattle or City eq Tacoma' but don't want to see separate values for each city, you can specify
        /// 'RollUpBy=City' to see the results for Seattle and Tacoma rolled up into one timeseries.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MetricsList(string resourceUri, string timespan, string interval, string metricnames, string aggregation, int? top, string orderby, string Filter, string resultType, string metricnamespace, bool? autoAdjustTimegrain, bool? validateDimensions, string rollupby, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/"
                        + (resourceUri)
                        + "/providers/Microsoft.Insights/metrics"
                        + "?"
                        + (string.IsNullOrEmpty(timespan) ? global::System.String.Empty : "timespan=" + global::System.Uri.EscapeDataString(timespan))
                        + "&"
                        + (string.IsNullOrEmpty(interval) ? global::System.String.Empty : "interval=" + global::System.Uri.EscapeDataString(interval))
                        + "&"
                        + (string.IsNullOrEmpty(metricnames) ? global::System.String.Empty : "metricnames=" + global::System.Uri.EscapeDataString(metricnames))
                        + "&"
                        + (string.IsNullOrEmpty(aggregation) ? global::System.String.Empty : "aggregation=" + global::System.Uri.EscapeDataString(aggregation))
                        + "&"
                        + (null == top ? global::System.String.Empty : "top=" + global::System.Uri.EscapeDataString(top.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(orderby) ? global::System.String.Empty : "orderby=" + global::System.Uri.EscapeDataString(orderby))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (string.IsNullOrEmpty(resultType) ? global::System.String.Empty : "resultType=" + global::System.Uri.EscapeDataString(resultType))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (string.IsNullOrEmpty(metricnamespace) ? global::System.String.Empty : "metricnamespace=" + global::System.Uri.EscapeDataString(metricnamespace))
                        + "&"
                        + (null == autoAdjustTimegrain ? global::System.String.Empty : "AutoAdjustTimegrain=" + global::System.Uri.EscapeDataString(autoAdjustTimegrain.ToString()))
                        + "&"
                        + (null == validateDimensions ? global::System.String.Empty : "ValidateDimensions=" + global::System.Uri.EscapeDataString(validateDimensions.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(rollupby) ? global::System.String.Empty : "rollupby=" + global::System.Uri.EscapeDataString(rollupby))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MetricsList_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>**Lists the metric data for a subscription**.</summary>
        /// <param name="subscriptionId">The ID of the target subscription.</param>
        /// <param name="region">The region where the metrics you want reside.</param>
        /// <param name="timespan">The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'.</param>
        /// <param name="interval">The interval (i.e. timegrain) of the query in ISO 8601 duration format. Defaults to PT1M. Special
        /// case for 'FULL' value that returns single datapoint for entire time span requested.
        /// *Examples: PT15M, PT1H, P1D, FULL*</param>
        /// <param name="metricnames">The names of the metrics (comma separated) to retrieve.</param>
        /// <param name="aggregation">The list of aggregation types (comma separated) to retrieve.
        /// *Examples: average, minimum, maximum*</param>
        /// <param name="top">The maximum number of records to retrieve per resource ID in the request.
        /// Valid only if filter is specified.
        /// Defaults to 10.</param>
        /// <param name="orderby">The aggregation to use for sorting results and the direction of the sort.
        /// Only one order can be specified.
        /// *Examples: sum asc*</param>
        /// <param name="Filter">The **$filter** is used to reduce the set of metric data returned.<br>Example:<br>Metric contains
        /// metadata A, B and C.<br>- Return all time series of C where A = a1 and B = b1 or b2<br>**$filter=A eq ‘a1’ and B eq ‘b1’
        /// or B eq ‘b2’ and C eq ‘*’**<br>- Invalid variant:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘*’ or B = ‘b2’**<br>This
        /// is invalid because the logical or operator cannot separate two different metadata names.<br>- Return all time series where
        /// A = a1, B = b1 and C = c1:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘c1’**<br>- Return all time series where A =
        /// a1<br>**$filter=A eq ‘a1’ and B eq ‘*’ and C eq ‘*’**.</param>
        /// <param name="resultType">Reduces the set of data collected. The syntax allowed depends on the operation. See the operation's
        /// description for details.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="autoAdjustTimegrain">When set to true, if the timespan passed in is not supported by this metric, the API
        /// will return the result using the closest supported timespan. When set to false, an error is returned for invalid timespan
        /// parameters. Defaults to false.</param>
        /// <param name="validateDimensions">When set to false, invalid filter parameter values will be ignored. When set to true,
        /// an error is returned for invalid filter parameters. Defaults to true.</param>
        /// <param name="rollupby">Dimension name(s) to rollup results by. For example if you only want to see metric values with
        /// a filter like 'City eq Seattle or City eq Tacoma' but don't want to see separate values for each city, you can specify
        /// 'RollUpBy=City' to see the results for Seattle and Tacoma rolled up into one timeseries.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MetricsListAtSubscriptionScope(string subscriptionId, string region, string timespan, string interval, string metricnames, string aggregation, int? top, string orderby, string Filter, string resultType, string metricnamespace, bool? autoAdjustTimegrain, bool? validateDimensions, string rollupby, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorContract>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/providers/Microsoft.Insights/metrics"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + "region=" + global::System.Uri.EscapeDataString(region)
                        + "&"
                        + (string.IsNullOrEmpty(timespan) ? global::System.String.Empty : "timespan=" + global::System.Uri.EscapeDataString(timespan))
                        + "&"
                        + (string.IsNullOrEmpty(interval) ? global::System.String.Empty : "interval=" + global::System.Uri.EscapeDataString(interval))
                        + "&"
                        + (string.IsNullOrEmpty(metricnames) ? global::System.String.Empty : "metricnames=" + global::System.Uri.EscapeDataString(metricnames))
                        + "&"
                        + (string.IsNullOrEmpty(aggregation) ? global::System.String.Empty : "aggregation=" + global::System.Uri.EscapeDataString(aggregation))
                        + "&"
                        + (null == top ? global::System.String.Empty : "top=" + global::System.Uri.EscapeDataString(top.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(orderby) ? global::System.String.Empty : "orderby=" + global::System.Uri.EscapeDataString(orderby))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (string.IsNullOrEmpty(resultType) ? global::System.String.Empty : "resultType=" + global::System.Uri.EscapeDataString(resultType))
                        + "&"
                        + (string.IsNullOrEmpty(metricnamespace) ? global::System.String.Empty : "metricnamespace=" + global::System.Uri.EscapeDataString(metricnamespace))
                        + "&"
                        + (null == autoAdjustTimegrain ? global::System.String.Empty : "AutoAdjustTimegrain=" + global::System.Uri.EscapeDataString(autoAdjustTimegrain.ToString()))
                        + "&"
                        + (null == validateDimensions ? global::System.String.Empty : "ValidateDimensions=" + global::System.Uri.EscapeDataString(validateDimensions.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(rollupby) ? global::System.String.Empty : "rollupby=" + global::System.Uri.EscapeDataString(rollupby))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MetricsListAtSubscriptionScope_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// **Lists the metric data for a subscription**. Parameters can be specified on either query params or the body.
        /// </summary>
        /// <param name="subscriptionId">The ID of the target subscription.</param>
        /// <param name="region">The region where the metrics you want reside.</param>
        /// <param name="body">Parameters serialized in the body</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MetricsListAtSubscriptionScopePost(string subscriptionId, string region, Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ISubscriptionScopeMetricsRequestBodyParameters body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorContract>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/providers/Microsoft.Insights/metrics"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + "region=" + global::System.Uri.EscapeDataString(region)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MetricsListAtSubscriptionScopePost_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// **Lists the metric data for a subscription**. Parameters can be specified on either query params or the body.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="region">The region where the metrics you want reside.</param>
        /// <param name="body">Parameters serialized in the body</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MetricsListAtSubscriptionScopePostViaIdentity(global::System.String viaIdentity, string region, Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ISubscriptionScopeMetricsRequestBodyParameters body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorContract>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/providers/Microsoft.Insights$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/providers/Microsoft.Insights'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/providers/Microsoft.Insights/metrics"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + "region=" + global::System.Uri.EscapeDataString(region)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MetricsListAtSubscriptionScopePost_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// **Lists the metric data for a subscription**. Parameters can be specified on either query params or the body.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="region">The region where the metrics you want reside.</param>
        /// <param name="body">Parameters serialized in the body</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse> MetricsListAtSubscriptionScopePostViaIdentityWithResult(global::System.String viaIdentity, string region, Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ISubscriptionScopeMetricsRequestBodyParameters body, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/providers/Microsoft.Insights$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/providers/Microsoft.Insights'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/providers/Microsoft.Insights/metrics"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + "region=" + global::System.Uri.EscapeDataString(region)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.MetricsListAtSubscriptionScopePostWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// **Lists the metric data for a subscription**. Parameters can be specified on either query params or the body.
        /// </summary>
        /// <param name="subscriptionId">The ID of the target subscription.</param>
        /// <param name="region">The region where the metrics you want reside.</param>
        /// <param name="jsonString">Json string supplied to the MetricsListAtSubscriptionScopePost operation</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MetricsListAtSubscriptionScopePostViaJsonString(string subscriptionId, string region, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorContract>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/providers/Microsoft.Insights/metrics"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + "region=" + global::System.Uri.EscapeDataString(region)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MetricsListAtSubscriptionScopePost_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// **Lists the metric data for a subscription**. Parameters can be specified on either query params or the body.
        /// </summary>
        /// <param name="subscriptionId">The ID of the target subscription.</param>
        /// <param name="region">The region where the metrics you want reside.</param>
        /// <param name="jsonString">Json string supplied to the MetricsListAtSubscriptionScopePost operation</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse> MetricsListAtSubscriptionScopePostViaJsonStringWithResult(string subscriptionId, string region, global::System.String jsonString, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/providers/Microsoft.Insights/metrics"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + "region=" + global::System.Uri.EscapeDataString(region)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.MetricsListAtSubscriptionScopePostWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// **Lists the metric data for a subscription**. Parameters can be specified on either query params or the body.
        /// </summary>
        /// <param name="subscriptionId">The ID of the target subscription.</param>
        /// <param name="region">The region where the metrics you want reside.</param>
        /// <param name="body">Parameters serialized in the body</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse> MetricsListAtSubscriptionScopePostWithResult(string subscriptionId, string region, Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ISubscriptionScopeMetricsRequestBodyParameters body, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/providers/Microsoft.Insights/metrics"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + "region=" + global::System.Uri.EscapeDataString(region)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.MetricsListAtSubscriptionScopePostWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref= "MetricsListAtSubscriptionScopePostWithResult" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse> MetricsListAtSubscriptionScopePostWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.Response.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) );
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ErrorContract.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.Message;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorContract>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "MetricsListAtSubscriptionScopePost" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MetricsListAtSubscriptionScopePost_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorContract>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.Response.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ErrorContract.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MetricsListAtSubscriptionScopePost" /> method. Call this like the actual call, but you
        /// will get validation events back.
        /// </summary>
        /// <param name="subscriptionId">The ID of the target subscription.</param>
        /// <param name="region">The region where the metrics you want reside.</param>
        /// <param name="body">Parameters serialized in the body</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MetricsListAtSubscriptionScopePost_Validate(string subscriptionId, string region, Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ISubscriptionScopeMetricsRequestBodyParameters body, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertMinimumLength(nameof(subscriptionId),subscriptionId,1);
                await eventListener.AssertNotNull(nameof(region),region);
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>**Lists the metric data for a subscription**.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="region">The region where the metrics you want reside.</param>
        /// <param name="timespan">The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'.</param>
        /// <param name="interval">The interval (i.e. timegrain) of the query in ISO 8601 duration format. Defaults to PT1M. Special
        /// case for 'FULL' value that returns single datapoint for entire time span requested.
        /// *Examples: PT15M, PT1H, P1D, FULL*</param>
        /// <param name="metricnames">The names of the metrics (comma separated) to retrieve.</param>
        /// <param name="aggregation">The list of aggregation types (comma separated) to retrieve.
        /// *Examples: average, minimum, maximum*</param>
        /// <param name="top">The maximum number of records to retrieve per resource ID in the request.
        /// Valid only if filter is specified.
        /// Defaults to 10.</param>
        /// <param name="orderby">The aggregation to use for sorting results and the direction of the sort.
        /// Only one order can be specified.
        /// *Examples: sum asc*</param>
        /// <param name="Filter">The **$filter** is used to reduce the set of metric data returned.<br>Example:<br>Metric contains
        /// metadata A, B and C.<br>- Return all time series of C where A = a1 and B = b1 or b2<br>**$filter=A eq ‘a1’ and B eq ‘b1’
        /// or B eq ‘b2’ and C eq ‘*’**<br>- Invalid variant:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘*’ or B = ‘b2’**<br>This
        /// is invalid because the logical or operator cannot separate two different metadata names.<br>- Return all time series where
        /// A = a1, B = b1 and C = c1:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘c1’**<br>- Return all time series where A =
        /// a1<br>**$filter=A eq ‘a1’ and B eq ‘*’ and C eq ‘*’**.</param>
        /// <param name="resultType">Reduces the set of data collected. The syntax allowed depends on the operation. See the operation's
        /// description for details.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="autoAdjustTimegrain">When set to true, if the timespan passed in is not supported by this metric, the API
        /// will return the result using the closest supported timespan. When set to false, an error is returned for invalid timespan
        /// parameters. Defaults to false.</param>
        /// <param name="validateDimensions">When set to false, invalid filter parameter values will be ignored. When set to true,
        /// an error is returned for invalid filter parameters. Defaults to true.</param>
        /// <param name="rollupby">Dimension name(s) to rollup results by. For example if you only want to see metric values with
        /// a filter like 'City eq Seattle or City eq Tacoma' but don't want to see separate values for each city, you can specify
        /// 'RollUpBy=City' to see the results for Seattle and Tacoma rolled up into one timeseries.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MetricsListAtSubscriptionScopeViaIdentity(global::System.String viaIdentity, string region, string timespan, string interval, string metricnames, string aggregation, int? top, string orderby, string Filter, string resultType, string metricnamespace, bool? autoAdjustTimegrain, bool? validateDimensions, string rollupby, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorContract>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/providers/Microsoft.Insights/metrics$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/providers/Microsoft.Insights/metrics'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/providers/Microsoft.Insights/metrics"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + "region=" + global::System.Uri.EscapeDataString(region)
                        + "&"
                        + (string.IsNullOrEmpty(timespan) ? global::System.String.Empty : "timespan=" + global::System.Uri.EscapeDataString(timespan))
                        + "&"
                        + (string.IsNullOrEmpty(interval) ? global::System.String.Empty : "interval=" + global::System.Uri.EscapeDataString(interval))
                        + "&"
                        + (string.IsNullOrEmpty(metricnames) ? global::System.String.Empty : "metricnames=" + global::System.Uri.EscapeDataString(metricnames))
                        + "&"
                        + (string.IsNullOrEmpty(aggregation) ? global::System.String.Empty : "aggregation=" + global::System.Uri.EscapeDataString(aggregation))
                        + "&"
                        + (null == top ? global::System.String.Empty : "top=" + global::System.Uri.EscapeDataString(top.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(orderby) ? global::System.String.Empty : "orderby=" + global::System.Uri.EscapeDataString(orderby))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (string.IsNullOrEmpty(resultType) ? global::System.String.Empty : "resultType=" + global::System.Uri.EscapeDataString(resultType))
                        + "&"
                        + (string.IsNullOrEmpty(metricnamespace) ? global::System.String.Empty : "metricnamespace=" + global::System.Uri.EscapeDataString(metricnamespace))
                        + "&"
                        + (null == autoAdjustTimegrain ? global::System.String.Empty : "AutoAdjustTimegrain=" + global::System.Uri.EscapeDataString(autoAdjustTimegrain.ToString()))
                        + "&"
                        + (null == validateDimensions ? global::System.String.Empty : "ValidateDimensions=" + global::System.Uri.EscapeDataString(validateDimensions.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(rollupby) ? global::System.String.Empty : "rollupby=" + global::System.Uri.EscapeDataString(rollupby))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MetricsListAtSubscriptionScope_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>**Lists the metric data for a subscription**.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="region">The region where the metrics you want reside.</param>
        /// <param name="timespan">The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'.</param>
        /// <param name="interval">The interval (i.e. timegrain) of the query in ISO 8601 duration format. Defaults to PT1M. Special
        /// case for 'FULL' value that returns single datapoint for entire time span requested.
        /// *Examples: PT15M, PT1H, P1D, FULL*</param>
        /// <param name="metricnames">The names of the metrics (comma separated) to retrieve.</param>
        /// <param name="aggregation">The list of aggregation types (comma separated) to retrieve.
        /// *Examples: average, minimum, maximum*</param>
        /// <param name="top">The maximum number of records to retrieve per resource ID in the request.
        /// Valid only if filter is specified.
        /// Defaults to 10.</param>
        /// <param name="orderby">The aggregation to use for sorting results and the direction of the sort.
        /// Only one order can be specified.
        /// *Examples: sum asc*</param>
        /// <param name="Filter">The **$filter** is used to reduce the set of metric data returned.<br>Example:<br>Metric contains
        /// metadata A, B and C.<br>- Return all time series of C where A = a1 and B = b1 or b2<br>**$filter=A eq ‘a1’ and B eq ‘b1’
        /// or B eq ‘b2’ and C eq ‘*’**<br>- Invalid variant:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘*’ or B = ‘b2’**<br>This
        /// is invalid because the logical or operator cannot separate two different metadata names.<br>- Return all time series where
        /// A = a1, B = b1 and C = c1:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘c1’**<br>- Return all time series where A =
        /// a1<br>**$filter=A eq ‘a1’ and B eq ‘*’ and C eq ‘*’**.</param>
        /// <param name="resultType">Reduces the set of data collected. The syntax allowed depends on the operation. See the operation's
        /// description for details.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="autoAdjustTimegrain">When set to true, if the timespan passed in is not supported by this metric, the API
        /// will return the result using the closest supported timespan. When set to false, an error is returned for invalid timespan
        /// parameters. Defaults to false.</param>
        /// <param name="validateDimensions">When set to false, invalid filter parameter values will be ignored. When set to true,
        /// an error is returned for invalid filter parameters. Defaults to true.</param>
        /// <param name="rollupby">Dimension name(s) to rollup results by. For example if you only want to see metric values with
        /// a filter like 'City eq Seattle or City eq Tacoma' but don't want to see separate values for each city, you can specify
        /// 'RollUpBy=City' to see the results for Seattle and Tacoma rolled up into one timeseries.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse> MetricsListAtSubscriptionScopeViaIdentityWithResult(global::System.String viaIdentity, string region, string timespan, string interval, string metricnames, string aggregation, int? top, string orderby, string Filter, string resultType, string metricnamespace, bool? autoAdjustTimegrain, bool? validateDimensions, string rollupby, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/providers/Microsoft.Insights/metrics$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/subscriptions/{subscriptionId}/providers/Microsoft.Insights/metrics'");
                }

                // replace URI parameters with values from identity
                var subscriptionId = _match.Groups["subscriptionId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + subscriptionId
                        + "/providers/Microsoft.Insights/metrics"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + "region=" + global::System.Uri.EscapeDataString(region)
                        + "&"
                        + (string.IsNullOrEmpty(timespan) ? global::System.String.Empty : "timespan=" + global::System.Uri.EscapeDataString(timespan))
                        + "&"
                        + (string.IsNullOrEmpty(interval) ? global::System.String.Empty : "interval=" + global::System.Uri.EscapeDataString(interval))
                        + "&"
                        + (string.IsNullOrEmpty(metricnames) ? global::System.String.Empty : "metricnames=" + global::System.Uri.EscapeDataString(metricnames))
                        + "&"
                        + (string.IsNullOrEmpty(aggregation) ? global::System.String.Empty : "aggregation=" + global::System.Uri.EscapeDataString(aggregation))
                        + "&"
                        + (null == top ? global::System.String.Empty : "top=" + global::System.Uri.EscapeDataString(top.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(orderby) ? global::System.String.Empty : "orderby=" + global::System.Uri.EscapeDataString(orderby))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (string.IsNullOrEmpty(resultType) ? global::System.String.Empty : "resultType=" + global::System.Uri.EscapeDataString(resultType))
                        + "&"
                        + (string.IsNullOrEmpty(metricnamespace) ? global::System.String.Empty : "metricnamespace=" + global::System.Uri.EscapeDataString(metricnamespace))
                        + "&"
                        + (null == autoAdjustTimegrain ? global::System.String.Empty : "AutoAdjustTimegrain=" + global::System.Uri.EscapeDataString(autoAdjustTimegrain.ToString()))
                        + "&"
                        + (null == validateDimensions ? global::System.String.Empty : "ValidateDimensions=" + global::System.Uri.EscapeDataString(validateDimensions.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(rollupby) ? global::System.String.Empty : "rollupby=" + global::System.Uri.EscapeDataString(rollupby))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.MetricsListAtSubscriptionScopeWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>**Lists the metric data for a subscription**.</summary>
        /// <param name="subscriptionId">The ID of the target subscription.</param>
        /// <param name="region">The region where the metrics you want reside.</param>
        /// <param name="timespan">The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'.</param>
        /// <param name="interval">The interval (i.e. timegrain) of the query in ISO 8601 duration format. Defaults to PT1M. Special
        /// case for 'FULL' value that returns single datapoint for entire time span requested.
        /// *Examples: PT15M, PT1H, P1D, FULL*</param>
        /// <param name="metricnames">The names of the metrics (comma separated) to retrieve.</param>
        /// <param name="aggregation">The list of aggregation types (comma separated) to retrieve.
        /// *Examples: average, minimum, maximum*</param>
        /// <param name="top">The maximum number of records to retrieve per resource ID in the request.
        /// Valid only if filter is specified.
        /// Defaults to 10.</param>
        /// <param name="orderby">The aggregation to use for sorting results and the direction of the sort.
        /// Only one order can be specified.
        /// *Examples: sum asc*</param>
        /// <param name="Filter">The **$filter** is used to reduce the set of metric data returned.<br>Example:<br>Metric contains
        /// metadata A, B and C.<br>- Return all time series of C where A = a1 and B = b1 or b2<br>**$filter=A eq ‘a1’ and B eq ‘b1’
        /// or B eq ‘b2’ and C eq ‘*’**<br>- Invalid variant:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘*’ or B = ‘b2’**<br>This
        /// is invalid because the logical or operator cannot separate two different metadata names.<br>- Return all time series where
        /// A = a1, B = b1 and C = c1:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘c1’**<br>- Return all time series where A =
        /// a1<br>**$filter=A eq ‘a1’ and B eq ‘*’ and C eq ‘*’**.</param>
        /// <param name="resultType">Reduces the set of data collected. The syntax allowed depends on the operation. See the operation's
        /// description for details.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="autoAdjustTimegrain">When set to true, if the timespan passed in is not supported by this metric, the API
        /// will return the result using the closest supported timespan. When set to false, an error is returned for invalid timespan
        /// parameters. Defaults to false.</param>
        /// <param name="validateDimensions">When set to false, invalid filter parameter values will be ignored. When set to true,
        /// an error is returned for invalid filter parameters. Defaults to true.</param>
        /// <param name="rollupby">Dimension name(s) to rollup results by. For example if you only want to see metric values with
        /// a filter like 'City eq Seattle or City eq Tacoma' but don't want to see separate values for each city, you can specify
        /// 'RollUpBy=City' to see the results for Seattle and Tacoma rolled up into one timeseries.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse> MetricsListAtSubscriptionScopeWithResult(string subscriptionId, string region, string timespan, string interval, string metricnames, string aggregation, int? top, string orderby, string Filter, string resultType, string metricnamespace, bool? autoAdjustTimegrain, bool? validateDimensions, string rollupby, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/subscriptions/"
                        + global::System.Uri.EscapeDataString(subscriptionId)
                        + "/providers/Microsoft.Insights/metrics"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + "region=" + global::System.Uri.EscapeDataString(region)
                        + "&"
                        + (string.IsNullOrEmpty(timespan) ? global::System.String.Empty : "timespan=" + global::System.Uri.EscapeDataString(timespan))
                        + "&"
                        + (string.IsNullOrEmpty(interval) ? global::System.String.Empty : "interval=" + global::System.Uri.EscapeDataString(interval))
                        + "&"
                        + (string.IsNullOrEmpty(metricnames) ? global::System.String.Empty : "metricnames=" + global::System.Uri.EscapeDataString(metricnames))
                        + "&"
                        + (string.IsNullOrEmpty(aggregation) ? global::System.String.Empty : "aggregation=" + global::System.Uri.EscapeDataString(aggregation))
                        + "&"
                        + (null == top ? global::System.String.Empty : "top=" + global::System.Uri.EscapeDataString(top.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(orderby) ? global::System.String.Empty : "orderby=" + global::System.Uri.EscapeDataString(orderby))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (string.IsNullOrEmpty(resultType) ? global::System.String.Empty : "resultType=" + global::System.Uri.EscapeDataString(resultType))
                        + "&"
                        + (string.IsNullOrEmpty(metricnamespace) ? global::System.String.Empty : "metricnamespace=" + global::System.Uri.EscapeDataString(metricnamespace))
                        + "&"
                        + (null == autoAdjustTimegrain ? global::System.String.Empty : "AutoAdjustTimegrain=" + global::System.Uri.EscapeDataString(autoAdjustTimegrain.ToString()))
                        + "&"
                        + (null == validateDimensions ? global::System.String.Empty : "ValidateDimensions=" + global::System.Uri.EscapeDataString(validateDimensions.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(rollupby) ? global::System.String.Empty : "rollupby=" + global::System.Uri.EscapeDataString(rollupby))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.MetricsListAtSubscriptionScopeWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref= "MetricsListAtSubscriptionScopeWithResult" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse> MetricsListAtSubscriptionScopeWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.Response.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) );
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ErrorContract.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.Message;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorContract>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "MetricsListAtSubscriptionScope" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MetricsListAtSubscriptionScope_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorContract>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.Response.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ErrorContract.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MetricsListAtSubscriptionScope" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="subscriptionId">The ID of the target subscription.</param>
        /// <param name="region">The region where the metrics you want reside.</param>
        /// <param name="timespan">The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'.</param>
        /// <param name="interval">The interval (i.e. timegrain) of the query in ISO 8601 duration format. Defaults to PT1M. Special
        /// case for 'FULL' value that returns single datapoint for entire time span requested.
        /// *Examples: PT15M, PT1H, P1D, FULL*</param>
        /// <param name="metricnames">The names of the metrics (comma separated) to retrieve.</param>
        /// <param name="aggregation">The list of aggregation types (comma separated) to retrieve.
        /// *Examples: average, minimum, maximum*</param>
        /// <param name="top">The maximum number of records to retrieve per resource ID in the request.
        /// Valid only if filter is specified.
        /// Defaults to 10.</param>
        /// <param name="orderby">The aggregation to use for sorting results and the direction of the sort.
        /// Only one order can be specified.
        /// *Examples: sum asc*</param>
        /// <param name="Filter">The **$filter** is used to reduce the set of metric data returned.<br>Example:<br>Metric contains
        /// metadata A, B and C.<br>- Return all time series of C where A = a1 and B = b1 or b2<br>**$filter=A eq ‘a1’ and B eq ‘b1’
        /// or B eq ‘b2’ and C eq ‘*’**<br>- Invalid variant:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘*’ or B = ‘b2’**<br>This
        /// is invalid because the logical or operator cannot separate two different metadata names.<br>- Return all time series where
        /// A = a1, B = b1 and C = c1:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘c1’**<br>- Return all time series where A =
        /// a1<br>**$filter=A eq ‘a1’ and B eq ‘*’ and C eq ‘*’**.</param>
        /// <param name="resultType">Reduces the set of data collected. The syntax allowed depends on the operation. See the operation's
        /// description for details.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="autoAdjustTimegrain">When set to true, if the timespan passed in is not supported by this metric, the API
        /// will return the result using the closest supported timespan. When set to false, an error is returned for invalid timespan
        /// parameters. Defaults to false.</param>
        /// <param name="validateDimensions">When set to false, invalid filter parameter values will be ignored. When set to true,
        /// an error is returned for invalid filter parameters. Defaults to true.</param>
        /// <param name="rollupby">Dimension name(s) to rollup results by. For example if you only want to see metric values with
        /// a filter like 'City eq Seattle or City eq Tacoma' but don't want to see separate values for each city, you can specify
        /// 'RollUpBy=City' to see the results for Seattle and Tacoma rolled up into one timeseries.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MetricsListAtSubscriptionScope_Validate(string subscriptionId, string region, string timespan, string interval, string metricnames, string aggregation, int? top, string orderby, string Filter, string resultType, string metricnamespace, bool? autoAdjustTimegrain, bool? validateDimensions, string rollupby, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(subscriptionId),subscriptionId);
                await eventListener.AssertMinimumLength(nameof(subscriptionId),subscriptionId,1);
                await eventListener.AssertNotNull(nameof(region),region);
                await eventListener.AssertNotNull(nameof(timespan),timespan);
                await eventListener.AssertNotNull(nameof(interval),interval);
                await eventListener.AssertNotNull(nameof(metricnames),metricnames);
                await eventListener.AssertNotNull(nameof(aggregation),aggregation);
                await eventListener.AssertNotNull(nameof(orderby),orderby);
                await eventListener.AssertNotNull(nameof(Filter),Filter);
                await eventListener.AssertNotNull(nameof(resultType),resultType);
                await eventListener.AssertNotNull(nameof(metricnamespace),metricnamespace);
                await eventListener.AssertNotNull(nameof(rollupby),rollupby);
            }
        }

        /// <summary>**Lists the metric values for a resource**.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="timespan">The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'.</param>
        /// <param name="interval">The interval (i.e. timegrain) of the query in ISO 8601 duration format. Defaults to PT1M. Special
        /// case for 'FULL' value that returns single datapoint for entire time span requested.
        /// *Examples: PT15M, PT1H, P1D, FULL*</param>
        /// <param name="metricnames">The names of the metrics (comma separated) to retrieve.</param>
        /// <param name="aggregation">The list of aggregation types (comma separated) to retrieve.
        /// *Examples: average, minimum, maximum*</param>
        /// <param name="top">The maximum number of records to retrieve per resource ID in the request.
        /// Valid only if filter is specified.
        /// Defaults to 10.</param>
        /// <param name="orderby">The aggregation to use for sorting results and the direction of the sort.
        /// Only one order can be specified.
        /// *Examples: sum asc*</param>
        /// <param name="Filter">The **$filter** is used to reduce the set of metric data returned.<br>Example:<br>Metric contains
        /// metadata A, B and C.<br>- Return all time series of C where A = a1 and B = b1 or b2<br>**$filter=A eq ‘a1’ and B eq ‘b1’
        /// or B eq ‘b2’ and C eq ‘*’**<br>- Invalid variant:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘*’ or B = ‘b2’**<br>This
        /// is invalid because the logical or operator cannot separate two different metadata names.<br>- Return all time series where
        /// A = a1, B = b1 and C = c1:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘c1’**<br>- Return all time series where A =
        /// a1<br>**$filter=A eq ‘a1’ and B eq ‘*’ and C eq ‘*’**.</param>
        /// <param name="resultType">Reduces the set of data collected. The syntax allowed depends on the operation. See the operation's
        /// description for details.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="autoAdjustTimegrain">When set to true, if the timespan passed in is not supported by this metric, the API
        /// will return the result using the closest supported timespan. When set to false, an error is returned for invalid timespan
        /// parameters. Defaults to false.</param>
        /// <param name="validateDimensions">When set to false, invalid filter parameter values will be ignored. When set to true,
        /// an error is returned for invalid filter parameters. Defaults to true.</param>
        /// <param name="rollupby">Dimension name(s) to rollup results by. For example if you only want to see metric values with
        /// a filter like 'City eq Seattle or City eq Tacoma' but don't want to see separate values for each city, you can specify
        /// 'RollUpBy=City' to see the results for Seattle and Tacoma rolled up into one timeseries.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task MetricsListViaIdentity(global::System.String viaIdentity, string timespan, string interval, string metricnames, string aggregation, int? top, string orderby, string Filter, string resultType, string metricnamespace, bool? autoAdjustTimegrain, bool? validateDimensions, string rollupby, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/(?<resourceUri>[^/]+)/providers/Microsoft.Insights/metrics$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/{resourceUri}/providers/Microsoft.Insights/metrics'");
                }

                // replace URI parameters with values from identity
                var resourceUri = _match.Groups["resourceUri"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/"
                        + resourceUri
                        + "/providers/Microsoft.Insights/metrics"
                        + "?"
                        + (string.IsNullOrEmpty(timespan) ? global::System.String.Empty : "timespan=" + global::System.Uri.EscapeDataString(timespan))
                        + "&"
                        + (string.IsNullOrEmpty(interval) ? global::System.String.Empty : "interval=" + global::System.Uri.EscapeDataString(interval))
                        + "&"
                        + (string.IsNullOrEmpty(metricnames) ? global::System.String.Empty : "metricnames=" + global::System.Uri.EscapeDataString(metricnames))
                        + "&"
                        + (string.IsNullOrEmpty(aggregation) ? global::System.String.Empty : "aggregation=" + global::System.Uri.EscapeDataString(aggregation))
                        + "&"
                        + (null == top ? global::System.String.Empty : "top=" + global::System.Uri.EscapeDataString(top.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(orderby) ? global::System.String.Empty : "orderby=" + global::System.Uri.EscapeDataString(orderby))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (string.IsNullOrEmpty(resultType) ? global::System.String.Empty : "resultType=" + global::System.Uri.EscapeDataString(resultType))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (string.IsNullOrEmpty(metricnamespace) ? global::System.String.Empty : "metricnamespace=" + global::System.Uri.EscapeDataString(metricnamespace))
                        + "&"
                        + (null == autoAdjustTimegrain ? global::System.String.Empty : "AutoAdjustTimegrain=" + global::System.Uri.EscapeDataString(autoAdjustTimegrain.ToString()))
                        + "&"
                        + (null == validateDimensions ? global::System.String.Empty : "ValidateDimensions=" + global::System.Uri.EscapeDataString(validateDimensions.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(rollupby) ? global::System.String.Empty : "rollupby=" + global::System.Uri.EscapeDataString(rollupby))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.MetricsList_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>**Lists the metric values for a resource**.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="timespan">The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'.</param>
        /// <param name="interval">The interval (i.e. timegrain) of the query in ISO 8601 duration format. Defaults to PT1M. Special
        /// case for 'FULL' value that returns single datapoint for entire time span requested.
        /// *Examples: PT15M, PT1H, P1D, FULL*</param>
        /// <param name="metricnames">The names of the metrics (comma separated) to retrieve.</param>
        /// <param name="aggregation">The list of aggregation types (comma separated) to retrieve.
        /// *Examples: average, minimum, maximum*</param>
        /// <param name="top">The maximum number of records to retrieve per resource ID in the request.
        /// Valid only if filter is specified.
        /// Defaults to 10.</param>
        /// <param name="orderby">The aggregation to use for sorting results and the direction of the sort.
        /// Only one order can be specified.
        /// *Examples: sum asc*</param>
        /// <param name="Filter">The **$filter** is used to reduce the set of metric data returned.<br>Example:<br>Metric contains
        /// metadata A, B and C.<br>- Return all time series of C where A = a1 and B = b1 or b2<br>**$filter=A eq ‘a1’ and B eq ‘b1’
        /// or B eq ‘b2’ and C eq ‘*’**<br>- Invalid variant:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘*’ or B = ‘b2’**<br>This
        /// is invalid because the logical or operator cannot separate two different metadata names.<br>- Return all time series where
        /// A = a1, B = b1 and C = c1:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘c1’**<br>- Return all time series where A =
        /// a1<br>**$filter=A eq ‘a1’ and B eq ‘*’ and C eq ‘*’**.</param>
        /// <param name="resultType">Reduces the set of data collected. The syntax allowed depends on the operation. See the operation's
        /// description for details.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="autoAdjustTimegrain">When set to true, if the timespan passed in is not supported by this metric, the API
        /// will return the result using the closest supported timespan. When set to false, an error is returned for invalid timespan
        /// parameters. Defaults to false.</param>
        /// <param name="validateDimensions">When set to false, invalid filter parameter values will be ignored. When set to true,
        /// an error is returned for invalid filter parameters. Defaults to true.</param>
        /// <param name="rollupby">Dimension name(s) to rollup results by. For example if you only want to see metric values with
        /// a filter like 'City eq Seattle or City eq Tacoma' but don't want to see separate values for each city, you can specify
        /// 'RollUpBy=City' to see the results for Seattle and Tacoma rolled up into one timeseries.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse> MetricsListViaIdentityWithResult(global::System.String viaIdentity, string timespan, string interval, string metricnames, string aggregation, int? top, string orderby, string Filter, string resultType, string metricnamespace, bool? autoAdjustTimegrain, bool? validateDimensions, string rollupby, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/(?<resourceUri>[^/]+)/providers/Microsoft.Insights/metrics$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/{resourceUri}/providers/Microsoft.Insights/metrics'");
                }

                // replace URI parameters with values from identity
                var resourceUri = _match.Groups["resourceUri"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/"
                        + resourceUri
                        + "/providers/Microsoft.Insights/metrics"
                        + "?"
                        + (string.IsNullOrEmpty(timespan) ? global::System.String.Empty : "timespan=" + global::System.Uri.EscapeDataString(timespan))
                        + "&"
                        + (string.IsNullOrEmpty(interval) ? global::System.String.Empty : "interval=" + global::System.Uri.EscapeDataString(interval))
                        + "&"
                        + (string.IsNullOrEmpty(metricnames) ? global::System.String.Empty : "metricnames=" + global::System.Uri.EscapeDataString(metricnames))
                        + "&"
                        + (string.IsNullOrEmpty(aggregation) ? global::System.String.Empty : "aggregation=" + global::System.Uri.EscapeDataString(aggregation))
                        + "&"
                        + (null == top ? global::System.String.Empty : "top=" + global::System.Uri.EscapeDataString(top.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(orderby) ? global::System.String.Empty : "orderby=" + global::System.Uri.EscapeDataString(orderby))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (string.IsNullOrEmpty(resultType) ? global::System.String.Empty : "resultType=" + global::System.Uri.EscapeDataString(resultType))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (string.IsNullOrEmpty(metricnamespace) ? global::System.String.Empty : "metricnamespace=" + global::System.Uri.EscapeDataString(metricnamespace))
                        + "&"
                        + (null == autoAdjustTimegrain ? global::System.String.Empty : "AutoAdjustTimegrain=" + global::System.Uri.EscapeDataString(autoAdjustTimegrain.ToString()))
                        + "&"
                        + (null == validateDimensions ? global::System.String.Empty : "ValidateDimensions=" + global::System.Uri.EscapeDataString(validateDimensions.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(rollupby) ? global::System.String.Empty : "rollupby=" + global::System.Uri.EscapeDataString(rollupby))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.MetricsListWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>**Lists the metric values for a resource**.</summary>
        /// <param name="resourceUri">The identifier of the resource.</param>
        /// <param name="timespan">The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'.</param>
        /// <param name="interval">The interval (i.e. timegrain) of the query in ISO 8601 duration format. Defaults to PT1M. Special
        /// case for 'FULL' value that returns single datapoint for entire time span requested.
        /// *Examples: PT15M, PT1H, P1D, FULL*</param>
        /// <param name="metricnames">The names of the metrics (comma separated) to retrieve.</param>
        /// <param name="aggregation">The list of aggregation types (comma separated) to retrieve.
        /// *Examples: average, minimum, maximum*</param>
        /// <param name="top">The maximum number of records to retrieve per resource ID in the request.
        /// Valid only if filter is specified.
        /// Defaults to 10.</param>
        /// <param name="orderby">The aggregation to use for sorting results and the direction of the sort.
        /// Only one order can be specified.
        /// *Examples: sum asc*</param>
        /// <param name="Filter">The **$filter** is used to reduce the set of metric data returned.<br>Example:<br>Metric contains
        /// metadata A, B and C.<br>- Return all time series of C where A = a1 and B = b1 or b2<br>**$filter=A eq ‘a1’ and B eq ‘b1’
        /// or B eq ‘b2’ and C eq ‘*’**<br>- Invalid variant:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘*’ or B = ‘b2’**<br>This
        /// is invalid because the logical or operator cannot separate two different metadata names.<br>- Return all time series where
        /// A = a1, B = b1 and C = c1:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘c1’**<br>- Return all time series where A =
        /// a1<br>**$filter=A eq ‘a1’ and B eq ‘*’ and C eq ‘*’**.</param>
        /// <param name="resultType">Reduces the set of data collected. The syntax allowed depends on the operation. See the operation's
        /// description for details.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="autoAdjustTimegrain">When set to true, if the timespan passed in is not supported by this metric, the API
        /// will return the result using the closest supported timespan. When set to false, an error is returned for invalid timespan
        /// parameters. Defaults to false.</param>
        /// <param name="validateDimensions">When set to false, invalid filter parameter values will be ignored. When set to true,
        /// an error is returned for invalid filter parameters. Defaults to true.</param>
        /// <param name="rollupby">Dimension name(s) to rollup results by. For example if you only want to see metric values with
        /// a filter like 'City eq Seattle or City eq Tacoma' but don't want to see separate values for each city, you can specify
        /// 'RollUpBy=City' to see the results for Seattle and Tacoma rolled up into one timeseries.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse> MetricsListWithResult(string resourceUri, string timespan, string interval, string metricnames, string aggregation, int? top, string orderby, string Filter, string resultType, string metricnamespace, bool? autoAdjustTimegrain, bool? validateDimensions, string rollupby, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2023-10-01";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/"
                        + (resourceUri)
                        + "/providers/Microsoft.Insights/metrics"
                        + "?"
                        + (string.IsNullOrEmpty(timespan) ? global::System.String.Empty : "timespan=" + global::System.Uri.EscapeDataString(timespan))
                        + "&"
                        + (string.IsNullOrEmpty(interval) ? global::System.String.Empty : "interval=" + global::System.Uri.EscapeDataString(interval))
                        + "&"
                        + (string.IsNullOrEmpty(metricnames) ? global::System.String.Empty : "metricnames=" + global::System.Uri.EscapeDataString(metricnames))
                        + "&"
                        + (string.IsNullOrEmpty(aggregation) ? global::System.String.Empty : "aggregation=" + global::System.Uri.EscapeDataString(aggregation))
                        + "&"
                        + (null == top ? global::System.String.Empty : "top=" + global::System.Uri.EscapeDataString(top.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(orderby) ? global::System.String.Empty : "orderby=" + global::System.Uri.EscapeDataString(orderby))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (string.IsNullOrEmpty(resultType) ? global::System.String.Empty : "resultType=" + global::System.Uri.EscapeDataString(resultType))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (string.IsNullOrEmpty(metricnamespace) ? global::System.String.Empty : "metricnamespace=" + global::System.Uri.EscapeDataString(metricnamespace))
                        + "&"
                        + (null == autoAdjustTimegrain ? global::System.String.Empty : "AutoAdjustTimegrain=" + global::System.Uri.EscapeDataString(autoAdjustTimegrain.ToString()))
                        + "&"
                        + (null == validateDimensions ? global::System.String.Empty : "ValidateDimensions=" + global::System.Uri.EscapeDataString(validateDimensions.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(rollupby) ? global::System.String.Empty : "rollupby=" + global::System.Uri.EscapeDataString(rollupby))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"https://management.azure.com{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.MetricsListWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "MetricsListWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse> MetricsListWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.Response.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) );
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.Message;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorResponse>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "MetricsList" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MetricsList_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IResponse>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.IErrorResponse>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.Response.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Metric.Models.ErrorResponse.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="MetricsList" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="resourceUri">The identifier of the resource.</param>
        /// <param name="timespan">The timespan of the query. It is a string with the following format 'startDateTime_ISO/endDateTime_ISO'.</param>
        /// <param name="interval">The interval (i.e. timegrain) of the query in ISO 8601 duration format. Defaults to PT1M. Special
        /// case for 'FULL' value that returns single datapoint for entire time span requested.
        /// *Examples: PT15M, PT1H, P1D, FULL*</param>
        /// <param name="metricnames">The names of the metrics (comma separated) to retrieve.</param>
        /// <param name="aggregation">The list of aggregation types (comma separated) to retrieve.
        /// *Examples: average, minimum, maximum*</param>
        /// <param name="top">The maximum number of records to retrieve per resource ID in the request.
        /// Valid only if filter is specified.
        /// Defaults to 10.</param>
        /// <param name="orderby">The aggregation to use for sorting results and the direction of the sort.
        /// Only one order can be specified.
        /// *Examples: sum asc*</param>
        /// <param name="Filter">The **$filter** is used to reduce the set of metric data returned.<br>Example:<br>Metric contains
        /// metadata A, B and C.<br>- Return all time series of C where A = a1 and B = b1 or b2<br>**$filter=A eq ‘a1’ and B eq ‘b1’
        /// or B eq ‘b2’ and C eq ‘*’**<br>- Invalid variant:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘*’ or B = ‘b2’**<br>This
        /// is invalid because the logical or operator cannot separate two different metadata names.<br>- Return all time series where
        /// A = a1, B = b1 and C = c1:<br>**$filter=A eq ‘a1’ and B eq ‘b1’ and C eq ‘c1’**<br>- Return all time series where A =
        /// a1<br>**$filter=A eq ‘a1’ and B eq ‘*’ and C eq ‘*’**.</param>
        /// <param name="resultType">Reduces the set of data collected. The syntax allowed depends on the operation. See the operation's
        /// description for details.</param>
        /// <param name="metricnamespace">Metric namespace where the metrics you want reside.</param>
        /// <param name="autoAdjustTimegrain">When set to true, if the timespan passed in is not supported by this metric, the API
        /// will return the result using the closest supported timespan. When set to false, an error is returned for invalid timespan
        /// parameters. Defaults to false.</param>
        /// <param name="validateDimensions">When set to false, invalid filter parameter values will be ignored. When set to true,
        /// an error is returned for invalid filter parameters. Defaults to true.</param>
        /// <param name="rollupby">Dimension name(s) to rollup results by. For example if you only want to see metric values with
        /// a filter like 'City eq Seattle or City eq Tacoma' but don't want to see separate values for each city, you can specify
        /// 'RollUpBy=City' to see the results for Seattle and Tacoma rolled up into one timeseries.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task MetricsList_Validate(string resourceUri, string timespan, string interval, string metricnames, string aggregation, int? top, string orderby, string Filter, string resultType, string metricnamespace, bool? autoAdjustTimegrain, bool? validateDimensions, string rollupby, Microsoft.Azure.PowerShell.Cmdlets.Metric.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(resourceUri),resourceUri);
                await eventListener.AssertNotNull(nameof(timespan),timespan);
                await eventListener.AssertNotNull(nameof(interval),interval);
                await eventListener.AssertNotNull(nameof(metricnames),metricnames);
                await eventListener.AssertNotNull(nameof(aggregation),aggregation);
                await eventListener.AssertNotNull(nameof(orderby),orderby);
                await eventListener.AssertNotNull(nameof(Filter),Filter);
                await eventListener.AssertNotNull(nameof(resultType),resultType);
                await eventListener.AssertNotNull(nameof(metricnamespace),metricnamespace);
                await eventListener.AssertNotNull(nameof(rollupby),rollupby);
            }
        }
    }
}