// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Extensions;

    /// <summary>Managed cluster.</summary>
    public partial class ManagedCluster :
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedCluster,
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal,
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.IValidates
    {
        /// <summary>
        /// Backing field for Inherited model <see cref= "Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.ITrackedResource" />
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.ITrackedResource __trackedResource = new Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.TrackedResource();

        /// <summary>The list of AAD group object IDs that will have admin role of the cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string[] AadProfileAdminGroupObjectID { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AadProfileAdminGroupObjectID; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AadProfileAdminGroupObjectID = value ?? null /* arrayOf */; }

        /// <summary>
        /// (DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AadProfileClientAppId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AadProfileClientAppId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AadProfileClientAppId = value ?? null; }

        /// <summary>Whether to enable Azure RBAC for Kubernetes authorization.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? AadProfileEnableAzureRbac { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AadProfileEnableAzureRbac; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AadProfileEnableAzureRbac = value ?? default(bool); }

        /// <summary>Whether to enable managed AAD.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? AadProfileManaged { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AadProfileManaged; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AadProfileManaged = value ?? default(bool); }

        /// <summary>
        /// (DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AadProfileServerAppId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AadProfileServerAppId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AadProfileServerAppId = value ?? null; }

        /// <summary>
        /// (DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AadProfileServerAppSecret { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AadProfileServerAppSecret; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AadProfileServerAppSecret = value ?? null; }

        /// <summary>
        /// The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AadProfileTenantId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AadProfileTenantId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AadProfileTenantId = value ?? null; }

        /// <summary>The profile of managed cluster add-on.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesAddonProfiles AddonProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AddonProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AddonProfile = value ?? null /* model class */; }

        /// <summary>The agent pool properties.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterAgentPoolProfile[] AgentPoolProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AgentPoolProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AgentPoolProfile = value ?? null /* arrayOf */; }

        /// <summary>
        /// IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use
        /// Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see [API server authorized
        /// IP ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string[] ApiServerAccessProfileAuthorizedIPRange { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ApiServerAccessProfileAuthorizedIPRange; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ApiServerAccessProfileAuthorizedIPRange = value ?? null /* arrayOf */; }

        /// <summary>Whether to disable run command for the cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? ApiServerAccessProfileDisableRunCommand { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ApiServerAccessProfileDisableRunCommand; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ApiServerAccessProfileDisableRunCommand = value ?? default(bool); }

        /// <summary>
        /// For more details, see [Creating a private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? ApiServerAccessProfileEnablePrivateCluster { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ApiServerAccessProfileEnablePrivateCluster; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ApiServerAccessProfileEnablePrivateCluster = value ?? default(bool); }

        /// <summary>Whether to create additional public FQDN for private cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? ApiServerAccessProfileEnablePrivateClusterPublicFqdn { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ApiServerAccessProfileEnablePrivateClusterPublicFqdn; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ApiServerAccessProfileEnablePrivateClusterPublicFqdn = value ?? default(bool); }

        /// <summary>
        /// The default is System. For more details see [configure private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone).
        /// Allowed values are 'system' and 'none'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string ApiServerAccessProfilePrivateDnsZone { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ApiServerAccessProfilePrivateDnsZone; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ApiServerAccessProfilePrivateDnsZone = value ?? null; }

        /// <summary>Valid values are 'true' and 'false'</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AutoScalerProfileBalanceSimilarNodeGroup { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileBalanceSimilarNodeGroup; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileBalanceSimilarNodeGroup = value ?? null; }

        /// <summary>
        /// If not specified, the default is 'random'. See [expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders)
        /// for more information.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.Expander? AutoScalerProfileExpander { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileExpander; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileExpander = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.Expander)""); }

        /// <summary>The default is 10.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AutoScalerProfileMaxEmptyBulkDelete { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileMaxEmptyBulkDelete; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileMaxEmptyBulkDelete = value ?? null; }

        /// <summary>The default is 600.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AutoScalerProfileMaxGracefulTerminationSec { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileMaxGracefulTerminationSec; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileMaxGracefulTerminationSec = value ?? null; }

        /// <summary>
        /// The default is '15m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AutoScalerProfileMaxNodeProvisionTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileMaxNodeProvisionTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileMaxNodeProvisionTime = value ?? null; }

        /// <summary>The default is 45. The maximum is 100 and the minimum is 0.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AutoScalerProfileMaxTotalUnreadyPercentage { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileMaxTotalUnreadyPercentage; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileMaxTotalUnreadyPercentage = value ?? null; }

        /// <summary>
        /// For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all
        /// the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is '0s'. Values must be
        /// an integer followed by a unit ('s' for seconds, 'm' for minutes, 'h' for hours, etc).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AutoScalerProfileNewPodScaleUpDelay { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileNewPodScaleUpDelay; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileNewPodScaleUpDelay = value ?? null; }

        /// <summary>This must be an integer. The default is 3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AutoScalerProfileOkTotalUnreadyCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileOkTotalUnreadyCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileOkTotalUnreadyCount = value ?? null; }

        /// <summary>
        /// The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AutoScalerProfileScaleDownDelayAfterAdd { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileScaleDownDelayAfterAdd; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileScaleDownDelayAfterAdd = value ?? null; }

        /// <summary>
        /// The default is the scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m)
        /// is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AutoScalerProfileScaleDownDelayAfterDelete { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileScaleDownDelayAfterDelete; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileScaleDownDelayAfterDelete = value ?? null; }

        /// <summary>
        /// The default is '3m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AutoScalerProfileScaleDownDelayAfterFailure { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileScaleDownDelayAfterFailure; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileScaleDownDelayAfterFailure = value ?? null; }

        /// <summary>
        /// The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AutoScalerProfileScaleDownUnneededTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileScaleDownUnneededTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileScaleDownUnneededTime = value ?? null; }

        /// <summary>
        /// The default is '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AutoScalerProfileScaleDownUnreadyTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileScaleDownUnreadyTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileScaleDownUnreadyTime = value ?? null; }

        /// <summary>The default is '0.5'.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AutoScalerProfileScaleDownUtilizationThreshold { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileScaleDownUtilizationThreshold; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileScaleDownUtilizationThreshold = value ?? null; }

        /// <summary>The default is '10'. Values must be an integer number of seconds.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AutoScalerProfileScanInterval { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileScanInterval; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileScanInterval = value ?? null; }

        /// <summary>The default is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AutoScalerProfileSkipNodesWithLocalStorage { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileSkipNodesWithLocalStorage; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileSkipNodesWithLocalStorage = value ?? null; }

        /// <summary>The default is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AutoScalerProfileSkipNodesWithSystemPod { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileSkipNodesWithSystemPod; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfileSkipNodesWithSystemPod = value ?? null; }

        /// <summary>
        /// For more information see [setting the AKS cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.UpgradeChannel? AutoUpgradeProfileUpgradeChannel { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoUpgradeProfileUpgradeChannel; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoUpgradeProfileUpgradeChannel = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.UpgradeChannel)""); }

        /// <summary>Whether to enable Azure Key Vault key management service. The default is false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? AzureKeyVaultKmEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AzureKeyVaultKmEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AzureKeyVaultKmEnabled = value ?? default(bool); }

        /// <summary>
        /// Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name)
        /// for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key
        /// identifier. When Azure Key Vault key management service is disabled, leave the field empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AzureKeyVaultKmKeyId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AzureKeyVaultKmKeyId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AzureKeyVaultKmKeyId = value ?? null; }

        /// <summary>
        /// Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public
        /// access from all networks. `Private` means the key vault disables public access and enables private link. The default value
        /// is `Public`.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.KeyVaultNetworkAccessTypes? AzureKeyVaultKmKeyVaultNetworkAccess { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AzureKeyVaultKmKeyVaultNetworkAccess; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AzureKeyVaultKmKeyVaultNetworkAccess = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.KeyVaultNetworkAccessTypes)""); }

        /// <summary>
        /// Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource
        /// ID. When keyVaultNetworkAccess is `Public`, leave the field empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AzureKeyVaultKmKeyVaultResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AzureKeyVaultKmKeyVaultResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AzureKeyVaultKmKeyVaultResourceId = value ?? null; }

        /// <summary>
        /// The Azure Portal requires certain Cross-Origin Resource Sharing (CORS) headers to be sent in some responses, which Kubernetes
        /// APIServer doesn't handle by default. This special FQDN supports CORS, allowing the Azure Portal to function properly.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string AzurePortalFqdn { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AzurePortalFqdn; }

        /// <summary>Whether to enable AzureBlob CSI Driver. The default value is false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? BlobCsiDriverEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).BlobCsiDriverEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).BlobCsiDriverEnabled = value ?? default(bool); }

        /// <summary>
        /// If kubernetesVersion was a fully specified version <major.minor.patch>, this field will be exactly equal to it. If kubernetesVersion
        /// was <major.minor>, this field will contain the full <major.minor.patch> version being used.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string CurrentKubernetesVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).CurrentKubernetesVersion; }

        /// <summary>
        /// Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled,
        /// this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field
        /// empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string DefenderLogAnalyticsWorkspaceResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).DefenderLogAnalyticsWorkspaceResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).DefenderLogAnalyticsWorkspaceResourceId = value ?? null; }

        /// <summary>
        /// If set to true, getting static credentials will be disabled for this cluster. This must only be used on Managed Clusters
        /// that are AAD enabled. For more details see [disable local accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? DisableLocalAccount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).DisableLocalAccount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).DisableLocalAccount = value ?? default(bool); }

        /// <summary>Whether to enable AzureDisk CSI Driver. The default value is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? DiskCsiDriverEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).DiskCsiDriverEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).DiskCsiDriverEnabled = value ?? default(bool); }

        /// <summary>
        /// This is of the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string DiskEncryptionSetId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).DiskEncryptionSetId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).DiskEncryptionSetId = value ?? null; }

        /// <summary>This cannot be updated once the Managed Cluster has been created.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string DnsPrefix { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).DnsPrefix; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).DnsPrefix = value ?? null; }

        /// <summary>
        /// (DEPRECATED) Whether to enable Kubernetes pod security policy (preview). PodSecurityPolicy was deprecated in Kubernetes
        /// v1.21, and removed from Kubernetes in v1.25. Learn more at https://aka.ms/k8s/psp and https://aka.ms/aks/psp.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? EnablePodSecurityPolicy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).EnablePodSecurityPolicy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).EnablePodSecurityPolicy = value ?? default(bool); }

        /// <summary>Whether to enable Kubernetes Role-Based Access Control.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? EnableRbac { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).EnableRbac; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).EnableRbac = value ?? default(bool); }

        /// <summary>Backing field for <see cref="ExtendedLocation" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IExtendedLocation _extendedLocation;

        /// <summary>The extended location of the Virtual Machine.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IExtendedLocation ExtendedLocation { get => (this._extendedLocation = this._extendedLocation ?? new Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.ExtendedLocation()); set => this._extendedLocation = value; }

        /// <summary>The name of the extended location.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string ExtendedLocationName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IExtendedLocationInternal)ExtendedLocation).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IExtendedLocationInternal)ExtendedLocation).Name = value ?? null; }

        /// <summary>The type of the extended location.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ExtendedLocationTypes? ExtendedLocationType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IExtendedLocationInternal)ExtendedLocation).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IExtendedLocationInternal)ExtendedLocation).Type = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ExtendedLocationTypes)""); }

        /// <summary>Whether to enable AzureFile CSI Driver. The default value is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? FileCsiDriverEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).FileCsiDriverEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).FileCsiDriverEnabled = value ?? default(bool); }

        /// <summary>The FQDN of the master pool.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string Fqdn { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).Fqdn; }

        /// <summary>This cannot be updated once the Managed Cluster has been created.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string FqdnSubdomain { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).FqdnSubdomain; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).FqdnSubdomain = value ?? null; }

        /// <summary>
        /// Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet
        /// which is used to create the managed cluster.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string GmsaProfileDnsServer { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).GmsaProfileDnsServer; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).GmsaProfileDnsServer = value ?? null; }

        /// <summary>Specifies whether to enable Windows gMSA in the managed cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? GmsaProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).GmsaProfileEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).GmsaProfileEnabled = value ?? default(bool); }

        /// <summary>
        /// Specifies the root domain name for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the
        /// vnet which is used to create the managed cluster.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string GmsaProfileRootDomainName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).GmsaProfileRootDomainName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).GmsaProfileRootDomainName = value ?? null; }

        /// <summary>The HTTP proxy server endpoint to use.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string HttpProxyConfigHttpProxy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).HttpProxyConfigHttpProxy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).HttpProxyConfigHttpProxy = value ?? null; }

        /// <summary>The HTTPS proxy server endpoint to use.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string HttpProxyConfigHttpsProxy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).HttpProxyConfigHttpsProxy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).HttpProxyConfigHttpsProxy = value ?? null; }

        /// <summary>The endpoints that should not go through proxy.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string[] HttpProxyConfigNoProxy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).HttpProxyConfigNoProxy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).HttpProxyConfigNoProxy = value ?? null /* arrayOf */; }

        /// <summary>Alternative CA cert to use for connecting to proxy servers.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string HttpProxyConfigTrustedCa { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).HttpProxyConfigTrustedCa; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).HttpProxyConfigTrustedCa = value ?? null; }

        /// <summary>
        /// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inherited)]
        public string Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).Id; }

        /// <summary>Backing field for <see cref="Identity" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentity _identity;

        /// <summary>The identity of the managed cluster, if configured.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentity Identity { get => (this._identity = this._identity ?? new Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.ManagedClusterIdentity()); set => this._identity = value; }

        /// <summary>
        /// The principal id of the system assigned identity which is used by master components.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string IdentityPrincipalId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentityInternal)Identity).PrincipalId; }

        /// <summary>Identities associated with the cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesIdentityProfile IdentityProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).IdentityProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).IdentityProfile = value ?? null /* model class */; }

        /// <summary>
        /// The tenant id of the system assigned identity which is used by master components.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string IdentityTenantId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentityInternal)Identity).TenantId; }

        /// <summary>
        /// For more information see [use managed identities in AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ResourceIdentityType? IdentityType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentityInternal)Identity).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentityInternal)Identity).Type = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ResourceIdentityType)""); }

        /// <summary>
        /// The keys must be ARM resource IDs in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentityUserAssignedIdentities IdentityUserAssignedIdentity { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentityInternal)Identity).UserAssignedIdentity; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentityInternal)Identity).UserAssignedIdentity = value ?? null /* model class */; }

        /// <summary>Whether to enable Image Cleaner on AKS cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? ImageCleanerEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ImageCleanerEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ImageCleanerEnabled = value ?? default(bool); }

        /// <summary>Image Cleaner scanning interval in hours.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public int? ImageCleanerIntervalHour { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ImageCleanerIntervalHour; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ImageCleanerIntervalHour = value ?? default(int); }

        /// <summary>Whether to enable KEDA.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? KedaEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).KedaEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).KedaEnabled = value ?? default(bool); }

        /// <summary>
        /// Comma-separated list of Kubernetes annotation keys that will be used in the resource's labels metric (Example: 'namespaces=[kubernetes.io/team,...],pods=[kubernetes.io/team],...').
        /// By default the metric contains only resource name and namespace labels.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string KubeStateMetricAnnotationsAllowList { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).KubeStateMetricAnnotationsAllowList; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).KubeStateMetricAnnotationsAllowList = value ?? null; }

        /// <summary>
        /// Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric (Example: 'namespaces=[k8s-label-1,k8s-label-n,...],pods=[app],...').
        /// By default the metric contains only resource name and namespace labels.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string KubeStateMetricLabelsAllowlist { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).KubeStateMetricLabelsAllowlist; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).KubeStateMetricLabelsAllowlist = value ?? null; }

        /// <summary>
        /// Both patch version <major.minor.patch> (e.g. 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor>
        /// is specified, the latest supported GA patch version is chosen automatically. Updating the cluster with the same <major.minor>
        /// once it has been created (e.g. 1.14.x -> 1.14) will not trigger an upgrade, even if a newer patch version is available.
        /// When you upgrade a supported AKS cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed
        /// sequentially by major version number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed,
        /// however 1.14.x -> 1.16.x is not allowed. See [upgrading an AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster)
        /// for more details.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string KubernetesVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).KubernetesVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).KubernetesVersion = value ?? null; }

        /// <summary>The administrator username to use for Linux VMs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string LinuxProfileAdminUsername { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).LinuxProfileAdminUsername; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).LinuxProfileAdminUsername = value ?? null; }

        /// <summary>The geo-location where the resource lives</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inherited)]
        public string Location { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.ITrackedResourceInternal)__trackedResource).Location; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.ITrackedResourceInternal)__trackedResource).Location = value ; }

        /// <summary>The max number of agent pools for the managed cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public int? MaxAgentPool { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).MaxAgentPool; }

        /// <summary>
        /// Whether to enable or disable the Azure Managed Prometheus addon for Prometheus monitoring. See aka.ms/AzureManagedPrometheus-aks-enable
        /// for details on enabling and disabling.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? MetricEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).MetricEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).MetricEnabled = value ?? default(bool); }

        /// <summary>Internal Acessors for AadProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterAadProfile Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.AadProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AadProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AadProfile = value; }

        /// <summary>Internal Acessors for ApiServerAccessProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterApiServerAccessProfile Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.ApiServerAccessProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ApiServerAccessProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ApiServerAccessProfile = value; }

        /// <summary>Internal Acessors for AutoScalerProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesAutoScalerProfile Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.AutoScalerProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoScalerProfile = value; }

        /// <summary>Internal Acessors for AutoUpgradeProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterAutoUpgradeProfile Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.AutoUpgradeProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoUpgradeProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AutoUpgradeProfile = value; }

        /// <summary>Internal Acessors for AzureMonitorProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterAzureMonitorProfile Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.AzureMonitorProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AzureMonitorProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AzureMonitorProfile = value; }

        /// <summary>Internal Acessors for AzureMonitorProfileMetric</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterAzureMonitorProfileMetrics Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.AzureMonitorProfileMetric { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AzureMonitorProfileMetric; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AzureMonitorProfileMetric = value; }

        /// <summary>Internal Acessors for AzurePortalFqdn</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.AzurePortalFqdn { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AzurePortalFqdn; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).AzurePortalFqdn = value; }

        /// <summary>Internal Acessors for CurrentKubernetesVersion</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.CurrentKubernetesVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).CurrentKubernetesVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).CurrentKubernetesVersion = value; }

        /// <summary>Internal Acessors for DefenderSecurityMonitoring</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSecurityProfileDefenderSecurityMonitoring Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.DefenderSecurityMonitoring { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).DefenderSecurityMonitoring; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).DefenderSecurityMonitoring = value; }

        /// <summary>Internal Acessors for ExtendedLocation</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IExtendedLocation Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.ExtendedLocation { get => (this._extendedLocation = this._extendedLocation ?? new Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.ExtendedLocation()); set { {_extendedLocation = value;} } }

        /// <summary>Internal Acessors for Fqdn</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.Fqdn { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).Fqdn; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).Fqdn = value; }

        /// <summary>Internal Acessors for HttpProxyConfig</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterHttpProxyConfig Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.HttpProxyConfig { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).HttpProxyConfig; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).HttpProxyConfig = value; }

        /// <summary>Internal Acessors for Identity</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentity Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.Identity { get => (this._identity = this._identity ?? new Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.ManagedClusterIdentity()); set { {_identity = value;} } }

        /// <summary>Internal Acessors for IdentityPrincipalId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.IdentityPrincipalId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentityInternal)Identity).PrincipalId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentityInternal)Identity).PrincipalId = value; }

        /// <summary>Internal Acessors for IdentityTenantId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.IdentityTenantId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentityInternal)Identity).TenantId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentityInternal)Identity).TenantId = value; }

        /// <summary>Internal Acessors for LinuxProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IContainerServiceLinuxProfile Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.LinuxProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).LinuxProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).LinuxProfile = value; }

        /// <summary>Internal Acessors for LinuxProfileSsh</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IContainerServiceSshConfiguration Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.LinuxProfileSsh { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).LinuxProfileSsh; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).LinuxProfileSsh = value; }

        /// <summary>Internal Acessors for MaxAgentPool</summary>
        int? Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.MaxAgentPool { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).MaxAgentPool; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).MaxAgentPool = value; }

        /// <summary>Internal Acessors for MetricKubeStateMetric</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterAzureMonitorProfileKubeStateMetrics Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.MetricKubeStateMetric { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).MetricKubeStateMetric; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).MetricKubeStateMetric = value; }

        /// <summary>Internal Acessors for OidcIssuerProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterOidcIssuerProfile Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.OidcIssuerProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).OidcIssuerProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).OidcIssuerProfile = value; }

        /// <summary>Internal Acessors for OidcIssuerProfileIssuerUrl</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.OidcIssuerProfileIssuerUrl { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).OidcIssuerProfileIssuerUrl; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).OidcIssuerProfileIssuerUrl = value; }

        /// <summary>Internal Acessors for PodIdentityProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPodIdentityProfile Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.PodIdentityProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PodIdentityProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PodIdentityProfile = value; }

        /// <summary>Internal Acessors for PowerState</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IPowerState Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.PowerState { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PowerState; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PowerState = value; }

        /// <summary>Internal Acessors for PrivateFqdn</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.PrivateFqdn { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PrivateFqdn; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PrivateFqdn = value; }

        /// <summary>Internal Acessors for Property</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterProperties Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.ManagedClusterProperties()); set { {_property = value;} } }

        /// <summary>Internal Acessors for ProvisioningState</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.ProvisioningState { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ProvisioningState; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ProvisioningState = value; }

        /// <summary>Internal Acessors for SecurityProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSecurityProfile Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.SecurityProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).SecurityProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).SecurityProfile = value; }

        /// <summary>Internal Acessors for SecurityProfileAzureKeyVaultKm</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IAzureKeyVaultKms Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.SecurityProfileAzureKeyVaultKm { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).SecurityProfileAzureKeyVaultKm; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).SecurityProfileAzureKeyVaultKm = value; }

        /// <summary>Internal Acessors for SecurityProfileDefender</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSecurityProfileDefender Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.SecurityProfileDefender { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).SecurityProfileDefender; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).SecurityProfileDefender = value; }

        /// <summary>Internal Acessors for SecurityProfileImageCleaner</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSecurityProfileImageCleaner Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.SecurityProfileImageCleaner { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).SecurityProfileImageCleaner; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).SecurityProfileImageCleaner = value; }

        /// <summary>Internal Acessors for SecurityProfileWorkloadIdentity</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSecurityProfileWorkloadIdentity Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.SecurityProfileWorkloadIdentity { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).SecurityProfileWorkloadIdentity; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).SecurityProfileWorkloadIdentity = value; }

        /// <summary>Internal Acessors for ServicePrincipalProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterServicePrincipalProfile Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.ServicePrincipalProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ServicePrincipalProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ServicePrincipalProfile = value; }

        /// <summary>Internal Acessors for Sku</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSku Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.Sku { get => (this._sku = this._sku ?? new Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.ManagedClusterSku()); set { {_sku = value;} } }

        /// <summary>Internal Acessors for StorageProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterStorageProfile Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.StorageProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).StorageProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).StorageProfile = value; }

        /// <summary>Internal Acessors for StorageProfileBlobCsiDriver</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterStorageProfileBlobCsiDriver Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.StorageProfileBlobCsiDriver { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).StorageProfileBlobCsiDriver; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).StorageProfileBlobCsiDriver = value; }

        /// <summary>Internal Acessors for StorageProfileDiskCsiDriver</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterStorageProfileDiskCsiDriver Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.StorageProfileDiskCsiDriver { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).StorageProfileDiskCsiDriver; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).StorageProfileDiskCsiDriver = value; }

        /// <summary>Internal Acessors for StorageProfileFileCsiDriver</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterStorageProfileFileCsiDriver Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.StorageProfileFileCsiDriver { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).StorageProfileFileCsiDriver; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).StorageProfileFileCsiDriver = value; }

        /// <summary>Internal Acessors for StorageProfileSnapshotController</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterStorageProfileSnapshotController Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.StorageProfileSnapshotController { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).StorageProfileSnapshotController; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).StorageProfileSnapshotController = value; }

        /// <summary>Internal Acessors for WindowProfileGmsaProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IWindowsGmsaProfile Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.WindowProfileGmsaProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WindowProfileGmsaProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WindowProfileGmsaProfile = value; }

        /// <summary>Internal Acessors for WindowsProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterWindowsProfile Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.WindowsProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WindowsProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WindowsProfile = value; }

        /// <summary>Internal Acessors for WorkloadAutoScalerProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterWorkloadAutoScalerProfile Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.WorkloadAutoScalerProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WorkloadAutoScalerProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WorkloadAutoScalerProfile = value; }

        /// <summary>Internal Acessors for WorkloadAutoScalerProfileKeda</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterWorkloadAutoScalerProfileKeda Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterInternal.WorkloadAutoScalerProfileKeda { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WorkloadAutoScalerProfileKeda; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WorkloadAutoScalerProfileKeda = value; }

        /// <summary>Internal Acessors for Id</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal.Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).Id = value; }

        /// <summary>Internal Acessors for Name</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal.Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).Name = value; }

        /// <summary>Internal Acessors for SystemData</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.ISystemData Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal.SystemData { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).SystemData; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).SystemData = value; }

        /// <summary>Internal Acessors for Type</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal.Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).Type = value; }

        /// <summary>The name of the resource</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inherited)]
        public string Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).Name; }

        /// <summary>The network configuration profile.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IContainerServiceNetworkProfile NetworkProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).NetworkProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).NetworkProfile = value ?? null /* model class */; }

        /// <summary>The name of the resource group containing agent pool nodes.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string NodeResourceGroup { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).NodeResourceGroup; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).NodeResourceGroup = value ?? null; }

        /// <summary>Whether the OIDC issuer is enabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? OidcIssuerProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).OidcIssuerProfileEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).OidcIssuerProfileEnabled = value ?? default(bool); }

        /// <summary>The OIDC issuer url of the Managed Cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string OidcIssuerProfileIssuerUrl { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).OidcIssuerProfileIssuerUrl; }

        /// <summary>
        /// Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing.
        /// See [using Kubenet network plugin with AAD Pod Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities)
        /// for more information.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? PodIdentityProfileAllowNetworkPluginKubenet { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PodIdentityProfileAllowNetworkPluginKubenet; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PodIdentityProfileAllowNetworkPluginKubenet = value ?? default(bool); }

        /// <summary>Whether the pod identity addon is enabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? PodIdentityProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PodIdentityProfileEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PodIdentityProfileEnabled = value ?? default(bool); }

        /// <summary>The pod identities to use in the cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPodIdentity[] PodIdentityProfileUserAssignedIdentity { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PodIdentityProfileUserAssignedIdentity; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PodIdentityProfileUserAssignedIdentity = value ?? null /* arrayOf */; }

        /// <summary>The pod identity exceptions to allow.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPodIdentityException[] PodIdentityProfileUserAssignedIdentityException { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PodIdentityProfileUserAssignedIdentityException; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PodIdentityProfileUserAssignedIdentityException = value ?? null /* arrayOf */; }

        /// <summary>Tells whether the cluster is Running or Stopped</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.Code? PowerStateCode { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PowerStateCode; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PowerStateCode = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.Code)""); }

        /// <summary>The FQDN of private cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string PrivateFqdn { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PrivateFqdn; }

        /// <summary>Private link resources associated with the cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IPrivateLinkResource[] PrivateLinkResource { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PrivateLinkResource; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PrivateLinkResource = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="Property" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterProperties _property;

        /// <summary>Properties of a managed cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterProperties Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.ManagedClusterProperties()); set => this._property = value; }

        /// <summary>The current provisioning state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string ProvisioningState { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ProvisioningState; }

        /// <summary>Allow or deny public network access for AKS</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.PublicNetworkAccess? PublicNetworkAccess { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PublicNetworkAccess; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).PublicNetworkAccess = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.PublicNetworkAccess)""); }

        /// <summary>Whether to enable Defender threat detection</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? SecurityMonitoringEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).SecurityMonitoringEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).SecurityMonitoringEnabled = value ?? default(bool); }

        /// <summary>The ID for the service principal.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string ServicePrincipalProfileClientId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ServicePrincipalProfileClientId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ServicePrincipalProfileClientId = value ?? null; }

        /// <summary>The secret password associated with the service principal in plain text.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string ServicePrincipalProfileSecret { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ServicePrincipalProfileSecret; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).ServicePrincipalProfileSecret = value ?? null; }

        /// <summary>Backing field for <see cref="Sku" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSku _sku;

        /// <summary>The managed cluster SKU.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSku Sku { get => (this._sku = this._sku ?? new Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.ManagedClusterSku()); set => this._sku = value; }

        /// <summary>The name of a managed cluster SKU.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ManagedClusterSkuName? SkuName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSkuInternal)Sku).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSkuInternal)Sku).Name = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ManagedClusterSkuName)""); }

        /// <summary>
        /// If not specified, the default is 'Free'. See [AKS Pricing Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers)
        /// for more details.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ManagedClusterSkuTier? SkuTier { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSkuInternal)Sku).Tier; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSkuInternal)Sku).Tier = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ManagedClusterSkuTier)""); }

        /// <summary>Whether to enable Snapshot Controller. The default value is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? SnapshotControllerEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).SnapshotControllerEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).SnapshotControllerEnabled = value ?? default(bool); }

        /// <summary>
        /// The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IContainerServiceSshPublicKey[] SshPublicKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).SshPublicKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).SshPublicKey = value ?? null /* arrayOf */; }

        /// <summary>
        /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inherited)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.ISystemData SystemData { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).SystemData; }

        /// <summary>The timestamp of resource creation (UTC).</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inherited)]
        public global::System.DateTime? SystemDataCreatedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).SystemDataCreatedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).SystemDataCreatedAt = value ?? default(global::System.DateTime); }

        /// <summary>The identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inherited)]
        public string SystemDataCreatedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).SystemDataCreatedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).SystemDataCreatedBy = value ?? null; }

        /// <summary>The type of identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inherited)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.CreatedByType? SystemDataCreatedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).SystemDataCreatedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).SystemDataCreatedByType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.CreatedByType)""); }

        /// <summary>The timestamp of resource last modification (UTC)</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inherited)]
        public global::System.DateTime? SystemDataLastModifiedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).SystemDataLastModifiedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).SystemDataLastModifiedAt = value ?? default(global::System.DateTime); }

        /// <summary>The identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inherited)]
        public string SystemDataLastModifiedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).SystemDataLastModifiedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).SystemDataLastModifiedBy = value ?? null; }

        /// <summary>The type of identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inherited)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.CreatedByType? SystemDataLastModifiedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).SystemDataLastModifiedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).SystemDataLastModifiedByType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.CreatedByType)""); }

        /// <summary>Resource tags.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inherited)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.ITrackedResourceTags Tag { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.ITrackedResourceInternal)__trackedResource).Tag; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.ITrackedResourceInternal)__trackedResource).Tag = value ?? null /* model class */; }

        /// <summary>
        /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inherited)]
        public string Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.IResourceInternal)__trackedResource).Type; }

        /// <summary>
        /// Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:**
        /// 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters
        /// <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:**
        /// "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string WindowProfileAdminPassword { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WindowProfileAdminPassword; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WindowProfileAdminPassword = value ?? null; }

        /// <summary>
        /// Specifies the name of the administrator account. <br><br> **Restriction:** Cannot end in "." <br><br> **Disallowed values:**
        /// "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm",
        /// "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server", "sql", "support", "support_388945a0",
        /// "sys", "test2", "test3", "user4", "user5". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public string WindowProfileAdminUsername { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WindowProfileAdminUsername; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WindowProfileAdminUsername = value ?? null; }

        /// <summary>
        /// For more details on CSI proxy, see the [CSI proxy GitHub repo](https://github.com/kubernetes-csi/csi-proxy).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? WindowProfileEnableCsiProxy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WindowProfileEnableCsiProxy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WindowProfileEnableCsiProxy = value ?? default(bool); }

        /// <summary>
        /// The license type to use for Windows VMs. See [Azure Hybrid User Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/)
        /// for more details.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.LicenseType? WindowProfileLicenseType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WindowProfileLicenseType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WindowProfileLicenseType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.LicenseType)""); }

        /// <summary>Whether to enable workload identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Origin(Microsoft.Azure.PowerShell.Cmdlets.Aks.PropertyOrigin.Inlined)]
        public bool? WorkloadIdentityEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WorkloadIdentityEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesInternal)Property).WorkloadIdentityEnabled = value ?? default(bool); }

        /// <summary>Creates an new <see cref="ManagedCluster" /> instance.</summary>
        public ManagedCluster()
        {

        }

        /// <summary>Validates that this object meets the validation criteria.</summary>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.IEventListener" /> instance that will receive validation
        /// events.</param>
        /// <returns>
        /// A <see cref = "global::System.Threading.Tasks.Task" /> that will be complete when validation is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task Validate(Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.IEventListener eventListener)
        {
            await eventListener.AssertNotNull(nameof(__trackedResource), __trackedResource);
            await eventListener.AssertObjectIsValid(nameof(__trackedResource), __trackedResource);
        }
    }
    /// Managed cluster.
    public partial interface IManagedCluster :
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.IJsonSerializable,
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.ITrackedResource
    {
        /// <summary>The list of AAD group object IDs that will have admin role of the cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The list of AAD group object IDs that will have admin role of the cluster.",
        SerializedName = @"adminGroupObjectIDs",
        PossibleTypes = new [] { typeof(string) })]
        string[] AadProfileAdminGroupObjectID { get; set; }
        /// <summary>
        /// (DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"(DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.",
        SerializedName = @"clientAppID",
        PossibleTypes = new [] { typeof(string) })]
        string AadProfileClientAppId { get; set; }
        /// <summary>Whether to enable Azure RBAC for Kubernetes authorization.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Azure RBAC for Kubernetes authorization.",
        SerializedName = @"enableAzureRBAC",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AadProfileEnableAzureRbac { get; set; }
        /// <summary>Whether to enable managed AAD.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable managed AAD.",
        SerializedName = @"managed",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AadProfileManaged { get; set; }
        /// <summary>
        /// (DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"(DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.",
        SerializedName = @"serverAppID",
        PossibleTypes = new [] { typeof(string) })]
        string AadProfileServerAppId { get; set; }
        /// <summary>
        /// (DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"(DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.",
        SerializedName = @"serverAppSecret",
        PossibleTypes = new [] { typeof(string) })]
        string AadProfileServerAppSecret { get; set; }
        /// <summary>
        /// The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.",
        SerializedName = @"tenantID",
        PossibleTypes = new [] { typeof(string) })]
        string AadProfileTenantId { get; set; }
        /// <summary>The profile of managed cluster add-on.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The profile of managed cluster add-on.",
        SerializedName = @"addonProfiles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesAddonProfiles) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesAddonProfiles AddonProfile { get; set; }
        /// <summary>The agent pool properties.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The agent pool properties.",
        SerializedName = @"agentPoolProfiles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterAgentPoolProfile) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterAgentPoolProfile[] AgentPoolProfile { get; set; }
        /// <summary>
        /// IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use
        /// Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see [API server authorized
        /// IP ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see [API server authorized IP ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).",
        SerializedName = @"authorizedIPRanges",
        PossibleTypes = new [] { typeof(string) })]
        string[] ApiServerAccessProfileAuthorizedIPRange { get; set; }
        /// <summary>Whether to disable run command for the cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to disable run command for the cluster or not.",
        SerializedName = @"disableRunCommand",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ApiServerAccessProfileDisableRunCommand { get; set; }
        /// <summary>
        /// For more details, see [Creating a private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For more details, see [Creating a private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).",
        SerializedName = @"enablePrivateCluster",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ApiServerAccessProfileEnablePrivateCluster { get; set; }
        /// <summary>Whether to create additional public FQDN for private cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to create additional public FQDN for private cluster or not.",
        SerializedName = @"enablePrivateClusterPublicFQDN",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ApiServerAccessProfileEnablePrivateClusterPublicFqdn { get; set; }
        /// <summary>
        /// The default is System. For more details see [configure private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone).
        /// Allowed values are 'system' and 'none'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is System. For more details see [configure private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone). Allowed values are 'system' and 'none'.",
        SerializedName = @"privateDNSZone",
        PossibleTypes = new [] { typeof(string) })]
        string ApiServerAccessProfilePrivateDnsZone { get; set; }
        /// <summary>Valid values are 'true' and 'false'</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Valid values are 'true' and 'false'",
        SerializedName = @"balance-similar-node-groups",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileBalanceSimilarNodeGroup { get; set; }
        /// <summary>
        /// If not specified, the default is 'random'. See [expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders)
        /// for more information.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If not specified, the default is 'random'. See [expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders) for more information.",
        SerializedName = @"expander",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.Expander) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.Expander? AutoScalerProfileExpander { get; set; }
        /// <summary>The default is 10.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is 10.",
        SerializedName = @"max-empty-bulk-delete",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileMaxEmptyBulkDelete { get; set; }
        /// <summary>The default is 600.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is 600.",
        SerializedName = @"max-graceful-termination-sec",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileMaxGracefulTerminationSec { get; set; }
        /// <summary>
        /// The default is '15m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '15m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"max-node-provision-time",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileMaxNodeProvisionTime { get; set; }
        /// <summary>The default is 45. The maximum is 100 and the minimum is 0.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is 45. The maximum is 100 and the minimum is 0.",
        SerializedName = @"max-total-unready-percentage",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileMaxTotalUnreadyPercentage { get; set; }
        /// <summary>
        /// For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all
        /// the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is '0s'. Values must be
        /// an integer followed by a unit ('s' for seconds, 'm' for minutes, 'h' for hours, etc).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is '0s'. Values must be an integer followed by a unit ('s' for seconds, 'm' for minutes, 'h' for hours, etc).",
        SerializedName = @"new-pod-scale-up-delay",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileNewPodScaleUpDelay { get; set; }
        /// <summary>This must be an integer. The default is 3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This must be an integer. The default is 3.",
        SerializedName = @"ok-total-unready-count",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileOkTotalUnreadyCount { get; set; }
        /// <summary>
        /// The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-delay-after-add",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileScaleDownDelayAfterAdd { get; set; }
        /// <summary>
        /// The default is the scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m)
        /// is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is the scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-delay-after-delete",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileScaleDownDelayAfterDelete { get; set; }
        /// <summary>
        /// The default is '3m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '3m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-delay-after-failure",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileScaleDownDelayAfterFailure { get; set; }
        /// <summary>
        /// The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-unneeded-time",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileScaleDownUnneededTime { get; set; }
        /// <summary>
        /// The default is '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-unready-time",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileScaleDownUnreadyTime { get; set; }
        /// <summary>The default is '0.5'.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '0.5'.",
        SerializedName = @"scale-down-utilization-threshold",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileScaleDownUtilizationThreshold { get; set; }
        /// <summary>The default is '10'. Values must be an integer number of seconds.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '10'. Values must be an integer number of seconds.",
        SerializedName = @"scan-interval",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileScanInterval { get; set; }
        /// <summary>The default is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is true.",
        SerializedName = @"skip-nodes-with-local-storage",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileSkipNodesWithLocalStorage { get; set; }
        /// <summary>The default is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is true.",
        SerializedName = @"skip-nodes-with-system-pods",
        PossibleTypes = new [] { typeof(string) })]
        string AutoScalerProfileSkipNodesWithSystemPod { get; set; }
        /// <summary>
        /// For more information see [setting the AKS cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For more information see [setting the AKS cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).",
        SerializedName = @"upgradeChannel",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.UpgradeChannel) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.UpgradeChannel? AutoUpgradeProfileUpgradeChannel { get; set; }
        /// <summary>Whether to enable Azure Key Vault key management service. The default is false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Azure Key Vault key management service. The default is false.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AzureKeyVaultKmEnabled { get; set; }
        /// <summary>
        /// Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name)
        /// for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key
        /// identifier. When Azure Key Vault key management service is disabled, leave the field empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name) for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key identifier. When Azure Key Vault key management service is disabled, leave the field empty.",
        SerializedName = @"keyId",
        PossibleTypes = new [] { typeof(string) })]
        string AzureKeyVaultKmKeyId { get; set; }
        /// <summary>
        /// Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public
        /// access from all networks. `Private` means the key vault disables public access and enables private link. The default value
        /// is `Public`.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link. The default value is `Public`.",
        SerializedName = @"keyVaultNetworkAccess",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.KeyVaultNetworkAccessTypes) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.KeyVaultNetworkAccessTypes? AzureKeyVaultKmKeyVaultNetworkAccess { get; set; }
        /// <summary>
        /// Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource
        /// ID. When keyVaultNetworkAccess is `Public`, leave the field empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource ID. When keyVaultNetworkAccess is `Public`, leave the field empty.",
        SerializedName = @"keyVaultResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string AzureKeyVaultKmKeyVaultResourceId { get; set; }
        /// <summary>
        /// The Azure Portal requires certain Cross-Origin Resource Sharing (CORS) headers to be sent in some responses, which Kubernetes
        /// APIServer doesn't handle by default. This special FQDN supports CORS, allowing the Azure Portal to function properly.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The Azure Portal requires certain Cross-Origin Resource Sharing (CORS) headers to be sent in some responses, which Kubernetes APIServer doesn't handle by default. This special FQDN supports CORS, allowing the Azure Portal to function properly.",
        SerializedName = @"azurePortalFQDN",
        PossibleTypes = new [] { typeof(string) })]
        string AzurePortalFqdn { get;  }
        /// <summary>Whether to enable AzureBlob CSI Driver. The default value is false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable AzureBlob CSI Driver. The default value is false.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? BlobCsiDriverEnabled { get; set; }
        /// <summary>
        /// If kubernetesVersion was a fully specified version <major.minor.patch>, this field will be exactly equal to it. If kubernetesVersion
        /// was <major.minor>, this field will contain the full <major.minor.patch> version being used.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"If kubernetesVersion was a fully specified version <major.minor.patch>, this field will be exactly equal to it. If kubernetesVersion was <major.minor>, this field will contain the full <major.minor.patch> version being used.",
        SerializedName = @"currentKubernetesVersion",
        PossibleTypes = new [] { typeof(string) })]
        string CurrentKubernetesVersion { get;  }
        /// <summary>
        /// Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled,
        /// this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field
        /// empty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled, this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field empty.",
        SerializedName = @"logAnalyticsWorkspaceResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string DefenderLogAnalyticsWorkspaceResourceId { get; set; }
        /// <summary>
        /// If set to true, getting static credentials will be disabled for this cluster. This must only be used on Managed Clusters
        /// that are AAD enabled. For more details see [disable local accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If set to true, getting static credentials will be disabled for this cluster. This must only be used on Managed Clusters that are AAD enabled. For more details see [disable local accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).",
        SerializedName = @"disableLocalAccounts",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DisableLocalAccount { get; set; }
        /// <summary>Whether to enable AzureDisk CSI Driver. The default value is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable AzureDisk CSI Driver. The default value is true.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DiskCsiDriverEnabled { get; set; }
        /// <summary>
        /// This is of the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This is of the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'",
        SerializedName = @"diskEncryptionSetID",
        PossibleTypes = new [] { typeof(string) })]
        string DiskEncryptionSetId { get; set; }
        /// <summary>This cannot be updated once the Managed Cluster has been created.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This cannot be updated once the Managed Cluster has been created.",
        SerializedName = @"dnsPrefix",
        PossibleTypes = new [] { typeof(string) })]
        string DnsPrefix { get; set; }
        /// <summary>
        /// (DEPRECATED) Whether to enable Kubernetes pod security policy (preview). PodSecurityPolicy was deprecated in Kubernetes
        /// v1.21, and removed from Kubernetes in v1.25. Learn more at https://aka.ms/k8s/psp and https://aka.ms/aks/psp.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"(DEPRECATED) Whether to enable Kubernetes pod security policy (preview). PodSecurityPolicy was deprecated in Kubernetes v1.21, and removed from Kubernetes in v1.25. Learn more at https://aka.ms/k8s/psp and https://aka.ms/aks/psp.",
        SerializedName = @"enablePodSecurityPolicy",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnablePodSecurityPolicy { get; set; }
        /// <summary>Whether to enable Kubernetes Role-Based Access Control.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Kubernetes Role-Based Access Control.",
        SerializedName = @"enableRBAC",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnableRbac { get; set; }
        /// <summary>The name of the extended location.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the extended location.",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string ExtendedLocationName { get; set; }
        /// <summary>The type of the extended location.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The type of the extended location.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ExtendedLocationTypes) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ExtendedLocationTypes? ExtendedLocationType { get; set; }
        /// <summary>Whether to enable AzureFile CSI Driver. The default value is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable AzureFile CSI Driver. The default value is true.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? FileCsiDriverEnabled { get; set; }
        /// <summary>The FQDN of the master pool.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The FQDN of the master pool.",
        SerializedName = @"fqdn",
        PossibleTypes = new [] { typeof(string) })]
        string Fqdn { get;  }
        /// <summary>This cannot be updated once the Managed Cluster has been created.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This cannot be updated once the Managed Cluster has been created.",
        SerializedName = @"fqdnSubdomain",
        PossibleTypes = new [] { typeof(string) })]
        string FqdnSubdomain { get; set; }
        /// <summary>
        /// Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet
        /// which is used to create the managed cluster.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.",
        SerializedName = @"dnsServer",
        PossibleTypes = new [] { typeof(string) })]
        string GmsaProfileDnsServer { get; set; }
        /// <summary>Specifies whether to enable Windows gMSA in the managed cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether to enable Windows gMSA in the managed cluster.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? GmsaProfileEnabled { get; set; }
        /// <summary>
        /// Specifies the root domain name for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the
        /// vnet which is used to create the managed cluster.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the root domain name for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.",
        SerializedName = @"rootDomainName",
        PossibleTypes = new [] { typeof(string) })]
        string GmsaProfileRootDomainName { get; set; }
        /// <summary>The HTTP proxy server endpoint to use.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The HTTP proxy server endpoint to use.",
        SerializedName = @"httpProxy",
        PossibleTypes = new [] { typeof(string) })]
        string HttpProxyConfigHttpProxy { get; set; }
        /// <summary>The HTTPS proxy server endpoint to use.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The HTTPS proxy server endpoint to use.",
        SerializedName = @"httpsProxy",
        PossibleTypes = new [] { typeof(string) })]
        string HttpProxyConfigHttpsProxy { get; set; }
        /// <summary>The endpoints that should not go through proxy.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The endpoints that should not go through proxy.",
        SerializedName = @"noProxy",
        PossibleTypes = new [] { typeof(string) })]
        string[] HttpProxyConfigNoProxy { get; set; }
        /// <summary>Alternative CA cert to use for connecting to proxy servers.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Alternative CA cert to use for connecting to proxy servers.",
        SerializedName = @"trustedCa",
        PossibleTypes = new [] { typeof(string) })]
        string HttpProxyConfigTrustedCa { get; set; }
        /// <summary>
        /// The principal id of the system assigned identity which is used by master components.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The principal id of the system assigned identity which is used by master components.",
        SerializedName = @"principalId",
        PossibleTypes = new [] { typeof(string) })]
        string IdentityPrincipalId { get;  }
        /// <summary>Identities associated with the cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Identities associated with the cluster.",
        SerializedName = @"identityProfile",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesIdentityProfile) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesIdentityProfile IdentityProfile { get; set; }
        /// <summary>
        /// The tenant id of the system assigned identity which is used by master components.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The tenant id of the system assigned identity which is used by master components.",
        SerializedName = @"tenantId",
        PossibleTypes = new [] { typeof(string) })]
        string IdentityTenantId { get;  }
        /// <summary>
        /// For more information see [use managed identities in AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For more information see [use managed identities in AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ResourceIdentityType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ResourceIdentityType? IdentityType { get; set; }
        /// <summary>
        /// The keys must be ARM resource IDs in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The keys must be ARM resource IDs in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.",
        SerializedName = @"userAssignedIdentities",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentityUserAssignedIdentities) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentityUserAssignedIdentities IdentityUserAssignedIdentity { get; set; }
        /// <summary>Whether to enable Image Cleaner on AKS cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Image Cleaner on AKS cluster.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ImageCleanerEnabled { get; set; }
        /// <summary>Image Cleaner scanning interval in hours.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Image Cleaner scanning interval in hours.",
        SerializedName = @"intervalHours",
        PossibleTypes = new [] { typeof(int) })]
        int? ImageCleanerIntervalHour { get; set; }
        /// <summary>Whether to enable KEDA.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable KEDA.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? KedaEnabled { get; set; }
        /// <summary>
        /// Comma-separated list of Kubernetes annotation keys that will be used in the resource's labels metric (Example: 'namespaces=[kubernetes.io/team,...],pods=[kubernetes.io/team],...').
        /// By default the metric contains only resource name and namespace labels.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Comma-separated list of Kubernetes annotation keys that will be used in the resource's labels metric (Example: 'namespaces=[kubernetes.io/team,...],pods=[kubernetes.io/team],...'). By default the metric contains only resource name and namespace labels.",
        SerializedName = @"metricAnnotationsAllowList",
        PossibleTypes = new [] { typeof(string) })]
        string KubeStateMetricAnnotationsAllowList { get; set; }
        /// <summary>
        /// Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric (Example: 'namespaces=[k8s-label-1,k8s-label-n,...],pods=[app],...').
        /// By default the metric contains only resource name and namespace labels.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric (Example: 'namespaces=[k8s-label-1,k8s-label-n,...],pods=[app],...'). By default the metric contains only resource name and namespace labels.",
        SerializedName = @"metricLabelsAllowlist",
        PossibleTypes = new [] { typeof(string) })]
        string KubeStateMetricLabelsAllowlist { get; set; }
        /// <summary>
        /// Both patch version <major.minor.patch> (e.g. 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor>
        /// is specified, the latest supported GA patch version is chosen automatically. Updating the cluster with the same <major.minor>
        /// once it has been created (e.g. 1.14.x -> 1.14) will not trigger an upgrade, even if a newer patch version is available.
        /// When you upgrade a supported AKS cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed
        /// sequentially by major version number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed,
        /// however 1.14.x -> 1.16.x is not allowed. See [upgrading an AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster)
        /// for more details.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Both patch version <major.minor.patch> (e.g. 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor> is specified, the latest supported GA patch version is chosen automatically. Updating the cluster with the same <major.minor> once it has been created (e.g. 1.14.x -> 1.14) will not trigger an upgrade, even if a newer patch version is available. When you upgrade a supported AKS cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed sequentially by major version number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed, however 1.14.x -> 1.16.x is not allowed. See [upgrading an AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster) for more details.",
        SerializedName = @"kubernetesVersion",
        PossibleTypes = new [] { typeof(string) })]
        string KubernetesVersion { get; set; }
        /// <summary>The administrator username to use for Linux VMs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The administrator username to use for Linux VMs.",
        SerializedName = @"adminUsername",
        PossibleTypes = new [] { typeof(string) })]
        string LinuxProfileAdminUsername { get; set; }
        /// <summary>The max number of agent pools for the managed cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The max number of agent pools for the managed cluster.",
        SerializedName = @"maxAgentPools",
        PossibleTypes = new [] { typeof(int) })]
        int? MaxAgentPool { get;  }
        /// <summary>
        /// Whether to enable or disable the Azure Managed Prometheus addon for Prometheus monitoring. See aka.ms/AzureManagedPrometheus-aks-enable
        /// for details on enabling and disabling.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable or disable the Azure Managed Prometheus addon for Prometheus monitoring. See aka.ms/AzureManagedPrometheus-aks-enable for details on enabling and disabling.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? MetricEnabled { get; set; }
        /// <summary>The network configuration profile.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The network configuration profile.",
        SerializedName = @"networkProfile",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IContainerServiceNetworkProfile) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IContainerServiceNetworkProfile NetworkProfile { get; set; }
        /// <summary>The name of the resource group containing agent pool nodes.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the resource group containing agent pool nodes.",
        SerializedName = @"nodeResourceGroup",
        PossibleTypes = new [] { typeof(string) })]
        string NodeResourceGroup { get; set; }
        /// <summary>Whether the OIDC issuer is enabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether the OIDC issuer is enabled.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? OidcIssuerProfileEnabled { get; set; }
        /// <summary>The OIDC issuer url of the Managed Cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The OIDC issuer url of the Managed Cluster.",
        SerializedName = @"issuerURL",
        PossibleTypes = new [] { typeof(string) })]
        string OidcIssuerProfileIssuerUrl { get;  }
        /// <summary>
        /// Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing.
        /// See [using Kubenet network plugin with AAD Pod Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities)
        /// for more information.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing. See [using Kubenet network plugin with AAD Pod Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities) for more information.",
        SerializedName = @"allowNetworkPluginKubenet",
        PossibleTypes = new [] { typeof(bool) })]
        bool? PodIdentityProfileAllowNetworkPluginKubenet { get; set; }
        /// <summary>Whether the pod identity addon is enabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether the pod identity addon is enabled.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? PodIdentityProfileEnabled { get; set; }
        /// <summary>The pod identities to use in the cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The pod identities to use in the cluster.",
        SerializedName = @"userAssignedIdentities",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPodIdentity) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPodIdentity[] PodIdentityProfileUserAssignedIdentity { get; set; }
        /// <summary>The pod identity exceptions to allow.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The pod identity exceptions to allow.",
        SerializedName = @"userAssignedIdentityExceptions",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPodIdentityException) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPodIdentityException[] PodIdentityProfileUserAssignedIdentityException { get; set; }
        /// <summary>Tells whether the cluster is Running or Stopped</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Tells whether the cluster is Running or Stopped",
        SerializedName = @"code",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.Code) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.Code? PowerStateCode { get; set; }
        /// <summary>The FQDN of private cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The FQDN of private cluster.",
        SerializedName = @"privateFQDN",
        PossibleTypes = new [] { typeof(string) })]
        string PrivateFqdn { get;  }
        /// <summary>Private link resources associated with the cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Private link resources associated with the cluster.",
        SerializedName = @"privateLinkResources",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IPrivateLinkResource) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IPrivateLinkResource[] PrivateLinkResource { get; set; }
        /// <summary>The current provisioning state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The current provisioning state.",
        SerializedName = @"provisioningState",
        PossibleTypes = new [] { typeof(string) })]
        string ProvisioningState { get;  }
        /// <summary>Allow or deny public network access for AKS</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Allow or deny public network access for AKS",
        SerializedName = @"publicNetworkAccess",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.PublicNetworkAccess) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.PublicNetworkAccess? PublicNetworkAccess { get; set; }
        /// <summary>Whether to enable Defender threat detection</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Defender threat detection",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SecurityMonitoringEnabled { get; set; }
        /// <summary>The ID for the service principal.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The ID for the service principal.",
        SerializedName = @"clientId",
        PossibleTypes = new [] { typeof(string) })]
        string ServicePrincipalProfileClientId { get; set; }
        /// <summary>The secret password associated with the service principal in plain text.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The secret password associated with the service principal in plain text.",
        SerializedName = @"secret",
        PossibleTypes = new [] { typeof(string) })]
        string ServicePrincipalProfileSecret { get; set; }
        /// <summary>The name of a managed cluster SKU.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of a managed cluster SKU.",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ManagedClusterSkuName) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ManagedClusterSkuName? SkuName { get; set; }
        /// <summary>
        /// If not specified, the default is 'Free'. See [AKS Pricing Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers)
        /// for more details.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If not specified, the default is 'Free'. See [AKS Pricing Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers) for more details.",
        SerializedName = @"tier",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ManagedClusterSkuTier) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ManagedClusterSkuTier? SkuTier { get; set; }
        /// <summary>Whether to enable Snapshot Controller. The default value is true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Snapshot Controller. The default value is true.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SnapshotControllerEnabled { get; set; }
        /// <summary>
        /// The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.",
        SerializedName = @"publicKeys",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IContainerServiceSshPublicKey) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IContainerServiceSshPublicKey[] SshPublicKey { get; set; }
        /// <summary>
        /// Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:**
        /// 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters
        /// <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:**
        /// "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:** 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:** ""abc@123"", ""P@$$w0rd"", ""P@ssw0rd"", ""P@ssword123"", ""Pa$$word"", ""pass@word1"", ""Password!"", ""Password1"", ""Password22"", ""iloveyou!""",
        SerializedName = @"adminPassword",
        PossibleTypes = new [] { typeof(string) })]
        string WindowProfileAdminPassword { get; set; }
        /// <summary>
        /// Specifies the name of the administrator account. <br><br> **Restriction:** Cannot end in "." <br><br> **Disallowed values:**
        /// "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm",
        /// "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server", "sql", "support", "support_388945a0",
        /// "sys", "test2", "test3", "user4", "user5". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the name of the administrator account. <br><br> **Restriction:** Cannot end in ""."" <br><br> **Disallowed values:** ""administrator"", ""admin"", ""user"", ""user1"", ""test"", ""user2"", ""test1"", ""user3"", ""admin1"", ""1"", ""123"", ""a"", ""actuser"", ""adm"", ""admin2"", ""aspnet"", ""backup"", ""console"", ""david"", ""guest"", ""john"", ""owner"", ""root"", ""server"", ""sql"", ""support"", ""support_388945a0"", ""sys"", ""test2"", ""test3"", ""user4"", ""user5"". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters",
        SerializedName = @"adminUsername",
        PossibleTypes = new [] { typeof(string) })]
        string WindowProfileAdminUsername { get; set; }
        /// <summary>
        /// For more details on CSI proxy, see the [CSI proxy GitHub repo](https://github.com/kubernetes-csi/csi-proxy).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For more details on CSI proxy, see the [CSI proxy GitHub repo](https://github.com/kubernetes-csi/csi-proxy).",
        SerializedName = @"enableCSIProxy",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WindowProfileEnableCsiProxy { get; set; }
        /// <summary>
        /// The license type to use for Windows VMs. See [Azure Hybrid User Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/)
        /// for more details.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The license type to use for Windows VMs. See [Azure Hybrid User Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more details.",
        SerializedName = @"licenseType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.LicenseType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.LicenseType? WindowProfileLicenseType { get; set; }
        /// <summary>Whether to enable workload identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Aks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable workload identity.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WorkloadIdentityEnabled { get; set; }

    }
    /// Managed cluster.
    internal partial interface IManagedClusterInternal :
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api30.ITrackedResourceInternal
    {
        /// <summary>The Azure Active Directory configuration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterAadProfile AadProfile { get; set; }
        /// <summary>The list of AAD group object IDs that will have admin role of the cluster.</summary>
        string[] AadProfileAdminGroupObjectID { get; set; }
        /// <summary>
        /// (DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        string AadProfileClientAppId { get; set; }
        /// <summary>Whether to enable Azure RBAC for Kubernetes authorization.</summary>
        bool? AadProfileEnableAzureRbac { get; set; }
        /// <summary>Whether to enable managed AAD.</summary>
        bool? AadProfileManaged { get; set; }
        /// <summary>
        /// (DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        string AadProfileServerAppId { get; set; }
        /// <summary>
        /// (DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        string AadProfileServerAppSecret { get; set; }
        /// <summary>
        /// The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.
        /// </summary>
        string AadProfileTenantId { get; set; }
        /// <summary>The profile of managed cluster add-on.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesAddonProfiles AddonProfile { get; set; }
        /// <summary>The agent pool properties.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterAgentPoolProfile[] AgentPoolProfile { get; set; }
        /// <summary>The access profile for managed cluster API server.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterApiServerAccessProfile ApiServerAccessProfile { get; set; }
        /// <summary>
        /// IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use
        /// Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see [API server authorized
        /// IP ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).
        /// </summary>
        string[] ApiServerAccessProfileAuthorizedIPRange { get; set; }
        /// <summary>Whether to disable run command for the cluster or not.</summary>
        bool? ApiServerAccessProfileDisableRunCommand { get; set; }
        /// <summary>
        /// For more details, see [Creating a private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).
        /// </summary>
        bool? ApiServerAccessProfileEnablePrivateCluster { get; set; }
        /// <summary>Whether to create additional public FQDN for private cluster or not.</summary>
        bool? ApiServerAccessProfileEnablePrivateClusterPublicFqdn { get; set; }
        /// <summary>
        /// The default is System. For more details see [configure private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone).
        /// Allowed values are 'system' and 'none'.
        /// </summary>
        string ApiServerAccessProfilePrivateDnsZone { get; set; }
        /// <summary>Parameters to be applied to the cluster-autoscaler when enabled</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesAutoScalerProfile AutoScalerProfile { get; set; }
        /// <summary>Valid values are 'true' and 'false'</summary>
        string AutoScalerProfileBalanceSimilarNodeGroup { get; set; }
        /// <summary>
        /// If not specified, the default is 'random'. See [expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders)
        /// for more information.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.Expander? AutoScalerProfileExpander { get; set; }
        /// <summary>The default is 10.</summary>
        string AutoScalerProfileMaxEmptyBulkDelete { get; set; }
        /// <summary>The default is 600.</summary>
        string AutoScalerProfileMaxGracefulTerminationSec { get; set; }
        /// <summary>
        /// The default is '15m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        string AutoScalerProfileMaxNodeProvisionTime { get; set; }
        /// <summary>The default is 45. The maximum is 100 and the minimum is 0.</summary>
        string AutoScalerProfileMaxTotalUnreadyPercentage { get; set; }
        /// <summary>
        /// For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all
        /// the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is '0s'. Values must be
        /// an integer followed by a unit ('s' for seconds, 'm' for minutes, 'h' for hours, etc).
        /// </summary>
        string AutoScalerProfileNewPodScaleUpDelay { get; set; }
        /// <summary>This must be an integer. The default is 3.</summary>
        string AutoScalerProfileOkTotalUnreadyCount { get; set; }
        /// <summary>
        /// The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        string AutoScalerProfileScaleDownDelayAfterAdd { get; set; }
        /// <summary>
        /// The default is the scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m)
        /// is supported.
        /// </summary>
        string AutoScalerProfileScaleDownDelayAfterDelete { get; set; }
        /// <summary>
        /// The default is '3m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        string AutoScalerProfileScaleDownDelayAfterFailure { get; set; }
        /// <summary>
        /// The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        string AutoScalerProfileScaleDownUnneededTime { get; set; }
        /// <summary>
        /// The default is '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        string AutoScalerProfileScaleDownUnreadyTime { get; set; }
        /// <summary>The default is '0.5'.</summary>
        string AutoScalerProfileScaleDownUtilizationThreshold { get; set; }
        /// <summary>The default is '10'. Values must be an integer number of seconds.</summary>
        string AutoScalerProfileScanInterval { get; set; }
        /// <summary>The default is true.</summary>
        string AutoScalerProfileSkipNodesWithLocalStorage { get; set; }
        /// <summary>The default is true.</summary>
        string AutoScalerProfileSkipNodesWithSystemPod { get; set; }
        /// <summary>The auto upgrade configuration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterAutoUpgradeProfile AutoUpgradeProfile { get; set; }
        /// <summary>
        /// For more information see [setting the AKS cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.UpgradeChannel? AutoUpgradeProfileUpgradeChannel { get; set; }
        /// <summary>Whether to enable Azure Key Vault key management service. The default is false.</summary>
        bool? AzureKeyVaultKmEnabled { get; set; }
        /// <summary>
        /// Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name)
        /// for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key
        /// identifier. When Azure Key Vault key management service is disabled, leave the field empty.
        /// </summary>
        string AzureKeyVaultKmKeyId { get; set; }
        /// <summary>
        /// Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public
        /// access from all networks. `Private` means the key vault disables public access and enables private link. The default value
        /// is `Public`.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.KeyVaultNetworkAccessTypes? AzureKeyVaultKmKeyVaultNetworkAccess { get; set; }
        /// <summary>
        /// Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource
        /// ID. When keyVaultNetworkAccess is `Public`, leave the field empty.
        /// </summary>
        string AzureKeyVaultKmKeyVaultResourceId { get; set; }
        /// <summary>Azure Monitor addon profiles for monitoring the managed cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterAzureMonitorProfile AzureMonitorProfile { get; set; }
        /// <summary>
        /// Metrics profile for the Azure Monitor managed service for Prometheus addon. Collect out-of-the-box Kubernetes infrastructure
        /// metrics to send to an Azure Monitor Workspace and configure additional scraping for custom targets. See aka.ms/AzureManagedPrometheus
        /// for an overview.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterAzureMonitorProfileMetrics AzureMonitorProfileMetric { get; set; }
        /// <summary>
        /// The Azure Portal requires certain Cross-Origin Resource Sharing (CORS) headers to be sent in some responses, which Kubernetes
        /// APIServer doesn't handle by default. This special FQDN supports CORS, allowing the Azure Portal to function properly.
        /// </summary>
        string AzurePortalFqdn { get; set; }
        /// <summary>Whether to enable AzureBlob CSI Driver. The default value is false.</summary>
        bool? BlobCsiDriverEnabled { get; set; }
        /// <summary>
        /// If kubernetesVersion was a fully specified version <major.minor.patch>, this field will be exactly equal to it. If kubernetesVersion
        /// was <major.minor>, this field will contain the full <major.minor.patch> version being used.
        /// </summary>
        string CurrentKubernetesVersion { get; set; }
        /// <summary>
        /// Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled,
        /// this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field
        /// empty.
        /// </summary>
        string DefenderLogAnalyticsWorkspaceResourceId { get; set; }
        /// <summary>
        /// Microsoft Defender threat detection for Cloud settings for the security profile.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSecurityProfileDefenderSecurityMonitoring DefenderSecurityMonitoring { get; set; }
        /// <summary>
        /// If set to true, getting static credentials will be disabled for this cluster. This must only be used on Managed Clusters
        /// that are AAD enabled. For more details see [disable local accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).
        /// </summary>
        bool? DisableLocalAccount { get; set; }
        /// <summary>Whether to enable AzureDisk CSI Driver. The default value is true.</summary>
        bool? DiskCsiDriverEnabled { get; set; }
        /// <summary>
        /// This is of the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'
        /// </summary>
        string DiskEncryptionSetId { get; set; }
        /// <summary>This cannot be updated once the Managed Cluster has been created.</summary>
        string DnsPrefix { get; set; }
        /// <summary>
        /// (DEPRECATED) Whether to enable Kubernetes pod security policy (preview). PodSecurityPolicy was deprecated in Kubernetes
        /// v1.21, and removed from Kubernetes in v1.25. Learn more at https://aka.ms/k8s/psp and https://aka.ms/aks/psp.
        /// </summary>
        bool? EnablePodSecurityPolicy { get; set; }
        /// <summary>Whether to enable Kubernetes Role-Based Access Control.</summary>
        bool? EnableRbac { get; set; }
        /// <summary>The extended location of the Virtual Machine.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IExtendedLocation ExtendedLocation { get; set; }
        /// <summary>The name of the extended location.</summary>
        string ExtendedLocationName { get; set; }
        /// <summary>The type of the extended location.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ExtendedLocationTypes? ExtendedLocationType { get; set; }
        /// <summary>Whether to enable AzureFile CSI Driver. The default value is true.</summary>
        bool? FileCsiDriverEnabled { get; set; }
        /// <summary>The FQDN of the master pool.</summary>
        string Fqdn { get; set; }
        /// <summary>This cannot be updated once the Managed Cluster has been created.</summary>
        string FqdnSubdomain { get; set; }
        /// <summary>
        /// Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet
        /// which is used to create the managed cluster.
        /// </summary>
        string GmsaProfileDnsServer { get; set; }
        /// <summary>Specifies whether to enable Windows gMSA in the managed cluster.</summary>
        bool? GmsaProfileEnabled { get; set; }
        /// <summary>
        /// Specifies the root domain name for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the
        /// vnet which is used to create the managed cluster.
        /// </summary>
        string GmsaProfileRootDomainName { get; set; }
        /// <summary>Configurations for provisioning the cluster with HTTP proxy servers.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterHttpProxyConfig HttpProxyConfig { get; set; }
        /// <summary>The HTTP proxy server endpoint to use.</summary>
        string HttpProxyConfigHttpProxy { get; set; }
        /// <summary>The HTTPS proxy server endpoint to use.</summary>
        string HttpProxyConfigHttpsProxy { get; set; }
        /// <summary>The endpoints that should not go through proxy.</summary>
        string[] HttpProxyConfigNoProxy { get; set; }
        /// <summary>Alternative CA cert to use for connecting to proxy servers.</summary>
        string HttpProxyConfigTrustedCa { get; set; }
        /// <summary>The identity of the managed cluster, if configured.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentity Identity { get; set; }
        /// <summary>
        /// The principal id of the system assigned identity which is used by master components.
        /// </summary>
        string IdentityPrincipalId { get; set; }
        /// <summary>Identities associated with the cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPropertiesIdentityProfile IdentityProfile { get; set; }
        /// <summary>
        /// The tenant id of the system assigned identity which is used by master components.
        /// </summary>
        string IdentityTenantId { get; set; }
        /// <summary>
        /// For more information see [use managed identities in AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ResourceIdentityType? IdentityType { get; set; }
        /// <summary>
        /// The keys must be ARM resource IDs in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterIdentityUserAssignedIdentities IdentityUserAssignedIdentity { get; set; }
        /// <summary>Whether to enable Image Cleaner on AKS cluster.</summary>
        bool? ImageCleanerEnabled { get; set; }
        /// <summary>Image Cleaner scanning interval in hours.</summary>
        int? ImageCleanerIntervalHour { get; set; }
        /// <summary>Whether to enable KEDA.</summary>
        bool? KedaEnabled { get; set; }
        /// <summary>
        /// Comma-separated list of Kubernetes annotation keys that will be used in the resource's labels metric (Example: 'namespaces=[kubernetes.io/team,...],pods=[kubernetes.io/team],...').
        /// By default the metric contains only resource name and namespace labels.
        /// </summary>
        string KubeStateMetricAnnotationsAllowList { get; set; }
        /// <summary>
        /// Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric (Example: 'namespaces=[k8s-label-1,k8s-label-n,...],pods=[app],...').
        /// By default the metric contains only resource name and namespace labels.
        /// </summary>
        string KubeStateMetricLabelsAllowlist { get; set; }
        /// <summary>
        /// Both patch version <major.minor.patch> (e.g. 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor>
        /// is specified, the latest supported GA patch version is chosen automatically. Updating the cluster with the same <major.minor>
        /// once it has been created (e.g. 1.14.x -> 1.14) will not trigger an upgrade, even if a newer patch version is available.
        /// When you upgrade a supported AKS cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed
        /// sequentially by major version number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed,
        /// however 1.14.x -> 1.16.x is not allowed. See [upgrading an AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster)
        /// for more details.
        /// </summary>
        string KubernetesVersion { get; set; }
        /// <summary>The profile for Linux VMs in the Managed Cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IContainerServiceLinuxProfile LinuxProfile { get; set; }
        /// <summary>The administrator username to use for Linux VMs.</summary>
        string LinuxProfileAdminUsername { get; set; }
        /// <summary>The SSH configuration for Linux-based VMs running on Azure.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IContainerServiceSshConfiguration LinuxProfileSsh { get; set; }
        /// <summary>The max number of agent pools for the managed cluster.</summary>
        int? MaxAgentPool { get; set; }
        /// <summary>
        /// Whether to enable or disable the Azure Managed Prometheus addon for Prometheus monitoring. See aka.ms/AzureManagedPrometheus-aks-enable
        /// for details on enabling and disabling.
        /// </summary>
        bool? MetricEnabled { get; set; }
        /// <summary>
        /// Kube State Metrics profile for the Azure Managed Prometheus addon. These optional settings are for the kube-state-metrics
        /// pod that is deployed with the addon. See aka.ms/AzureManagedPrometheus-optional-parameters for details.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterAzureMonitorProfileKubeStateMetrics MetricKubeStateMetric { get; set; }
        /// <summary>The network configuration profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IContainerServiceNetworkProfile NetworkProfile { get; set; }
        /// <summary>The name of the resource group containing agent pool nodes.</summary>
        string NodeResourceGroup { get; set; }
        /// <summary>The OIDC issuer profile of the Managed Cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterOidcIssuerProfile OidcIssuerProfile { get; set; }
        /// <summary>Whether the OIDC issuer is enabled.</summary>
        bool? OidcIssuerProfileEnabled { get; set; }
        /// <summary>The OIDC issuer url of the Managed Cluster.</summary>
        string OidcIssuerProfileIssuerUrl { get; set; }
        /// <summary>
        /// See [use AAD pod identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity) for more details on AAD pod
        /// identity integration.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPodIdentityProfile PodIdentityProfile { get; set; }
        /// <summary>
        /// Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing.
        /// See [using Kubenet network plugin with AAD Pod Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities)
        /// for more information.
        /// </summary>
        bool? PodIdentityProfileAllowNetworkPluginKubenet { get; set; }
        /// <summary>Whether the pod identity addon is enabled.</summary>
        bool? PodIdentityProfileEnabled { get; set; }
        /// <summary>The pod identities to use in the cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPodIdentity[] PodIdentityProfileUserAssignedIdentity { get; set; }
        /// <summary>The pod identity exceptions to allow.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterPodIdentityException[] PodIdentityProfileUserAssignedIdentityException { get; set; }
        /// <summary>The Power State of the cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IPowerState PowerState { get; set; }
        /// <summary>Tells whether the cluster is Running or Stopped</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.Code? PowerStateCode { get; set; }
        /// <summary>The FQDN of private cluster.</summary>
        string PrivateFqdn { get; set; }
        /// <summary>Private link resources associated with the cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IPrivateLinkResource[] PrivateLinkResource { get; set; }
        /// <summary>Properties of a managed cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterProperties Property { get; set; }
        /// <summary>The current provisioning state.</summary>
        string ProvisioningState { get; set; }
        /// <summary>Allow or deny public network access for AKS</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.PublicNetworkAccess? PublicNetworkAccess { get; set; }
        /// <summary>Whether to enable Defender threat detection</summary>
        bool? SecurityMonitoringEnabled { get; set; }
        /// <summary>Security profile for the managed cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSecurityProfile SecurityProfile { get; set; }
        /// <summary>
        /// Azure Key Vault [key management service](https://kubernetes.io/docs/tasks/administer-cluster/kms-provider/) settings for
        /// the security profile.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IAzureKeyVaultKms SecurityProfileAzureKeyVaultKm { get; set; }
        /// <summary>Microsoft Defender settings for the security profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSecurityProfileDefender SecurityProfileDefender { get; set; }
        /// <summary>Image Cleaner settings for the security profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSecurityProfileImageCleaner SecurityProfileImageCleaner { get; set; }
        /// <summary>
        /// Workload identity settings for the security profile. Workload identity enables Kubernetes applications to access Azure
        /// cloud resources securely with Azure AD. See https://aka.ms/aks/wi for more details.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSecurityProfileWorkloadIdentity SecurityProfileWorkloadIdentity { get; set; }
        /// <summary>
        /// Information about a service principal identity for the cluster to use for manipulating Azure APIs.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterServicePrincipalProfile ServicePrincipalProfile { get; set; }
        /// <summary>The ID for the service principal.</summary>
        string ServicePrincipalProfileClientId { get; set; }
        /// <summary>The secret password associated with the service principal in plain text.</summary>
        string ServicePrincipalProfileSecret { get; set; }
        /// <summary>The managed cluster SKU.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterSku Sku { get; set; }
        /// <summary>The name of a managed cluster SKU.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ManagedClusterSkuName? SkuName { get; set; }
        /// <summary>
        /// If not specified, the default is 'Free'. See [AKS Pricing Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers)
        /// for more details.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.ManagedClusterSkuTier? SkuTier { get; set; }
        /// <summary>Whether to enable Snapshot Controller. The default value is true.</summary>
        bool? SnapshotControllerEnabled { get; set; }
        /// <summary>
        /// The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IContainerServiceSshPublicKey[] SshPublicKey { get; set; }
        /// <summary>Storage profile for the managed cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterStorageProfile StorageProfile { get; set; }
        /// <summary>AzureBlob CSI Driver settings for the storage profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterStorageProfileBlobCsiDriver StorageProfileBlobCsiDriver { get; set; }
        /// <summary>AzureDisk CSI Driver settings for the storage profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterStorageProfileDiskCsiDriver StorageProfileDiskCsiDriver { get; set; }
        /// <summary>AzureFile CSI Driver settings for the storage profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterStorageProfileFileCsiDriver StorageProfileFileCsiDriver { get; set; }
        /// <summary>Snapshot Controller settings for the storage profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterStorageProfileSnapshotController StorageProfileSnapshotController { get; set; }
        /// <summary>
        /// Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:**
        /// 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters
        /// <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:**
        /// "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
        /// </summary>
        string WindowProfileAdminPassword { get; set; }
        /// <summary>
        /// Specifies the name of the administrator account. <br><br> **Restriction:** Cannot end in "." <br><br> **Disallowed values:**
        /// "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm",
        /// "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server", "sql", "support", "support_388945a0",
        /// "sys", "test2", "test3", "user4", "user5". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters
        /// </summary>
        string WindowProfileAdminUsername { get; set; }
        /// <summary>
        /// For more details on CSI proxy, see the [CSI proxy GitHub repo](https://github.com/kubernetes-csi/csi-proxy).
        /// </summary>
        bool? WindowProfileEnableCsiProxy { get; set; }
        /// <summary>The Windows gMSA Profile in the Managed Cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IWindowsGmsaProfile WindowProfileGmsaProfile { get; set; }
        /// <summary>
        /// The license type to use for Windows VMs. See [Azure Hybrid User Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/)
        /// for more details.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Support.LicenseType? WindowProfileLicenseType { get; set; }
        /// <summary>The profile for Windows VMs in the Managed Cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterWindowsProfile WindowsProfile { get; set; }
        /// <summary>Workload Auto-scaler profile for the managed cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterWorkloadAutoScalerProfile WorkloadAutoScalerProfile { get; set; }
        /// <summary>
        /// KEDA (Kubernetes Event-driven Autoscaling) settings for the workload auto-scaler profile.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Aks.Models.Api20230201.IManagedClusterWorkloadAutoScalerProfileKeda WorkloadAutoScalerProfileKeda { get; set; }
        /// <summary>Whether to enable workload identity.</summary>
        bool? WorkloadIdentityEnabled { get; set; }

    }
}