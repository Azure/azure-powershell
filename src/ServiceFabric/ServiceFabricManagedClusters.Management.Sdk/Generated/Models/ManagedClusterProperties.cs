// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.Management.ServiceFabricManagedClusters.Models
{
    using System.Linq;

    /// <summary>
    /// Describes the managed cluster resource properties.
    /// </summary>
    public partial class ManagedClusterProperties
    {
        /// <summary>
        /// Initializes a new instance of the ManagedClusterProperties class.
        /// </summary>
        public ManagedClusterProperties()
        {
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the ManagedClusterProperties class.
        /// </summary>

        /// <param name="dnsName">The cluster dns name.
        /// </param>

        /// <param name="fqdn">The fully qualified domain name associated with the public load balancer of
        /// the cluster.
        /// </param>

        /// <param name="ipv4Address">The IPv4 address associated with the public load balancer of the cluster.
        /// </param>

        /// <param name="clusterId">A service generated unique identifier for the cluster resource.
        /// </param>

        /// <param name="clusterState">The current state of the cluster.
        /// Possible values include: 'WaitingForNodes', 'Deploying', 'BaselineUpgrade',
        /// 'Upgrading', 'UpgradeFailed', 'Ready'</param>

        /// <param name="clusterCertificateThumbprints">List of thumbprints of the cluster certificates.
        /// </param>

        /// <param name="clientConnectionPort">The port used for client connections to the cluster.
        /// </param>

        /// <param name="httpGatewayConnectionPort">The port used for HTTP connections to the cluster.
        /// </param>

        /// <param name="adminUserName">VM admin user name.
        /// </param>

        /// <param name="adminPassword">VM admin user password.
        /// </param>

        /// <param name="loadBalancingRules">Load balancing rules that are applied to the public load balancer of the
        /// cluster.
        /// </param>

        /// <param name="allowRdpAccess">Setting this to true enables RDP access to the VM. The default NSG rule
        /// opens RDP port to Internet which can be overridden with custom Network
        /// Security Rules. The default value for this setting is false.
        /// </param>

        /// <param name="networkSecurityRules">Custom Network Security Rules that are applied to the Virtual Network of
        /// the cluster.
        /// </param>

        /// <param name="clients">Client certificates that are allowed to manage the cluster.
        /// </param>

        /// <param name="azureActiveDirectory">The AAD authentication settings of the cluster.
        /// </param>

        /// <param name="fabricSettings">The list of custom fabric settings to configure the cluster.
        /// </param>

        /// <param name="provisioningState">The provisioning state of the managed cluster resource.
        /// Possible values include: 'None', 'Creating', 'Created', 'Updating',
        /// 'Succeeded', 'Failed', 'Canceled', 'Deleting', 'Deleted', 'Other'</param>

        /// <param name="clusterCodeVersion">The Service Fabric runtime version of the cluster. This property is
        /// required when **clusterUpgradeMode** is set to &#39;Manual&#39;. To get list of
        /// available Service Fabric versions for new clusters use [ClusterVersion
        /// API](./ClusterVersion.md). To get the list of available version for
        /// existing clusters use **availableClusterVersions**.
        /// </param>

        /// <param name="clusterUpgradeMode">The upgrade mode of the cluster when new Service Fabric runtime version is
        /// available.
        /// Possible values include: 'Automatic', 'Manual'</param>

        /// <param name="clusterUpgradeCadence">Indicates when new cluster runtime version upgrades will be applied after
        /// they are released. By default is Wave0. Only applies when
        /// **clusterUpgradeMode** is set to &#39;Automatic&#39;.
        /// Possible values include: 'Wave0', 'Wave1', 'Wave2'</param>

        /// <param name="addonFeatures">List of add-on features to enable on the cluster.
        /// </param>

        /// <param name="enableAutoOSUpgrade">Setting this to true enables automatic OS upgrade for the node types that
        /// are created using any platform OS image with version &#39;latest&#39;. The default
        /// value for this setting is false.
        /// </param>

        /// <param name="zonalResiliency">Indicates if the cluster has zone resiliency.
        /// </param>

        /// <param name="applicationTypeVersionsCleanupPolicy">The policy used to clean up unused versions.
        /// </param>

        /// <param name="enableIpv6">Setting this to true creates IPv6 address space for the default VNet used
        /// by the cluster. This setting cannot be changed once the cluster is created.
        /// The default value for this setting is false.
        /// </param>

        /// <param name="subnetId">If specified, the node types for the cluster are created in this subnet
        /// instead of the default VNet. The **networkSecurityRules** specified for the
        /// cluster are also applied to this subnet. This setting cannot be changed
        /// once the cluster is created.
        /// </param>

        /// <param name="ipTags">The list of IP tags associated with the default public IP address of the
        /// cluster.
        /// </param>

        /// <param name="ipv6Address">IPv6 address for the cluster if IPv6 is enabled.
        /// </param>

        /// <param name="enableServicePublicIP">Setting this to true will link the IPv4 address as the ServicePublicIP of
        /// the IPv6 address. It can only be set to True if IPv6 is enabled on the
        /// cluster.
        /// </param>

        /// <param name="auxiliarySubnets">Auxiliary subnets for the cluster.
        /// </param>

        /// <param name="serviceEndpoints">Service endpoints for subnets in the cluster.
        /// </param>

        /// <param name="zonalUpdateMode">Indicates the update mode for Cross Az clusters.
        /// Possible values include: 'Standard', 'Fast'</param>

        /// <param name="useCustomVnet">For new clusters, this parameter indicates that it uses Bring your own
        /// VNet, but the subnet is specified at node type level; and for such
        /// clusters, the subnetId property is required for node types.
        /// </param>

        /// <param name="publicIPPrefixId">Specify the resource id of a public IP prefix that the load balancer will
        /// allocate a public IP address from. Only supports IPv4.
        /// </param>
        public ManagedClusterProperties(string dnsName, string adminUserName, string fqdn = default(string), string ipv4Address = default(string), string clusterId = default(string), string clusterState = default(string), System.Collections.Generic.IList<string> clusterCertificateThumbprints = default(System.Collections.Generic.IList<string>), int? clientConnectionPort = default(int?), int? httpGatewayConnectionPort = default(int?), string adminPassword = default(string), System.Collections.Generic.IList<LoadBalancingRule> loadBalancingRules = default(System.Collections.Generic.IList<LoadBalancingRule>), bool? allowRdpAccess = default(bool?), System.Collections.Generic.IList<NetworkSecurityRule> networkSecurityRules = default(System.Collections.Generic.IList<NetworkSecurityRule>), System.Collections.Generic.IList<ClientCertificate> clients = default(System.Collections.Generic.IList<ClientCertificate>), AzureActiveDirectory azureActiveDirectory = default(AzureActiveDirectory), System.Collections.Generic.IList<SettingsSectionDescription> fabricSettings = default(System.Collections.Generic.IList<SettingsSectionDescription>), string provisioningState = default(string), string clusterCodeVersion = default(string), string clusterUpgradeMode = default(string), string clusterUpgradeCadence = default(string), System.Collections.Generic.IList<string> addonFeatures = default(System.Collections.Generic.IList<string>), bool? enableAutoOSUpgrade = default(bool?), bool? zonalResiliency = default(bool?), ApplicationTypeVersionsCleanupPolicy applicationTypeVersionsCleanupPolicy = default(ApplicationTypeVersionsCleanupPolicy), bool? enableIpv6 = default(bool?), string subnetId = default(string), System.Collections.Generic.IList<IPTag> ipTags = default(System.Collections.Generic.IList<IPTag>), string ipv6Address = default(string), bool? enableServicePublicIP = default(bool?), System.Collections.Generic.IList<Subnet> auxiliarySubnets = default(System.Collections.Generic.IList<Subnet>), System.Collections.Generic.IList<ServiceEndpoint> serviceEndpoints = default(System.Collections.Generic.IList<ServiceEndpoint>), string zonalUpdateMode = default(string), bool? useCustomVnet = default(bool?), string publicIPPrefixId = default(string))

        {
            this.DnsName = dnsName;
            this.Fqdn = fqdn;
            this.Ipv4Address = ipv4Address;
            this.ClusterId = clusterId;
            this.ClusterState = clusterState;
            this.ClusterCertificateThumbprints = clusterCertificateThumbprints;
            this.ClientConnectionPort = clientConnectionPort;
            this.HttpGatewayConnectionPort = httpGatewayConnectionPort;
            this.AdminUserName = adminUserName;
            this.AdminPassword = adminPassword;
            this.LoadBalancingRules = loadBalancingRules;
            this.AllowRdpAccess = allowRdpAccess;
            this.NetworkSecurityRules = networkSecurityRules;
            this.Clients = clients;
            this.AzureActiveDirectory = azureActiveDirectory;
            this.FabricSettings = fabricSettings;
            this.ProvisioningState = provisioningState;
            this.ClusterCodeVersion = clusterCodeVersion;
            this.ClusterUpgradeMode = clusterUpgradeMode;
            this.ClusterUpgradeCadence = clusterUpgradeCadence;
            this.AddonFeatures = addonFeatures;
            this.EnableAutoOSUpgrade = enableAutoOSUpgrade;
            this.ZonalResiliency = zonalResiliency;
            this.ApplicationTypeVersionsCleanupPolicy = applicationTypeVersionsCleanupPolicy;
            this.EnableIpv6 = enableIpv6;
            this.SubnetId = subnetId;
            this.IPTags = ipTags;
            this.Ipv6Address = ipv6Address;
            this.EnableServicePublicIP = enableServicePublicIP;
            this.AuxiliarySubnets = auxiliarySubnets;
            this.ServiceEndpoints = serviceEndpoints;
            this.ZonalUpdateMode = zonalUpdateMode;
            this.UseCustomVnet = useCustomVnet;
            this.PublicIPPrefixId = publicIPPrefixId;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();


        /// <summary>
        /// Gets or sets the cluster dns name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "dnsName")]
        public string DnsName {get; set; }

        /// <summary>
        /// Gets the fully qualified domain name associated with the public load
        /// balancer of the cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "fqdn")]
        public string Fqdn {get; private set; }

        /// <summary>
        /// Gets the IPv4 address associated with the public load balancer of the
        /// cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "ipv4Address")]
        public string Ipv4Address {get; private set; }

        /// <summary>
        /// Gets a service generated unique identifier for the cluster resource.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "clusterId")]
        public string ClusterId {get; private set; }

        /// <summary>
        /// Gets the current state of the cluster. Possible values include: &#39;WaitingForNodes&#39;, &#39;Deploying&#39;, &#39;BaselineUpgrade&#39;, &#39;Upgrading&#39;, &#39;UpgradeFailed&#39;, &#39;Ready&#39;
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "clusterState")]
        public string ClusterState {get; private set; }

        /// <summary>
        /// Gets list of thumbprints of the cluster certificates.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "clusterCertificateThumbprints")]
        public System.Collections.Generic.IList<string> ClusterCertificateThumbprints {get; private set; }

        /// <summary>
        /// Gets or sets the port used for client connections to the cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "clientConnectionPort")]
        public int? ClientConnectionPort {get; set; }

        /// <summary>
        /// Gets or sets the port used for HTTP connections to the cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "httpGatewayConnectionPort")]
        public int? HttpGatewayConnectionPort {get; set; }

        /// <summary>
        /// Gets or sets vM admin user name.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "adminUserName")]
        public string AdminUserName {get; set; }

        /// <summary>
        /// Gets or sets vM admin user password.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "adminPassword")]
        public string AdminPassword {get; set; }

        /// <summary>
        /// Gets or sets load balancing rules that are applied to the public load
        /// balancer of the cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "loadBalancingRules")]
        public System.Collections.Generic.IList<LoadBalancingRule> LoadBalancingRules {get; set; }

        /// <summary>
        /// Gets or sets setting this to true enables RDP access to the VM. The default
        /// NSG rule opens RDP port to Internet which can be overridden with custom
        /// Network Security Rules. The default value for this setting is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "allowRdpAccess")]
        public bool? AllowRdpAccess {get; set; }

        /// <summary>
        /// Gets or sets custom Network Security Rules that are applied to the Virtual
        /// Network of the cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "networkSecurityRules")]
        public System.Collections.Generic.IList<NetworkSecurityRule> NetworkSecurityRules {get; set; }

        /// <summary>
        /// Gets or sets client certificates that are allowed to manage the cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "clients")]
        public System.Collections.Generic.IList<ClientCertificate> Clients {get; set; }

        /// <summary>
        /// Gets or sets the AAD authentication settings of the cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "azureActiveDirectory")]
        public AzureActiveDirectory AzureActiveDirectory {get; set; }

        /// <summary>
        /// Gets or sets the list of custom fabric settings to configure the cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "fabricSettings")]
        public System.Collections.Generic.IList<SettingsSectionDescription> FabricSettings {get; set; }

        /// <summary>
        /// Gets the provisioning state of the managed cluster resource. Possible values include: &#39;None&#39;, &#39;Creating&#39;, &#39;Created&#39;, &#39;Updating&#39;, &#39;Succeeded&#39;, &#39;Failed&#39;, &#39;Canceled&#39;, &#39;Deleting&#39;, &#39;Deleted&#39;, &#39;Other&#39;
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "provisioningState")]
        public string ProvisioningState {get; private set; }

        /// <summary>
        /// Gets or sets the Service Fabric runtime version of the cluster. This
        /// property is required when **clusterUpgradeMode** is set to &#39;Manual&#39;. To get
        /// list of available Service Fabric versions for new clusters use
        /// [ClusterVersion API](./ClusterVersion.md). To get the list of available
        /// version for existing clusters use **availableClusterVersions**.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "clusterCodeVersion")]
        public string ClusterCodeVersion {get; set; }

        /// <summary>
        /// Gets or sets the upgrade mode of the cluster when new Service Fabric
        /// runtime version is available. Possible values include: &#39;Automatic&#39;, &#39;Manual&#39;
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "clusterUpgradeMode")]
        public string ClusterUpgradeMode {get; set; }

        /// <summary>
        /// Gets or sets indicates when new cluster runtime version upgrades will be
        /// applied after they are released. By default is Wave0. Only applies when
        /// **clusterUpgradeMode** is set to &#39;Automatic&#39;. Possible values include: &#39;Wave0&#39;, &#39;Wave1&#39;, &#39;Wave2&#39;
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "clusterUpgradeCadence")]
        public string ClusterUpgradeCadence {get; set; }

        /// <summary>
        /// Gets or sets list of add-on features to enable on the cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "addonFeatures")]
        public System.Collections.Generic.IList<string> AddonFeatures {get; set; }

        /// <summary>
        /// Gets or sets setting this to true enables automatic OS upgrade for the node
        /// types that are created using any platform OS image with version &#39;latest&#39;.
        /// The default value for this setting is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "enableAutoOSUpgrade")]
        public bool? EnableAutoOSUpgrade {get; set; }

        /// <summary>
        /// Gets or sets indicates if the cluster has zone resiliency.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "zonalResiliency")]
        public bool? ZonalResiliency {get; set; }

        /// <summary>
        /// Gets or sets the policy used to clean up unused versions.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "applicationTypeVersionsCleanupPolicy")]
        public ApplicationTypeVersionsCleanupPolicy ApplicationTypeVersionsCleanupPolicy {get; set; }

        /// <summary>
        /// Gets or sets setting this to true creates IPv6 address space for the
        /// default VNet used by the cluster. This setting cannot be changed once the
        /// cluster is created. The default value for this setting is false.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "enableIpv6")]
        public bool? EnableIpv6 {get; set; }

        /// <summary>
        /// Gets or sets if specified, the node types for the cluster are created in
        /// this subnet instead of the default VNet. The **networkSecurityRules**
        /// specified for the cluster are also applied to this subnet. This setting
        /// cannot be changed once the cluster is created.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "subnetId")]
        public string SubnetId {get; set; }

        /// <summary>
        /// Gets or sets the list of IP tags associated with the default public IP
        /// address of the cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "ipTags")]
        public System.Collections.Generic.IList<IPTag> IPTags {get; set; }

        /// <summary>
        /// Gets iPv6 address for the cluster if IPv6 is enabled.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "ipv6Address")]
        public string Ipv6Address {get; private set; }

        /// <summary>
        /// Gets or sets setting this to true will link the IPv4 address as the
        /// ServicePublicIP of the IPv6 address. It can only be set to True if IPv6 is
        /// enabled on the cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "enableServicePublicIP")]
        public bool? EnableServicePublicIP {get; set; }

        /// <summary>
        /// Gets or sets auxiliary subnets for the cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "auxiliarySubnets")]
        public System.Collections.Generic.IList<Subnet> AuxiliarySubnets {get; set; }

        /// <summary>
        /// Gets or sets service endpoints for subnets in the cluster.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "serviceEndpoints")]
        public System.Collections.Generic.IList<ServiceEndpoint> ServiceEndpoints {get; set; }

        /// <summary>
        /// Gets or sets indicates the update mode for Cross Az clusters. Possible values include: &#39;Standard&#39;, &#39;Fast&#39;
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "zonalUpdateMode")]
        public string ZonalUpdateMode {get; set; }

        /// <summary>
        /// Gets or sets for new clusters, this parameter indicates that it uses Bring
        /// your own VNet, but the subnet is specified at node type level; and for such
        /// clusters, the subnetId property is required for node types.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "useCustomVnet")]
        public bool? UseCustomVnet {get; set; }

        /// <summary>
        /// Gets or sets specify the resource id of a public IP prefix that the load
        /// balancer will allocate a public IP address from. Only supports IPv4.
        /// </summary>
        [Newtonsoft.Json.JsonProperty(PropertyName = "publicIPPrefixId")]
        public string PublicIPPrefixId {get; set; }
        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="Microsoft.Rest.ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (this.DnsName == null)
            {
                throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.CannotBeNull, "DnsName");
            }
            if (this.AdminUserName == null)
            {
                throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.CannotBeNull, "AdminUserName");
            }








            if (this.LoadBalancingRules != null)
            {
                foreach (var element in this.LoadBalancingRules)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }
            if (this.NetworkSecurityRules != null)
            {
                foreach (var element in this.NetworkSecurityRules)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }
            if (this.Clients != null)
            {
                foreach (var element in this.Clients)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }

            if (this.FabricSettings != null)
            {
                foreach (var element in this.FabricSettings)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }





            if (this.ApplicationTypeVersionsCleanupPolicy != null)
            {
                this.ApplicationTypeVersionsCleanupPolicy.Validate();
            }

            if (this.IPTags != null)
            {
                foreach (var element in this.IPTags)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }

            if (this.AuxiliarySubnets != null)
            {
                foreach (var element in this.AuxiliarySubnets)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }
            if (this.ServiceEndpoints != null)
            {
                foreach (var element in this.ServiceEndpoints)
                {
                    if (element != null)
                    {
                        element.Validate();
                    }
                }
            }


        }
    }
}