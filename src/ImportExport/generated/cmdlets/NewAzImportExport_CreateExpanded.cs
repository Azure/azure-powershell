// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Cmdlets
{
    using static Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Extensions;

    /// <summary>Creates a new job or updates an existing job in the specified subscription.</summary>
    /// <remarks>
    /// [OpenAPI] Jobs_Create=>PUT:"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ImportExport/jobs/{jobName}"
    /// </remarks>
    [global::System.Management.Automation.Cmdlet(global::System.Management.Automation.VerbsCommon.New, @"AzImportExport_CreateExpanded", SupportsShouldProcess = true)]
    [global::System.Management.Automation.OutputType(typeof(Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IJobResponse))]
    [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Description(@"Creates a new job or updates an existing job in the specified subscription.")]
    [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Generated]
    public partial class NewAzImportExport_CreateExpanded : global::System.Management.Automation.PSCmdlet,
        Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener
    {
        /// <summary>A unique id generatd for the this cmdlet when it is instantiated.</summary>
        private string __correlationId = System.Guid.NewGuid().ToString();

        /// <summary>A copy of the Invocation Info (necessary to allow asJob to clone this cmdlet)</summary>
        private global::System.Management.Automation.InvocationInfo __invocationInfo;

        /// <summary>A unique id generatd for the this cmdlet when ProcessRecord() is called.</summary>
        private string __processRecordId;

        /// <summary>
        /// The <see cref="global::System.Threading.CancellationTokenSource" /> for this operation.
        /// </summary>
        private global::System.Threading.CancellationTokenSource _cancellationTokenSource = new global::System.Threading.CancellationTokenSource();

        /// <summary>Backing field for <see cref="AcceptLanguage" /> property.</summary>
        private string _acceptLanguage;

        /// <summary>Specifies the preferred language for the response.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the preferred language for the response.")]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the preferred language for the response.",
        SerializedName = @"Accept-Language",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Header)]
        public string AcceptLanguage { get => this._acceptLanguage; set => this._acceptLanguage = value; }

        /// <summary>
        /// Default value is false. Indicates whether the manifest files on the drives should be copied to block blobs.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Default value is false. Indicates whether the manifest files on the drives should be copied to block blobs.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Default value is false. Indicates whether the manifest files on the drives should be copied to block blobs.",
        SerializedName = @"backupDriveManifest",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter BackupDriveManifest { get => Body.BackupDriveManifest ?? default(global::System.Management.Automation.SwitchParameter); set => Body.BackupDriveManifest = value; }

        /// <summary>A collection of blob-path strings.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "A collection of blob-path strings.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A collection of blob-path strings.",
        SerializedName = @"blobPath",
        PossibleTypes = new [] { typeof(string) })]
        public string[] BlobListBlobPath { get => Body.BlobListBlobPath ?? null /* arrayOf */; set => Body.BlobListBlobPath = value; }

        /// <summary>A collection of blob-prefix strings.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "A collection of blob-prefix strings.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A collection of blob-prefix strings.",
        SerializedName = @"blobPathPrefix",
        PossibleTypes = new [] { typeof(string) })]
        public string[] BlobListBlobPathPrefix { get => Body.BlobListBlobPathPrefix ?? null /* arrayOf */; set => Body.BlobListBlobPathPrefix = value; }

        /// <summary>Backing field for <see cref="Body" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IPutJobParameters _body= new Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.PutJobParameters();

        /// <summary>Put Job parameters</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IPutJobParameters Body { get => this._body; set => this._body = value; }

        /// <summary>Wait for .NET debugger to attach</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Wait for .NET debugger to attach")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter Break { get; set; }

        /// <summary>Indicates whether a request has been submitted to cancel the job.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Indicates whether a request has been submitted to cancel the job.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether a request has been submitted to cancel the job.",
        SerializedName = @"cancelRequested",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter CancelRequested { get => Body.CancelRequested ?? default(global::System.Management.Automation.SwitchParameter); set => Body.CancelRequested = value; }

        /// <summary>The reference to the client API class.</summary>
        public Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ImportExport Client => Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Module.Instance.ClientAPI;

        /// <summary>Backing field for <see cref="ClientTenantId" /> property.</summary>
        private string _clientTenantId;

        /// <summary>The tenant ID of the client making the request.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The tenant ID of the client making the request.")]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The tenant ID of the client making the request.",
        SerializedName = @"x-ms-client-tenant-id",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Header)]
        public string ClientTenantId { get => this._clientTenantId; set => this._clientTenantId = value; }

        /// <summary>
        /// The credentials, account, tenant, and subscription used for communication with Azure
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The credentials, account, tenant, and subscription used for communication with Azure.")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::System.Management.Automation.Alias("AzureRMContext", "AzureCredential")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Azure)]
        public global::System.Management.Automation.PSObject DefaultProfile { get; set; }

        /// <summary>The name of the carrier that is used to ship the import or export drives.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The name of the carrier that is used to ship the import or export drives.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the carrier that is used to ship the import or export drives.",
        SerializedName = @"carrierName",
        PossibleTypes = new [] { typeof(string) })]
        public string DeliveryPackageCarrierName { get => Body.DeliveryPackageCarrierName ?? null; set => Body.DeliveryPackageCarrierName = value; }

        /// <summary>The number of drives included in the package.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The number of drives included in the package.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The number of drives included in the package.",
        SerializedName = @"driveCount",
        PossibleTypes = new [] { typeof(int) })]
        public int DeliveryPackageDriveCount { get => Body.DeliveryPackageDriveCount; set => Body.DeliveryPackageDriveCount = value; }

        /// <summary>The date when the package is shipped.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The date when the package is shipped.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The date when the package is shipped.",
        SerializedName = @"shipDate",
        PossibleTypes = new [] { typeof(string) })]
        public string DeliveryPackageShipDate { get => Body.DeliveryPackageShipDate ?? null; set => Body.DeliveryPackageShipDate = value; }

        /// <summary>The tracking number of the package.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The tracking number of the package.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The tracking number of the package.",
        SerializedName = @"trackingNumber",
        PossibleTypes = new [] { typeof(string) })]
        public string DeliveryPackageTrackingNumber { get => Body.DeliveryPackageTrackingNumber ?? null; set => Body.DeliveryPackageTrackingNumber = value; }

        /// <summary>
        /// The virtual blob directory to which the copy logs and backups of drive manifest files (if enabled) will be stored.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The virtual blob directory to which the copy logs and backups of drive manifest files (if enabled) will be stored.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The virtual blob directory to which the copy logs and backups of drive manifest files (if enabled) will be stored.",
        SerializedName = @"diagnosticsPath",
        PossibleTypes = new [] { typeof(string) })]
        public string DiagnosticsPath { get => Body.DiagnosticsPath ?? null; set => Body.DiagnosticsPath = value; }

        /// <summary>
        /// List of up to ten drives that comprise the job. The drive list is a required element for an import job; it is not specified
        /// for export jobs.
        /// </summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "List of up to ten drives that comprise the job. The drive list is a required element for an import job; it is not specified for export jobs.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"List of up to ten drives that comprise the job. The drive list is a required element for an import job; it is not specified for export jobs.",
        SerializedName = @"driveList",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IDriveStatus) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IDriveStatus[] DriveList { get => Body.DriveList ?? null /* arrayOf */; set => Body.DriveList = value; }

        /// <summary>
        /// The relative URI to the block blob that contains the list of blob paths or blob path prefixes as defined above, beginning
        /// with the container name. If the blob is in root container, the URI must begin with $root.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The relative URI to the block blob that contains the list of blob paths or blob path prefixes as defined above, beginning with the container name. If the blob is in root container, the URI must begin with $root. ")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The relative URI to the block blob that contains the list of blob paths or blob path prefixes as defined above, beginning with the container name. If the blob is in root container, the URI must begin with $root. ",
        SerializedName = @"blobListblobPath",
        PossibleTypes = new [] { typeof(string) })]
        public string ExportBlobListblobPath { get => Body.ExportBlobListblobPath ?? null; set => Body.ExportBlobListblobPath = value; }

        /// <summary>SendAsync Pipeline Steps to be appended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be appended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Runtime)]
        public Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.SendAsyncStep[] HttpPipelineAppend { get; set; }

        /// <summary>SendAsync Pipeline Steps to be prepended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be prepended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Runtime)]
        public Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.SendAsyncStep[] HttpPipelinePrepend { get; set; }

        /// <summary>
        /// A blob path that points to a block blob containing a list of blob names that were not exported due to insufficient drive
        /// space. If all blobs were exported successfully, then this element is not included in the response.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "A blob path that points to a block blob containing a list of blob names that were not exported due to insufficient drive space. If all blobs were exported successfully, then this element is not included in the response.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A blob path that points to a block blob containing a list of blob names that were not exported due to insufficient drive space. If all blobs were exported successfully, then this element is not included in the response.",
        SerializedName = @"incompleteBlobListUri",
        PossibleTypes = new [] { typeof(string) })]
        public string IncompleteBlobListUri { get => Body.IncompleteBlobListUri ?? null; set => Body.IncompleteBlobListUri = value; }

        /// <summary>Accessor for our copy of the InvocationInfo.</summary>
        public global::System.Management.Automation.InvocationInfo InvocationInformation { get => __invocationInfo = __invocationInfo ?? this.MyInvocation ; set { __invocationInfo = value; } }

        /// <summary>The type of job</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The type of job")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The type of job",
        SerializedName = @"jobType",
        PossibleTypes = new [] { typeof(string) })]
        public string JobType { get => Body.JobType ?? null; set => Body.JobType = value; }

        /// <summary>Specifies the supported Azure location where the job should be created</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the supported Azure location where the job should be created")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the supported Azure location where the job should be created",
        SerializedName = @"location",
        PossibleTypes = new [] { typeof(string) })]
        public string Location { get => Body.Location ?? null; set => Body.Location = value; }

        /// <summary>
        /// Default value is Error. Indicates whether error logging or verbose logging will be enabled.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Default value is Error. Indicates whether error logging or verbose logging will be enabled.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Default value is Error. Indicates whether error logging or verbose logging will be enabled.",
        SerializedName = @"logLevel",
        PossibleTypes = new [] { typeof(string) })]
        public string LogLevel { get => Body.LogLevel ?? null; set => Body.LogLevel = value; }

        /// <summary>
        /// <see cref="IEventListener" /> cancellation delegate. Stops the cmdlet when called.
        /// </summary>
        global::System.Action Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener.Cancel => _cancellationTokenSource.Cancel;

        /// <summary><see cref="IEventListener" /> cancellation token.</summary>
        global::System.Threading.CancellationToken Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener.Token => _cancellationTokenSource.Token;

        /// <summary>Backing field for <see cref="Name" /> property.</summary>
        private string _name;

        /// <summary>The name of the import/export job.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The name of the import/export job.")]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The name of the import/export job.",
        SerializedName = @"jobName",
        PossibleTypes = new [] { typeof(string) })]
        [global::System.Management.Automation.Alias("JobName")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Path)]
        public string Name { get => this._name; set => this._name = value; }

        /// <summary>Overall percentage completed for the job.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Overall percentage completed for the job.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Overall percentage completed for the job.",
        SerializedName = @"percentComplete",
        PossibleTypes = new [] { typeof(int) })]
        public int PercentComplete { get => Body.PercentComplete ?? default(int); set => Body.PercentComplete = value; }

        /// <summary>
        /// The instance of the <see cref="Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.HttpPipeline" /> that the remote call will use.
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.HttpPipeline Pipeline { get; set; }

        /// <summary>Specifies the provisioning state of the job.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the provisioning state of the job.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the provisioning state of the job.",
        SerializedName = @"provisioningState",
        PossibleTypes = new [] { typeof(string) })]
        public string ProvisioningState { get => Body.ProvisioningState ?? null; set => Body.ProvisioningState = value; }

        /// <summary>The URI for the proxy server to use</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "The URI for the proxy server to use")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Runtime)]
        public global::System.Uri Proxy { get; set; }

        /// <summary>Credentials for a proxy server to use for the remote call</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Credentials for a proxy server to use for the remote call")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Runtime)]
        public global::System.Management.Automation.PSCredential ProxyCredential { get; set; }

        /// <summary>Use the default credentials for the proxy</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Use the default credentials for the proxy")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter ProxyUseDefaultCredentials { get; set; }

        /// <summary>Backing field for <see cref="ResourceGroupName" /> property.</summary>
        private string _resourceGroupName;

        /// <summary>
        /// The resource group name uniquely identifies the resource group within the user subscription.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The resource group name uniquely identifies the resource group within the user subscription.")]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The resource group name uniquely identifies the resource group within the user subscription.",
        SerializedName = @"resourceGroupName",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Path)]
        public string ResourceGroupName { get => this._resourceGroupName; set => this._resourceGroupName = value; }

        /// <summary>The city name to use when returning the drives.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The city name to use when returning the drives.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The city name to use when returning the drives.",
        SerializedName = @"city",
        PossibleTypes = new [] { typeof(string) })]
        public string ReturnAddressCity { get => Body.ReturnAddressCity ?? null; set => Body.ReturnAddressCity = value; }

        /// <summary>The country or region to use when returning the drives.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The country or region to use when returning the drives. ")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The country or region to use when returning the drives. ",
        SerializedName = @"countryOrRegion",
        PossibleTypes = new [] { typeof(string) })]
        public string ReturnAddressCountryOrRegion { get => Body.ReturnAddressCountryOrRegion ?? null; set => Body.ReturnAddressCountryOrRegion = value; }

        /// <summary>Email address of the recipient of the returned drives.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Email address of the recipient of the returned drives.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Email address of the recipient of the returned drives.",
        SerializedName = @"email",
        PossibleTypes = new [] { typeof(string) })]
        public string ReturnAddressEmail { get => Body.ReturnAddressEmail ?? null; set => Body.ReturnAddressEmail = value; }

        /// <summary>Phone number of the recipient of the returned drives.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Phone number of the recipient of the returned drives.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Phone number of the recipient of the returned drives.",
        SerializedName = @"phone",
        PossibleTypes = new [] { typeof(string) })]
        public string ReturnAddressPhone { get => Body.ReturnAddressPhone ?? null; set => Body.ReturnAddressPhone = value; }

        /// <summary>The postal code to use when returning the drives.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The postal code to use when returning the drives.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The postal code to use when returning the drives.",
        SerializedName = @"postalCode",
        PossibleTypes = new [] { typeof(string) })]
        public string ReturnAddressPostalCode { get => Body.ReturnAddressPostalCode ?? null; set => Body.ReturnAddressPostalCode = value; }

        /// <summary>
        /// The name of the recipient who will receive the hard drives when they are returned.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The name of the recipient who will receive the hard drives when they are returned. ")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the recipient who will receive the hard drives when they are returned. ",
        SerializedName = @"recipientName",
        PossibleTypes = new [] { typeof(string) })]
        public string ReturnAddressRecipientName { get => Body.ReturnAddressRecipientName ?? null; set => Body.ReturnAddressRecipientName = value; }

        /// <summary>The state or province to use when returning the drives.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The state or province to use when returning the drives.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The state or province to use when returning the drives.",
        SerializedName = @"stateOrProvince",
        PossibleTypes = new [] { typeof(string) })]
        public string ReturnAddressStateOrProvince { get => Body.ReturnAddressStateOrProvince ?? null; set => Body.ReturnAddressStateOrProvince = value; }

        /// <summary>The first line of the street address to use when returning the drives.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The first line of the street address to use when returning the drives. ")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The first line of the street address to use when returning the drives. ",
        SerializedName = @"streetAddress1",
        PossibleTypes = new [] { typeof(string) })]
        public string ReturnAddressStreetAddress1 { get => Body.ReturnAddressStreetAddress1 ?? null; set => Body.ReturnAddressStreetAddress1 = value; }

        /// <summary>The second line of the street address to use when returning the drives.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The second line of the street address to use when returning the drives. ")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The second line of the street address to use when returning the drives. ",
        SerializedName = @"streetAddress2",
        PossibleTypes = new [] { typeof(string) })]
        public string ReturnAddressStreetAddress2 { get => Body.ReturnAddressStreetAddress2 ?? null; set => Body.ReturnAddressStreetAddress2 = value; }

        /// <summary>The name of the carrier that is used to ship the import or export drives.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The name of the carrier that is used to ship the import or export drives.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the carrier that is used to ship the import or export drives.",
        SerializedName = @"carrierName",
        PossibleTypes = new [] { typeof(string) })]
        public string ReturnPackageCarrierName { get => Body.ReturnPackageCarrierName ?? null; set => Body.ReturnPackageCarrierName = value; }

        /// <summary>The number of drives included in the package.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The number of drives included in the package.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The number of drives included in the package.",
        SerializedName = @"driveCount",
        PossibleTypes = new [] { typeof(int) })]
        public int ReturnPackageDriveCount { get => Body.ReturnPackageDriveCount; set => Body.ReturnPackageDriveCount = value; }

        /// <summary>The date when the package is shipped.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The date when the package is shipped.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The date when the package is shipped.",
        SerializedName = @"shipDate",
        PossibleTypes = new [] { typeof(string) })]
        public string ReturnPackageShipDate { get => Body.ReturnPackageShipDate ?? null; set => Body.ReturnPackageShipDate = value; }

        /// <summary>The tracking number of the package.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The tracking number of the package.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The tracking number of the package.",
        SerializedName = @"trackingNumber",
        PossibleTypes = new [] { typeof(string) })]
        public string ReturnPackageTrackingNumber { get => Body.ReturnPackageTrackingNumber ?? null; set => Body.ReturnPackageTrackingNumber = value; }

        /// <summary>The customer's account number with the carrier.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The customer's account number with the carrier.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The customer's account number with the carrier.",
        SerializedName = @"carrierAccountNumber",
        PossibleTypes = new [] { typeof(string) })]
        public string ReturnShippingCarrierAccountNumber { get => Body.ReturnShippingCarrierAccountNumber ?? null; set => Body.ReturnShippingCarrierAccountNumber = value; }

        /// <summary>The carrier's name.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The carrier's name.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The carrier's name.",
        SerializedName = @"carrierName",
        PossibleTypes = new [] { typeof(string) })]
        public string ReturnShippingCarrierName { get => Body.ReturnShippingCarrierName ?? null; set => Body.ReturnShippingCarrierName = value; }

        /// <summary>The city name to use when returning the drives.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The city name to use when returning the drives.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The city name to use when returning the drives.",
        SerializedName = @"city",
        PossibleTypes = new [] { typeof(string) })]
        public string ShippingInformationCity { get => Body.ShippingInformationCity ?? null; set => Body.ShippingInformationCity = value; }

        /// <summary>The country or region to use when returning the drives.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The country or region to use when returning the drives. ")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The country or region to use when returning the drives. ",
        SerializedName = @"countryOrRegion",
        PossibleTypes = new [] { typeof(string) })]
        public string ShippingInformationCountryOrRegion { get => Body.ShippingInformationCountryOrRegion ?? null; set => Body.ShippingInformationCountryOrRegion = value; }

        /// <summary>Phone number of the recipient of the returned drives.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Phone number of the recipient of the returned drives.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Phone number of the recipient of the returned drives.",
        SerializedName = @"phone",
        PossibleTypes = new [] { typeof(string) })]
        public string ShippingInformationPhone { get => Body.ShippingInformationPhone ?? null; set => Body.ShippingInformationPhone = value; }

        /// <summary>The postal code to use when returning the drives.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The postal code to use when returning the drives.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The postal code to use when returning the drives.",
        SerializedName = @"postalCode",
        PossibleTypes = new [] { typeof(string) })]
        public string ShippingInformationPostalCode { get => Body.ShippingInformationPostalCode ?? null; set => Body.ShippingInformationPostalCode = value; }

        /// <summary>
        /// The name of the recipient who will receive the hard drives when they are returned.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The name of the recipient who will receive the hard drives when they are returned. ")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the recipient who will receive the hard drives when they are returned. ",
        SerializedName = @"recipientName",
        PossibleTypes = new [] { typeof(string) })]
        public string ShippingInformationRecipientName { get => Body.ShippingInformationRecipientName ?? null; set => Body.ShippingInformationRecipientName = value; }

        /// <summary>The state or province to use when returning the drives.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The state or province to use when returning the drives.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The state or province to use when returning the drives.",
        SerializedName = @"stateOrProvince",
        PossibleTypes = new [] { typeof(string) })]
        public string ShippingInformationStateOrProvince { get => Body.ShippingInformationStateOrProvince ?? null; set => Body.ShippingInformationStateOrProvince = value; }

        /// <summary>The first line of the street address to use when returning the drives.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The first line of the street address to use when returning the drives. ")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The first line of the street address to use when returning the drives. ",
        SerializedName = @"streetAddress1",
        PossibleTypes = new [] { typeof(string) })]
        public string ShippingInformationStreetAddress1 { get => Body.ShippingInformationStreetAddress1 ?? null; set => Body.ShippingInformationStreetAddress1 = value; }

        /// <summary>The second line of the street address to use when returning the drives.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The second line of the street address to use when returning the drives. ")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The second line of the street address to use when returning the drives. ",
        SerializedName = @"streetAddress2",
        PossibleTypes = new [] { typeof(string) })]
        public string ShippingInformationStreetAddress2 { get => Body.ShippingInformationStreetAddress2 ?? null; set => Body.ShippingInformationStreetAddress2 = value; }

        /// <summary>Current state of the job.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Current state of the job.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Current state of the job.",
        SerializedName = @"state",
        PossibleTypes = new [] { typeof(string) })]
        public string State { get => Body.State ?? null; set => Body.State = value; }

        /// <summary>
        /// The resource identifier of the storage account where data will be imported to or exported from.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The resource identifier of the storage account where data will be imported to or exported from.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The resource identifier of the storage account where data will be imported to or exported from.",
        SerializedName = @"storageAccountId",
        PossibleTypes = new [] { typeof(string) })]
        public string StorageAccountId { get => Body.StorageAccountId ?? null; set => Body.StorageAccountId = value; }

        /// <summary>Backing field for <see cref="SubscriptionId" /> property.</summary>
        private string _subscriptionId;

        /// <summary>The subscription ID for the Azure user.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The subscription ID for the Azure user.")]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The subscription ID for the Azure user.",
        SerializedName = @"subscriptionId",
        PossibleTypes = new [] { typeof(string) })]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.DefaultInfo(
        Name = @"",
        Description =@"",
        Script = @"(Get-AzContext).Subscription.Id")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Path)]
        public string SubscriptionId { get => this._subscriptionId; set => this._subscriptionId = value; }

        /// <summary>Specifies the tags that will be assigned to the job.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the tags that will be assigned to the job.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ImportExport.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the tags that will be assigned to the job.",
        SerializedName = @"tags",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IPutJobParametersTags) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IPutJobParametersTags Tag { get => Body.Tag ?? null /* object */; set => Body.Tag = value; }

        /// <summary>
        /// <c>overrideOnCreated</c> will be called before the regular onCreated has been processed, allowing customization of what
        /// happens on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IJobResponse"
        /// /> from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onCreated method should be processed, or if the method should
        /// return immediately (set to true to skip further processing )</param>

        partial void overrideOnCreated(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IJobResponse> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// <c>overrideOnDefault</c> will be called before the regular onDefault has been processed, allowing customization of what
        /// happens on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IErrorResponse"
        /// /> from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onDefault method should be processed, or if the method should
        /// return immediately (set to true to skip further processing )</param>

        partial void overrideOnDefault(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IErrorResponse> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// <c>overrideOnOk</c> will be called before the regular onOk has been processed, allowing customization of what happens
        /// on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IJobResponse"
        /// /> from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onOk method should be processed, or if the method should return
        /// immediately (set to true to skip further processing )</param>

        partial void overrideOnOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IJobResponse> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// (overrides the default BeginProcessing method in global::System.Management.Automation.PSCmdlet)
        /// </summary>
        protected override void BeginProcessing()
        {
            Module.Instance.SetProxyConfiguration(Proxy, ProxyCredential, ProxyUseDefaultCredentials);
            if (Break)
            {
                Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.AttachDebugger.Break();
            }
            ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Events.CmdletBeginProcessing).Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
        }

        /// <summary>Performs clean-up after the command execution</summary>
        protected override void EndProcessing()
        {
            ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Events.CmdletEndProcessing).Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
        }

        /// <summary>Handles/Dispatches events during the call to the REST service.</summary>
        /// <param name="id">The message id</param>
        /// <param name="token">The message cancellation token. When this call is cancelled, this should be <c>true</c></param>
        /// <param name="messageData">Detailed message data for the message event.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the message is completed.
        /// </returns>
         async global::System.Threading.Tasks.Task Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener.Signal(string id, global::System.Threading.CancellationToken token, global::System.Func<Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.EventData> messageData)
        {
            using( NoSynchronizationContext )
            {
                if (token.IsCancellationRequested)
                {
                    return ;
                }

                switch ( id )
                {
                    case Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Events.Verbose:
                    {
                        WriteVerbose($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Events.Warning:
                    {
                        WriteWarning($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Events.Information:
                    {
                        var data = messageData();
                        WriteInformation(data, new[] { data.Message });
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Events.Debug:
                    {
                        WriteDebug($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Events.Error:
                    {
                        WriteError(new global::System.Management.Automation.ErrorRecord( new global::System.Exception(messageData().Message), string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null ) );
                        return ;
                    }
                }
                await Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Module.Instance.Signal(id, token, messageData, (i,t,m) => ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Signal(i,t,()=> Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.EventDataConverter.ConvertFrom( m() ) as Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.EventData ), InvocationInformation, this.ParameterSetName, __correlationId, __processRecordId, null );
                if (token.IsCancellationRequested)
                {
                    return ;
                }
                WriteDebug($"{id}: {(messageData().Message ?? global::System.String.Empty)}");
            }
        }

        /// <summary>
        /// Intializes a new instance of the <see cref="NewAzImportExport_CreateExpanded" /> cmdlet class.
        /// </summary>
        public NewAzImportExport_CreateExpanded()
        {

        }

        /// <summary>Performs execution of the command.</summary>
        protected override void ProcessRecord()
        {
            ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Events.CmdletProcessRecordStart).Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
            __processRecordId = System.Guid.NewGuid().ToString();
            try
            {
                // work
                if (ShouldProcess($"Call remote 'JobsCreate' operation"))
                {
                    using( var asyncCommandRuntime = new Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.PowerShell.AsyncCommandRuntime(this, ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Token) )
                    {
                        asyncCommandRuntime.Wait( ProcessRecordAsync(),((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Token);
                    }
                }
            }
            catch (global::System.AggregateException aggregateException)
            {
                // unroll the inner exceptions to get the root cause
                foreach( var innerException in aggregateException.Flatten().InnerExceptions )
                {
                    ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Events.CmdletException, $"{innerException.GetType().Name} - {innerException.Message} : {innerException.StackTrace}").Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    // Write exception out to error channel.
                    WriteError( new global::System.Management.Automation.ErrorRecord(innerException,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
                }
            }
            catch (global::System.Exception exception) when ((exception as System.Management.Automation.PipelineStoppedException)== null || (exception as System.Management.Automation.PipelineStoppedException).InnerException != null)
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Events.CmdletException, $"{exception.GetType().Name} - {exception.Message} : {exception.StackTrace}").Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                // Write exception out to error channel.
                WriteError( new global::System.Management.Automation.ErrorRecord(exception,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
            }
            finally
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Events.CmdletProcessRecordEnd).Wait();
            }
        }

        /// <summary>Performs execution of the command, working asynchronously if required.</summary>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        protected async global::System.Threading.Tasks.Task ProcessRecordAsync()
        {
            using( NoSynchronizationContext )
            {
                await ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Events.CmdletProcessRecordAsyncStart); if( ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                await ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Events.CmdletGetPipeline); if( ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                Pipeline = Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Module.Instance.CreatePipeline(InvocationInformation, __correlationId, __processRecordId, this.ParameterSetName);
                if (null != HttpPipelinePrepend)
                {
                    Pipeline.Prepend((this.CommandRuntime as Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelinePrepend) ?? HttpPipelinePrepend);
                }
                if (null != HttpPipelineAppend)
                {
                    Pipeline.Append((this.CommandRuntime as Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelineAppend) ?? HttpPipelineAppend);
                }
                // get the client instance
                try
                {
                    await ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Events.CmdletBeforeAPICall); if( ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    await this.Client.JobsCreate(Name, SubscriptionId, ResourceGroupName, this.InvocationInformation.BoundParameters.ContainsKey("AcceptLanguage") ? AcceptLanguage : null, this.InvocationInformation.BoundParameters.ContainsKey("ClientTenantId") ? ClientTenantId : null, Body, onOk, onCreated, onDefault, this, Pipeline);
                    await ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Events.CmdletAfterAPICall); if( ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                }
                catch (Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.UndeclaredResponseException urexception)
                {
                    WriteError(new global::System.Management.Automation.ErrorRecord(urexception, urexception.StatusCode.ToString(), global::System.Management.Automation.ErrorCategory.InvalidOperation, new {  Name=Name,SubscriptionId=SubscriptionId,ResourceGroupName=ResourceGroupName,AcceptLanguage=this.InvocationInformation.BoundParameters.ContainsKey("AcceptLanguage") ? AcceptLanguage : null,ClientTenantId=this.InvocationInformation.BoundParameters.ContainsKey("ClientTenantId") ? ClientTenantId : null,body=Body})
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(urexception.Message) { RecommendedAction = urexception.Action }
                    });
                }
                finally
                {
                    await ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.Events.CmdletProcessRecordAsyncEnd);
                }
            }
        }

        /// <summary>Interrupts currently running code within the command.</summary>
        protected override void StopProcessing()
        {
            ((Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.IEventListener)this).Cancel();
            base.StopProcessing();
        }

        /// <summary>a delegate that is called when the remote service returns 201 (Created).</summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IJobResponse"
        /// /> from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onCreated(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IJobResponse> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnCreated(responseMessage, response, ref _returnNow);
                // if overrideOnCreated has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // onCreated - response for 201 / application/json
                // (await response) // should be Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IJobResponse
                WriteObject((await response));
            }
        }

        /// <summary>
        /// a delegate that is called when the remote service returns default (any response code not handled elsewhere).
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IErrorResponse"
        /// /> from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onDefault(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IErrorResponse> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnDefault(responseMessage, response, ref _returnNow);
                // if overrideOnDefault has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // Error Response : default
                var code = (await response)?.Code;
                var message = (await response)?.Message;
                if ((null == code || null == message))
                {
                    // Unrecognized Response. Create an error record based on what we have.
                    var ex = new Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IErrorResponse>(responseMessage, await response);
                    WriteError( new global::System.Management.Automation.ErrorRecord(ex, ex.Code, global::System.Management.Automation.ErrorCategory.InvalidOperation, new { Name=Name, SubscriptionId=SubscriptionId, ResourceGroupName=ResourceGroupName, AcceptLanguage=this.InvocationInformation.BoundParameters.ContainsKey("AcceptLanguage") ? AcceptLanguage : null, ClientTenantId=this.InvocationInformation.BoundParameters.ContainsKey("ClientTenantId") ? ClientTenantId : null, body=Body })
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(ex.Message) { RecommendedAction = ex.Action }
                    });
                }
                else
                {
                    WriteError( new global::System.Management.Automation.ErrorRecord(new global::System.Exception($"[{code}] : {message}"), code?.ToString(), global::System.Management.Automation.ErrorCategory.InvalidOperation, new { Name=Name, SubscriptionId=SubscriptionId, ResourceGroupName=ResourceGroupName, AcceptLanguage=this.InvocationInformation.BoundParameters.ContainsKey("AcceptLanguage") ? AcceptLanguage : null, ClientTenantId=this.InvocationInformation.BoundParameters.ContainsKey("ClientTenantId") ? ClientTenantId : null, body=Body })
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(message) { RecommendedAction = global::System.String.Empty }
                    });
                }
            }
        }

        /// <summary>a delegate that is called when the remote service returns 200 (OK).</summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IJobResponse"
        /// /> from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IJobResponse> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnOk(responseMessage, response, ref _returnNow);
                // if overrideOnOk has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // onOk - response for 200 / application/json
                // (await response) // should be Microsoft.Azure.PowerShell.Cmdlets.ImportExport.Models.Api20161101.IJobResponse
                WriteObject((await response));
            }
        }
    }
}