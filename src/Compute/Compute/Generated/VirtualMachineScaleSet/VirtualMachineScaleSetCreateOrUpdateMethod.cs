//
// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Warning: This code was generated by a tool.
//
// Changes to this file may cause incorrect behavior and will be lost if the
// code is regenerated.

using System;
using System.Collections.Generic;
using System.Management.Automation;
using Microsoft.Azure.Commands.Compute.Automation.Models;
using Microsoft.Azure.Commands.Common.Strategies;
using Microsoft.Azure.Commands.Compute.Strategies;
using Microsoft.Azure.Commands.ResourceManager.Common.ArgumentCompleters;
using Microsoft.Azure.Management.Compute;
using Microsoft.Azure.Management.Compute.Models;
using Microsoft.WindowsAzure.Commands.Utilities.Common;
using Microsoft.Azure.Commands.Compute.Common;
using AutoMapper;
using Microsoft.Azure.Commands.Compute.Strategies.ComputeRp;
using System.Linq;
using Microsoft.WindowsAzure.Commands.Common.CustomAttributes;
using Microsoft.Azure.Management.Internal.Resources;
using Microsoft.Azure.Commands.Common.Authentication;
using Microsoft.Azure.Commands.Common.Authentication.Abstractions;

namespace Microsoft.Azure.Commands.Compute.Automation
{
    [GenericBreakingChangeWithVersion("Starting November 2023, the \"New-AzVmss\" cmdlet will default to Trusted Launch VMSS. For more info, visit https://aka.ms/TLaD.", "11.0.0", "7.0.0")]
    [GenericBreakingChangeWithVersion("Starting November 2023, the \"New-AzVmss\" cmdlet will use new defaults: Flexible orchestration mode and enable NATv2 configuration for Load Balancer. To learn more about Flexible Orchestration modes, visit https://aka.ms/orchestrationModeVMSS.", "11.0.0", "7.0.0")]
    [Cmdlet(VerbsCommon.New, ResourceManager.Common.AzureRMConstants.AzureRMPrefix + "Vmss", DefaultParameterSetName = "DefaultParameter", SupportsShouldProcess = true)]
    [OutputType(typeof(PSVirtualMachineScaleSet))]
    public partial class NewAzureRmVmss : ComputeAutomationBaseCmdlet
    {
        public const string SimpleParameterSet = "SimpleParameterSet", DefaultParameter = "DefaultParameter";
        public const int vmssFlexibleOrchestrationModeNetworkAPIVersionMinimumInt = 20201101;
        public const string vmssFlexibleOrchestrationModeNetworkAPIVersionMinimum = "2020-11-01";

        public override void ExecuteCmdlet()
        {
            if (this.IsParameterBound(c => c.UserData))
            {
                if (!ValidateBase64EncodedString.ValidateStringIsBase64Encoded(this.UserData))
                {
                    this.UserData = ValidateBase64EncodedString.EncodeStringToBase64(this.UserData);
                    this.WriteInformation(ValidateBase64EncodedString.UserDataEncodeNotification, new string[] { "PSHOST" });
                }
            }

            base.ExecuteCmdlet();
            switch (ParameterSetName)
            {
                case SimpleParameterSet:
                    this.StartAndWait(SimpleParameterSetExecuteCmdlet);
                    break;
                default:
                    ExecuteClientAction(() =>
                    {
                        if (ShouldProcess(this.VMScaleSetName, VerbsCommon.New))
                        {
                            // TL defaulting for default param set, config object.
                            // if security type not set, 
                            // if parameters.VirtualMachineProfile.StorageProfile.ImageReference.SharedGalleryImageId == null
                            // if parameters.VirtualMachineProfile.StorageProfile.ImageReference.Id == null
                            // if parameters.VirtualMachineProfile.StorageProfile.OsDisk == null
                            if (this.VirtualMachineScaleSet.VirtualMachineProfile?.SecurityProfile?.SecurityType == null
                                && this.VirtualMachineScaleSet.VirtualMachineProfile?.StorageProfile?.ImageReference == null
                                && this.VirtualMachineScaleSet.VirtualMachineProfile?.StorageProfile?.OsDisk == null)
                            {
                                trustedLaunchDefaultingSecurityValues();
                                trustedLaunchDefaultingImageValues();
                            }

                            if (this.VirtualMachineScaleSet.VirtualMachineProfile?.SecurityProfile?.SecurityType == null
                                //&& this.VirtualMachineScaleSet.VirtualMachineProfile?.StorageProfile?.OsDisk == null//had to remove this as it has the FromImage value from set-azvmssstorageprofile call
                                && this.VirtualMachineScaleSet.VirtualMachineProfile?.StorageProfile?.ImageReference?.Publisher != null
                                && this.VirtualMachineScaleSet.VirtualMachineProfile?.StorageProfile?.ImageReference?.Offer != null
                                && this.VirtualMachineScaleSet.VirtualMachineProfile?.StorageProfile?.ImageReference?.Sku != null
                                && this.VirtualMachineScaleSet.VirtualMachineProfile?.StorageProfile?.ImageReference?.Version != null)
                            {
                                // retrieve the image that this points to and check if it is HyperVGeneration V2.
                                Microsoft.Rest.Azure.AzureOperationResponse<VirtualMachineImage> specificImageRespone;
                                specificImageRespone = retrieveSpecificImageFromNotId();
                                setHyperVGenForImageCheckAndTLDefaulting(specificImageRespone);
                            }


                            string resourceGroupName = this.ResourceGroupName;
                            string vmScaleSetName = this.VMScaleSetName;
                            VirtualMachineScaleSet parameters = new VirtualMachineScaleSet();
                            ComputeAutomationAutoMapperProfile.Mapper.Map<PSVirtualMachineScaleSet, VirtualMachineScaleSet>(this.VirtualMachineScaleSet, parameters);
                            if (parameters?.VirtualMachineProfile?.StorageProfile?.ImageReference?.Version?.ToLower() != "latest")
                            {
                                WriteWarning("You are deploying VMSS pinned to a specific image version from Azure Marketplace. \n" +
                                    "Consider using \"latest\" as the image version. This allows VMSS to auto upgrade when a newer version is available.");
                            }

                            if (parameters?.OrchestrationMode == "Flexible")
                            {
                                if (parameters?.VirtualMachineProfile?.NetworkProfile?.NetworkInterfaceConfigurations != null)
                                {
                                    foreach (var nicConfig in parameters.VirtualMachineProfile.NetworkProfile.NetworkInterfaceConfigurations)
                                    {
                                        if (nicConfig.IpConfigurations != null)
                                        {
                                            foreach (var ipConfig in nicConfig.IpConfigurations)
                                            {
                                                ipConfig.LoadBalancerInboundNatPools = null;
                                            }
                                        }
                                    }
                                }

                                parameters.UpgradePolicy = null;

                                flexibleOrchestrationModeDefaultParameters(parameters);
                                checkFlexibleOrchestrationModeParamsDefaultParamSet(parameters);
                            }
                            
                            if (parameters.VirtualMachineProfile?.SecurityProfile?.SecurityType?.ToLower() == ConstantValues.TrustedLaunchSecurityType || parameters.VirtualMachineProfile?.SecurityProfile?.SecurityType?.ToLower() == ConstantValues.ConfidentialVMSecurityType)
                            {
                                if (parameters.VirtualMachineProfile?.SecurityProfile?.UefiSettings != null)
                                {
                                    parameters.VirtualMachineProfile.SecurityProfile.UefiSettings.SecureBootEnabled = parameters.VirtualMachineProfile.SecurityProfile.UefiSettings.SecureBootEnabled ?? true;
                                    parameters.VirtualMachineProfile.SecurityProfile.UefiSettings.VTpmEnabled = parameters.VirtualMachineProfile.SecurityProfile.UefiSettings.VTpmEnabled ?? true;

                                }
                                else
                                {
                                    parameters.VirtualMachineProfile.SecurityProfile.UefiSettings = new UefiSettings(true, true);
                                }
                            }

                            // For Cross-tenant RBAC sharing
                            Dictionary<string, List<string>> auxAuthHeader = null;
                            if (!string.IsNullOrEmpty(parameters.VirtualMachineProfile?.StorageProfile?.ImageReference?.Id))
                            {
                                var resourceId = ResourceId.TryParse(parameters.VirtualMachineProfile?.StorageProfile.ImageReference.Id);

                                if (string.Equals(ComputeStrategy.Namespace, resourceId?.ResourceType?.Namespace, StringComparison.OrdinalIgnoreCase)
                                 && string.Equals("galleries", resourceId?.ResourceType?.Provider, StringComparison.OrdinalIgnoreCase)
                                 && !string.Equals(this.ComputeClient?.ComputeManagementClient?.SubscriptionId, resourceId?.SubscriptionId, StringComparison.OrdinalIgnoreCase))
                                {
                                    List<string> resourceIds = new List<string>();
                                    resourceIds.Add(parameters.VirtualMachineProfile?.StorageProfile.ImageReference.Id);
                                    var auxHeaderDictionary = GetAuxilaryAuthHeaderFromResourceIds(resourceIds);
                                    if (auxHeaderDictionary != null && auxHeaderDictionary.Count > 0)
                                    {
                                        auxAuthHeader = new Dictionary<string, List<string>>(auxHeaderDictionary);
                                    }
                                }
                            }
                            // END: For Cross-tenant RBAC sharing
                            // GuestAttestation install scenario
                            if (shouldGuestAttestationExtBeInstalled(parameters) &&
                               parameters.Identity == null)
                            {
                                parameters.Identity = new VirtualMachineScaleSetIdentity(null, null, Microsoft.Azure.Management.Compute.Models.ResourceIdentityType.SystemAssigned, null);
                            }

                            // Standard securityType is currently not supported in API, jsut used on client side for now,
                            // so removing it here before API call is made. 
                            if (parameters.VirtualMachineProfile?.SecurityProfile?.SecurityType != null
                                && parameters.VirtualMachineProfile?.SecurityProfile?.SecurityType?.ToLower() == ConstantValues.StandardSecurityType)
                            {
                                if (parameters.VirtualMachineProfile.SecurityProfile.UefiSettings?.SecureBootEnabled == null
                                    && parameters.VirtualMachineProfile.SecurityProfile.UefiSettings?.VTpmEnabled == null
                                    && parameters.VirtualMachineProfile.SecurityProfile.EncryptionAtHost == null)
                                {
                                    parameters.VirtualMachineProfile.SecurityProfile = null;
                                }
                                else
                                {
                                    parameters.VirtualMachineProfile.SecurityProfile.SecurityType = null;
                                }
                            }

                            VirtualMachineScaleSet result;
                            if (auxAuthHeader != null)
                            {
                                var res = VirtualMachineScaleSetsClient.CreateOrUpdateWithHttpMessagesAsync(
                                        resourceGroupName,
                                        vmScaleSetName,
                                        parameters,
                                        auxAuthHeader).GetAwaiter().GetResult();

                                result = res.Body;
                            }
                            else
                            {
                                result = VirtualMachineScaleSetsClient.CreateOrUpdate(resourceGroupName, vmScaleSetName, parameters);
                            }

                            //Guest Attestation extension defaulting behavior check.
                            if (shouldGuestAttestationExtBeInstalled(parameters))
                            {
                                string extensionNameGA = "GuestAttestation";
                                var extensionDirect = new VirtualMachineScaleSetExtension();
                                if (this.VirtualMachineScaleSet.VirtualMachineProfile == null)
                                {
                                    this.VirtualMachineScaleSet.VirtualMachineProfile = new PSVirtualMachineScaleSetVMProfile();
                                }
                                // ExtensionProfile
                                if (this.VirtualMachineScaleSet.VirtualMachineProfile.ExtensionProfile == null)
                                {
                                    this.VirtualMachineScaleSet.VirtualMachineProfile.ExtensionProfile = new PSVirtualMachineScaleSetExtensionProfile();
                                }
                                // Extensions
                                if (this.VirtualMachineScaleSet.VirtualMachineProfile.ExtensionProfile.Extensions == null)
                                {
                                    this.VirtualMachineScaleSet.VirtualMachineProfile.ExtensionProfile.Extensions = new List<PSVirtualMachineScaleSetExtension>();
                                }
                                if (parameters.VirtualMachineProfile.OsProfile != null)
                                {
                                    if (parameters.VirtualMachineProfile.OsProfile.LinuxConfiguration != null)
                                    {
                                        extensionDirect.Name = extensionNameGA;
                                        extensionDirect.Publisher = "Microsoft.Azure.Security.LinuxAttestation";
                                        extensionDirect.Type1 = extensionNameGA;
                                        extensionDirect.TypeHandlerVersion = "1.0";
                                        extensionDirect.EnableAutomaticUpgrade = true;
                                    }
                                    else
                                    {
                                        extensionDirect.Name = extensionNameGA;
                                        extensionDirect.Publisher = "Microsoft.Azure.Security.WindowsAttestation";
                                        extensionDirect.Type1 = extensionNameGA;
                                        extensionDirect.TypeHandlerVersion = "1.0";
                                        extensionDirect.EnableAutomaticUpgrade = true;
                                    }
                                }
                                VirtualMachineScaleSetUpdate parametersupdate = new VirtualMachineScaleSetUpdate();
                                parametersupdate.VirtualMachineProfile = new VirtualMachineScaleSetUpdateVMProfile();
                                parametersupdate.VirtualMachineProfile.ExtensionProfile = new VirtualMachineScaleSetExtensionProfile();
                                parametersupdate.VirtualMachineProfile.ExtensionProfile.Extensions = new List<VirtualMachineScaleSetExtension>();
                                parametersupdate.VirtualMachineProfile.ExtensionProfile.Extensions.Add(extensionDirect);
                                result = VirtualMachineScaleSetsClient.Update(resourceGroupName, vmScaleSetName, parametersupdate);
                                var vmssVmExtParams = new VirtualMachineScaleSetVMExtension();
                                var resultVmssVm = VirtualMachineScaleSetVMsClient.List(resourceGroupName, vmScaleSetName);
                                var resultList = resultVmssVm.ToList();
                                var nextPageLink = resultVmssVm.NextPageLink;
                                while (!string.IsNullOrEmpty(nextPageLink))
                                {
                                    var pageResult = VirtualMachineScaleSetVMsClient.ListNext(nextPageLink);
                                    foreach (var pageItem in pageResult)
                                    {
                                        resultList.Add(pageItem);
                                    }
                                    nextPageLink = pageResult.NextPageLink;
                                }
                                foreach (var currentVmssVm in resultList)
                                {
                                    if (currentVmssVm.StorageProfile != null &&
                                        currentVmssVm.StorageProfile.OsDisk != null)
                                    {
                                        if (currentVmssVm.StorageProfile.OsDisk.OsType == OperatingSystemTypes.Linux)
                                        {
                                            vmssVmExtParams = new VirtualMachineScaleSetVMExtension
                                            {
                                                Publisher = "Microsoft.Azure.Security.LinuxAttestation",
                                                Type1 = extensionNameGA,
                                                TypeHandlerVersion = "1.0",
                                                EnableAutomaticUpgrade = true
                                            };
                                        }
                                        else
                                        {
                                            vmssVmExtParams = new VirtualMachineScaleSetVMExtension
                                            {
                                                Publisher = "Microsoft.Azure.Security.WindowsAttestation",
                                                Type1 = extensionNameGA,
                                                TypeHandlerVersion = "1.0",
                                                EnableAutomaticUpgrade = true
                                            };
                                        }
                                        var opt = this.VirtualMachineScaleSetVMExtensionsClient.CreateOrUpdateWithHttpMessagesAsync(resourceGroupName, vmScaleSetName, currentVmssVm.InstanceId, extensionNameGA, vmssVmExtParams);
                                    }
                                }
                            }

                            var psObject = new PSVirtualMachineScaleSet();
                            ComputeAutomationAutoMapperProfile.Mapper.Map<VirtualMachineScaleSet, PSVirtualMachineScaleSet>(result, psObject);
                            WriteObject(psObject);
                        }
                    });
                    break;
            }
        }

        private void setHyperVGenForImageCheckAndTLDefaulting(Microsoft.Rest.Azure.AzureOperationResponse<VirtualMachineImage> specificImageRespone)
        {
            if (specificImageRespone.Body.HyperVGeneration.ToUpper() == "V2")
            {
                trustedLaunchDefaultingSecurityValues();
            }
            else if (specificImageRespone.Body.HyperVGeneration.ToUpper() == "V1")
            {
                if (this.VirtualMachineScaleSet.VirtualMachineProfile.SecurityProfile == null)
                {
                    this.VirtualMachineScaleSet.VirtualMachineProfile.SecurityProfile = new SecurityProfile();
                }
                this.VirtualMachineScaleSet.VirtualMachineProfile.SecurityProfile.SecurityType = ConstantValues.StandardSecurityType;
                if (this.AsJobPresent() == false) // to avoid a failure when it is a job. Seems to fail when it is a job.
                {
                    WriteInformation(HelpMessages.TrustedLaunchUpgradeMessage, new string[] { "PSHOST" });
                }
            }
        }

        /// <summary>
        /// Query for the given image if the ImageId is not used. 
        /// </summary>
        /// <returns> The API response of the VirtualMachineImage with the HyperVGeneration property. </returns>
        private Microsoft.Rest.Azure.AzureOperationResponse<VirtualMachineImage> retrieveSpecificImageFromNotId()
        {
            var resourceClient = AzureSession.Instance.ClientFactory.CreateArmClient<ResourceManagementClient>(
                            DefaultProfile.DefaultContext,
                            AzureEnvironment.Endpoint.ResourceManager);
            string loc = "";
            if (this.Location == null)
            {
                loc = resourceClient.ResourceGroups.GetAsync(this.ResourceGroupName).Result.Location;
            }
            else
            {
                loc = this.Location;
            }
            
            var imageVersion = retrieveImageVersion(this.VirtualMachineScaleSet.VirtualMachineProfile.StorageProfile.ImageReference.Publisher,
                                                    this.VirtualMachineScaleSet.VirtualMachineProfile.StorageProfile.ImageReference.Offer,
                                                    this.VirtualMachineScaleSet.VirtualMachineProfile.StorageProfile.ImageReference.Sku,
                                                    this.VirtualMachineScaleSet.VirtualMachineProfile.StorageProfile.ImageReference.Version,
                                                    loc);
            var imgResponse = ComputeClient.ComputeManagementClient.VirtualMachineImages.GetWithHttpMessagesAsync(
                    loc.Canonicalize(),
                    this.VirtualMachineScaleSet.VirtualMachineProfile.StorageProfile.ImageReference.Publisher,
                    this.VirtualMachineScaleSet.VirtualMachineProfile.StorageProfile.ImageReference.Offer,
                    this.VirtualMachineScaleSet.VirtualMachineProfile.StorageProfile.ImageReference.Sku,
                    version: imageVersion).GetAwaiter().GetResult();
            return imgResponse;
        }

        /// <summary>
        /// Retrieves the specific image value if the version is 'latest' to use in Get calls.
        /// </summary>
        /// <param name="publisher"></param>
        /// <param name="offer"></param>
        /// <param name="sku"></param>
        /// <param name="version"></param>
        /// /// <param name="location"></param>
        /// <returns></returns>
        private string retrieveImageVersion(string publisher, string offer, string sku, string version, string location)
        {
            if (version.ToLower() == "latest")
            {
                var imgResponse = ComputeClient.ComputeManagementClient.VirtualMachineImages.ListWithHttpMessagesAsync(
                            location.Canonicalize(),
                            publisher,
                            offer,
                            sku,
                            top: 1,
                            orderby: "name desc").GetAwaiter().GetResult();

                var parts = imgResponse.Body[0].Id.ToString().Split(new char[] { '/' }, StringSplitOptions.RemoveEmptyEntries);

                string imageVersion = parts[Array.IndexOf(parts, "Versions") + 1];

                return imageVersion;
            }
            else
            {
                return version;
            }
        }

        private void trustedLaunchDefaultingSecurityValues()
        {
            if (this.VirtualMachineScaleSet.VirtualMachineProfile == null)
            {
                this.VirtualMachineScaleSet.VirtualMachineProfile = new PSVirtualMachineScaleSetVMProfile();
            }
            if (this.VirtualMachineScaleSet.VirtualMachineProfile.SecurityProfile == null)
            {
                this.VirtualMachineScaleSet.VirtualMachineProfile.SecurityProfile = new SecurityProfile();
            }
            this.VirtualMachineScaleSet.VirtualMachineProfile.SecurityProfile.SecurityType = ConstantValues.TrustedLaunchSecurityType;

            if (this.VirtualMachineScaleSet.VirtualMachineProfile.SecurityProfile.UefiSettings == null)
            {
                this.VirtualMachineScaleSet.VirtualMachineProfile.SecurityProfile.UefiSettings = new UefiSettings(true, true);
            }
            if (this.VirtualMachineScaleSet.VirtualMachineProfile.SecurityProfile.UefiSettings.SecureBootEnabled == null)
            {
                this.VirtualMachineScaleSet.VirtualMachineProfile.SecurityProfile.UefiSettings.SecureBootEnabled = true;
            }
            if (this.VirtualMachineScaleSet.VirtualMachineProfile.SecurityProfile.UefiSettings.VTpmEnabled == null)
            {
                this.VirtualMachineScaleSet.VirtualMachineProfile.SecurityProfile.UefiSettings.VTpmEnabled = true;
            }
        }

        private void trustedLaunchDefaultingImageValues()
        {
            if (this.VirtualMachineScaleSet.VirtualMachineProfile.StorageProfile == null)
            {
                this.VirtualMachineScaleSet.VirtualMachineProfile.StorageProfile = new VirtualMachineScaleSetStorageProfile();
            }
            if (this.VirtualMachineScaleSet.VirtualMachineProfile.StorageProfile.ImageReference == null)
            {
                this.VirtualMachineScaleSet.VirtualMachineProfile.StorageProfile.ImageReference = new ImageReference();
            }
            this.VirtualMachineScaleSet.VirtualMachineProfile.StorageProfile.ImageReference.Publisher = ConstantValues.TrustedLaunchDefaultPublisher;
            this.VirtualMachineScaleSet.VirtualMachineProfile.StorageProfile.ImageReference.Offer = ConstantValues.TrustedLaunchDefaultOffer;
            this.VirtualMachineScaleSet.VirtualMachineProfile.StorageProfile.ImageReference.Sku = ConstantValues.TrustedLaunchDefaultSku;
            this.VirtualMachineScaleSet.VirtualMachineProfile.StorageProfile.ImageReference.Version = ConstantValues.TrustedLaunchDefaultVersion;

        }

        /// <summary>
        /// Check to see if the Guest Attestation extension should be installed and Identity set to SystemAssigned.
        /// Requirements for this scenario to be true:
        /// 1) DisableIntegrityMonitoring is not true.
        /// 2) SecurityType is TrustedLaunch.
        /// 3) SecureBootEnabled is true.
        /// 4) VTpmEnabled is true.
        /// </summary>
        /// <param name="vmssParameters"></param>
        /// <returns></returns>
        private bool shouldGuestAttestationExtBeInstalled(VirtualMachineScaleSet vmssParameters)
        {
            if (this.DisableIntegrityMonitoring != true &&
                    vmssParameters != null &&
                    vmssParameters.VirtualMachineProfile != null &&
                    vmssParameters.VirtualMachineProfile.SecurityProfile != null &&
                    vmssParameters.VirtualMachineProfile.SecurityProfile.SecurityType?.ToLower() == ConstantValues.TrustedLaunchSecurityType &&
                    vmssParameters.VirtualMachineProfile.SecurityProfile.UefiSettings != null &&
                    vmssParameters.VirtualMachineProfile.SecurityProfile.UefiSettings.SecureBootEnabled == true &&
                    vmssParameters.VirtualMachineProfile.SecurityProfile.UefiSettings.VTpmEnabled == true)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        /// This somewhat contradicts with the above behavior that sets UpgradePolicy to null.
        /// There is some concern with the above behavior being correct or not, and requires additional testing before changing.
        private void checkFlexibleOrchestrationModeParamsDefaultParamSet(VirtualMachineScaleSet parameters)
        {
            if (parameters?.UpgradePolicy != null)
            {
                throw new Exception("UpgradePolicy is not currently supported for a VMSS with OrchestrationMode set to Flexible.");
            }
            else if (parameters?.VirtualMachineProfile?.NetworkProfile?.NetworkApiVersion != null
                && convertAPIVersionToInt(parameters?.VirtualMachineProfile?.NetworkProfile?.NetworkApiVersion) < vmssFlexibleOrchestrationModeNetworkAPIVersionMinimumInt)
            {
                throw new Exception("The value for NetworkApiVersion is not valid for a VMSS with OrchestrationMode set to Flexible. You must use a valid Network API Version equal to or greater than " + vmssFlexibleOrchestrationModeNetworkAPIVersionMinimum);
            }
            //else if (convertAPIVersionToInt(parameters?.VirtualMachineProfile?.NetworkProfile?.NetworkApiVersion) < vmssFlexibleOrchestrationModeNetworkAPIVersionMinimumInt)
            //{
            //    throw new Exception("The value for NetworkApiVersion is not valid for a VMSS with OrchestrationMode set to Flexible. You must use a valid Network API Version equal to or greater than " + vmssFlexibleOrchestrationModeNetworkAPIVersionMinimum);
            //}
        }

        private void flexibleOrchestrationModeDefaultParameters(VirtualMachineScaleSet parameters)
        {
            if (parameters?.VirtualMachineProfile?.NetworkProfile != null &&
                parameters?.VirtualMachineProfile?.NetworkProfile.NetworkApiVersion == null)
            {
                parameters.VirtualMachineProfile.NetworkProfile.NetworkApiVersion = vmssFlexibleOrchestrationModeNetworkAPIVersionMinimum;
            }
            /*if (parameters?.VirtualMachineProfile?.NetworkProfile?.NetworkApiVersion == null)
            {
                parameters.VirtualMachineProfile.NetworkProfile.NetworkApiVersion = vmssFlexibleOrchestrationModeNetworkAPIVersionMinimum;
            }*/
            if (parameters?.PlatformFaultDomainCount == null)
            {
                parameters.PlatformFaultDomainCount = 1;
            }
        }

        private int convertAPIVersionToInt(string networkAPIVersion)
        {
            string networkAPIVersionString = String.Join("", networkAPIVersion.Split('-'));
            int apiversionInt = Convert.ToInt32(networkAPIVersionString);

            return apiversionInt;
        }

        [Parameter(
            ParameterSetName = "DefaultParameter",
            Position = 0,
            Mandatory = true,
            ValueFromPipelineByPropertyName = true)]
        [Parameter(
            ParameterSetName = SimpleParameterSet,
            Mandatory = false)]
        [ResourceGroupCompleter]
        public string ResourceGroupName { get; set; }

        [Parameter(
            ParameterSetName = DefaultParameter,
            Position = 1,
            Mandatory = true,
            ValueFromPipelineByPropertyName = true)]
        [Parameter(
            ParameterSetName = SimpleParameterSet,
            Mandatory = true)]
        [Alias("Name")]
        public string VMScaleSetName { get; set; }

        [Parameter(
            ParameterSetName = DefaultParameter,
            Position = 2,
            Mandatory = true,
            ValueFromPipeline = true)]
        public PSVirtualMachineScaleSet VirtualMachineScaleSet { get; set; }

        [Parameter(Mandatory = false, HelpMessage = "Run cmdlet in the background")]
        public SwitchParameter AsJob { get; set; }

        [Parameter(
            Mandatory = false,
            ParameterSetName = SimpleParameterSet,
            HelpMessage = "UserData for the Vmss, which will be Base64 encoded. Customer should not pass any secrets in here.",
            ValueFromPipelineByPropertyName = true)]
        public string UserData { get; set; }

        [Parameter(
           Mandatory = false,
           ValueFromPipelineByPropertyName = true,
           HelpMessage = "This flag disables the default behavior to install the Guest Attestation extension to the virtual machine if: 1) SecurityType is TrustedLaunch, 2) SecureBootEnabled on the SecurityProfile is true, 3) VTpmEnabled on the SecurityProfile is true.")]
        public SwitchParameter DisableIntegrityMonitoring { get; set; }
    }
}
