// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Extensions;

    /// <summary>A web app, a mobile app backend, or an API app.</summary>
    [Microsoft.Azure.PowerShell.Cmdlets.Functions.DoNotFormat]
    public partial class Site :
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISite,
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal,
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.IValidates,
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.IHeaderSerializable
    {
        /// <summary>
        /// Backing field for Inherited model <see cref= "Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResource"
        /// />
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResource __resource = new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.Resource();

        /// <summary>
        /// Use this property for StorageAccountConnectionString. Set the name of the app setting that has the storage account connection
        /// string. Do not set a value for this property when using other authentication type.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string AuthenticationStorageAccountConnectionStringName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).AuthenticationStorageAccountConnectionStringName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).AuthenticationStorageAccountConnectionStringName = value ?? null; }

        /// <summary>
        /// Property to select authentication type to access the selected storage account. Available options: SystemAssignedIdentity,
        /// UserAssignedIdentity, StorageAccountConnectionString.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.AuthenticationType? AuthenticationType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).AuthenticationType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).AuthenticationType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.AuthenticationType)""); }

        /// <summary>
        /// Use this property for UserAssignedIdentity. Set the resource ID of the identity. Do not set a value for this property
        /// when using other authentication type.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string AuthenticationUserAssignedIdentityResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).AuthenticationUserAssignedIdentityResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).AuthenticationUserAssignedIdentityResourceId = value ?? null; }

        /// <summary>Management information availability state for the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.SiteAvailabilityState? AvailabilityState { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).AvailabilityState; }

        /// <summary>
        /// <code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity cookies, which route
        /// client requests in the same session to the same instance. Default is <code>true</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? ClientAffinityEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ClientAffinityEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ClientAffinityEnabled = value ?? default(bool); }

        /// <summary>
        /// <code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise, <code>false</code>.
        /// Default is <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? ClientCertEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ClientCertEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ClientCertEnabled = value ?? default(bool); }

        /// <summary>client certificate authentication comma-separated exclusion paths</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string ClientCertExclusionPath { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ClientCertExclusionPath; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ClientCertExclusionPath = value ?? null; }

        /// <summary>
        /// This composes with ClientCertEnabled setting.
        /// - ClientCertEnabled: false means ClientCert is ignored.
        /// - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
        /// - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ClientCertMode? ClientCertMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ClientCertMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ClientCertMode = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ClientCertMode)""); }

        /// <summary>
        /// Application setting overrides for cloned app. If specified, these settings override the settings cloned
        /// from source app. Otherwise, application settings from source app are retained.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoAppSettingsOverrides CloningInfoAppSettingsOverride { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoAppSettingsOverride; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoAppSettingsOverride = value ?? null /* model class */; }

        /// <summary>
        /// <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? CloningInfoCloneCustomHostName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoCloneCustomHostName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoCloneCustomHostName = value ?? default(bool); }

        /// <summary>
        /// <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? CloningInfoCloneSourceControl { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoCloneSourceControl; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoCloneSourceControl = value ?? default(bool); }

        /// <summary><code>true</code> to configure load balancing for source and destination app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? CloningInfoConfigureLoadBalancing { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoConfigureLoadBalancing; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoConfigureLoadBalancing = value ?? default(bool); }

        /// <summary>
        /// Correlation ID of cloning operation. This ID ties multiple cloning operations
        /// together to use the same snapshot.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string CloningInfoCorrelationId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoCorrelationId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoCorrelationId = value ?? null; }

        /// <summary>App Service Environment.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string CloningInfoHostingEnvironment { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoHostingEnvironment; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoHostingEnvironment = value ?? null; }

        /// <summary><code>true</code> to overwrite destination app; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? CloningInfoOverwrite { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoOverwrite; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoOverwrite = value ?? default(bool); }

        /// <summary>
        /// ARM resource ID of the source app. App resource ID is of the form
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots
        /// and
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for
        /// other slots.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string CloningInfoSourceWebAppId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoSourceWebAppId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoSourceWebAppId = value ?? null; }

        /// <summary>Location of source app ex: West US or North Europe</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string CloningInfoSourceWebAppLocation { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoSourceWebAppLocation; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoSourceWebAppLocation = value ?? null; }

        /// <summary>
        /// ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource ID is of the form
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string CloningInfoTrafficManagerProfileId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoTrafficManagerProfileId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoTrafficManagerProfileId = value ?? null; }

        /// <summary>
        /// Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile does not already exist.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string CloningInfoTrafficManagerProfileName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoTrafficManagerProfileName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfoTrafficManagerProfileName = value ?? null; }

        /// <summary>Configuration of the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteConfig Config { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).SiteConfig; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).SiteConfig = value ?? null /* model class */; }

        /// <summary>Size of the function container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public int? ContainerSize { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ContainerSize; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ContainerSize = value ?? default(int); }

        /// <summary>
        /// Unique identifier that verifies the custom domains assigned to the app. Customer will add this id to a txt record for
        /// verification.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string CustomDomainVerificationId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CustomDomainVerificationId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CustomDomainVerificationId = value ?? null; }

        /// <summary>Maximum allowed daily memory-time quota (applicable on dynamic apps only).</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public int? DailyMemoryTimeQuota { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DailyMemoryTimeQuota; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DailyMemoryTimeQuota = value ?? default(int); }

        /// <summary>Dapr application identifier</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string DaprConfigAppId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DaprConfigAppId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DaprConfigAppId = value ?? null; }

        /// <summary>Tells Dapr which port your application is listening on</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public int? DaprConfigAppPort { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DaprConfigAppPort; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DaprConfigAppPort = value ?? default(int); }

        /// <summary>Enables API logging for the Dapr sidecar</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? DaprConfigEnableApiLogging { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DaprConfigEnableApiLogging; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DaprConfigEnableApiLogging = value ?? default(bool); }

        /// <summary>Boolean indicating if the Dapr side car is enabled</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? DaprConfigEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DaprConfigEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DaprConfigEnabled = value ?? default(bool); }

        /// <summary>
        /// Increasing max size of request body http servers parameter in MB to handle uploading of big files. Default is 4 MB.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public int? DaprConfigHttpMaxRequestSize { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DaprConfigHttpMaxRequestSize; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DaprConfigHttpMaxRequestSize = value ?? default(int); }

        /// <summary>
        /// Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public int? DaprConfigHttpReadBufferSize { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DaprConfigHttpReadBufferSize; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DaprConfigHttpReadBufferSize = value ?? default(int); }

        /// <summary>
        /// Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.DaprLogLevel? DaprConfigLogLevel { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DaprConfigLogLevel; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DaprConfigLogLevel = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.DaprLogLevel)""); }

        /// <summary>Default hostname of the app. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string DefaultHostName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DefaultHostName; }

        /// <summary>
        /// Alternate DNS server to be used by apps. This property replicates the WEBSITE_DNS_ALT_SERVER app setting.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string DnsConfigurationDnsAltServer { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DnsConfigurationDnsAltServer; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DnsConfigurationDnsAltServer = value ?? null; }

        /// <summary>
        /// Indicates that sites using Virtual network custom DNS servers are still sorting the list of DNS servers. Read-Only.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? DnsConfigurationDnsLegacySortOrder { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DnsConfigurationDnsLegacySortOrder; }

        /// <summary>
        /// Custom time for DNS to be cached in seconds. Allowed range: 0-60. Default is 30 seconds. 0 means caching disabled.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public int? DnsConfigurationDnsMaxCacheTimeout { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DnsConfigurationDnsMaxCacheTimeout; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DnsConfigurationDnsMaxCacheTimeout = value ?? default(int); }

        /// <summary>Total number of retries for dns lookup. Allowed range: 1-5. Default is 3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public int? DnsConfigurationDnsRetryAttemptCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DnsConfigurationDnsRetryAttemptCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DnsConfigurationDnsRetryAttemptCount = value ?? default(int); }

        /// <summary>Timeout for a single dns lookup in seconds. Allowed range: 1-30. Default is 3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public int? DnsConfigurationDnsRetryAttemptTimeout { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DnsConfigurationDnsRetryAttemptTimeout; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DnsConfigurationDnsRetryAttemptTimeout = value ?? default(int); }

        /// <summary>
        /// List of custom DNS servers to be used by an app for lookups. Maximum 5 dns servers can be set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string[] DnsConfigurationDnsServer { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DnsConfigurationDnsServer; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DnsConfigurationDnsServer = value ?? null /* arrayOf */; }

        /// <summary>
        /// <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables the app (takes
        /// the app offline).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? Enabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).Enabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).Enabled = value ?? default(bool); }

        /// <summary>
        /// Enabled hostnames for the app.Hostnames need to be assigned (see HostNames) AND enabled. Otherwise,
        /// the app is not served on those hostnames.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string[] EnabledHostName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).EnabledHostName; }

        /// <summary>Backing field for <see cref="ExtendedLocation" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IExtendedLocation _extendedLocation;

        /// <summary>Extended Location.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IExtendedLocation ExtendedLocation { get => (this._extendedLocation = this._extendedLocation ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ExtendedLocation()); set => this._extendedLocation = value; }

        /// <summary>Name of extended location.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string ExtendedLocationName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IExtendedLocationInternal)ExtendedLocation).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IExtendedLocationInternal)ExtendedLocation).Name = value ?? null; }

        /// <summary>Type of extended location.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string ExtendedLocationType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IExtendedLocationInternal)ExtendedLocation).Type; }

        /// <summary>Hostnames associated with the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string[] HostName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HostName; }

        /// <summary>Hostname SSL states are used to manage the SSL bindings for app's hostnames.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostNameSslState[] HostNameSslState { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HostNameSslState; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HostNameSslState = value ?? null /* arrayOf */; }

        /// <summary>
        /// <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
        /// If <code>true</code>, the app is only accessible via API management process.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? HostNamesDisabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HostNamesDisabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HostNamesDisabled = value ?? default(bool); }

        /// <summary>Resource ID of the App Service Environment.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string HostingEnvironmentProfileId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HostingEnvironmentProfileId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HostingEnvironmentProfileId = value ?? null; }

        /// <summary>Name of the App Service Environment.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string HostingEnvironmentProfileName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HostingEnvironmentProfileName; }

        /// <summary>Resource type of the App Service Environment.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string HostingEnvironmentProfileType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HostingEnvironmentProfileType; }

        /// <summary>The maximum number of concurrent HTTP trigger invocations per instance.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public float? HttpPerInstanceConcurrency { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HttpPerInstanceConcurrency; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HttpPerInstanceConcurrency = value ?? default(float); }

        /// <summary>
        /// HttpsOnly: configures a web site to accept only https requests. Issues redirect for
        /// http requests
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? HttpsOnly { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HttpsOnly; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HttpsOnly = value ?? default(bool); }

        /// <summary>Hyper-V sandbox.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? HyperV { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HyperV; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HyperV = value ?? default(bool); }

        /// <summary>Resource Id.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inherited)]
        public string Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal)__resource).Id; }

        /// <summary>Backing field for <see cref="Identity" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentity _identity;

        /// <summary>Managed service identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentity Identity { get => (this._identity = this._identity ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ManagedServiceIdentity()); set => this._identity = value; }

        /// <summary>Principal Id of managed service identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string IdentityPrincipalId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentityInternal)Identity).PrincipalId; }

        /// <summary>Tenant of managed service identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string IdentityTenantId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentityInternal)Identity).TenantId; }

        /// <summary>Type of managed service identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ManagedServiceIdentityType? IdentityType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentityInternal)Identity).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentityInternal)Identity).Type = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ManagedServiceIdentityType)""); }

        /// <summary>
        /// The list of user assigned identities associated with the resource. The user identity dictionary key references will be
        /// ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentityUserAssignedIdentities IdentityUserAssignedIdentity { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentityInternal)Identity).UserAssignedIdentity; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentityInternal)Identity).UserAssignedIdentity = value ?? null /* model class */; }

        /// <summary>Specifies an operation id if this site has a pending operation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string InProgressOperationId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).InProgressOperationId; }

        /// <summary>
        /// <code>true</code> if the app is a default container; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? IsDefaultContainer { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).IsDefaultContainer; }

        /// <summary>Obsolete: Hyper-V sandbox.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? IsXenon { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).IsXenon; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).IsXenon = value ?? default(bool); }

        /// <summary>Identity to use for Key Vault Reference authentication.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string KeyVaultReferenceIdentity { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).KeyVaultReferenceIdentity; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).KeyVaultReferenceIdentity = value ?? null; }

        /// <summary>Kind of resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inherited)]
        public string Kind { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal)__resource).Kind; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal)__resource).Kind = value ?? null; }

        /// <summary>Last time the app was modified, in UTC. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public global::System.DateTime? LastModifiedTimeUtc { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).LastModifiedTimeUtc; }

        /// <summary>Resource Location.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inherited)]
        public string Location { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal)__resource).Location; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal)__resource).Location = value ; }

        /// <summary>
        /// Azure Resource Manager ID of the customer's selected Managed Environment on which to host this app. This must be of the
        /// form /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.App/managedEnvironments/{managedEnvironmentName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string ManagedEnvironmentId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ManagedEnvironmentId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ManagedEnvironmentId = value ?? null; }

        /// <summary>
        /// Maximum number of workers.
        /// This only applies to Functions container.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public int? MaxNumberOfWorker { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).MaxNumberOfWorker; }

        /// <summary>Internal Acessors for Id</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal.Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal)__resource).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal)__resource).Id = value; }

        /// <summary>Internal Acessors for Name</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal.Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal)__resource).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal)__resource).Name = value; }

        /// <summary>Internal Acessors for Type</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal.Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal)__resource).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal)__resource).Type = value; }

        /// <summary>Internal Acessors for AvailabilityState</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.SiteAvailabilityState? Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.AvailabilityState { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).AvailabilityState; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).AvailabilityState = value; }

        /// <summary>Internal Acessors for CloningInfo</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfo Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.CloningInfo { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfo; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).CloningInfo = value; }

        /// <summary>Internal Acessors for DaprConfig</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfig Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.DaprConfig { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DaprConfig; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DaprConfig = value; }

        /// <summary>Internal Acessors for DefaultHostName</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.DefaultHostName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DefaultHostName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DefaultHostName = value; }

        /// <summary>Internal Acessors for DeploymentStorage</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsDeploymentStorage Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.DeploymentStorage { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DeploymentStorage; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DeploymentStorage = value; }

        /// <summary>Internal Acessors for DnsConfiguration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfig Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.DnsConfiguration { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DnsConfiguration; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DnsConfiguration = value; }

        /// <summary>Internal Acessors for DnsConfigurationDnsLegacySortOrder</summary>
        bool? Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.DnsConfigurationDnsLegacySortOrder { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DnsConfigurationDnsLegacySortOrder; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).DnsConfigurationDnsLegacySortOrder = value; }

        /// <summary>Internal Acessors for EnabledHostName</summary>
        string[] Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.EnabledHostName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).EnabledHostName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).EnabledHostName = value; }

        /// <summary>Internal Acessors for ExtendedLocation</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IExtendedLocation Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.ExtendedLocation { get => (this._extendedLocation = this._extendedLocation ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ExtendedLocation()); set { {_extendedLocation = value;} } }

        /// <summary>Internal Acessors for ExtendedLocationType</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.ExtendedLocationType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IExtendedLocationInternal)ExtendedLocation).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IExtendedLocationInternal)ExtendedLocation).Type = value; }

        /// <summary>Internal Acessors for FunctionAppConfig</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfig Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.FunctionAppConfig { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).FunctionAppConfig; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).FunctionAppConfig = value; }

        /// <summary>Internal Acessors for FunctionAppConfigDeployment</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsDeployment Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.FunctionAppConfigDeployment { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).FunctionAppConfigDeployment; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).FunctionAppConfigDeployment = value; }

        /// <summary>Internal Acessors for FunctionAppConfigRuntime</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsRuntime Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.FunctionAppConfigRuntime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).FunctionAppConfigRuntime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).FunctionAppConfigRuntime = value; }

        /// <summary>Internal Acessors for FunctionAppConfigScaleAndConcurrency</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsScaleAndConcurrency Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.FunctionAppConfigScaleAndConcurrency { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).FunctionAppConfigScaleAndConcurrency; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).FunctionAppConfigScaleAndConcurrency = value; }

        /// <summary>Internal Acessors for HostName</summary>
        string[] Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.HostName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HostName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HostName = value; }

        /// <summary>Internal Acessors for HostingEnvironmentProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostingEnvironmentProfile Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.HostingEnvironmentProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HostingEnvironmentProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HostingEnvironmentProfile = value; }

        /// <summary>Internal Acessors for HostingEnvironmentProfileName</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.HostingEnvironmentProfileName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HostingEnvironmentProfileName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HostingEnvironmentProfileName = value; }

        /// <summary>Internal Acessors for HostingEnvironmentProfileType</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.HostingEnvironmentProfileType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HostingEnvironmentProfileType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).HostingEnvironmentProfileType = value; }

        /// <summary>Internal Acessors for Identity</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentity Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.Identity { get => (this._identity = this._identity ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ManagedServiceIdentity()); set { {_identity = value;} } }

        /// <summary>Internal Acessors for IdentityPrincipalId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.IdentityPrincipalId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentityInternal)Identity).PrincipalId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentityInternal)Identity).PrincipalId = value; }

        /// <summary>Internal Acessors for IdentityTenantId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.IdentityTenantId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentityInternal)Identity).TenantId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentityInternal)Identity).TenantId = value; }

        /// <summary>Internal Acessors for InProgressOperationId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.InProgressOperationId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).InProgressOperationId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).InProgressOperationId = value; }

        /// <summary>Internal Acessors for IsDefaultContainer</summary>
        bool? Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.IsDefaultContainer { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).IsDefaultContainer; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).IsDefaultContainer = value; }

        /// <summary>Internal Acessors for LastModifiedTimeUtc</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.LastModifiedTimeUtc { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).LastModifiedTimeUtc; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).LastModifiedTimeUtc = value; }

        /// <summary>Internal Acessors for MaxNumberOfWorker</summary>
        int? Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.MaxNumberOfWorker { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).MaxNumberOfWorker; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).MaxNumberOfWorker = value; }

        /// <summary>Internal Acessors for OutboundIPAddress</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.OutboundIPAddress { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).OutboundIPAddress; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).OutboundIPAddress = value; }

        /// <summary>Internal Acessors for PossibleOutboundIPAddress</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.PossibleOutboundIPAddress { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).PossibleOutboundIPAddress; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).PossibleOutboundIPAddress = value; }

        /// <summary>Internal Acessors for Property</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteProperties Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.SiteProperties()); set { {_property = value;} } }

        /// <summary>Internal Acessors for RepositorySiteName</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.RepositorySiteName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).RepositorySiteName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).RepositorySiteName = value; }

        /// <summary>Internal Acessors for ResourceConfig</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceConfig Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.ResourceConfig { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ResourceConfig; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ResourceConfig = value; }

        /// <summary>Internal Acessors for ResourceGroup</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.ResourceGroup { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ResourceGroup; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ResourceGroup = value; }

        /// <summary>Internal Acessors for ScaleAndConcurrencyTrigger</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsScaleAndConcurrencyTriggers Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.ScaleAndConcurrencyTrigger { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ScaleAndConcurrencyTrigger; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ScaleAndConcurrencyTrigger = value; }

        /// <summary>Internal Acessors for SlotSwapStatus</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISlotSwapStatus Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.SlotSwapStatus { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).SlotSwapStatus; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).SlotSwapStatus = value; }

        /// <summary>Internal Acessors for SlotSwapStatusDestinationSlotName</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.SlotSwapStatusDestinationSlotName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).SlotSwapStatusDestinationSlotName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).SlotSwapStatusDestinationSlotName = value; }

        /// <summary>Internal Acessors for SlotSwapStatusSourceSlotName</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.SlotSwapStatusSourceSlotName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).SlotSwapStatusSourceSlotName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).SlotSwapStatusSourceSlotName = value; }

        /// <summary>Internal Acessors for SlotSwapStatusTimestampUtc</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.SlotSwapStatusTimestampUtc { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).SlotSwapStatusTimestampUtc; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).SlotSwapStatusTimestampUtc = value; }

        /// <summary>Internal Acessors for State</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.State { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).State; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).State = value; }

        /// <summary>Internal Acessors for StorageAuthentication</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsDeploymentStorageAuthentication Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.StorageAuthentication { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).StorageAuthentication; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).StorageAuthentication = value; }

        /// <summary>Internal Acessors for SuspendedTill</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.SuspendedTill { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).SuspendedTill; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).SuspendedTill = value; }

        /// <summary>Internal Acessors for TargetSwapSlot</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.TargetSwapSlot { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).TargetSwapSlot; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).TargetSwapSlot = value; }

        /// <summary>Internal Acessors for TrafficManagerHostName</summary>
        string[] Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.TrafficManagerHostName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).TrafficManagerHostName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).TrafficManagerHostName = value; }

        /// <summary>Internal Acessors for TriggerHttp</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsScaleAndConcurrencyTriggersHttp Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.TriggerHttp { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).TriggerHttp; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).TriggerHttp = value; }

        /// <summary>Internal Acessors for UsageState</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.UsageState? Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteInternal.UsageState { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).UsageState; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).UsageState = value; }

        /// <summary>Resource Name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inherited)]
        public string Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal)__resource).Name; }

        /// <summary>
        /// List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from tenants that
        /// site can be hosted with current settings. Read-only.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string OutboundIPAddress { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).OutboundIPAddress; }

        /// <summary>
        /// List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from all tenants
        /// except dataComponent. Read-only.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string PossibleOutboundIPAddress { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).PossibleOutboundIPAddress; }

        /// <summary>Backing field for <see cref="Property" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteProperties _property;

        /// <summary>Site resource specific properties</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteProperties Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.SiteProperties()); set => this._property = value; }

        /// <summary>
        /// Property to allow or block all public traffic. Allowed Values: 'Enabled', 'Disabled' or an empty string.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string PublicNetworkAccess { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).PublicNetworkAccess; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).PublicNetworkAccess = value ?? null; }

        /// <summary>Site redundancy mode</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RedundancyMode? RedundancyMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).RedundancyMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).RedundancyMode = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RedundancyMode)""); }

        /// <summary>Name of the repository site.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string RepositorySiteName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).RepositorySiteName; }

        /// <summary><code>true</code> if reserved; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? Reserved { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).Reserved; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).Reserved = value ?? default(bool); }

        /// <summary>Required CPU in cores, e.g. 0.5</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public double? ResourceConfigCpu { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ResourceConfigCpu; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ResourceConfigCpu = value ?? default(double); }

        /// <summary>Required memory, e.g. "1Gi"</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string ResourceConfigMemory { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ResourceConfigMemory; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ResourceConfigMemory = value ?? null; }

        /// <summary>Name of the resource group the app belongs to. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string ResourceGroup { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ResourceGroup; }

        /// <summary>
        /// Function app runtime name. Available options: dotnet-isolated, node, java, powershell, python, custom
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RuntimeName? RuntimeName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).RuntimeName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).RuntimeName = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RuntimeName)""); }

        /// <summary>Function app runtime version. Example: 8 (for dotnet-isolated)</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string RuntimeVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).RuntimeVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).RuntimeVersion = value ?? null; }

        /// <summary>'Always Ready' configuration for the function app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsAlwaysReadyConfig[] ScaleAndConcurrencyAlwaysReady { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ScaleAndConcurrencyAlwaysReady; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ScaleAndConcurrencyAlwaysReady = value ?? null /* arrayOf */; }

        /// <summary>
        /// Set the amount of memory allocated to each instance of the function app in MB. CPU and network bandwidth are allocated
        /// proportionally.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public float? ScaleAndConcurrencyInstanceMemoryMb { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ScaleAndConcurrencyInstanceMemoryMb; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ScaleAndConcurrencyInstanceMemoryMb = value ?? default(float); }

        /// <summary>The maximum number of instances for the function app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public float? ScaleAndConcurrencyMaximumInstanceCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ScaleAndConcurrencyMaximumInstanceCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ScaleAndConcurrencyMaximumInstanceCount = value ?? default(float); }

        /// <summary>
        /// <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The default is <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? ScmSiteAlsoStopped { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ScmSiteAlsoStopped; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ScmSiteAlsoStopped = value ?? default(bool); }

        /// <summary>
        /// Resource ID of the associated App Service plan, formatted as: "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string ServerFarmId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ServerFarmId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).ServerFarmId = value ?? null; }

        /// <summary>The destination slot of the last swap operation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string SlotSwapStatusDestinationSlotName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).SlotSwapStatusDestinationSlotName; }

        /// <summary>The source slot of the last swap operation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string SlotSwapStatusSourceSlotName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).SlotSwapStatusSourceSlotName; }

        /// <summary>The time the last successful slot swap completed.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public global::System.DateTime? SlotSwapStatusTimestampUtc { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).SlotSwapStatusTimestampUtc; }

        /// <summary>Current state of the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string State { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).State; }

        /// <summary>Checks if Customer provided storage account is required</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? StorageAccountRequired { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).StorageAccountRequired; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).StorageAccountRequired = value ?? default(bool); }

        /// <summary>Property to select Azure Storage type. Available options: blobContainer.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.FunctionsDeploymentStorageType? StorageType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).StorageType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).StorageType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.FunctionsDeploymentStorageType)""); }

        /// <summary>
        /// Property to set the URL for the selected Azure Storage type. Example: For blobContainer, the value could be https://<storageAccountName>.blob.core.windows.net/<containerName>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string StorageValue { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).StorageValue; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).StorageValue = value ?? null; }

        /// <summary>App suspended till in case memory-time quota is exceeded.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public global::System.DateTime? SuspendedTill { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).SuspendedTill; }

        /// <summary>Resource tags.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inherited)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceTags Tag { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal)__resource).Tag; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal)__resource).Tag = value ?? null /* model class */; }

        /// <summary>Specifies which deployment slot this app will swap into. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string TargetSwapSlot { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).TargetSwapSlot; }

        /// <summary>Azure Traffic Manager hostnames associated with the app. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string[] TrafficManagerHostName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).TrafficManagerHostName; }

        /// <summary>Resource type.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inherited)]
        public string Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal)__resource).Type; }

        /// <summary>State indicating whether the app has exceeded its quota usage. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.UsageState? UsageState { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).UsageState; }

        /// <summary>
        /// Azure Resource Manager ID of the Virtual network and subnet to be joined by Regional VNET Integration.
        /// This must be of the form /subscriptions/{subscriptionName}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string VirtualNetworkSubnetId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).VirtualNetworkSubnetId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).VirtualNetworkSubnetId = value ?? null; }

        /// <summary>To enable Backup and Restore operations over virtual network</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? VnetBackupRestoreEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).VnetBackupRestoreEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).VnetBackupRestoreEnabled = value ?? default(bool); }

        /// <summary>To enable accessing content over virtual network</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? VnetContentShareEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).VnetContentShareEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).VnetContentShareEnabled = value ?? default(bool); }

        /// <summary>To enable pulling image over Virtual Network</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? VnetImagePullEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).VnetImagePullEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).VnetImagePullEnabled = value ?? default(bool); }

        /// <summary>
        /// Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined
        /// Routes applied.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? VnetRouteAllEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).VnetRouteAllEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).VnetRouteAllEnabled = value ?? default(bool); }

        /// <summary>Workload profile name for function app to execute on.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string WorkloadProfileName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).WorkloadProfileName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal)Property).WorkloadProfileName = value ?? null; }

        /// <param name="headers"></param>
        void Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.IHeaderSerializable.ReadHeaders(global::System.Net.Http.Headers.HttpResponseHeaders headers)
        {
            if (headers.TryGetValues("location", out var __locationHeader0))
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal)this).Location = System.Linq.Enumerable.FirstOrDefault(__locationHeader0) is string __headerLocationHeader0 ? __headerLocationHeader0 : (string)null;
            }
        }

        /// <summary>Creates an new <see cref="Site" /> instance.</summary>
        public Site()
        {

        }

        /// <summary>Validates that this object meets the validation criteria.</summary>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.IEventListener" /> instance that will receive validation
        /// events.</param>
        /// <returns>
        /// A <see cref = "global::System.Threading.Tasks.Task" /> that will be complete when validation is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task Validate(Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.IEventListener eventListener)
        {
            await eventListener.AssertNotNull(nameof(__resource), __resource);
            await eventListener.AssertObjectIsValid(nameof(__resource), __resource);
        }
    }
    /// A web app, a mobile app backend, or an API app.
    public partial interface ISite :
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.IJsonSerializable,
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResource
    {
        /// <summary>
        /// Use this property for StorageAccountConnectionString. Set the name of the app setting that has the storage account connection
        /// string. Do not set a value for this property when using other authentication type.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Use this property for StorageAccountConnectionString. Set the name of the app setting that has the storage account connection string. Do not set a value for this property when using other authentication type.",
        SerializedName = @"storageAccountConnectionStringName",
        PossibleTypes = new [] { typeof(string) })]
        string AuthenticationStorageAccountConnectionStringName { get; set; }
        /// <summary>
        /// Property to select authentication type to access the selected storage account. Available options: SystemAssignedIdentity,
        /// UserAssignedIdentity, StorageAccountConnectionString.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Property to select authentication type to access the selected storage account. Available options: SystemAssignedIdentity, UserAssignedIdentity, StorageAccountConnectionString.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.AuthenticationType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.AuthenticationType? AuthenticationType { get; set; }
        /// <summary>
        /// Use this property for UserAssignedIdentity. Set the resource ID of the identity. Do not set a value for this property
        /// when using other authentication type.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Use this property for UserAssignedIdentity. Set the resource ID of the identity. Do not set a value for this property when using other authentication type.",
        SerializedName = @"userAssignedIdentityResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string AuthenticationUserAssignedIdentityResourceId { get; set; }
        /// <summary>Management information availability state for the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Management information availability state for the app.",
        SerializedName = @"availabilityState",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.SiteAvailabilityState) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.SiteAvailabilityState? AvailabilityState { get;  }
        /// <summary>
        /// <code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity cookies, which route
        /// client requests in the same session to the same instance. Default is <code>true</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity cookies, which route client requests in the same session to the same instance. Default is <code>true</code>.",
        SerializedName = @"clientAffinityEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ClientAffinityEnabled { get; set; }
        /// <summary>
        /// <code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise, <code>false</code>.
        /// Default is <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise, <code>false</code>. Default is <code>false</code>.",
        SerializedName = @"clientCertEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ClientCertEnabled { get; set; }
        /// <summary>client certificate authentication comma-separated exclusion paths</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"client certificate authentication comma-separated exclusion paths",
        SerializedName = @"clientCertExclusionPaths",
        PossibleTypes = new [] { typeof(string) })]
        string ClientCertExclusionPath { get; set; }
        /// <summary>
        /// This composes with ClientCertEnabled setting.
        /// - ClientCertEnabled: false means ClientCert is ignored.
        /// - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
        /// - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This composes with ClientCertEnabled setting.
        - ClientCertEnabled: false means ClientCert is ignored.
        - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
        - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.",
        SerializedName = @"clientCertMode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ClientCertMode) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ClientCertMode? ClientCertMode { get; set; }
        /// <summary>
        /// Application setting overrides for cloned app. If specified, these settings override the settings cloned
        /// from source app. Otherwise, application settings from source app are retained.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Application setting overrides for cloned app. If specified, these settings override the settings cloned
        from source app. Otherwise, application settings from source app are retained.",
        SerializedName = @"appSettingsOverrides",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoAppSettingsOverrides) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoAppSettingsOverrides CloningInfoAppSettingsOverride { get; set; }
        /// <summary>
        /// <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.",
        SerializedName = @"cloneCustomHostNames",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CloningInfoCloneCustomHostName { get; set; }
        /// <summary>
        /// <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to clone source control from source app; otherwise, <code>false</code>.",
        SerializedName = @"cloneSourceControl",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CloningInfoCloneSourceControl { get; set; }
        /// <summary><code>true</code> to configure load balancing for source and destination app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to configure load balancing for source and destination app.",
        SerializedName = @"configureLoadBalancing",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CloningInfoConfigureLoadBalancing { get; set; }
        /// <summary>
        /// Correlation ID of cloning operation. This ID ties multiple cloning operations
        /// together to use the same snapshot.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Correlation ID of cloning operation. This ID ties multiple cloning operations
        together to use the same snapshot.",
        SerializedName = @"correlationId",
        PossibleTypes = new [] { typeof(string) })]
        string CloningInfoCorrelationId { get; set; }
        /// <summary>App Service Environment.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"App Service Environment.",
        SerializedName = @"hostingEnvironment",
        PossibleTypes = new [] { typeof(string) })]
        string CloningInfoHostingEnvironment { get; set; }
        /// <summary><code>true</code> to overwrite destination app; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to overwrite destination app; otherwise, <code>false</code>.",
        SerializedName = @"overwrite",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CloningInfoOverwrite { get; set; }
        /// <summary>
        /// ARM resource ID of the source app. App resource ID is of the form
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots
        /// and
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for
        /// other slots.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"ARM resource ID of the source app. App resource ID is of the form
        /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots and
        /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for other slots.",
        SerializedName = @"sourceWebAppId",
        PossibleTypes = new [] { typeof(string) })]
        string CloningInfoSourceWebAppId { get; set; }
        /// <summary>Location of source app ex: West US or North Europe</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Location of source app ex: West US or North Europe",
        SerializedName = @"sourceWebAppLocation",
        PossibleTypes = new [] { typeof(string) })]
        string CloningInfoSourceWebAppLocation { get; set; }
        /// <summary>
        /// ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource ID is of the form
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource ID is of the form
        /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.",
        SerializedName = @"trafficManagerProfileId",
        PossibleTypes = new [] { typeof(string) })]
        string CloningInfoTrafficManagerProfileId { get; set; }
        /// <summary>
        /// Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile does not already exist.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile does not already exist.",
        SerializedName = @"trafficManagerProfileName",
        PossibleTypes = new [] { typeof(string) })]
        string CloningInfoTrafficManagerProfileName { get; set; }
        /// <summary>Configuration of the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Configuration of the app.",
        SerializedName = @"siteConfig",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteConfig) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteConfig Config { get; set; }
        /// <summary>Size of the function container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Size of the function container.",
        SerializedName = @"containerSize",
        PossibleTypes = new [] { typeof(int) })]
        int? ContainerSize { get; set; }
        /// <summary>
        /// Unique identifier that verifies the custom domains assigned to the app. Customer will add this id to a txt record for
        /// verification.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Unique identifier that verifies the custom domains assigned to the app. Customer will add this id to a txt record for verification.",
        SerializedName = @"customDomainVerificationId",
        PossibleTypes = new [] { typeof(string) })]
        string CustomDomainVerificationId { get; set; }
        /// <summary>Maximum allowed daily memory-time quota (applicable on dynamic apps only).</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Maximum allowed daily memory-time quota (applicable on dynamic apps only).",
        SerializedName = @"dailyMemoryTimeQuota",
        PossibleTypes = new [] { typeof(int) })]
        int? DailyMemoryTimeQuota { get; set; }
        /// <summary>Dapr application identifier</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Dapr application identifier",
        SerializedName = @"appId",
        PossibleTypes = new [] { typeof(string) })]
        string DaprConfigAppId { get; set; }
        /// <summary>Tells Dapr which port your application is listening on</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Tells Dapr which port your application is listening on",
        SerializedName = @"appPort",
        PossibleTypes = new [] { typeof(int) })]
        int? DaprConfigAppPort { get; set; }
        /// <summary>Enables API logging for the Dapr sidecar</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enables API logging for the Dapr sidecar",
        SerializedName = @"enableApiLogging",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DaprConfigEnableApiLogging { get; set; }
        /// <summary>Boolean indicating if the Dapr side car is enabled</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Boolean indicating if the Dapr side car is enabled",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DaprConfigEnabled { get; set; }
        /// <summary>
        /// Increasing max size of request body http servers parameter in MB to handle uploading of big files. Default is 4 MB.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Increasing max size of request body http servers parameter in MB to handle uploading of big files. Default is 4 MB.",
        SerializedName = @"httpMaxRequestSize",
        PossibleTypes = new [] { typeof(int) })]
        int? DaprConfigHttpMaxRequestSize { get; set; }
        /// <summary>
        /// Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.",
        SerializedName = @"httpReadBufferSize",
        PossibleTypes = new [] { typeof(int) })]
        int? DaprConfigHttpReadBufferSize { get; set; }
        /// <summary>
        /// Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.",
        SerializedName = @"logLevel",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.DaprLogLevel) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.DaprLogLevel? DaprConfigLogLevel { get; set; }
        /// <summary>Default hostname of the app. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Default hostname of the app. Read-only.",
        SerializedName = @"defaultHostName",
        PossibleTypes = new [] { typeof(string) })]
        string DefaultHostName { get;  }
        /// <summary>
        /// Alternate DNS server to be used by apps. This property replicates the WEBSITE_DNS_ALT_SERVER app setting.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Alternate DNS server to be used by apps. This property replicates the WEBSITE_DNS_ALT_SERVER app setting.",
        SerializedName = @"dnsAltServer",
        PossibleTypes = new [] { typeof(string) })]
        string DnsConfigurationDnsAltServer { get; set; }
        /// <summary>
        /// Indicates that sites using Virtual network custom DNS servers are still sorting the list of DNS servers. Read-Only.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Indicates that sites using Virtual network custom DNS servers are still sorting the list of DNS servers. Read-Only.",
        SerializedName = @"dnsLegacySortOrder",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DnsConfigurationDnsLegacySortOrder { get;  }
        /// <summary>
        /// Custom time for DNS to be cached in seconds. Allowed range: 0-60. Default is 30 seconds. 0 means caching disabled.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Custom time for DNS to be cached in seconds. Allowed range: 0-60. Default is 30 seconds. 0 means caching disabled.",
        SerializedName = @"dnsMaxCacheTimeout",
        PossibleTypes = new [] { typeof(int) })]
        int? DnsConfigurationDnsMaxCacheTimeout { get; set; }
        /// <summary>Total number of retries for dns lookup. Allowed range: 1-5. Default is 3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Total number of retries for dns lookup. Allowed range: 1-5. Default is 3.",
        SerializedName = @"dnsRetryAttemptCount",
        PossibleTypes = new [] { typeof(int) })]
        int? DnsConfigurationDnsRetryAttemptCount { get; set; }
        /// <summary>Timeout for a single dns lookup in seconds. Allowed range: 1-30. Default is 3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Timeout for a single dns lookup in seconds. Allowed range: 1-30. Default is 3.",
        SerializedName = @"dnsRetryAttemptTimeout",
        PossibleTypes = new [] { typeof(int) })]
        int? DnsConfigurationDnsRetryAttemptTimeout { get; set; }
        /// <summary>
        /// List of custom DNS servers to be used by an app for lookups. Maximum 5 dns servers can be set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"List of custom DNS servers to be used by an app for lookups. Maximum 5 dns servers can be set.",
        SerializedName = @"dnsServers",
        PossibleTypes = new [] { typeof(string) })]
        string[] DnsConfigurationDnsServer { get; set; }
        /// <summary>
        /// <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables the app (takes
        /// the app offline).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables the app (takes the app offline).",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? Enabled { get; set; }
        /// <summary>
        /// Enabled hostnames for the app.Hostnames need to be assigned (see HostNames) AND enabled. Otherwise,
        /// the app is not served on those hostnames.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Enabled hostnames for the app.Hostnames need to be assigned (see HostNames) AND enabled. Otherwise,
        the app is not served on those hostnames.",
        SerializedName = @"enabledHostNames",
        PossibleTypes = new [] { typeof(string) })]
        string[] EnabledHostName { get;  }
        /// <summary>Name of extended location.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Name of extended location.",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string ExtendedLocationName { get; set; }
        /// <summary>Type of extended location.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Type of extended location.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(string) })]
        string ExtendedLocationType { get;  }
        /// <summary>Hostnames associated with the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Hostnames associated with the app.",
        SerializedName = @"hostNames",
        PossibleTypes = new [] { typeof(string) })]
        string[] HostName { get;  }
        /// <summary>Hostname SSL states are used to manage the SSL bindings for app's hostnames.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Hostname SSL states are used to manage the SSL bindings for app's hostnames.",
        SerializedName = @"hostNameSslStates",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostNameSslState) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostNameSslState[] HostNameSslState { get; set; }
        /// <summary>
        /// <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
        /// If <code>true</code>, the app is only accessible via API management process.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
         If <code>true</code>, the app is only accessible via API management process.",
        SerializedName = @"hostNamesDisabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? HostNamesDisabled { get; set; }
        /// <summary>Resource ID of the App Service Environment.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource ID of the App Service Environment.",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(string) })]
        string HostingEnvironmentProfileId { get; set; }
        /// <summary>Name of the App Service Environment.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Name of the App Service Environment.",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string HostingEnvironmentProfileName { get;  }
        /// <summary>Resource type of the App Service Environment.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Resource type of the App Service Environment.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(string) })]
        string HostingEnvironmentProfileType { get;  }
        /// <summary>The maximum number of concurrent HTTP trigger invocations per instance.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The maximum number of concurrent HTTP trigger invocations per instance.",
        SerializedName = @"perInstanceConcurrency",
        PossibleTypes = new [] { typeof(float) })]
        float? HttpPerInstanceConcurrency { get; set; }
        /// <summary>
        /// HttpsOnly: configures a web site to accept only https requests. Issues redirect for
        /// http requests
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"HttpsOnly: configures a web site to accept only https requests. Issues redirect for
        http requests",
        SerializedName = @"httpsOnly",
        PossibleTypes = new [] { typeof(bool) })]
        bool? HttpsOnly { get; set; }
        /// <summary>Hyper-V sandbox.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Hyper-V sandbox.",
        SerializedName = @"hyperV",
        PossibleTypes = new [] { typeof(bool) })]
        bool? HyperV { get; set; }
        /// <summary>Principal Id of managed service identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Principal Id of managed service identity.",
        SerializedName = @"principalId",
        PossibleTypes = new [] { typeof(string) })]
        string IdentityPrincipalId { get;  }
        /// <summary>Tenant of managed service identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Tenant of managed service identity.",
        SerializedName = @"tenantId",
        PossibleTypes = new [] { typeof(string) })]
        string IdentityTenantId { get;  }
        /// <summary>Type of managed service identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Type of managed service identity.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ManagedServiceIdentityType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ManagedServiceIdentityType? IdentityType { get; set; }
        /// <summary>
        /// The list of user assigned identities associated with the resource. The user identity dictionary key references will be
        /// ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The list of user assigned identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}",
        SerializedName = @"userAssignedIdentities",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentityUserAssignedIdentities) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentityUserAssignedIdentities IdentityUserAssignedIdentity { get; set; }
        /// <summary>Specifies an operation id if this site has a pending operation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Specifies an operation id if this site has a pending operation.",
        SerializedName = @"inProgressOperationId",
        PossibleTypes = new [] { typeof(string) })]
        string InProgressOperationId { get;  }
        /// <summary>
        /// <code>true</code> if the app is a default container; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"<code>true</code> if the app is a default container; otherwise, <code>false</code>.",
        SerializedName = @"isDefaultContainer",
        PossibleTypes = new [] { typeof(bool) })]
        bool? IsDefaultContainer { get;  }
        /// <summary>Obsolete: Hyper-V sandbox.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Obsolete: Hyper-V sandbox.",
        SerializedName = @"isXenon",
        PossibleTypes = new [] { typeof(bool) })]
        bool? IsXenon { get; set; }
        /// <summary>Identity to use for Key Vault Reference authentication.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Identity to use for Key Vault Reference authentication.",
        SerializedName = @"keyVaultReferenceIdentity",
        PossibleTypes = new [] { typeof(string) })]
        string KeyVaultReferenceIdentity { get; set; }
        /// <summary>Last time the app was modified, in UTC. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Last time the app was modified, in UTC. Read-only.",
        SerializedName = @"lastModifiedTimeUtc",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? LastModifiedTimeUtc { get;  }
        /// <summary>
        /// Azure Resource Manager ID of the customer's selected Managed Environment on which to host this app. This must be of the
        /// form /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.App/managedEnvironments/{managedEnvironmentName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Azure Resource Manager ID of the customer's selected Managed Environment on which to host this app. This must be of the form /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.App/managedEnvironments/{managedEnvironmentName}",
        SerializedName = @"managedEnvironmentId",
        PossibleTypes = new [] { typeof(string) })]
        string ManagedEnvironmentId { get; set; }
        /// <summary>
        /// Maximum number of workers.
        /// This only applies to Functions container.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Maximum number of workers.
        This only applies to Functions container.",
        SerializedName = @"maxNumberOfWorkers",
        PossibleTypes = new [] { typeof(int) })]
        int? MaxNumberOfWorker { get;  }
        /// <summary>
        /// List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from tenants that
        /// site can be hosted with current settings. Read-only.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from tenants that site can be hosted with current settings. Read-only.",
        SerializedName = @"outboundIpAddresses",
        PossibleTypes = new [] { typeof(string) })]
        string OutboundIPAddress { get;  }
        /// <summary>
        /// List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from all tenants
        /// except dataComponent. Read-only.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from all tenants except dataComponent. Read-only.",
        SerializedName = @"possibleOutboundIpAddresses",
        PossibleTypes = new [] { typeof(string) })]
        string PossibleOutboundIPAddress { get;  }
        /// <summary>
        /// Property to allow or block all public traffic. Allowed Values: 'Enabled', 'Disabled' or an empty string.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Property to allow or block all public traffic. Allowed Values: 'Enabled', 'Disabled' or an empty string.",
        SerializedName = @"publicNetworkAccess",
        PossibleTypes = new [] { typeof(string) })]
        string PublicNetworkAccess { get; set; }
        /// <summary>Site redundancy mode</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Site redundancy mode",
        SerializedName = @"redundancyMode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RedundancyMode) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RedundancyMode? RedundancyMode { get; set; }
        /// <summary>Name of the repository site.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Name of the repository site.",
        SerializedName = @"repositorySiteName",
        PossibleTypes = new [] { typeof(string) })]
        string RepositorySiteName { get;  }
        /// <summary><code>true</code> if reserved; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> if reserved; otherwise, <code>false</code>.",
        SerializedName = @"reserved",
        PossibleTypes = new [] { typeof(bool) })]
        bool? Reserved { get; set; }
        /// <summary>Required CPU in cores, e.g. 0.5</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Required CPU in cores, e.g. 0.5",
        SerializedName = @"cpu",
        PossibleTypes = new [] { typeof(double) })]
        double? ResourceConfigCpu { get; set; }
        /// <summary>Required memory, e.g. "1Gi"</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Required memory, e.g. ""1Gi""",
        SerializedName = @"memory",
        PossibleTypes = new [] { typeof(string) })]
        string ResourceConfigMemory { get; set; }
        /// <summary>Name of the resource group the app belongs to. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Name of the resource group the app belongs to. Read-only.",
        SerializedName = @"resourceGroup",
        PossibleTypes = new [] { typeof(string) })]
        string ResourceGroup { get;  }
        /// <summary>
        /// Function app runtime name. Available options: dotnet-isolated, node, java, powershell, python, custom
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Function app runtime name. Available options: dotnet-isolated, node, java, powershell, python, custom",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RuntimeName) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RuntimeName? RuntimeName { get; set; }
        /// <summary>Function app runtime version. Example: 8 (for dotnet-isolated)</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Function app runtime version. Example: 8 (for dotnet-isolated)",
        SerializedName = @"version",
        PossibleTypes = new [] { typeof(string) })]
        string RuntimeVersion { get; set; }
        /// <summary>'Always Ready' configuration for the function app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"'Always Ready' configuration for the function app.",
        SerializedName = @"alwaysReady",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsAlwaysReadyConfig) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsAlwaysReadyConfig[] ScaleAndConcurrencyAlwaysReady { get; set; }
        /// <summary>
        /// Set the amount of memory allocated to each instance of the function app in MB. CPU and network bandwidth are allocated
        /// proportionally.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Set the amount of memory allocated to each instance of the function app in MB. CPU and network bandwidth are allocated proportionally.",
        SerializedName = @"instanceMemoryMB",
        PossibleTypes = new [] { typeof(float) })]
        float? ScaleAndConcurrencyInstanceMemoryMb { get; set; }
        /// <summary>The maximum number of instances for the function app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The maximum number of instances for the function app.",
        SerializedName = @"maximumInstanceCount",
        PossibleTypes = new [] { typeof(float) })]
        float? ScaleAndConcurrencyMaximumInstanceCount { get; set; }
        /// <summary>
        /// <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The default is <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The default is <code>false</code>.",
        SerializedName = @"scmSiteAlsoStopped",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ScmSiteAlsoStopped { get; set; }
        /// <summary>
        /// Resource ID of the associated App Service plan, formatted as: "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource ID of the associated App Service plan, formatted as: ""/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}"".",
        SerializedName = @"serverFarmId",
        PossibleTypes = new [] { typeof(string) })]
        string ServerFarmId { get; set; }
        /// <summary>The destination slot of the last swap operation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The destination slot of the last swap operation.",
        SerializedName = @"destinationSlotName",
        PossibleTypes = new [] { typeof(string) })]
        string SlotSwapStatusDestinationSlotName { get;  }
        /// <summary>The source slot of the last swap operation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The source slot of the last swap operation.",
        SerializedName = @"sourceSlotName",
        PossibleTypes = new [] { typeof(string) })]
        string SlotSwapStatusSourceSlotName { get;  }
        /// <summary>The time the last successful slot swap completed.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The time the last successful slot swap completed.",
        SerializedName = @"timestampUtc",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? SlotSwapStatusTimestampUtc { get;  }
        /// <summary>Current state of the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Current state of the app.",
        SerializedName = @"state",
        PossibleTypes = new [] { typeof(string) })]
        string State { get;  }
        /// <summary>Checks if Customer provided storage account is required</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Checks if Customer provided storage account is required",
        SerializedName = @"storageAccountRequired",
        PossibleTypes = new [] { typeof(bool) })]
        bool? StorageAccountRequired { get; set; }
        /// <summary>Property to select Azure Storage type. Available options: blobContainer.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Property to select Azure Storage type. Available options: blobContainer.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.FunctionsDeploymentStorageType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.FunctionsDeploymentStorageType? StorageType { get; set; }
        /// <summary>
        /// Property to set the URL for the selected Azure Storage type. Example: For blobContainer, the value could be https://<storageAccountName>.blob.core.windows.net/<containerName>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Property to set the URL for the selected Azure Storage type. Example: For blobContainer, the value could be https://<storageAccountName>.blob.core.windows.net/<containerName>.",
        SerializedName = @"value",
        PossibleTypes = new [] { typeof(string) })]
        string StorageValue { get; set; }
        /// <summary>App suspended till in case memory-time quota is exceeded.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"App suspended till in case memory-time quota is exceeded.",
        SerializedName = @"suspendedTill",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? SuspendedTill { get;  }
        /// <summary>Specifies which deployment slot this app will swap into. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Specifies which deployment slot this app will swap into. Read-only.",
        SerializedName = @"targetSwapSlot",
        PossibleTypes = new [] { typeof(string) })]
        string TargetSwapSlot { get;  }
        /// <summary>Azure Traffic Manager hostnames associated with the app. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Azure Traffic Manager hostnames associated with the app. Read-only.",
        SerializedName = @"trafficManagerHostNames",
        PossibleTypes = new [] { typeof(string) })]
        string[] TrafficManagerHostName { get;  }
        /// <summary>State indicating whether the app has exceeded its quota usage. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"State indicating whether the app has exceeded its quota usage. Read-only.",
        SerializedName = @"usageState",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.UsageState) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.UsageState? UsageState { get;  }
        /// <summary>
        /// Azure Resource Manager ID of the Virtual network and subnet to be joined by Regional VNET Integration.
        /// This must be of the form /subscriptions/{subscriptionName}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Azure Resource Manager ID of the Virtual network and subnet to be joined by Regional VNET Integration.
        This must be of the form /subscriptions/{subscriptionName}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}",
        SerializedName = @"virtualNetworkSubnetId",
        PossibleTypes = new [] { typeof(string) })]
        string VirtualNetworkSubnetId { get; set; }
        /// <summary>To enable Backup and Restore operations over virtual network</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To enable Backup and Restore operations over virtual network",
        SerializedName = @"vnetBackupRestoreEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? VnetBackupRestoreEnabled { get; set; }
        /// <summary>To enable accessing content over virtual network</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To enable accessing content over virtual network",
        SerializedName = @"vnetContentShareEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? VnetContentShareEnabled { get; set; }
        /// <summary>To enable pulling image over Virtual Network</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To enable pulling image over Virtual Network",
        SerializedName = @"vnetImagePullEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? VnetImagePullEnabled { get; set; }
        /// <summary>
        /// Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined
        /// Routes applied.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied.",
        SerializedName = @"vnetRouteAllEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? VnetRouteAllEnabled { get; set; }
        /// <summary>Workload profile name for function app to execute on.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Workload profile name for function app to execute on.",
        SerializedName = @"workloadProfileName",
        PossibleTypes = new [] { typeof(string) })]
        string WorkloadProfileName { get; set; }

    }
    /// A web app, a mobile app backend, or an API app.
    internal partial interface ISiteInternal :
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceInternal
    {
        /// <summary>
        /// Use this property for StorageAccountConnectionString. Set the name of the app setting that has the storage account connection
        /// string. Do not set a value for this property when using other authentication type.
        /// </summary>
        string AuthenticationStorageAccountConnectionStringName { get; set; }
        /// <summary>
        /// Property to select authentication type to access the selected storage account. Available options: SystemAssignedIdentity,
        /// UserAssignedIdentity, StorageAccountConnectionString.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.AuthenticationType? AuthenticationType { get; set; }
        /// <summary>
        /// Use this property for UserAssignedIdentity. Set the resource ID of the identity. Do not set a value for this property
        /// when using other authentication type.
        /// </summary>
        string AuthenticationUserAssignedIdentityResourceId { get; set; }
        /// <summary>Management information availability state for the app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.SiteAvailabilityState? AvailabilityState { get; set; }
        /// <summary>
        /// <code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity cookies, which route
        /// client requests in the same session to the same instance. Default is <code>true</code>.
        /// </summary>
        bool? ClientAffinityEnabled { get; set; }
        /// <summary>
        /// <code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise, <code>false</code>.
        /// Default is <code>false</code>.
        /// </summary>
        bool? ClientCertEnabled { get; set; }
        /// <summary>client certificate authentication comma-separated exclusion paths</summary>
        string ClientCertExclusionPath { get; set; }
        /// <summary>
        /// This composes with ClientCertEnabled setting.
        /// - ClientCertEnabled: false means ClientCert is ignored.
        /// - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
        /// - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ClientCertMode? ClientCertMode { get; set; }
        /// <summary>If specified during app creation, the app is cloned from a source app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfo CloningInfo { get; set; }
        /// <summary>
        /// Application setting overrides for cloned app. If specified, these settings override the settings cloned
        /// from source app. Otherwise, application settings from source app are retained.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoAppSettingsOverrides CloningInfoAppSettingsOverride { get; set; }
        /// <summary>
        /// <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
        /// </summary>
        bool? CloningInfoCloneCustomHostName { get; set; }
        /// <summary>
        /// <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
        /// </summary>
        bool? CloningInfoCloneSourceControl { get; set; }
        /// <summary><code>true</code> to configure load balancing for source and destination app.</summary>
        bool? CloningInfoConfigureLoadBalancing { get; set; }
        /// <summary>
        /// Correlation ID of cloning operation. This ID ties multiple cloning operations
        /// together to use the same snapshot.
        /// </summary>
        string CloningInfoCorrelationId { get; set; }
        /// <summary>App Service Environment.</summary>
        string CloningInfoHostingEnvironment { get; set; }
        /// <summary><code>true</code> to overwrite destination app; otherwise, <code>false</code>.</summary>
        bool? CloningInfoOverwrite { get; set; }
        /// <summary>
        /// ARM resource ID of the source app. App resource ID is of the form
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots
        /// and
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for
        /// other slots.
        /// </summary>
        string CloningInfoSourceWebAppId { get; set; }
        /// <summary>Location of source app ex: West US or North Europe</summary>
        string CloningInfoSourceWebAppLocation { get; set; }
        /// <summary>
        /// ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource ID is of the form
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
        /// </summary>
        string CloningInfoTrafficManagerProfileId { get; set; }
        /// <summary>
        /// Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile does not already exist.
        /// </summary>
        string CloningInfoTrafficManagerProfileName { get; set; }
        /// <summary>Configuration of the app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteConfig Config { get; set; }
        /// <summary>Size of the function container.</summary>
        int? ContainerSize { get; set; }
        /// <summary>
        /// Unique identifier that verifies the custom domains assigned to the app. Customer will add this id to a txt record for
        /// verification.
        /// </summary>
        string CustomDomainVerificationId { get; set; }
        /// <summary>Maximum allowed daily memory-time quota (applicable on dynamic apps only).</summary>
        int? DailyMemoryTimeQuota { get; set; }
        /// <summary>Dapr configuration of the app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfig DaprConfig { get; set; }
        /// <summary>Dapr application identifier</summary>
        string DaprConfigAppId { get; set; }
        /// <summary>Tells Dapr which port your application is listening on</summary>
        int? DaprConfigAppPort { get; set; }
        /// <summary>Enables API logging for the Dapr sidecar</summary>
        bool? DaprConfigEnableApiLogging { get; set; }
        /// <summary>Boolean indicating if the Dapr side car is enabled</summary>
        bool? DaprConfigEnabled { get; set; }
        /// <summary>
        /// Increasing max size of request body http servers parameter in MB to handle uploading of big files. Default is 4 MB.
        /// </summary>
        int? DaprConfigHttpMaxRequestSize { get; set; }
        /// <summary>
        /// Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
        /// </summary>
        int? DaprConfigHttpReadBufferSize { get; set; }
        /// <summary>
        /// Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.DaprLogLevel? DaprConfigLogLevel { get; set; }
        /// <summary>Default hostname of the app. Read-only.</summary>
        string DefaultHostName { get; set; }
        /// <summary>Storage for deployed package used by the function app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsDeploymentStorage DeploymentStorage { get; set; }
        /// <summary>Property to configure various DNS related settings for a site.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfig DnsConfiguration { get; set; }
        /// <summary>
        /// Alternate DNS server to be used by apps. This property replicates the WEBSITE_DNS_ALT_SERVER app setting.
        /// </summary>
        string DnsConfigurationDnsAltServer { get; set; }
        /// <summary>
        /// Indicates that sites using Virtual network custom DNS servers are still sorting the list of DNS servers. Read-Only.
        /// </summary>
        bool? DnsConfigurationDnsLegacySortOrder { get; set; }
        /// <summary>
        /// Custom time for DNS to be cached in seconds. Allowed range: 0-60. Default is 30 seconds. 0 means caching disabled.
        /// </summary>
        int? DnsConfigurationDnsMaxCacheTimeout { get; set; }
        /// <summary>Total number of retries for dns lookup. Allowed range: 1-5. Default is 3.</summary>
        int? DnsConfigurationDnsRetryAttemptCount { get; set; }
        /// <summary>Timeout for a single dns lookup in seconds. Allowed range: 1-30. Default is 3.</summary>
        int? DnsConfigurationDnsRetryAttemptTimeout { get; set; }
        /// <summary>
        /// List of custom DNS servers to be used by an app for lookups. Maximum 5 dns servers can be set.
        /// </summary>
        string[] DnsConfigurationDnsServer { get; set; }
        /// <summary>
        /// <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables the app (takes
        /// the app offline).
        /// </summary>
        bool? Enabled { get; set; }
        /// <summary>
        /// Enabled hostnames for the app.Hostnames need to be assigned (see HostNames) AND enabled. Otherwise,
        /// the app is not served on those hostnames.
        /// </summary>
        string[] EnabledHostName { get; set; }
        /// <summary>Extended Location.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IExtendedLocation ExtendedLocation { get; set; }
        /// <summary>Name of extended location.</summary>
        string ExtendedLocationName { get; set; }
        /// <summary>Type of extended location.</summary>
        string ExtendedLocationType { get; set; }
        /// <summary>Configuration specific of the Azure Function app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfig FunctionAppConfig { get; set; }
        /// <summary>Function app deployment configuration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsDeployment FunctionAppConfigDeployment { get; set; }
        /// <summary>Function app runtime settings.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsRuntime FunctionAppConfigRuntime { get; set; }
        /// <summary>Function app scale and concurrency settings.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsScaleAndConcurrency FunctionAppConfigScaleAndConcurrency { get; set; }
        /// <summary>Hostnames associated with the app.</summary>
        string[] HostName { get; set; }
        /// <summary>Hostname SSL states are used to manage the SSL bindings for app's hostnames.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostNameSslState[] HostNameSslState { get; set; }
        /// <summary>
        /// <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
        /// If <code>true</code>, the app is only accessible via API management process.
        /// </summary>
        bool? HostNamesDisabled { get; set; }
        /// <summary>App Service Environment to use for the app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostingEnvironmentProfile HostingEnvironmentProfile { get; set; }
        /// <summary>Resource ID of the App Service Environment.</summary>
        string HostingEnvironmentProfileId { get; set; }
        /// <summary>Name of the App Service Environment.</summary>
        string HostingEnvironmentProfileName { get; set; }
        /// <summary>Resource type of the App Service Environment.</summary>
        string HostingEnvironmentProfileType { get; set; }
        /// <summary>The maximum number of concurrent HTTP trigger invocations per instance.</summary>
        float? HttpPerInstanceConcurrency { get; set; }
        /// <summary>
        /// HttpsOnly: configures a web site to accept only https requests. Issues redirect for
        /// http requests
        /// </summary>
        bool? HttpsOnly { get; set; }
        /// <summary>Hyper-V sandbox.</summary>
        bool? HyperV { get; set; }
        /// <summary>Managed service identity.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentity Identity { get; set; }
        /// <summary>Principal Id of managed service identity.</summary>
        string IdentityPrincipalId { get; set; }
        /// <summary>Tenant of managed service identity.</summary>
        string IdentityTenantId { get; set; }
        /// <summary>Type of managed service identity.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ManagedServiceIdentityType? IdentityType { get; set; }
        /// <summary>
        /// The list of user assigned identities associated with the resource. The user identity dictionary key references will be
        /// ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IManagedServiceIdentityUserAssignedIdentities IdentityUserAssignedIdentity { get; set; }
        /// <summary>Specifies an operation id if this site has a pending operation.</summary>
        string InProgressOperationId { get; set; }
        /// <summary>
        /// <code>true</code> if the app is a default container; otherwise, <code>false</code>.
        /// </summary>
        bool? IsDefaultContainer { get; set; }
        /// <summary>Obsolete: Hyper-V sandbox.</summary>
        bool? IsXenon { get; set; }
        /// <summary>Identity to use for Key Vault Reference authentication.</summary>
        string KeyVaultReferenceIdentity { get; set; }
        /// <summary>Last time the app was modified, in UTC. Read-only.</summary>
        global::System.DateTime? LastModifiedTimeUtc { get; set; }
        /// <summary>
        /// Azure Resource Manager ID of the customer's selected Managed Environment on which to host this app. This must be of the
        /// form /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.App/managedEnvironments/{managedEnvironmentName}
        /// </summary>
        string ManagedEnvironmentId { get; set; }
        /// <summary>
        /// Maximum number of workers.
        /// This only applies to Functions container.
        /// </summary>
        int? MaxNumberOfWorker { get; set; }
        /// <summary>
        /// List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from tenants that
        /// site can be hosted with current settings. Read-only.
        /// </summary>
        string OutboundIPAddress { get; set; }
        /// <summary>
        /// List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from all tenants
        /// except dataComponent. Read-only.
        /// </summary>
        string PossibleOutboundIPAddress { get; set; }
        /// <summary>Site resource specific properties</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteProperties Property { get; set; }
        /// <summary>
        /// Property to allow or block all public traffic. Allowed Values: 'Enabled', 'Disabled' or an empty string.
        /// </summary>
        string PublicNetworkAccess { get; set; }
        /// <summary>Site redundancy mode</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RedundancyMode? RedundancyMode { get; set; }
        /// <summary>Name of the repository site.</summary>
        string RepositorySiteName { get; set; }
        /// <summary><code>true</code> if reserved; otherwise, <code>false</code>.</summary>
        bool? Reserved { get; set; }
        /// <summary>Function app resource requirements.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceConfig ResourceConfig { get; set; }
        /// <summary>Required CPU in cores, e.g. 0.5</summary>
        double? ResourceConfigCpu { get; set; }
        /// <summary>Required memory, e.g. "1Gi"</summary>
        string ResourceConfigMemory { get; set; }
        /// <summary>Name of the resource group the app belongs to. Read-only.</summary>
        string ResourceGroup { get; set; }
        /// <summary>
        /// Function app runtime name. Available options: dotnet-isolated, node, java, powershell, python, custom
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RuntimeName? RuntimeName { get; set; }
        /// <summary>Function app runtime version. Example: 8 (for dotnet-isolated)</summary>
        string RuntimeVersion { get; set; }
        /// <summary>'Always Ready' configuration for the function app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsAlwaysReadyConfig[] ScaleAndConcurrencyAlwaysReady { get; set; }
        /// <summary>
        /// Set the amount of memory allocated to each instance of the function app in MB. CPU and network bandwidth are allocated
        /// proportionally.
        /// </summary>
        float? ScaleAndConcurrencyInstanceMemoryMb { get; set; }
        /// <summary>The maximum number of instances for the function app.</summary>
        float? ScaleAndConcurrencyMaximumInstanceCount { get; set; }
        /// <summary>Scale and concurrency settings for the function app triggers.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsScaleAndConcurrencyTriggers ScaleAndConcurrencyTrigger { get; set; }
        /// <summary>
        /// <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The default is <code>false</code>.
        /// </summary>
        bool? ScmSiteAlsoStopped { get; set; }
        /// <summary>
        /// Resource ID of the associated App Service plan, formatted as: "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
        /// </summary>
        string ServerFarmId { get; set; }
        /// <summary>Status of the last deployment slot swap operation.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISlotSwapStatus SlotSwapStatus { get; set; }
        /// <summary>The destination slot of the last swap operation.</summary>
        string SlotSwapStatusDestinationSlotName { get; set; }
        /// <summary>The source slot of the last swap operation.</summary>
        string SlotSwapStatusSourceSlotName { get; set; }
        /// <summary>The time the last successful slot swap completed.</summary>
        global::System.DateTime? SlotSwapStatusTimestampUtc { get; set; }
        /// <summary>Current state of the app.</summary>
        string State { get; set; }
        /// <summary>Checks if Customer provided storage account is required</summary>
        bool? StorageAccountRequired { get; set; }
        /// <summary>Authentication method to access the storage account for deployment.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsDeploymentStorageAuthentication StorageAuthentication { get; set; }
        /// <summary>Property to select Azure Storage type. Available options: blobContainer.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.FunctionsDeploymentStorageType? StorageType { get; set; }
        /// <summary>
        /// Property to set the URL for the selected Azure Storage type. Example: For blobContainer, the value could be https://<storageAccountName>.blob.core.windows.net/<containerName>.
        /// </summary>
        string StorageValue { get; set; }
        /// <summary>App suspended till in case memory-time quota is exceeded.</summary>
        global::System.DateTime? SuspendedTill { get; set; }
        /// <summary>Specifies which deployment slot this app will swap into. Read-only.</summary>
        string TargetSwapSlot { get; set; }
        /// <summary>Azure Traffic Manager hostnames associated with the app. Read-only.</summary>
        string[] TrafficManagerHostName { get; set; }
        /// <summary>Scale and concurrency settings for the HTTP trigger.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsScaleAndConcurrencyTriggersHttp TriggerHttp { get; set; }
        /// <summary>State indicating whether the app has exceeded its quota usage. Read-only.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.UsageState? UsageState { get; set; }
        /// <summary>
        /// Azure Resource Manager ID of the Virtual network and subnet to be joined by Regional VNET Integration.
        /// This must be of the form /subscriptions/{subscriptionName}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}
        /// </summary>
        string VirtualNetworkSubnetId { get; set; }
        /// <summary>To enable Backup and Restore operations over virtual network</summary>
        bool? VnetBackupRestoreEnabled { get; set; }
        /// <summary>To enable accessing content over virtual network</summary>
        bool? VnetContentShareEnabled { get; set; }
        /// <summary>To enable pulling image over Virtual Network</summary>
        bool? VnetImagePullEnabled { get; set; }
        /// <summary>
        /// Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined
        /// Routes applied.
        /// </summary>
        bool? VnetRouteAllEnabled { get; set; }
        /// <summary>Workload profile name for function app to execute on.</summary>
        string WorkloadProfileName { get; set; }

    }
}