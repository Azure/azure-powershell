// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Extensions;

    /// <summary>
    /// The configuration settings of the login flow of users using App Service Authentication/Authorization.
    /// </summary>
    public partial class Login :
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ILogin,
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ILoginInternal
    {

        /// <summary>Backing field for <see cref="AllowedExternalRedirectUrl" /> property.</summary>
        private string[] _allowedExternalRedirectUrl;

        /// <summary>
        /// External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part
        /// of the URL is ignored.
        /// This is an advanced setting typically only needed by Windows Store application backends.
        /// Note that URLs within the current domain are always implicitly allowed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Owned)]
        public string[] AllowedExternalRedirectUrl { get => this._allowedExternalRedirectUrl; set => this._allowedExternalRedirectUrl = value; }

        /// <summary>
        /// The name of the app setting containing the SAS URL of the blob storage containing the tokens.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string AzureBlobStorageSasUrlSettingName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ITokenStoreInternal)TokenStore).AzureBlobStorageSasUrlSettingName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ITokenStoreInternal)TokenStore).AzureBlobStorageSasUrlSettingName = value ?? null; }

        /// <summary>Backing field for <see cref="CookieExpiration" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ICookieExpiration _cookieExpiration;

        /// <summary>The configuration settings of the session cookie's expiration.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ICookieExpiration CookieExpiration { get => (this._cookieExpiration = this._cookieExpiration ?? new Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.CookieExpiration()); set => this._cookieExpiration = value; }

        /// <summary>The convention used when determining the session cookie's expiration.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.CookieExpirationConvention? CookieExpirationConvention { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ICookieExpirationInternal)CookieExpiration).Convention; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ICookieExpirationInternal)CookieExpiration).Convention = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.CookieExpirationConvention)""); }

        /// <summary>The time after the request is made when the session cookie should expire.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string CookieExpirationTimeToExpiration { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ICookieExpirationInternal)CookieExpiration).TimeToExpiration; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ICookieExpirationInternal)CookieExpiration).TimeToExpiration = value ?? null; }

        /// <summary>The directory in which the tokens will be stored.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string FileSystemDirectory { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ITokenStoreInternal)TokenStore).FileSystemDirectory; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ITokenStoreInternal)TokenStore).FileSystemDirectory = value ?? null; }

        /// <summary>Internal Acessors for CookieExpiration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ICookieExpiration Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ILoginInternal.CookieExpiration { get => (this._cookieExpiration = this._cookieExpiration ?? new Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.CookieExpiration()); set { {_cookieExpiration = value;} } }

        /// <summary>Internal Acessors for Nonce</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.INonce Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ILoginInternal.Nonce { get => (this._nonce = this._nonce ?? new Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.Nonce()); set { {_nonce = value;} } }

        /// <summary>Internal Acessors for Route</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ILoginRoutes Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ILoginInternal.Route { get => (this._route = this._route ?? new Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.LoginRoutes()); set { {_route = value;} } }

        /// <summary>Internal Acessors for TokenStore</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ITokenStore Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ILoginInternal.TokenStore { get => (this._tokenStore = this._tokenStore ?? new Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.TokenStore()); set { {_tokenStore = value;} } }

        /// <summary>Internal Acessors for TokenStoreAzureBlobStorage</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IBlobStorageTokenStore Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ILoginInternal.TokenStoreAzureBlobStorage { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ITokenStoreInternal)TokenStore).AzureBlobStorage; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ITokenStoreInternal)TokenStore).AzureBlobStorage = value; }

        /// <summary>Internal Acessors for TokenStoreFileSystem</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IFileSystemTokenStore Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ILoginInternal.TokenStoreFileSystem { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ITokenStoreInternal)TokenStore).FileSystem; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ITokenStoreInternal)TokenStore).FileSystem = value; }

        /// <summary>Backing field for <see cref="Nonce" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.INonce _nonce;

        /// <summary>The configuration settings of the nonce used in the login flow.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.INonce Nonce { get => (this._nonce = this._nonce ?? new Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.Nonce()); set => this._nonce = value; }

        /// <summary>The time after the request is made when the nonce should expire.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string NonceExpirationInterval { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.INonceInternal)Nonce).ExpirationInterval; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.INonceInternal)Nonce).ExpirationInterval = value ?? null; }

        /// <summary>
        /// <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? NonceValidateNonce { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.INonceInternal)Nonce).ValidateNonce; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.INonceInternal)Nonce).ValidateNonce = value ?? default(bool); }

        /// <summary>Backing field for <see cref="PreserveUrlFragmentsForLogin" /> property.</summary>
        private bool? _preserveUrlFragmentsForLogin;

        /// <summary>
        /// <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Owned)]
        public bool? PreserveUrlFragmentsForLogin { get => this._preserveUrlFragmentsForLogin; set => this._preserveUrlFragmentsForLogin = value; }

        /// <summary>Backing field for <see cref="Route" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ILoginRoutes _route;

        /// <summary>The routes that specify the endpoints used for login and logout requests.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ILoginRoutes Route { get => (this._route = this._route ?? new Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.LoginRoutes()); set => this._route = value; }

        /// <summary>The endpoint at which a logout request should be made.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string RouteLogoutEndpoint { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ILoginRoutesInternal)Route).LogoutEndpoint; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ILoginRoutesInternal)Route).LogoutEndpoint = value ?? null; }

        /// <summary>Backing field for <see cref="TokenStore" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ITokenStore _tokenStore;

        /// <summary>The configuration settings of the token store.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ITokenStore TokenStore { get => (this._tokenStore = this._tokenStore ?? new Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.TokenStore()); set => this._tokenStore = value; }

        /// <summary>
        /// <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise,
        /// <code>false</code>.
        /// The default is <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? TokenStoreEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ITokenStoreInternal)TokenStore).Enabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ITokenStoreInternal)TokenStore).Enabled = value ?? default(bool); }

        /// <summary>
        /// The number of hours after session token expiration that a session token can be used to
        /// call the token refresh API. The default is 72 hours.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public double? TokenStoreTokenRefreshExtensionHour { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ITokenStoreInternal)TokenStore).TokenRefreshExtensionHour; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ITokenStoreInternal)TokenStore).TokenRefreshExtensionHour = value ?? default(double); }

        /// <summary>Creates an new <see cref="Login" /> instance.</summary>
        public Login()
        {

        }
    }
    /// The configuration settings of the login flow of users using App Service Authentication/Authorization.
    public partial interface ILogin :
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.IJsonSerializable
    {
        /// <summary>
        /// External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part
        /// of the URL is ignored.
        /// This is an advanced setting typically only needed by Windows Store application backends.
        /// Note that URLs within the current domain are always implicitly allowed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
        This is an advanced setting typically only needed by Windows Store application backends.
        Note that URLs within the current domain are always implicitly allowed.",
        SerializedName = @"allowedExternalRedirectUrls",
        PossibleTypes = new [] { typeof(string) })]
        string[] AllowedExternalRedirectUrl { get; set; }
        /// <summary>
        /// The name of the app setting containing the SAS URL of the blob storage containing the tokens.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the app setting containing the SAS URL of the blob storage containing the tokens.",
        SerializedName = @"sasUrlSettingName",
        PossibleTypes = new [] { typeof(string) })]
        string AzureBlobStorageSasUrlSettingName { get; set; }
        /// <summary>The convention used when determining the session cookie's expiration.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The convention used when determining the session cookie's expiration.",
        SerializedName = @"convention",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.CookieExpirationConvention) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.CookieExpirationConvention? CookieExpirationConvention { get; set; }
        /// <summary>The time after the request is made when the session cookie should expire.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The time after the request is made when the session cookie should expire.",
        SerializedName = @"timeToExpiration",
        PossibleTypes = new [] { typeof(string) })]
        string CookieExpirationTimeToExpiration { get; set; }
        /// <summary>The directory in which the tokens will be stored.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The directory in which the tokens will be stored.",
        SerializedName = @"directory",
        PossibleTypes = new [] { typeof(string) })]
        string FileSystemDirectory { get; set; }
        /// <summary>The time after the request is made when the nonce should expire.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The time after the request is made when the nonce should expire.",
        SerializedName = @"nonceExpirationInterval",
        PossibleTypes = new [] { typeof(string) })]
        string NonceExpirationInterval { get; set; }
        /// <summary>
        /// <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.",
        SerializedName = @"validateNonce",
        PossibleTypes = new [] { typeof(bool) })]
        bool? NonceValidateNonce { get; set; }
        /// <summary>
        /// <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.",
        SerializedName = @"preserveUrlFragmentsForLogins",
        PossibleTypes = new [] { typeof(bool) })]
        bool? PreserveUrlFragmentsForLogin { get; set; }
        /// <summary>The endpoint at which a logout request should be made.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The endpoint at which a logout request should be made.",
        SerializedName = @"logoutEndpoint",
        PossibleTypes = new [] { typeof(string) })]
        string RouteLogoutEndpoint { get; set; }
        /// <summary>
        /// <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise,
        /// <code>false</code>.
        /// The default is <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise, <code>false</code>.
         The default is <code>false</code>.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? TokenStoreEnabled { get; set; }
        /// <summary>
        /// The number of hours after session token expiration that a session token can be used to
        /// call the token refresh API. The default is 72 hours.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The number of hours after session token expiration that a session token can be used to
        call the token refresh API. The default is 72 hours.",
        SerializedName = @"tokenRefreshExtensionHours",
        PossibleTypes = new [] { typeof(double) })]
        double? TokenStoreTokenRefreshExtensionHour { get; set; }

    }
    /// The configuration settings of the login flow of users using App Service Authentication/Authorization.
    internal partial interface ILoginInternal

    {
        /// <summary>
        /// External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part
        /// of the URL is ignored.
        /// This is an advanced setting typically only needed by Windows Store application backends.
        /// Note that URLs within the current domain are always implicitly allowed.
        /// </summary>
        string[] AllowedExternalRedirectUrl { get; set; }
        /// <summary>
        /// The name of the app setting containing the SAS URL of the blob storage containing the tokens.
        /// </summary>
        string AzureBlobStorageSasUrlSettingName { get; set; }
        /// <summary>The configuration settings of the session cookie's expiration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ICookieExpiration CookieExpiration { get; set; }
        /// <summary>The convention used when determining the session cookie's expiration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.CookieExpirationConvention? CookieExpirationConvention { get; set; }
        /// <summary>The time after the request is made when the session cookie should expire.</summary>
        string CookieExpirationTimeToExpiration { get; set; }
        /// <summary>The directory in which the tokens will be stored.</summary>
        string FileSystemDirectory { get; set; }
        /// <summary>The configuration settings of the nonce used in the login flow.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.INonce Nonce { get; set; }
        /// <summary>The time after the request is made when the nonce should expire.</summary>
        string NonceExpirationInterval { get; set; }
        /// <summary>
        /// <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        /// </summary>
        bool? NonceValidateNonce { get; set; }
        /// <summary>
        /// <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        /// </summary>
        bool? PreserveUrlFragmentsForLogin { get; set; }
        /// <summary>The routes that specify the endpoints used for login and logout requests.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ILoginRoutes Route { get; set; }
        /// <summary>The endpoint at which a logout request should be made.</summary>
        string RouteLogoutEndpoint { get; set; }
        /// <summary>The configuration settings of the token store.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ITokenStore TokenStore { get; set; }
        /// <summary>
        /// The configuration settings of the storage of the tokens if blob storage is used.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IBlobStorageTokenStore TokenStoreAzureBlobStorage { get; set; }
        /// <summary>
        /// <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise,
        /// <code>false</code>.
        /// The default is <code>false</code>.
        /// </summary>
        bool? TokenStoreEnabled { get; set; }
        /// <summary>
        /// The configuration settings of the storage of the tokens if a file system is used.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IFileSystemTokenStore TokenStoreFileSystem { get; set; }
        /// <summary>
        /// The number of hours after session token expiration that a session token can be used to
        /// call the token refresh API. The default is 72 hours.
        /// </summary>
        double? TokenStoreTokenRefreshExtensionHour { get; set; }

    }
}