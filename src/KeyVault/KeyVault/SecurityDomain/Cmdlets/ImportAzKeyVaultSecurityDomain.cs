using Microsoft.Azure.Commands.Common.Authentication;
using Microsoft.Azure.Commands.Common.Exceptions;
using Microsoft.Azure.Commands.KeyVault.Models;
using Microsoft.Azure.Commands.KeyVault.Properties;
using Microsoft.Azure.Commands.KeyVault.SecurityDomain.Common;
using Microsoft.Azure.Commands.KeyVault.SecurityDomain.Models;
using Microsoft.WindowsAzure.Commands.Utilities.Common;
using Newtonsoft.Json;
using System;
using System.IO;
using System.Linq;
using System.Management.Automation;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;

namespace Microsoft.Azure.Commands.KeyVault.SecurityDomain.Cmdlets
{
    [Cmdlet(VerbsData.Import, ResourceManager.Common.AzureRMConstants.AzurePrefix + CmdletNoun.KeyVault + "SecurityDomain", SupportsShouldProcess = true, DefaultParameterSetName = ByName)]
    [OutputType(typeof(bool))]
    public class ImportAzKeyVaultSecurityDomain : SecurityDomainCmdlet
    {
        protected const string DoRestoreBlob = "DoRestoreBlob";
        protected const string ByRestoredBlob = "ByRestoredBlob";
        protected const string GenerateExchangeKey = "GenerateExchangeKey";
        protected const string ByName = "ByName";
        protected const string ByInputObject = "ByInputObject";
        // protected const string ByResourceId = "ByResourceID";

        [Parameter(HelpMessage = "Name of the managed HSM.", Mandatory = true, ParameterSetName = ByName)]
        [Parameter(HelpMessage = "Name of the managed HSM.", Mandatory = true, ParameterSetName = ByRestoredBlob)]
        [Parameter(HelpMessage = "Name of the managed HSM.", Mandatory = true, ParameterSetName = GenerateExchangeKey)]
        [Alias("HsmName")]
        [ValidateNotNullOrEmpty]
        public string Name { get; set; }

        [Parameter(HelpMessage = "Object representing a managed HSM.", Mandatory = true, ParameterSetName = ByInputObject, ValueFromPipeline = true)]
        [ValidateNotNull]
        public PSKeyVaultIdentityItem InputObject { get; set; }

        [Parameter(HelpMessage = "Information about the keys that are used to decrypt the security domain data. See examples for how it is constructed.", Mandatory = true, ParameterSetName = ByName)]
        [Parameter(HelpMessage = "Information about the keys that are used to decrypt the security domain data. See examples for how it is constructed.", Mandatory = true, ParameterSetName = ByInputObject)]
        [Parameter(HelpMessage = "Information about the keys that are used to decrypt the security domain data. See examples for how it is constructed.", Mandatory = true, ParameterSetName = DoRestoreBlob)]
        [ValidateNotNullOrEmpty]
        public KeyPath[] Keys { get; set; }

        [Parameter(HelpMessage = "Specify the path to the encrypted security domain data.", Mandatory = true, ParameterSetName = ByName)]
        [Parameter(HelpMessage = "Specify the path to the encrypted security domain data.", Mandatory = true, ParameterSetName = ByInputObject)]
        [Parameter(HelpMessage = "Specify the path to the prepared security domain data.", Mandatory = true, ParameterSetName = ByRestoredBlob)]
        [Parameter(HelpMessage = "Specify the path to the encrypted security domain data.", Mandatory = true, ParameterSetName = DoRestoreBlob)]
        [Alias("Path")]
        [ValidateNotNullOrEmpty]
        public string SecurityDomainPath { get; set; }

        [Parameter(HelpMessage = "Local file path to store the security domain encrypted with the exchange key.", Mandatory = true, ParameterSetName = DoRestoreBlob)]
        [Parameter(HelpMessage = "Local file path to store the exported key.", Mandatory = true, ParameterSetName = GenerateExchangeKey)]
        [ValidateNotNullOrEmpty]
        public string OutFile { get; set; }

        [Parameter(HelpMessage = "Local path of exchange key used to encrypt the security domain data. Generated by running Import-AzKeyVaultSecurityDomain with -DownloadExchangeKey.", Mandatory = true, ParameterSetName=DoRestoreBlob)]
        [ValidateNotNullOrEmpty]
        public string ExchangeKeyPath { get; set; }


        [Parameter(HelpMessage = "Specify whether to overwrite existing file.", ParameterSetName = GenerateExchangeKey)]
        [Parameter(HelpMessage = "Specify whether to overwrite existing file.", ParameterSetName = DoRestoreBlob)]
        public SwitchParameter Force { get; set; }

        [Parameter(HelpMessage = "When specified, an exchange key will be downloaded to specified path.", Mandatory = true, ParameterSetName = GenerateExchangeKey)]
        public SwitchParameter DownloadExchangeKey { get; set; }

        [Parameter(HelpMessage = "When specified, the security domain data will be decrypted and encrypted using generated ExchangeKey locally.", Mandatory = true, ParameterSetName = DoRestoreBlob)]
        public SwitchParameter RestoreBlob { get; set; }

        [Parameter(HelpMessage = "When specified, SecurityDomainPath should be encrypted security domain data generated by Restore-AzKeyVaultSecurityDomainBlob.", Mandatory = true, ParameterSetName = ByRestoredBlob)]
        public SwitchParameter ImportRestoredBlob { get; set; }

        [Parameter(HelpMessage = "When specified, a boolean will be returned when cmdlet succeeds.")]
        public SwitchParameter PassThru { get; set; }

        public override void DoExecuteCmdlet()
        {
            if (this.IsParameterBound(c => c.InputObject))
            {
                Name = InputObject.VaultName;
            }
            if (ParameterSetName == GenerateExchangeKey)
            {
                if (ShouldProcess($"managed HSM {Name}", $"download exported key to '{OutFile}'"))
                {
                    var exchangeKey = Client.DownloadSecurityDomainExchangeKeyAsPem(Name, CancellationToken);
                    OutFile = ResolveUserPath(OutFile);

                    if (!AzureSession.Instance.DataStore.FileExists(OutFile) || Force || ShouldContinue(string.Format(Resources.FileOverwriteMessage, OutFile), Resources.FileOverwriteCaption))
                    {
                        AzureSession.Instance.DataStore.WriteFile(OutFile, exchangeKey);
                        WriteDebug($"Security domain data of managed HSM '{Name}' downloaded to '{OutFile}'.");
                    }
                }
            }
            else if (ParameterSetName == DoRestoreBlob)
            {
                ValidateParameters();
                if (ShouldProcess($"Generating file {OutFile}", $"restore security domain data from file \"{SecurityDomainPath}\""))
                {
                    Keys = Keys.Select(key => new KeyPath()
                    {
                        PublicKey = ResolveUserPath(key.PublicKey),
                        PrivateKey = ResolveUserPath(key.PrivateKey)
                    }).ToArray();
                    ExchangeKeyPath = ResolveUserPath(ExchangeKeyPath);
                    OutFile = ResolveUserPath(OutFile);

                    // Decrypt using Private Keys
                    var securityDomain = LoadSdFromFile(ResolveUserPath(SecurityDomainPath));
                    var rawSecurityDomain = Client.DecryptSecurityDomain(securityDomain, Keys);
                    // Encript using Exchange Keys Generated by Initialize-AzKeyVaultSecurityDomainRecovery
                    var exchangeKey = new X509Certificate2(ExchangeKeyPath);
                    var encryptedSecurityDomain = Client.EncryptForRestore(rawSecurityDomain, exchangeKey);
                    string securityDomainBlob = JsonConvert.SerializeObject(encryptedSecurityDomain);

                    if (!AzureSession.Instance.DataStore.FileExists(OutFile) || Force || ShouldContinue(string.Format(Resources.FileOverwriteMessage, OutFile), Resources.FileOverwriteCaption))
                    {
                        AzureSession.Instance.DataStore.WriteFile(OutFile, securityDomainBlob);
                        WriteDebug($"Security domain data of exported managed HSM '{SecurityDomainPath}' restored to '{OutFile}'.");
                    }
                }
            }
            else
            {
                if (ShouldProcess($"managed HSM {Name}", $"restore security domain data from file \"{SecurityDomainPath}\""))
                {
                    var securityDomainRestore = JsonConvert.DeserializeObject<SecurityDomainRestoreData>(Utils.FileToString(SecurityDomainPath));

                    if (!ImportRestoredBlob)
                    {
                        ValidateParameters();
                        var securityDomain = LoadSdFromFile(ResolveUserPath(SecurityDomainPath));
                        Keys = Keys.Select(key => new KeyPath()
                        {
                            PublicKey = this.ResolveUserPath(key.PublicKey),
                            PrivateKey = this.ResolveUserPath(key.PrivateKey)
                        }).ToArray();

                        var rawSecurityDomain = Client.DecryptSecurityDomain(securityDomain, Keys);
                        var exchangeKey = Client.DownloadSecurityDomainExchangeKey(Name, CancellationToken);
                        securityDomainRestore = Client.EncryptForRestore(rawSecurityDomain, exchangeKey);
                    }

                    Client.RestoreSecurityDomain(Name, securityDomainRestore, CancellationToken);
                }
            }
            if (PassThru)
            {
                WriteObject(true);
            }

        }

        private void ValidateParameters()
        {
            if (Keys.Length < 2)
            {
                throw new AzPSArgumentException(string.Format(Resources.RestoreSecurityDomainNotEnoughKey, Common.Constants.MinQuorum), nameof(Keys));
            }
            if (Keys.Any(key => string.IsNullOrEmpty(key.PublicKey) || string.IsNullOrEmpty(key.PrivateKey)))
            {
                throw new AzPSArgumentException(Resources.RestoreSecurityDomainBadKey, nameof(Keys));
            }
        }

        private SecurityDomainData LoadSdFromFile(string path)
        {
            try
            {
                string content = Utils.FileToString(path);
                if (string.IsNullOrWhiteSpace(content))
                {
                    throw new ArgumentException(nameof(SecurityDomainPath));
                }
                return JsonConvert.DeserializeObject<SecurityDomainData>(content);
            }
            catch (Exception ex)
            {
                throw new Exception(
                    string.Format(Resources.LoadSecurityDomainFileFailed, path), ex);
            }
        }
    }
}
