
# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Code generated by Microsoft (R) AutoRest Code Generator.Changes may cause incorrect behavior and will be lost if the code
# is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
The operation to Remove a virtual machine virtual disk.
.Description
The operation to Remove a virtual machine virtual disk.
.Example
Remove-AzScVmmVMDisk -vmName "test-vm" -ResourceGroupName "test-rg-01" -DiskName 'test-disk-01'

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Models.IVirtualMachineInstance
.Link
https://learn.microsoft.com/powershell/module/az.scvmm/remove-azscvmmvmdisk
#>

function Remove-AzScVmmVMDisk {
  [OutputType([Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Models.IVirtualMachineInstance])]
  [CmdletBinding(DefaultParameterSetName='DeleteExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
  param(
      [Parameter(Mandatory)]
      [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Category('Path')]
      [System.String]
      # The name of the virtual machine.
      ${vmName},
  
      [Parameter(Mandatory)]
      [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Category('Path')]
      [System.String]
      # The name of the resource group.
      # The name is case insensitive.
      ${ResourceGroupName},
  
      [Parameter()]
      [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Category('Path')]
      [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Runtime.DefaultInfo(Script = '(Get-AzContext).Subscription.Id')]
      [System.String]
      # The ID of the target subscription.
      # The value must be an UUID.
      ${SubscriptionId},

      [Parameter(ParameterSetName='DeleteExpanded')]
      [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Category('Path')]
      [System.String]
      # The name of Virtual Disk
      ${DiskName},

      [Parameter(ParameterSetName='DeleteExpanded')]
      [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Category('Path')]
      [System.String]
      # The UUID of Virtual Disk
      ${DiskId},
  
      [Parameter()]
      [Alias('AzureRMContext', 'AzureCredential')]
      [ValidateNotNull()]
      [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Category('Azure')]
      [System.Management.Automation.PSObject]
      # The DefaultProfile parameter is not functional.
      # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
      ${DefaultProfile},
  
      [Parameter()]
      [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Category('Runtime')]
      [System.Management.Automation.SwitchParameter]
      # Run the command as a job
      ${AsJob},
  
      [Parameter(DontShow)]
      [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Category('Runtime')]
      [System.Management.Automation.SwitchParameter]
      # Wait for .NET debugger to attach
      ${Break},
  
      [Parameter(DontShow)]
      [ValidateNotNull()]
      [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Category('Runtime')]
      [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Runtime.SendAsyncStep[]]
      # SendAsync Pipeline Steps to be appended to the front of the pipeline
      ${HttpPipelineAppend},
  
      [Parameter(DontShow)]
      [ValidateNotNull()]
      [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Category('Runtime')]
      [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Runtime.SendAsyncStep[]]
      # SendAsync Pipeline Steps to be prepended to the front of the pipeline
      ${HttpPipelinePrepend},
  
      [Parameter()]
      [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Category('Runtime')]
      [System.Management.Automation.SwitchParameter]
      # Run the command asynchronously
      ${NoWait},
  
      [Parameter(DontShow)]
      [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Category('Runtime')]
      [System.Uri]
      # The URI for the proxy server to use
      ${Proxy},
  
      [Parameter(DontShow)]
      [ValidateNotNull()]
      [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Category('Runtime')]
      [System.Management.Automation.PSCredential]
      # Credentials for a proxy server to use for the remote call
      ${ProxyCredential},
  
      [Parameter(DontShow)]
      [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Category('Runtime')]
      [System.Management.Automation.SwitchParameter]
      # Use the default credentials for the proxy
      ${ProxyUseDefaultCredentials}
  )
  
  begin {
      try {
          $outBuffer = $null
          if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
              $PSBoundParameters['OutBuffer'] = 1
          }
          $parameterSet = $PSCmdlet.ParameterSetName
  
          if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
              [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
          }         
          $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
          if ($preTelemetryId -eq '') {
              [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
              [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
          } else {
              $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
              if ($internalCalledCmdlets -eq '') {
                  [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
              } else {
                  [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
              }
              [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
          }
  
          $mapping = @{
            DeleteExpanded = 'Az.ScVmm.private\Update-AzScVmmVM_UpdateExpanded';
          }
          $cmdInfo = Get-Command -Name $mapping[$parameterSet]
          [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
          if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
              [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
              [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
          }
          $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
          if ($null -eq $wrappedCmd) {
              $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
          }
  
          # Custom Code Begin

          if (-not $PSBoundParameters.ContainsKey('DiskName') -and -not $PSBoundParameters.ContainsKey('DiskId')) {
            throw "Either disk name or disk id must be specified to remove the disk."
          }

          try {
            $machineObj = Az.ScVmm.internal\Get-AzScVmmMachine -Name $vmName -ResourceGroupName $ResourceGroupName -SubscriptionId $SubscriptionId
            if ($null -eq $machineObj) {
              throw "Virtual Machine $vmName not found in Resource Group $ResourceGroupName (SubscriptionId $SubscriptionId)"
            }
          }
          catch {
            throw "Virtual Machine $vmName not found in Resource Group $ResourceGroupName (SubscriptionId $SubscriptionId)"
          }

          try {
            $vmObj = Az.ScVmm.internal\Get-AzScVmmVM -MachineId $machineObj.Id
            if ($null -eq $machineObj) {
              throw "Failed to fetch Virtual Machine Object for Virtual Machine $vmName"
            }
          }
          catch {
            throw "Failed to fetch Virtual Machine Object for Virtual Machine $vmName"
          }

          $newDiskObject = @()
          $diskFound = $false

          if ($null -ne $vmObj.StorageProfileDisk -and $vmObj.StorageProfileDisk.Count -ge 1) {
            foreach ($vmDisk in $vmObj.StorageProfileDisk) {

              $diskParams = @{}

              if ($null -ne $vmDisk.Name -and $vmDisk.Name -ne "") { 
                  $diskParams['Name'] = $vmDisk.Name 
              }
              if ($null -ne $vmDisk.Bus) { 
                  $diskParams['Bus'] = $vmDisk.Bus 
              }
              if ($null -ne $vmDisk.BusType -and $vmDisk.BusType -ne "") { 
                  $diskParams['BusType'] = $vmDisk.BusType 
              }
              if ($null -ne $vmDisk.DiskId -and $vmDisk.DiskId -ne "") { 
                  $diskParams['DiskId'] = $vmDisk.DiskId 
              }
              if ($null -ne $vmDisk.MaxDiskSizeGb) { 
                  $diskParams['DiskSizeGb'] = $vmDisk.MaxDiskSizeGb 
              }
              if ($null -ne $vmDisk.Lun) { 
                  $diskParams['Lun'] = $vmDisk.Lun 
              }
              if ($null -ne $vmDisk.StorageQoSPolicyId -and $vmDisk.StorageQoSPolicyId -ne "") { 
                  $diskParams['StorageQoSPolicyId'] = $vmDisk.StorageQoSPolicyId 
              }
              if ($null -ne $vmDisk.StorageQoSPolicyName -and $vmDisk.StorageQoSPolicyName -ne "") { 
                  $diskParams['StorageQoSPolicyName'] = $vmDisk.StorageQoSPolicyName 
              }
              if ($null -ne $vmDisk.VhdType -and $vmDisk.VhdType -ne "") { 
                  $diskParams['VhdType'] = $vmDisk.VhdType 
              }

              $diskObj = New-AzScVmmVirtualDiskUpdateObject @diskParams
              if ($null -eq $diskObj) {
                throw "Failed to create new VirtualDiskUpdateObject with specified parameters. Error $($_.Exception.Message)"
              }

              if (($PSBoundParameters.ContainsKey('DiskName') -and ($null -ne $vmDisk.Name -and $vmDisk.Name -ne "") -and $DiskName -eq $vmDisk.Name) -or ($PSBoundParameters.ContainsKey('DiskId') -and ($null -ne $vmDisk.DiskId -and $vmDisk.DiskId -ne "") -and $DiskId -eq $vmDisk.DiskId)) {
                  if (($PSBoundParameters.ContainsKey('DiskName') -and ($null -ne $vmDisk.Name -and $vmDisk.Name -ne "") -and $DiskName -ne $vmDisk.Name) -or ($PSBoundParameters.ContainsKey('DiskId') -and ($null -ne $vmDisk.DiskId -and $vmDisk.DiskId -ne "") -and $DiskId -ne $vmDisk.DiskId)) {
                      throw "Incorrect DiskName and DiskId combination, Please specify both DiskName and DiskId to remove the Disk."
                  }
                  $diskFound = $true
                  continue
              }
              $newDiskObject += $diskObj
            }
          }

          if (-not $diskFound) {
            if ($DiskName) {
              throw "Disks with name $DiskName not present in the given virtual machine."
            } elseif ($DiskId) {
              throw "Disks with id $DiskId not present in the given virtual machine."
            }
          }

          # List of parameters to remove
          $keysToRemove = @('vmName', 'ResourceGroupName', 'SubscriptionId', 'DiskName', 'DiskId')

          # Remove parameters if they exist in PSBoundParameters
          foreach ($key in $keysToRemove) {
              if ($PSBoundParameters.ContainsKey($key)) {
                [void]$PSBoundParameters.Remove($key)
              }
          }

          $PSBoundParameters['MachineId'] = $machineObj.Id
          $PSBoundParameters['StorageProfileDisk'] = [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.Models.IVirtualDiskUpdate[]]$newDiskObject
                  
          # Custom Code End
  
          $scriptCmd = {& $wrappedCmd @PSBoundParameters}
          $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
          $steppablePipeline.Begin($PSCmdlet)
      } catch {
          [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
          throw
      }
  }
  
  process {
      try {
          $steppablePipeline.Process($_)
      } catch {
          [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
          throw
      }
  
      finally {
          $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
          $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
          [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
      }
  
  }
  end {
      try {
          $steppablePipeline.End()
  
          [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
          [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
          if ($preTelemetryId -eq '') {
              [Microsoft.Azure.PowerShell.Cmdlets.ScVmm.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
              [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
          }
          [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId
  
      } catch {
          [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
          throw
      }
  } 
}