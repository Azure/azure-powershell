// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Batch
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Extensions;

    /// <summary>
    /// Low-level API implementation for the Batch service.
    /// Azure Batch provides Cloud-scale job scheduling and compute management.
    /// </summary>
    public partial class Batch
    {

        /// <summary>
        /// This operation returns only Applications and versions that are available for
        /// use on Compute Nodes; that is, that can be used in an Package reference. For
        /// administrator information about Applications and versions that are not yet
        /// available to Compute Nodes, use the Azure portal or the Azure Resource Manager
        /// API.
        /// </summary>
        /// <param name="applicationId">The ID of the Application</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ApplicationsGetApplication(string applicationId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplication>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/applications/"
                        + global::System.Uri.EscapeDataString(applicationId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ApplicationsGetApplication_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This operation returns only Applications and versions that are available for
        /// use on Compute Nodes; that is, that can be used in an Package reference. For
        /// administrator information about Applications and versions that are not yet
        /// available to Compute Nodes, use the Azure portal or the Azure Resource Manager
        /// API.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ApplicationsGetApplicationViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplication>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/applications/(?<applicationId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/applications/{applicationId}'");
                }

                // replace URI parameters with values from identity
                var applicationId = _match.Groups["applicationId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/applications/"
                        + applicationId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ApplicationsGetApplication_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This operation returns only Applications and versions that are available for
        /// use on Compute Nodes; that is, that can be used in an Package reference. For
        /// administrator information about Applications and versions that are not yet
        /// available to Compute Nodes, use the Azure portal or the Azure Resource Manager
        /// API.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplication>" />
        /// that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplication> ApplicationsGetApplicationViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/applications/(?<applicationId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/applications/{applicationId}'");
                }

                // replace URI parameters with values from identity
                var applicationId = _match.Groups["applicationId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/applications/"
                        + applicationId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.ApplicationsGetApplicationWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// This operation returns only Applications and versions that are available for
        /// use on Compute Nodes; that is, that can be used in an Package reference. For
        /// administrator information about Applications and versions that are not yet
        /// available to Compute Nodes, use the Azure portal or the Azure Resource Manager
        /// API.
        /// </summary>
        /// <param name="applicationId">The ID of the Application</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplication>" />
        /// that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplication> ApplicationsGetApplicationWithResult(string applicationId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/applications/"
                        + global::System.Uri.EscapeDataString(applicationId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.ApplicationsGetApplicationWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref= "ApplicationsGetApplicationWithResult" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplication>" />
        /// that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplication> ApplicationsGetApplicationWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchApplication.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "ApplicationsGetApplication" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ApplicationsGetApplication_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplication>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchApplication.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ApplicationsGetApplication" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="applicationId">The ID of the Application</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ApplicationsGetApplication_Validate(string applicationId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(applicationId),applicationId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>
        /// This operation returns only Applications and versions that are available for
        /// use on Compute Nodes; that is, that can be used in an Package reference. For
        /// administrator information about applications and versions that are not yet
        /// available to Compute Nodes, use the Azure portal or the Azure Resource Manager
        /// API.
        /// </summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ApplicationsListApplications(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplicationListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/applications"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ApplicationsListApplications_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This operation returns only Applications and versions that are available for
        /// use on Compute Nodes; that is, that can be used in an Package reference. For
        /// administrator information about applications and versions that are not yet
        /// available to Compute Nodes, use the Azure portal or the Azure Resource Manager
        /// API.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task ApplicationsListApplicationsViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplicationListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/applications$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/applications'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/applications"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.ApplicationsListApplications_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This operation returns only Applications and versions that are available for
        /// use on Compute Nodes; that is, that can be used in an Package reference. For
        /// administrator information about applications and versions that are not yet
        /// available to Compute Nodes, use the Azure portal or the Azure Resource Manager
        /// API.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplicationListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplicationListResult> ApplicationsListApplicationsViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/applications$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/applications'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/applications"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.ApplicationsListApplicationsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// This operation returns only Applications and versions that are available for
        /// use on Compute Nodes; that is, that can be used in an Package reference. For
        /// administrator information about applications and versions that are not yet
        /// available to Compute Nodes, use the Azure portal or the Azure Resource Manager
        /// API.
        /// </summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplicationListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplicationListResult> ApplicationsListApplicationsWithResult(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/applications"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.ApplicationsListApplicationsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref= "ApplicationsListApplicationsWithResult" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplicationListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplicationListResult> ApplicationsListApplicationsWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchApplicationListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "ApplicationsListApplications" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ApplicationsListApplications_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchApplicationListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchApplicationListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="ApplicationsListApplications" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task ApplicationsListApplications_Validate(string endpoint, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? maxresults, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(maxresults),maxresults,1);
                await eventListener.AssertIsLessThanOrEqual(nameof(maxresults),maxresults,1000);
            }
        }

        /// <summary>
        /// If you try to delete a Certificate that is being used by a Pool or Compute
        /// Node, the status of the Certificate changes to deleteFailed. If you decide that
        /// you want to continue using the Certificate, you can use this operation to set
        /// the status of the Certificate back to active. If you intend to delete the
        /// Certificate, you do not need to run this operation after the deletion failed.
        /// You must make sure that the Certificate is not being used by any resources, and
        /// then you can try again to delete the Certificate.
        /// </summary>
        /// <param name="thumbprintAlgorithm">The algorithm used to derive the thumbprint parameter. This must be sha1.</param>
        /// <param name="thumbprint">The thumbprint of the Certificate being deleted.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CertificatesCancelCertificateDeletion(string thumbprintAlgorithm, string thumbprint, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ICertificatesCancelCertificateDeletionNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/certificates(thumbprintAlgorithm="
                        + global::System.Uri.EscapeDataString(thumbprintAlgorithm)
                        + ",thumbprint="
                        + global::System.Uri.EscapeDataString(thumbprint)
                        + ")/canceldelete"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CertificatesCancelCertificateDeletion_Call (request, onNoContent,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// If you try to delete a Certificate that is being used by a Pool or Compute
        /// Node, the status of the Certificate changes to deleteFailed. If you decide that
        /// you want to continue using the Certificate, you can use this operation to set
        /// the status of the Certificate back to active. If you intend to delete the
        /// Certificate, you do not need to run this operation after the deletion failed.
        /// You must make sure that the Certificate is not being used by any resources, and
        /// then you can try again to delete the Certificate.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CertificatesCancelCertificateDeletionViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ICertificatesCancelCertificateDeletionNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/certificates(thumbprintAlgorithm=(?<thumbprintAlgorithm>[^/]+),thumbprint=(?<thumbprint>[^/]+))$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/certificates(thumbprintAlgorithm={thumbprintAlgorithm},thumbprint={thumbprint})'");
                }

                // replace URI parameters with values from identity
                var thumbprintAlgorithm = _match.Groups["thumbprintAlgorithm"].Value;
                var thumbprint = _match.Groups["thumbprint"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/certificates(thumbprintAlgorithm="
                        + thumbprintAlgorithm
                        + ",thumbprint="
                        + thumbprint
                        + ")/canceldelete"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CertificatesCancelCertificateDeletion_Call (request, onNoContent,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref= "CertificatesCancelCertificateDeletion" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CertificatesCancelCertificateDeletion_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ICertificatesCancelCertificateDeletionNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.NoContent:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNoContent(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CertificatesCancelCertificateDeletion" /> method. Call this like the actual call, but
        /// you will get validation events back.
        /// </summary>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="thumbprintAlgorithm">The algorithm used to derive the thumbprint parameter. This must be sha1.</param>
        /// <param name="thumbprint">The thumbprint of the Certificate being deleted.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CertificatesCancelCertificateDeletion_Validate(string endpoint, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string thumbprintAlgorithm, string thumbprint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(thumbprintAlgorithm),thumbprintAlgorithm);
                await eventListener.AssertNotNull(nameof(thumbprint),thumbprint);
            }
        }

        /// <summary>create a Certificate to the specified Account.</summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Certificate to be created.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CertificatesCreateCertificate(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificate body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ICertificatesCreateCertificateCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/certificates"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CertificatesCreateCertificate_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>create a Certificate to the specified Account.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Certificate to be created.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CertificatesCreateCertificateViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificate body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ICertificatesCreateCertificateCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI ''");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/certificates"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CertificatesCreateCertificate_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>create a Certificate to the specified Account.</summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the CertificatesCreateCertificate operation</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CertificatesCreateCertificateViaJsonString(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ICertificatesCreateCertificateCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/certificates"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CertificatesCreateCertificate_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "CertificatesCreateCertificate" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CertificatesCreateCertificate_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ICertificatesCreateCertificateCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Created:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onCreated(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CertificatesCreateCertificate" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="body">The Certificate to be created.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CertificatesCreateCertificate_Validate(string endpoint, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificate body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// You cannot delete a Certificate if a resource (Pool or Compute Node) is using
        /// it. Before you can delete a Certificate, you must therefore make sure that the
        /// Certificate is not associated with any existing Pools, the Certificate is not
        /// installed on any Nodes (even if you remove a Certificate from a Pool, it is not
        /// removed from existing Compute Nodes in that Pool until they restart), and no
        /// running Tasks depend on the Certificate. If you try to delete a Certificate
        /// that is in use, the deletion fails. The Certificate status changes to
        /// deleteFailed. You can use Cancel Delete Certificate to set the status back to
        /// active if you decide that you want to continue using the Certificate.
        /// </summary>
        /// <param name="thumbprintAlgorithm">The algorithm used to derive the thumbprint parameter. This must be sha1.</param>
        /// <param name="thumbprint">The thumbprint of the Certificate to be deleted.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CertificatesDeleteCertificate(string thumbprintAlgorithm, string thumbprint, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ICertificatesDeleteCertificateAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/certificates(thumbprintAlgorithm="
                        + global::System.Uri.EscapeDataString(thumbprintAlgorithm)
                        + ",thumbprint="
                        + global::System.Uri.EscapeDataString(thumbprint)
                        + ")"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CertificatesDeleteCertificate_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// You cannot delete a Certificate if a resource (Pool or Compute Node) is using
        /// it. Before you can delete a Certificate, you must therefore make sure that the
        /// Certificate is not associated with any existing Pools, the Certificate is not
        /// installed on any Nodes (even if you remove a Certificate from a Pool, it is not
        /// removed from existing Compute Nodes in that Pool until they restart), and no
        /// running Tasks depend on the Certificate. If you try to delete a Certificate
        /// that is in use, the deletion fails. The Certificate status changes to
        /// deleteFailed. You can use Cancel Delete Certificate to set the status back to
        /// active if you decide that you want to continue using the Certificate.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CertificatesDeleteCertificateViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ICertificatesDeleteCertificateAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/certificates(thumbprintAlgorithm=(?<thumbprintAlgorithm>[^/]+),thumbprint=(?<thumbprint>[^/]+))$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/certificates(thumbprintAlgorithm={thumbprintAlgorithm},thumbprint={thumbprint})'");
                }

                // replace URI parameters with values from identity
                var thumbprintAlgorithm = _match.Groups["thumbprintAlgorithm"].Value;
                var thumbprint = _match.Groups["thumbprint"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/certificates(thumbprintAlgorithm="
                        + thumbprintAlgorithm
                        + ",thumbprint="
                        + thumbprint
                        + ")"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CertificatesDeleteCertificate_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "CertificatesDeleteCertificate" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CertificatesDeleteCertificate_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ICertificatesDeleteCertificateAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Accepted:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onAccepted(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CertificatesDeleteCertificate" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="thumbprintAlgorithm">The algorithm used to derive the thumbprint parameter. This must be sha1.</param>
        /// <param name="thumbprint">The thumbprint of the Certificate to be deleted.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CertificatesDeleteCertificate_Validate(string endpoint, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string thumbprintAlgorithm, string thumbprint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(thumbprintAlgorithm),thumbprintAlgorithm);
                await eventListener.AssertNotNull(nameof(thumbprint),thumbprint);
            }
        }

        /// <summary>Gets information about the specified Certificate.</summary>
        /// <param name="thumbprintAlgorithm">The algorithm used to derive the thumbprint parameter. This must be sha1.</param>
        /// <param name="thumbprint">The thumbprint of the Certificate to get.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CertificatesGetCertificate(string thumbprintAlgorithm, string thumbprint, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, System.Collections.Generic.List<string> Select, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificate>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/certificates(thumbprintAlgorithm="
                        + global::System.Uri.EscapeDataString(thumbprintAlgorithm)
                        + ",thumbprint="
                        + global::System.Uri.EscapeDataString(thumbprint)
                        + ")"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CertificatesGetCertificate_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Gets information about the specified Certificate.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CertificatesGetCertificateViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, System.Collections.Generic.List<string> Select, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificate>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/certificates(thumbprintAlgorithm=(?<thumbprintAlgorithm>[^/]+),thumbprint=(?<thumbprint>[^/]+))$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/certificates(thumbprintAlgorithm={thumbprintAlgorithm},thumbprint={thumbprint})'");
                }

                // replace URI parameters with values from identity
                var thumbprintAlgorithm = _match.Groups["thumbprintAlgorithm"].Value;
                var thumbprint = _match.Groups["thumbprint"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/certificates(thumbprintAlgorithm="
                        + thumbprintAlgorithm
                        + ",thumbprint="
                        + thumbprint
                        + ")"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CertificatesGetCertificate_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Gets information about the specified Certificate.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificate>" />
        /// that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificate> CertificatesGetCertificateViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, System.Collections.Generic.List<string> Select, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/certificates(thumbprintAlgorithm=(?<thumbprintAlgorithm>[^/]+),thumbprint=(?<thumbprint>[^/]+))$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/certificates(thumbprintAlgorithm={thumbprintAlgorithm},thumbprint={thumbprint})'");
                }

                // replace URI parameters with values from identity
                var thumbprintAlgorithm = _match.Groups["thumbprintAlgorithm"].Value;
                var thumbprint = _match.Groups["thumbprint"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/certificates(thumbprintAlgorithm="
                        + thumbprintAlgorithm
                        + ",thumbprint="
                        + thumbprint
                        + ")"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.CertificatesGetCertificateWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Gets information about the specified Certificate.</summary>
        /// <param name="thumbprintAlgorithm">The algorithm used to derive the thumbprint parameter. This must be sha1.</param>
        /// <param name="thumbprint">The thumbprint of the Certificate to get.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificate>" />
        /// that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificate> CertificatesGetCertificateWithResult(string thumbprintAlgorithm, string thumbprint, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, System.Collections.Generic.List<string> Select, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/certificates(thumbprintAlgorithm="
                        + global::System.Uri.EscapeDataString(thumbprintAlgorithm)
                        + ",thumbprint="
                        + global::System.Uri.EscapeDataString(thumbprint)
                        + ")"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.CertificatesGetCertificateWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref= "CertificatesGetCertificateWithResult" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificate>" />
        /// that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificate> CertificatesGetCertificateWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchCertificate.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "CertificatesGetCertificate" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CertificatesGetCertificate_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificate>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchCertificate.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CertificatesGetCertificate" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="thumbprintAlgorithm">The algorithm used to derive the thumbprint parameter. This must be sha1.</param>
        /// <param name="thumbprint">The thumbprint of the Certificate to get.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CertificatesGetCertificate_Validate(string endpoint, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string thumbprintAlgorithm, string thumbprint, System.Collections.Generic.List<string> Select, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(thumbprintAlgorithm),thumbprintAlgorithm);
                await eventListener.AssertNotNull(nameof(thumbprint),thumbprint);
            }
        }

        /// <summary>Lists all of the Certificates that have been added to the specified Account.</summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-certificates.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CertificatesListCertificates(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificateListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/certificates"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CertificatesListCertificates_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists all of the Certificates that have been added to the specified Account.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-certificates.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task CertificatesListCertificatesViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificateListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/certificates$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/certificates'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/certificates"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.CertificatesListCertificates_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists all of the Certificates that have been added to the specified Account.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-certificates.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificateListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificateListResult> CertificatesListCertificatesViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/certificates$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/certificates'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/certificates"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.CertificatesListCertificatesWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Lists all of the Certificates that have been added to the specified Account.</summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-certificates.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificateListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificateListResult> CertificatesListCertificatesWithResult(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/certificates"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.CertificatesListCertificatesWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref= "CertificatesListCertificatesWithResult" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificateListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificateListResult> CertificatesListCertificatesWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchCertificateListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "CertificatesListCertificates" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CertificatesListCertificates_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCertificateListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchCertificateListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="CertificatesListCertificates" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-certificates.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task CertificatesListCertificates_Validate(string endpoint, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(maxresults),maxresults,1);
                await eventListener.AssertIsLessThanOrEqual(nameof(maxresults),maxresults,1000);
                await eventListener.AssertNotNull(nameof(Filter),Filter);
            }
        }

        /// <summary>create a Job Schedule to the specified Account.</summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Job Schedule to be created.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesCreateJobSchedule(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleCreateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesCreateJobScheduleCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesCreateJobSchedule_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>create a Job Schedule to the specified Account.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Job Schedule to be created.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesCreateJobScheduleViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleCreateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesCreateJobScheduleCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI ''");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesCreateJobSchedule_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>create a Job Schedule to the specified Account.</summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the JobSchedulesCreateJobSchedule operation</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesCreateJobScheduleViaJsonString(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesCreateJobScheduleCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesCreateJobSchedule_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobSchedulesCreateJobSchedule" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesCreateJobSchedule_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesCreateJobScheduleCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Created:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onCreated(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobSchedulesCreateJobSchedule" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="body">The Job Schedule to be created.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesCreateJobSchedule_Validate(string endpoint, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleCreateOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// When you delete a Job Schedule, this also deletes all Jobs and Tasks under that
        /// schedule. When Tasks are deleted, all the files in their working directories on
        /// the Compute Nodes are also deleted (the retention period is ignored). The Job
        /// Schedule statistics are no longer accessible once the Job Schedule is deleted,
        /// though they are still counted towards Account lifetime statistics.
        /// </summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule to delete.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="force">If true, the server will delete the JobSchedule even if the corresponding nodes have not fully processed
        /// the deletion. The default value is false.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesDeleteJobSchedule(string jobScheduleId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, bool? force, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesDeleteJobScheduleAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + global::System.Uri.EscapeDataString(jobScheduleId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == force ? global::System.String.Empty : "force=" + global::System.Uri.EscapeDataString(force.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesDeleteJobSchedule_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// When you delete a Job Schedule, this also deletes all Jobs and Tasks under that
        /// schedule. When Tasks are deleted, all the files in their working directories on
        /// the Compute Nodes are also deleted (the retention period is ignored). The Job
        /// Schedule statistics are no longer accessible once the Job Schedule is deleted,
        /// though they are still counted towards Account lifetime statistics.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="force">If true, the server will delete the JobSchedule even if the corresponding nodes have not fully processed
        /// the deletion. The default value is false.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesDeleteJobScheduleViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, bool? force, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesDeleteJobScheduleAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobschedules/(?<jobScheduleId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobschedules/{jobScheduleId}'");
                }

                // replace URI parameters with values from identity
                var jobScheduleId = _match.Groups["jobScheduleId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + jobScheduleId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == force ? global::System.String.Empty : "force=" + global::System.Uri.EscapeDataString(force.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesDeleteJobSchedule_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobSchedulesDeleteJobSchedule" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesDeleteJobSchedule_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesDeleteJobScheduleAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Accepted:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onAccepted(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobSchedulesDeleteJobSchedule" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule to delete.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="force">If true, the server will delete the JobSchedule even if the corresponding nodes have not fully processed
        /// the deletion. The default value is false.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesDeleteJobSchedule_Validate(string jobScheduleId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, bool? force, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobScheduleId),jobScheduleId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>No new Jobs will be created until the Job Schedule is enabled again.</summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule to disable.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesDisableJobSchedule(string jobScheduleId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesDisableJobScheduleNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + global::System.Uri.EscapeDataString(jobScheduleId)
                        + "/disable"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesDisableJobSchedule_Call (request, onNoContent,onDefault,eventListener,sender);
            }
        }

        /// <summary>No new Jobs will be created until the Job Schedule is enabled again.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesDisableJobScheduleViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesDisableJobScheduleNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobschedules/(?<jobScheduleId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobschedules/{jobScheduleId}'");
                }

                // replace URI parameters with values from identity
                var jobScheduleId = _match.Groups["jobScheduleId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + jobScheduleId
                        + "/disable"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesDisableJobSchedule_Call (request, onNoContent,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobSchedulesDisableJobSchedule" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesDisableJobSchedule_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesDisableJobScheduleNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.NoContent:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNoContent(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobSchedulesDisableJobSchedule" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule to disable.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesDisableJobSchedule_Validate(string jobScheduleId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobScheduleId),jobScheduleId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>Enables a Job Schedule.</summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule to enable.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesEnableJobSchedule(string jobScheduleId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesEnableJobScheduleNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + global::System.Uri.EscapeDataString(jobScheduleId)
                        + "/enable"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesEnableJobSchedule_Call (request, onNoContent,onDefault,eventListener,sender);
            }
        }

        /// <summary>Enables a Job Schedule.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesEnableJobScheduleViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesEnableJobScheduleNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobschedules/(?<jobScheduleId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobschedules/{jobScheduleId}'");
                }

                // replace URI parameters with values from identity
                var jobScheduleId = _match.Groups["jobScheduleId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + jobScheduleId
                        + "/enable"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesEnableJobSchedule_Call (request, onNoContent,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobSchedulesEnableJobSchedule" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesEnableJobSchedule_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesEnableJobScheduleNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.NoContent:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNoContent(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobSchedulesEnableJobSchedule" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule to enable.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesEnableJobSchedule_Validate(string jobScheduleId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobScheduleId),jobScheduleId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>Gets information about the specified Job Schedule.</summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule to get.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesGetJobSchedule(string jobScheduleId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSchedule>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + global::System.Uri.EscapeDataString(jobScheduleId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesGetJobSchedule_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Gets information about the specified Job Schedule.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesGetJobScheduleViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSchedule>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobschedules/(?<jobScheduleId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobschedules/{jobScheduleId}'");
                }

                // replace URI parameters with values from identity
                var jobScheduleId = _match.Groups["jobScheduleId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + jobScheduleId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesGetJobSchedule_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Gets information about the specified Job Schedule.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSchedule>" />
        /// that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSchedule> JobSchedulesGetJobScheduleViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobschedules/(?<jobScheduleId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobschedules/{jobScheduleId}'");
                }

                // replace URI parameters with values from identity
                var jobScheduleId = _match.Groups["jobScheduleId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + jobScheduleId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.JobSchedulesGetJobScheduleWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Gets information about the specified Job Schedule.</summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule to get.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSchedule>" />
        /// that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSchedule> JobSchedulesGetJobScheduleWithResult(string jobScheduleId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + global::System.Uri.EscapeDataString(jobScheduleId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.JobSchedulesGetJobScheduleWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref= "JobSchedulesGetJobScheduleWithResult" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSchedule>" />
        /// that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSchedule> JobSchedulesGetJobScheduleWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobSchedule.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "JobSchedulesGetJobSchedule" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesGetJobSchedule_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSchedule>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobSchedule.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobSchedulesGetJobSchedule" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule to get.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesGetJobSchedule_Validate(string jobScheduleId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobScheduleId),jobScheduleId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>Checks the specified Job Schedule exists.</summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule which you want to check.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesJobScheduleExists(string jobScheduleId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesJobScheduleExistsOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + global::System.Uri.EscapeDataString(jobScheduleId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Head, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesJobScheduleExists_Call (request, onOk,onNotFound,onDefault,eventListener,sender);
            }
        }

        /// <summary>Checks the specified Job Schedule exists.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesJobScheduleExistsViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesJobScheduleExistsOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobschedules/(?<jobScheduleId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobschedules/{jobScheduleId}'");
                }

                // replace URI parameters with values from identity
                var jobScheduleId = _match.Groups["jobScheduleId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + jobScheduleId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Head, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesJobScheduleExists_Call (request, onOk,onNotFound,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobSchedulesJobScheduleExists" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesJobScheduleExists_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesJobScheduleExistsOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobSchedulesJobScheduleExists" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule which you want to check.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesJobScheduleExists_Validate(string jobScheduleId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobScheduleId),jobScheduleId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>Lists all of the Job Schedules in the specified Account.</summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-job-schedules.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesListJobSchedules(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesListJobSchedules_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists all of the Job Schedules in the specified Account.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-job-schedules.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesListJobSchedulesViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobschedules$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobschedules'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesListJobSchedules_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists all of the Job Schedules in the specified Account.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-job-schedules.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleListResult> JobSchedulesListJobSchedulesViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobschedules$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobschedules'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.JobSchedulesListJobSchedulesWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Lists all of the Job Schedules in the specified Account.</summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-job-schedules.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleListResult> JobSchedulesListJobSchedulesWithResult(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.JobSchedulesListJobSchedulesWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref= "JobSchedulesListJobSchedulesWithResult" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleListResult> JobSchedulesListJobSchedulesWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobScheduleListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "JobSchedulesListJobSchedules" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesListJobSchedules_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobScheduleListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobSchedulesListJobSchedules" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-job-schedules.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesListJobSchedules_Validate(string endpoint, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(maxresults),maxresults,1);
                await eventListener.AssertIsLessThanOrEqual(nameof(maxresults),maxresults,1000);
                await eventListener.AssertNotNull(nameof(Filter),Filter);
            }
        }

        /// <summary>
        /// This fully replaces all the updatable properties of the Job Schedule. For
        /// example, if the schedule property is not specified with this request, then the
        /// Batch service will remove the existing schedule. Changes to a Job Schedule only
        /// impact Jobs created by the schedule after the replace has taken place; currently
        /// running Jobs are unaffected.
        /// </summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule to update.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">A Job Schedule with updated properties</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesReplaceJobSchedule(string jobScheduleId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSchedule body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesReplaceJobScheduleOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + global::System.Uri.EscapeDataString(jobScheduleId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Put, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesReplaceJobSchedule_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This fully replaces all the updatable properties of the Job Schedule. For
        /// example, if the schedule property is not specified with this request, then the
        /// Batch service will remove the existing schedule. Changes to a Job Schedule only
        /// impact Jobs created by the schedule after the replace has taken place; currently
        /// running Jobs are unaffected.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">A Job Schedule with updated properties</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesReplaceJobScheduleViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSchedule body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesReplaceJobScheduleOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobschedules/(?<jobScheduleId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobschedules/{jobScheduleId}'");
                }

                // replace URI parameters with values from identity
                var jobScheduleId = _match.Groups["jobScheduleId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + jobScheduleId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Put, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesReplaceJobSchedule_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This fully replaces all the updatable properties of the Job Schedule. For
        /// example, if the schedule property is not specified with this request, then the
        /// Batch service will remove the existing schedule. Changes to a Job Schedule only
        /// impact Jobs created by the schedule after the replace has taken place; currently
        /// running Jobs are unaffected.
        /// </summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule to update.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the JobSchedulesReplaceJobSchedule operation</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesReplaceJobScheduleViaJsonString(string jobScheduleId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesReplaceJobScheduleOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + global::System.Uri.EscapeDataString(jobScheduleId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Put, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesReplaceJobSchedule_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobSchedulesReplaceJobSchedule" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesReplaceJobSchedule_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesReplaceJobScheduleOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobSchedulesReplaceJobSchedule" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule to update.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">A Job Schedule with updated properties</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesReplaceJobSchedule_Validate(string jobScheduleId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSchedule body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobScheduleId),jobScheduleId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Terminates a Job Schedule.</summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule to terminates.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="force">If true, the server will terminate the JobSchedule even if the corresponding nodes have not fully
        /// processed the termination. The default value is false.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesTerminateJobSchedule(string jobScheduleId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, bool? force, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesTerminateJobScheduleAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + global::System.Uri.EscapeDataString(jobScheduleId)
                        + "/terminate"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == force ? global::System.String.Empty : "force=" + global::System.Uri.EscapeDataString(force.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesTerminateJobSchedule_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>Terminates a Job Schedule.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="force">If true, the server will terminate the JobSchedule even if the corresponding nodes have not fully
        /// processed the termination. The default value is false.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesTerminateJobScheduleViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, bool? force, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesTerminateJobScheduleAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobschedules/(?<jobScheduleId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobschedules/{jobScheduleId}'");
                }

                // replace URI parameters with values from identity
                var jobScheduleId = _match.Groups["jobScheduleId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + jobScheduleId
                        + "/terminate"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == force ? global::System.String.Empty : "force=" + global::System.Uri.EscapeDataString(force.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesTerminateJobSchedule_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobSchedulesTerminateJobSchedule" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesTerminateJobSchedule_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesTerminateJobScheduleAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Accepted:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onAccepted(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobSchedulesTerminateJobSchedule" /> method. Call this like the actual call, but you
        /// will get validation events back.
        /// </summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule to terminates.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="force">If true, the server will terminate the JobSchedule even if the corresponding nodes have not fully
        /// processed the termination. The default value is false.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesTerminateJobSchedule_Validate(string jobScheduleId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, bool? force, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobScheduleId),jobScheduleId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>
        /// This replaces only the Job Schedule properties specified in the request. For
        /// example, if the schedule property is not specified with this request, then the
        /// Batch service will keep the existing schedule. Changes to a Job Schedule only
        /// impact Jobs created by the schedule after the update has taken place; currently
        /// running Jobs are unaffected.
        /// </summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule to update.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for updating the Job Schedule.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesUpdateJobSchedule(string jobScheduleId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleUpdateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesUpdateJobScheduleOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + global::System.Uri.EscapeDataString(jobScheduleId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Patch, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesUpdateJobSchedule_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This replaces only the Job Schedule properties specified in the request. For
        /// example, if the schedule property is not specified with this request, then the
        /// Batch service will keep the existing schedule. Changes to a Job Schedule only
        /// impact Jobs created by the schedule after the update has taken place; currently
        /// running Jobs are unaffected.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for updating the Job Schedule.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesUpdateJobScheduleViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleUpdateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesUpdateJobScheduleOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobschedules/(?<jobScheduleId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobschedules/{jobScheduleId}'");
                }

                // replace URI parameters with values from identity
                var jobScheduleId = _match.Groups["jobScheduleId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + jobScheduleId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Patch, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesUpdateJobSchedule_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This replaces only the Job Schedule properties specified in the request. For
        /// example, if the schedule property is not specified with this request, then the
        /// Batch service will keep the existing schedule. Changes to a Job Schedule only
        /// impact Jobs created by the schedule after the update has taken place; currently
        /// running Jobs are unaffected.
        /// </summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule to update.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the JobSchedulesUpdateJobSchedule operation</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobSchedulesUpdateJobScheduleViaJsonString(string jobScheduleId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesUpdateJobScheduleOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + global::System.Uri.EscapeDataString(jobScheduleId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Patch, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobSchedulesUpdateJobSchedule_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobSchedulesUpdateJobSchedule" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesUpdateJobSchedule_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobSchedulesUpdateJobScheduleOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobSchedulesUpdateJobSchedule" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule to update.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for updating the Job Schedule.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobSchedulesUpdateJobSchedule_Validate(string jobScheduleId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleUpdateOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobScheduleId),jobScheduleId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// The Batch service supports two ways to control the work done as part of a Job.
        /// In the first approach, the user specifies a Job Manager Task. The Batch service
        /// launches this Task when it is ready to start the Job. The Job Manager Task
        /// controls all other Tasks that run under this Job, by using the Task APIs. In
        /// the second approach, the user directly controls the execution of Tasks under an
        /// active Job, by using the Task APIs. Also note: when naming Jobs, avoid
        /// including sensitive information such as user names or secret project names.
        /// This information may appear in telemetry logs accessible to Microsoft Support
        /// engineers.
        /// </summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Job to be created.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsCreateJob(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobCreateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsCreateJobCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsCreateJob_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// The Batch service supports two ways to control the work done as part of a Job.
        /// In the first approach, the user specifies a Job Manager Task. The Batch service
        /// launches this Task when it is ready to start the Job. The Job Manager Task
        /// controls all other Tasks that run under this Job, by using the Task APIs. In
        /// the second approach, the user directly controls the execution of Tasks under an
        /// active Job, by using the Task APIs. Also note: when naming Jobs, avoid
        /// including sensitive information such as user names or secret project names.
        /// This information may appear in telemetry logs accessible to Microsoft Support
        /// engineers.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Job to be created.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsCreateJobViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobCreateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsCreateJobCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI ''");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsCreateJob_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// The Batch service supports two ways to control the work done as part of a Job.
        /// In the first approach, the user specifies a Job Manager Task. The Batch service
        /// launches this Task when it is ready to start the Job. The Job Manager Task
        /// controls all other Tasks that run under this Job, by using the Task APIs. In
        /// the second approach, the user directly controls the execution of Tasks under an
        /// active Job, by using the Task APIs. Also note: when naming Jobs, avoid
        /// including sensitive information such as user names or secret project names.
        /// This information may appear in telemetry logs accessible to Microsoft Support
        /// engineers.
        /// </summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the JobsCreateJob operation</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsCreateJobViaJsonString(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsCreateJobCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsCreateJob_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobsCreateJob" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsCreateJob_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsCreateJobCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Created:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onCreated(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobsCreateJob" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="body">The Job to be created.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsCreateJob_Validate(string endpoint, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobCreateOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// Deleting a Job also deletes all Tasks that are part of that Job, and all Job
        /// statistics. This also overrides the retention period for Task data; that is, if
        /// the Job contains Tasks which are still retained on Compute Nodes, the Batch
        /// services deletes those Tasks' working directories and all their contents. When
        /// a Delete Job request is received, the Batch service sets the Job to the
        /// deleting state. All delete operations on a Job that is in deleting state will
        /// fail with status code 409 (Conflict), with additional information indicating
        /// that the Job is being deleted.
        /// </summary>
        /// <param name="jobId">The ID of the Job to delete.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="force">If true, the server will delete the Job even if the corresponding nodes have not fully processed the
        /// deletion. The default value is false.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsDeleteJob(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, bool? force, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsDeleteJobAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == force ? global::System.String.Empty : "force=" + global::System.Uri.EscapeDataString(force.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsDeleteJob_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Deleting a Job also deletes all Tasks that are part of that Job, and all Job
        /// statistics. This also overrides the retention period for Task data; that is, if
        /// the Job contains Tasks which are still retained on Compute Nodes, the Batch
        /// services deletes those Tasks' working directories and all their contents. When
        /// a Delete Job request is received, the Batch service sets the Job to the
        /// deleting state. All delete operations on a Job that is in deleting state will
        /// fail with status code 409 (Conflict), with additional information indicating
        /// that the Job is being deleted.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="force">If true, the server will delete the Job even if the corresponding nodes have not fully processed the
        /// deletion. The default value is false.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsDeleteJobViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, bool? force, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsDeleteJobAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == force ? global::System.String.Empty : "force=" + global::System.Uri.EscapeDataString(force.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsDeleteJob_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobsDeleteJob" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsDeleteJob_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsDeleteJobAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Accepted:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onAccepted(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobsDeleteJob" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job to delete.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="force">If true, the server will delete the Job even if the corresponding nodes have not fully processed the
        /// deletion. The default value is false.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsDeleteJob_Validate(string jobId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, bool? force, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>
        /// The Batch Service immediately moves the Job to the disabling state. Batch then
        /// uses the disableTasks parameter to determine what to do with the currently
        /// running Tasks of the Job. The Job remains in the disabling state until the
        /// disable operation is completed and all Tasks have been dealt with according to
        /// the disableTasks option; the Job then moves to the disabled state. No new Tasks
        /// are started under the Job until it moves back to active state. If you try to
        /// disable a Job that is in any state other than active, disabling, or disabled,
        /// the request fails with status code 409.
        /// </summary>
        /// <param name="jobId">The ID of the Job to disable.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for disabling the Job.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsDisableJob(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobDisableOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsDisableJobAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/disable"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsDisableJob_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// The Batch Service immediately moves the Job to the disabling state. Batch then
        /// uses the disableTasks parameter to determine what to do with the currently
        /// running Tasks of the Job. The Job remains in the disabling state until the
        /// disable operation is completed and all Tasks have been dealt with according to
        /// the disableTasks option; the Job then moves to the disabled state. No new Tasks
        /// are started under the Job until it moves back to active state. If you try to
        /// disable a Job that is in any state other than active, disabling, or disabled,
        /// the request fails with status code 409.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for disabling the Job.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsDisableJobViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobDisableOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsDisableJobAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/disable"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsDisableJob_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// The Batch Service immediately moves the Job to the disabling state. Batch then
        /// uses the disableTasks parameter to determine what to do with the currently
        /// running Tasks of the Job. The Job remains in the disabling state until the
        /// disable operation is completed and all Tasks have been dealt with according to
        /// the disableTasks option; the Job then moves to the disabled state. No new Tasks
        /// are started under the Job until it moves back to active state. If you try to
        /// disable a Job that is in any state other than active, disabling, or disabled,
        /// the request fails with status code 409.
        /// </summary>
        /// <param name="jobId">The ID of the Job to disable.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the JobsDisableJob operation</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsDisableJobViaJsonString(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsDisableJobAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/disable"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsDisableJob_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobsDisableJob" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsDisableJob_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsDisableJobAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Accepted:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onAccepted(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobsDisableJob" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job to disable.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for disabling the Job.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsDisableJob_Validate(string jobId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobDisableOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// When you call this API, the Batch service sets a disabled Job to the enabling
        /// state. After the this operation is completed, the Job moves to the active
        /// state, and scheduling of new Tasks under the Job resumes. The Batch service
        /// does not allow a Task to remain in the active state for more than 180 days.
        /// Therefore, if you enable a Job containing active Tasks which were added more
        /// than 180 days ago, those Tasks will not run.
        /// </summary>
        /// <param name="jobId">The ID of the Job to enable.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsEnableJob(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsEnableJobAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/enable"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsEnableJob_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// When you call this API, the Batch service sets a disabled Job to the enabling
        /// state. After the this operation is completed, the Job moves to the active
        /// state, and scheduling of new Tasks under the Job resumes. The Batch service
        /// does not allow a Task to remain in the active state for more than 180 days.
        /// Therefore, if you enable a Job containing active Tasks which were added more
        /// than 180 days ago, those Tasks will not run.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsEnableJobViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsEnableJobAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/enable"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsEnableJob_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobsEnableJob" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsEnableJob_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsEnableJobAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Accepted:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onAccepted(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobsEnableJob" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job to enable.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsEnableJob_Validate(string jobId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>Gets information about the specified Job.</summary>
        /// <param name="jobId">The ID of the Job.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsGetJob(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJob>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsGetJob_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Task counts provide a count of the Tasks by active, running or completed Task
        /// state, and a count of Tasks which succeeded or failed. Tasks in the preparing
        /// state are counted as running. Note that the numbers returned may not always be
        /// up to date. If you need exact task counts, use a list query.
        /// </summary>
        /// <param name="jobId">The ID of the Job.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsGetJobTaskCounts(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskCountsResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/taskcounts"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsGetJobTaskCounts_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Task counts provide a count of the Tasks by active, running or completed Task
        /// state, and a count of Tasks which succeeded or failed. Tasks in the preparing
        /// state are counted as running. Note that the numbers returned may not always be
        /// up to date. If you need exact task counts, use a list query.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsGetJobTaskCountsViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskCountsResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/taskcounts$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/taskcounts'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/taskcounts"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsGetJobTaskCounts_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Task counts provide a count of the Tasks by active, running or completed Task
        /// state, and a count of Tasks which succeeded or failed. Tasks in the preparing
        /// state are counted as running. Note that the numbers returned may not always be
        /// up to date. If you need exact task counts, use a list query.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskCountsResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskCountsResult> JobsGetJobTaskCountsViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/taskcounts$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/taskcounts'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/taskcounts"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.JobsGetJobTaskCountsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Task counts provide a count of the Tasks by active, running or completed Task
        /// state, and a count of Tasks which succeeded or failed. Tasks in the preparing
        /// state are counted as running. Note that the numbers returned may not always be
        /// up to date. If you need exact task counts, use a list query.
        /// </summary>
        /// <param name="jobId">The ID of the Job.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskCountsResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskCountsResult> JobsGetJobTaskCountsWithResult(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/taskcounts"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.JobsGetJobTaskCountsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobsGetJobTaskCountsWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskCountsResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskCountsResult> JobsGetJobTaskCountsWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchTaskCountsResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "JobsGetJobTaskCounts" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsGetJobTaskCounts_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskCountsResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchTaskCountsResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobsGetJobTaskCounts" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsGetJobTaskCounts_Validate(string jobId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>Gets information about the specified Job.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsGetJobViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJob>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsGetJob_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Gets information about the specified Job.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJob>" /> that will
        /// be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJob> JobsGetJobViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.JobsGetJobWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Gets information about the specified Job.</summary>
        /// <param name="jobId">The ID of the Job.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJob>" /> that will
        /// be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJob> JobsGetJobWithResult(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.JobsGetJobWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobsGetJobWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJob>" /> that will
        /// be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJob> JobsGetJobWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJob.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "JobsGetJob" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsGetJob_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJob>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJob.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobsGetJob" /> method. Call this like the actual call, but you will get validation events
        /// back.
        /// </summary>
        /// <param name="jobId">The ID of the Job.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsGetJob_Validate(string jobId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>
        /// This API returns the Job Preparation and Job Release Task status on all Compute
        /// Nodes that have run the Job Preparation or Job Release Task. This includes
        /// Compute Nodes which have since been removed from the Pool. If this API is
        /// invoked on a Job which has no Job Preparation or Job Release Task, the Batch
        /// service returns HTTP status code 409 (Conflict) with an error code of
        /// JobPreparationTaskNotSpecified.
        /// </summary>
        /// <param name="jobId">The ID of the Job.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsListJobPreparationAndReleaseTaskStatus(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobPreparationAndReleaseTaskStatusListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/jobpreparationandreleasetaskstatus"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsListJobPreparationAndReleaseTaskStatus_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This API returns the Job Preparation and Job Release Task status on all Compute
        /// Nodes that have run the Job Preparation or Job Release Task. This includes
        /// Compute Nodes which have since been removed from the Pool. If this API is
        /// invoked on a Job which has no Job Preparation or Job Release Task, the Batch
        /// service returns HTTP status code 409 (Conflict) with an error code of
        /// JobPreparationTaskNotSpecified.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsListJobPreparationAndReleaseTaskStatusViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobPreparationAndReleaseTaskStatusListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/jobpreparationandreleasetaskstatus$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/jobpreparationandreleasetaskstatus'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/jobpreparationandreleasetaskstatus"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsListJobPreparationAndReleaseTaskStatus_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This API returns the Job Preparation and Job Release Task status on all Compute
        /// Nodes that have run the Job Preparation or Job Release Task. This includes
        /// Compute Nodes which have since been removed from the Pool. If this API is
        /// invoked on a Job which has no Job Preparation or Job Release Task, the Batch
        /// service returns HTTP status code 409 (Conflict) with an error code of
        /// JobPreparationTaskNotSpecified.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobPreparationAndReleaseTaskStatusListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobPreparationAndReleaseTaskStatusListResult> JobsListJobPreparationAndReleaseTaskStatusViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/jobpreparationandreleasetaskstatus$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/jobpreparationandreleasetaskstatus'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/jobpreparationandreleasetaskstatus"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.JobsListJobPreparationAndReleaseTaskStatusWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// This API returns the Job Preparation and Job Release Task status on all Compute
        /// Nodes that have run the Job Preparation or Job Release Task. This includes
        /// Compute Nodes which have since been removed from the Pool. If this API is
        /// invoked on a Job which has no Job Preparation or Job Release Task, the Batch
        /// service returns HTTP status code 409 (Conflict) with an error code of
        /// JobPreparationTaskNotSpecified.
        /// </summary>
        /// <param name="jobId">The ID of the Job.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobPreparationAndReleaseTaskStatusListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobPreparationAndReleaseTaskStatusListResult> JobsListJobPreparationAndReleaseTaskStatusWithResult(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/jobpreparationandreleasetaskstatus"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.JobsListJobPreparationAndReleaseTaskStatusWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref= "JobsListJobPreparationAndReleaseTaskStatusWithResult" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobPreparationAndReleaseTaskStatusListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobPreparationAndReleaseTaskStatusListResult> JobsListJobPreparationAndReleaseTaskStatusWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobPreparationAndReleaseTaskStatusListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Actual wire call for <see cref= "JobsListJobPreparationAndReleaseTaskStatus" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsListJobPreparationAndReleaseTaskStatus_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobPreparationAndReleaseTaskStatusListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobPreparationAndReleaseTaskStatusListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobsListJobPreparationAndReleaseTaskStatus" /> method. Call this like the actual call,
        /// but you will get validation events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsListJobPreparationAndReleaseTaskStatus_Validate(string jobId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? maxresults, string endpoint, string Filter, System.Collections.Generic.List<string> Select, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(maxresults),maxresults,1);
                await eventListener.AssertIsLessThanOrEqual(nameof(maxresults),maxresults,1000);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(Filter),Filter);
            }
        }

        /// <summary>Lists all of the Jobs in the specified Account.</summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-jobs.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsListJobs(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsListJobs_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists the Jobs that have been created under the specified Job Schedule.</summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule from which you want to get a list of Jobs.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsListJobsFromSchedule(string jobScheduleId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + global::System.Uri.EscapeDataString(jobScheduleId)
                        + "/jobs"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsListJobsFromSchedule_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists the Jobs that have been created under the specified Job Schedule.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsListJobsFromScheduleViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobschedules/(?<jobScheduleId>[^/]+)/jobs$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobschedules/{jobScheduleId}/jobs'");
                }

                // replace URI parameters with values from identity
                var jobScheduleId = _match.Groups["jobScheduleId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + jobScheduleId
                        + "/jobs"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsListJobsFromSchedule_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists the Jobs that have been created under the specified Job Schedule.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult> JobsListJobsFromScheduleViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobschedules/(?<jobScheduleId>[^/]+)/jobs$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobschedules/{jobScheduleId}/jobs'");
                }

                // replace URI parameters with values from identity
                var jobScheduleId = _match.Groups["jobScheduleId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + jobScheduleId
                        + "/jobs"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.JobsListJobsFromScheduleWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Lists the Jobs that have been created under the specified Job Schedule.</summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule from which you want to get a list of Jobs.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult> JobsListJobsFromScheduleWithResult(string jobScheduleId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobschedules/"
                        + global::System.Uri.EscapeDataString(jobScheduleId)
                        + "/jobs"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.JobsListJobsFromScheduleWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobsListJobsFromScheduleWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult> JobsListJobsFromScheduleWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "JobsListJobsFromSchedule" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsListJobsFromSchedule_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobsListJobsFromSchedule" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="jobScheduleId">The ID of the Job Schedule from which you want to get a list of Jobs.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsListJobsFromSchedule_Validate(string jobScheduleId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? maxresults, string endpoint, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobScheduleId),jobScheduleId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(maxresults),maxresults,1);
                await eventListener.AssertIsLessThanOrEqual(nameof(maxresults),maxresults,1000);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(Filter),Filter);
            }
        }

        /// <summary>Lists all of the Jobs in the specified Account.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-jobs.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsListJobsViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsListJobs_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists all of the Jobs in the specified Account.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-jobs.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult> JobsListJobsViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.JobsListJobsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Lists all of the Jobs in the specified Account.</summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-jobs.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult> JobsListJobsWithResult(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.JobsListJobsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobsListJobsWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult> JobsListJobsWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "JobsListJobs" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsListJobs_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobsListJobs" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-jobs.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsListJobs_Validate(string endpoint, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(maxresults),maxresults,1);
                await eventListener.AssertIsLessThanOrEqual(nameof(maxresults),maxresults,1000);
                await eventListener.AssertNotNull(nameof(Filter),Filter);
            }
        }

        /// <summary>
        /// This fully replaces all the updatable properties of the Job. For example, if
        /// the Job has constraints associated with it and if constraints is not specified
        /// with this request, then the Batch service will remove the existing constraints.
        /// </summary>
        /// <param name="jobId">The ID of the Job whose properties you want to update.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">A job with updated properties</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsReplaceJob(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJob body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsReplaceJobOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Put, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsReplaceJob_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This fully replaces all the updatable properties of the Job. For example, if
        /// the Job has constraints associated with it and if constraints is not specified
        /// with this request, then the Batch service will remove the existing constraints.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">A job with updated properties</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsReplaceJobViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJob body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsReplaceJobOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Put, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsReplaceJob_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This fully replaces all the updatable properties of the Job. For example, if
        /// the Job has constraints associated with it and if constraints is not specified
        /// with this request, then the Batch service will remove the existing constraints.
        /// </summary>
        /// <param name="jobId">The ID of the Job whose properties you want to update.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the JobsReplaceJob operation</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsReplaceJobViaJsonString(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsReplaceJobOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Put, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsReplaceJob_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobsReplaceJob" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsReplaceJob_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsReplaceJobOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobsReplaceJob" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job whose properties you want to update.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">A job with updated properties</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsReplaceJob_Validate(string jobId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJob body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// When a Terminate Job request is received, the Batch service sets the Job to the
        /// terminating state. The Batch service then terminates any running Tasks
        /// associated with the Job and runs any required Job release Tasks. Then the Job
        /// moves into the completed state. If there are any Tasks in the Job in the active
        /// state, they will remain in the active state. Once a Job is terminated, new
        /// Tasks cannot be added and any remaining active Tasks will not be scheduled.
        /// </summary>
        /// <param name="jobId">The ID of the Job to terminate.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="force">If true, the server will terminate the Job even if the corresponding nodes have not fully processed
        /// the termination. The default value is false.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for terminating the Job.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsTerminateJob(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, bool? force, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobTerminateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsTerminateJobAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/terminate"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == force ? global::System.String.Empty : "force=" + global::System.Uri.EscapeDataString(force.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsTerminateJob_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// When a Terminate Job request is received, the Batch service sets the Job to the
        /// terminating state. The Batch service then terminates any running Tasks
        /// associated with the Job and runs any required Job release Tasks. Then the Job
        /// moves into the completed state. If there are any Tasks in the Job in the active
        /// state, they will remain in the active state. Once a Job is terminated, new
        /// Tasks cannot be added and any remaining active Tasks will not be scheduled.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="force">If true, the server will terminate the Job even if the corresponding nodes have not fully processed
        /// the termination. The default value is false.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for terminating the Job.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsTerminateJobViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, bool? force, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobTerminateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsTerminateJobAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/terminate"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == force ? global::System.String.Empty : "force=" + global::System.Uri.EscapeDataString(force.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsTerminateJob_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// When a Terminate Job request is received, the Batch service sets the Job to the
        /// terminating state. The Batch service then terminates any running Tasks
        /// associated with the Job and runs any required Job release Tasks. Then the Job
        /// moves into the completed state. If there are any Tasks in the Job in the active
        /// state, they will remain in the active state. Once a Job is terminated, new
        /// Tasks cannot be added and any remaining active Tasks will not be scheduled.
        /// </summary>
        /// <param name="jobId">The ID of the Job to terminate.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="force">If true, the server will terminate the Job even if the corresponding nodes have not fully processed
        /// the termination. The default value is false.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the JobsTerminateJob operation</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsTerminateJobViaJsonString(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, bool? force, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsTerminateJobAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/terminate"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == force ? global::System.String.Empty : "force=" + global::System.Uri.EscapeDataString(force.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsTerminateJob_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobsTerminateJob" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsTerminateJob_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsTerminateJobAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Accepted:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onAccepted(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobsTerminateJob" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job to terminate.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="force">If true, the server will terminate the Job even if the corresponding nodes have not fully processed
        /// the termination. The default value is false.</param>
        /// <param name="body">The options to use for terminating the Job.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsTerminateJob_Validate(string jobId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, bool? force, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobTerminateOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// This replaces only the Job properties specified in the request. For example, if
        /// the Job has constraints, and a request does not specify the constraints
        /// element, then the Job keeps the existing constraints.
        /// </summary>
        /// <param name="jobId">The ID of the Job whose properties you want to update.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for updating the Job.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsUpdateJob(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobUpdateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsUpdateJobOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Patch, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsUpdateJob_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This replaces only the Job properties specified in the request. For example, if
        /// the Job has constraints, and a request does not specify the constraints
        /// element, then the Job keeps the existing constraints.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for updating the Job.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsUpdateJobViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobUpdateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsUpdateJobOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Patch, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsUpdateJob_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This replaces only the Job properties specified in the request. For example, if
        /// the Job has constraints, and a request does not specify the constraints
        /// element, then the Job keeps the existing constraints.
        /// </summary>
        /// <param name="jobId">The ID of the Job whose properties you want to update.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the JobsUpdateJob operation</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task JobsUpdateJobViaJsonString(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsUpdateJobOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Patch, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.JobsUpdateJob_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "JobsUpdateJob" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsUpdateJob_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IJobsUpdateJobOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="JobsUpdateJob" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job whose properties you want to update.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for updating the Job.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task JobsUpdateJob_Validate(string jobId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobUpdateOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// You can add a user Account to a Compute Node only when it is in the idle or
        /// running state.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the machine on which you want to create a user Account.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for creating the user.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesCreateNodeUser(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeUserCreateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesCreateNodeUserCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/users"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesCreateNodeUser_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// You can add a user Account to a Compute Node only when it is in the idle or
        /// running state.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for creating the user.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesCreateNodeUserViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeUserCreateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesCreateNodeUserCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/users"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesCreateNodeUser_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// You can add a user Account to a Compute Node only when it is in the idle or
        /// running state.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the machine on which you want to create a user Account.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the NodesCreateNodeUser operation</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesCreateNodeUserViaJsonString(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesCreateNodeUserCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/users"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesCreateNodeUser_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesCreateNodeUser" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesCreateNodeUser_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesCreateNodeUserCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Created:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onCreated(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesCreateNodeUser" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the machine on which you want to create a user Account.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for creating the user.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesCreateNodeUser_Validate(string poolId, string nodeId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeUserCreateOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>You can deallocate a Compute Node only if it is in an idle or running state.</summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that you want to restart.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for deallocating the Compute Node.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesDeallocateNode(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeDeallocateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesDeallocateNodeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/deallocate"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesDeallocateNode_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>You can deallocate a Compute Node only if it is in an idle or running state.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for deallocating the Compute Node.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesDeallocateNodeViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeDeallocateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesDeallocateNodeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/deallocate"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesDeallocateNode_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>You can deallocate a Compute Node only if it is in an idle or running state.</summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that you want to restart.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the NodesDeallocateNode operation</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesDeallocateNodeViaJsonString(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesDeallocateNodeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/deallocate"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesDeallocateNode_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesDeallocateNode" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesDeallocateNode_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesDeallocateNodeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Accepted:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onAccepted(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesDeallocateNode" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that you want to restart.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for deallocating the Compute Node.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesDeallocateNode_Validate(string poolId, string nodeId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeDeallocateOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Deletes the specified file from the Compute Node.</summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node.</param>
        /// <param name="filePath">The path to the file or directory.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="recursive">Whether to delete children of a directory. If the filePath parameter represents
        /// a directory instead of a file, you can set recursive to true to delete the
        /// directory and all of the files and subdirectories in it. If recursive is false
        /// then the directory must be empty or deletion will fail.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesDeleteNodeFile(string poolId, string nodeId, string filePath, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, bool? recursive, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesDeleteNodeFileOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/files/"
                        + global::System.Uri.EscapeDataString(filePath)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == recursive ? global::System.String.Empty : "recursive=" + global::System.Uri.EscapeDataString(recursive.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesDeleteNodeFile_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Deletes the specified file from the Compute Node.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="recursive">Whether to delete children of a directory. If the filePath parameter represents
        /// a directory instead of a file, you can set recursive to true to delete the
        /// directory and all of the files and subdirectories in it. If recursive is false
        /// then the directory must be empty or deletion will fail.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesDeleteNodeFileViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, bool? recursive, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesDeleteNodeFileOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)/files/(?<filePath>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}/files/{filePath}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                var filePath = _match.Groups["filePath"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/files/"
                        + filePath
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == recursive ? global::System.String.Empty : "recursive=" + global::System.Uri.EscapeDataString(recursive.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesDeleteNodeFile_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesDeleteNodeFile" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesDeleteNodeFile_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesDeleteNodeFileOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesDeleteNodeFile" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node.</param>
        /// <param name="filePath">The path to the file or directory.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="recursive">Whether to delete children of a directory. If the filePath parameter represents
        /// a directory instead of a file, you can set recursive to true to delete the
        /// directory and all of the files and subdirectories in it. If recursive is false
        /// then the directory must be empty or deletion will fail.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesDeleteNodeFile_Validate(string poolId, string nodeId, string filePath, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, int? timeOut, bool? recursive, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(filePath),filePath);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>
        /// You can delete a user Account to a Compute Node only when it is in the idle or
        /// running state.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the machine on which you want to delete a user Account.</param>
        /// <param name="userName">The name of the user Account to delete.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesDeleteNodeUser(string poolId, string nodeId, string userName, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesDeleteNodeUserOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/users/"
                        + global::System.Uri.EscapeDataString(userName)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesDeleteNodeUser_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// You can delete a user Account to a Compute Node only when it is in the idle or
        /// running state.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesDeleteNodeUserViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesDeleteNodeUserOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)/users/(?<userName>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}/users/{userName}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                var userName = _match.Groups["userName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/users/"
                        + userName
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesDeleteNodeUser_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesDeleteNodeUser" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesDeleteNodeUser_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesDeleteNodeUserOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesDeleteNodeUser" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the machine on which you want to delete a user Account.</param>
        /// <param name="userName">The name of the user Account to delete.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesDeleteNodeUser_Validate(string poolId, string nodeId, string userName, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, int? timeOut, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(userName),userName);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>
        /// You can disable Task scheduling on a Compute Node only if its current
        /// scheduling state is enabled.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node on which you want to disable Task scheduling.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for disabling scheduling on the Compute Node.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesDisableNodeScheduling(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeDisableSchedulingOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesDisableNodeSchedulingOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/disablescheduling"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesDisableNodeScheduling_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// You can disable Task scheduling on a Compute Node only if its current
        /// scheduling state is enabled.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for disabling scheduling on the Compute Node.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesDisableNodeSchedulingViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeDisableSchedulingOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesDisableNodeSchedulingOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/disablescheduling"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesDisableNodeScheduling_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// You can disable Task scheduling on a Compute Node only if its current
        /// scheduling state is enabled.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node on which you want to disable Task scheduling.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the NodesDisableNodeScheduling operation</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesDisableNodeSchedulingViaJsonString(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesDisableNodeSchedulingOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/disablescheduling"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesDisableNodeScheduling_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesDisableNodeScheduling" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesDisableNodeScheduling_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesDisableNodeSchedulingOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesDisableNodeScheduling" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node on which you want to disable Task scheduling.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for disabling scheduling on the Compute Node.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesDisableNodeScheduling_Validate(string poolId, string nodeId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeDisableSchedulingOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// You can enable Task scheduling on a Compute Node only if its current scheduling
        /// state is disabled
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node on which you want to enable Task scheduling.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesEnableNodeScheduling(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesEnableNodeSchedulingOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/enablescheduling"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesEnableNodeScheduling_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// You can enable Task scheduling on a Compute Node only if its current scheduling
        /// state is disabled
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesEnableNodeSchedulingViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesEnableNodeSchedulingOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/enablescheduling"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesEnableNodeScheduling_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesEnableNodeScheduling" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesEnableNodeScheduling_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesEnableNodeSchedulingOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesEnableNodeScheduling" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node on which you want to enable Task scheduling.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesEnableNodeScheduling_Validate(string poolId, string nodeId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>Gets information about the specified Compute Node.</summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that you want to get information about.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesGetNode(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, System.Collections.Generic.List<string> Select, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNode>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesGetNode_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Gets information about the specified Compute Node Extension.</summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that contains the extensions.</param>
        /// <param name="extensionName">The name of the Compute Node Extension that you want to get information about.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesGetNodeExtension(string poolId, string nodeId, string extensionName, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, System.Collections.Generic.List<string> Select, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtension>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/extensions/"
                        + global::System.Uri.EscapeDataString(extensionName)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesGetNodeExtension_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Gets information about the specified Compute Node Extension.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesGetNodeExtensionViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, System.Collections.Generic.List<string> Select, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtension>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)/extensions/(?<extensionName>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}/extensions/{extensionName}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                var extensionName = _match.Groups["extensionName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/extensions/"
                        + extensionName
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesGetNodeExtension_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Gets information about the specified Compute Node Extension.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtension>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtension> NodesGetNodeExtensionViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, System.Collections.Generic.List<string> Select, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)/extensions/(?<extensionName>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}/extensions/{extensionName}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                var extensionName = _match.Groups["extensionName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/extensions/"
                        + extensionName
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.NodesGetNodeExtensionWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Gets information about the specified Compute Node Extension.</summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that contains the extensions.</param>
        /// <param name="extensionName">The name of the Compute Node Extension that you want to get information about.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtension>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtension> NodesGetNodeExtensionWithResult(string poolId, string nodeId, string extensionName, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, System.Collections.Generic.List<string> Select, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/extensions/"
                        + global::System.Uri.EscapeDataString(extensionName)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.NodesGetNodeExtensionWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesGetNodeExtensionWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtension>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtension> NodesGetNodeExtensionWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchNodeVMExtension.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesGetNodeExtension" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesGetNodeExtension_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtension>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchNodeVMExtension.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesGetNodeExtension" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that contains the extensions.</param>
        /// <param name="extensionName">The name of the Compute Node Extension that you want to get information about.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesGetNodeExtension_Validate(string poolId, string nodeId, string extensionName, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, int? timeOut, System.Collections.Generic.List<string> Select, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(extensionName),extensionName);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>Returns the content of the specified Compute Node file.</summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node.</param>
        /// <param name="filePath">The path to the file or directory.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ocpRange">The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesGetNodeFile(string poolId, string nodeId, string filePath, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ocpRange, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<global::System.IO.Stream>, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesGetNodeFileOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/files/"
                        + global::System.Uri.EscapeDataString(filePath)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ocpRange)
                {
                    request.Headers.Add("ocp-range",ocpRange);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesGetNodeFile_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Gets the properties of the specified Compute Node file.</summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node.</param>
        /// <param name="filePath">The path to the file or directory.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesGetNodeFileProperties(string poolId, string nodeId, string filePath, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesGetNodeFilePropertiesOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/files/"
                        + global::System.Uri.EscapeDataString(filePath)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Head, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesGetNodeFileProperties_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Gets the properties of the specified Compute Node file.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesGetNodeFilePropertiesViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesGetNodeFilePropertiesOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)/files/(?<filePath>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}/files/{filePath}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                var filePath = _match.Groups["filePath"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/files/"
                        + filePath
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Head, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesGetNodeFileProperties_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesGetNodeFileProperties" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesGetNodeFileProperties_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesGetNodeFilePropertiesOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesGetNodeFileProperties" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node.</param>
        /// <param name="filePath">The path to the file or directory.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesGetNodeFileProperties_Validate(string poolId, string nodeId, string filePath, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, int? timeOut, string ifModifiedSince, string ifUnmodifiedSince, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(filePath),filePath);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
            }
        }

        /// <summary>Returns the content of the specified Compute Node file.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ocpRange">The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesGetNodeFileViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ocpRange, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<global::System.IO.Stream>, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesGetNodeFileOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)/files/(?<filePath>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}/files/{filePath}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                var filePath = _match.Groups["filePath"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/files/"
                        + filePath
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ocpRange)
                {
                    request.Headers.Add("ocp-range",ocpRange);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesGetNodeFile_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Returns the content of the specified Compute Node file.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ocpRange">The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<global::System.IO.Stream>" /> that will be complete when handling of
        /// the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<global::System.IO.Stream> NodesGetNodeFileViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ocpRange, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)/files/(?<filePath>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}/files/{filePath}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                var filePath = _match.Groups["filePath"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/files/"
                        + filePath
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ocpRange)
                {
                    request.Headers.Add("ocp-range",ocpRange);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.NodesGetNodeFileWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Returns the content of the specified Compute Node file.</summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node.</param>
        /// <param name="filePath">The path to the file or directory.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ocpRange">The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<global::System.IO.Stream>" /> that will be complete when handling of
        /// the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<global::System.IO.Stream> NodesGetNodeFileWithResult(string poolId, string nodeId, string filePath, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ocpRange, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/files/"
                        + global::System.Uri.EscapeDataString(filePath)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ocpRange)
                {
                    request.Headers.Add("ocp-range",ocpRange);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.NodesGetNodeFileWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesGetNodeFileWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<global::System.IO.Stream>" /> that will be complete when handling of
        /// the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<global::System.IO.Stream> NodesGetNodeFileWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStreamAsync();
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesGetNodeFile" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesGetNodeFile_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<global::System.IO.Stream>, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesGetNodeFileOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStreamAsync(), null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesGetNodeFile" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node.</param>
        /// <param name="filePath">The path to the file or directory.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ocpRange">The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesGetNodeFile_Validate(string poolId, string nodeId, string filePath, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, int? timeOut, string ifModifiedSince, string ifUnmodifiedSince, string ocpRange, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(filePath),filePath);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ocpRange),ocpRange);
            }
        }

        /// <summary>
        /// Before you can remotely login to a Compute Node using the remote login settings,
        /// you must get a user Account on the Compute Node.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node for which to obtain the remote login settings.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesGetNodeRemoteLoginSettings(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeRemoteLoginSettings>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/remoteloginsettings"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesGetNodeRemoteLoginSettings_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Before you can remotely login to a Compute Node using the remote login settings,
        /// you must get a user Account on the Compute Node.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesGetNodeRemoteLoginSettingsViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeRemoteLoginSettings>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)/remoteloginsettings$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}/remoteloginsettings'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/remoteloginsettings"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesGetNodeRemoteLoginSettings_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Before you can remotely login to a Compute Node using the remote login settings,
        /// you must get a user Account on the Compute Node.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeRemoteLoginSettings>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeRemoteLoginSettings> NodesGetNodeRemoteLoginSettingsViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)/remoteloginsettings$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}/remoteloginsettings'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/remoteloginsettings"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.NodesGetNodeRemoteLoginSettingsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Before you can remotely login to a Compute Node using the remote login settings,
        /// you must get a user Account on the Compute Node.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node for which to obtain the remote login settings.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeRemoteLoginSettings>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeRemoteLoginSettings> NodesGetNodeRemoteLoginSettingsWithResult(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/remoteloginsettings"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.NodesGetNodeRemoteLoginSettingsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref= "NodesGetNodeRemoteLoginSettingsWithResult" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeRemoteLoginSettings>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeRemoteLoginSettings> NodesGetNodeRemoteLoginSettingsWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchNodeRemoteLoginSettings.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesGetNodeRemoteLoginSettings" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesGetNodeRemoteLoginSettings_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeRemoteLoginSettings>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchNodeRemoteLoginSettings.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesGetNodeRemoteLoginSettings" /> method. Call this like the actual call, but you will
        /// get validation events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node for which to obtain the remote login settings.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesGetNodeRemoteLoginSettings_Validate(string poolId, string nodeId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>Gets information about the specified Compute Node.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesGetNodeViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, System.Collections.Generic.List<string> Select, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNode>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesGetNode_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Gets information about the specified Compute Node.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNode>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNode> NodesGetNodeViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, System.Collections.Generic.List<string> Select, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.NodesGetNodeWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Gets information about the specified Compute Node.</summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that you want to get information about.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNode>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNode> NodesGetNodeWithResult(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, System.Collections.Generic.List<string> Select, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.NodesGetNodeWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesGetNodeWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNode>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNode> NodesGetNodeWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchNode.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesGetNode" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesGetNode_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNode>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchNode.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesGetNode" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that you want to get information about.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesGetNode_Validate(string poolId, string nodeId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, System.Collections.Generic.List<string> Select, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>Lists the Compute Nodes Extensions in the specified Pool.</summary>
        /// <param name="poolId">The ID of the Pool that contains Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that you want to list extensions.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesListNodeExtensions(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, System.Collections.Generic.List<string> Select, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtensionListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/extensions"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesListNodeExtensions_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists the Compute Nodes Extensions in the specified Pool.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesListNodeExtensionsViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, System.Collections.Generic.List<string> Select, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtensionListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)/extensions$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}/extensions'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/extensions"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesListNodeExtensions_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists the Compute Nodes Extensions in the specified Pool.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtensionListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtensionListResult> NodesListNodeExtensionsViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, System.Collections.Generic.List<string> Select, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)/extensions$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}/extensions'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/extensions"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.NodesListNodeExtensionsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Lists the Compute Nodes Extensions in the specified Pool.</summary>
        /// <param name="poolId">The ID of the Pool that contains Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that you want to list extensions.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtensionListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtensionListResult> NodesListNodeExtensionsWithResult(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, System.Collections.Generic.List<string> Select, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/extensions"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.NodesListNodeExtensionsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesListNodeExtensionsWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtensionListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtensionListResult> NodesListNodeExtensionsWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchNodeVMExtensionListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesListNodeExtensions" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesListNodeExtensions_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeVMExtensionListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchNodeVMExtensionListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesListNodeExtensions" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that you want to list extensions.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesListNodeExtensions_Validate(string poolId, string nodeId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? maxresults, string endpoint, System.Collections.Generic.List<string> Select, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(maxresults),maxresults,1);
                await eventListener.AssertIsLessThanOrEqual(nameof(maxresults),maxresults,1000);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>Lists all of the files in Task directories on the specified Compute Node.</summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node whose files you want to list.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-compute-node-files.</param>
        /// <param name="recursive">Whether to list children of a directory.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesListNodeFiles(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, bool? recursive, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/files"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null == recursive ? global::System.String.Empty : "recursive=" + global::System.Uri.EscapeDataString(recursive.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesListNodeFiles_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists all of the files in Task directories on the specified Compute Node.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-compute-node-files.</param>
        /// <param name="recursive">Whether to list children of a directory.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesListNodeFilesViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, bool? recursive, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)/files$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}/files'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/files"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null == recursive ? global::System.String.Empty : "recursive=" + global::System.Uri.EscapeDataString(recursive.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesListNodeFiles_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists all of the files in Task directories on the specified Compute Node.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-compute-node-files.</param>
        /// <param name="recursive">Whether to list children of a directory.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult> NodesListNodeFilesViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, bool? recursive, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)/files$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}/files'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/files"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null == recursive ? global::System.String.Empty : "recursive=" + global::System.Uri.EscapeDataString(recursive.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.NodesListNodeFilesWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Lists all of the files in Task directories on the specified Compute Node.</summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node whose files you want to list.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-compute-node-files.</param>
        /// <param name="recursive">Whether to list children of a directory.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult> NodesListNodeFilesWithResult(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, bool? recursive, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/files"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null == recursive ? global::System.String.Empty : "recursive=" + global::System.Uri.EscapeDataString(recursive.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.NodesListNodeFilesWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesListNodeFilesWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult> NodesListNodeFilesWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchNodeFileListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesListNodeFiles" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesListNodeFiles_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchNodeFileListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesListNodeFiles" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node whose files you want to list.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-compute-node-files.</param>
        /// <param name="recursive">Whether to list children of a directory.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesListNodeFiles_Validate(string poolId, string nodeId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? maxresults, string endpoint, string Filter, bool? recursive, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(maxresults),maxresults,1);
                await eventListener.AssertIsLessThanOrEqual(nameof(maxresults),maxresults,1000);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(Filter),Filter);
            }
        }

        /// <summary>Lists the Compute Nodes in the specified Pool.</summary>
        /// <param name="poolId">The ID of the Pool from which you want to list Compute Nodes.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesListNodes(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesListNodes_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists the Compute Nodes in the specified Pool.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesListNodesViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesListNodes_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists the Compute Nodes in the specified Pool.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeListResult> NodesListNodesViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.NodesListNodesWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Lists the Compute Nodes in the specified Pool.</summary>
        /// <param name="poolId">The ID of the Pool from which you want to list Compute Nodes.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeListResult> NodesListNodesWithResult(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.NodesListNodesWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesListNodesWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeListResult> NodesListNodesWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchNodeListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesListNodes" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesListNodes_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchNodeListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesListNodes" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool from which you want to list Compute Nodes.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesListNodes_Validate(string poolId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? maxresults, string endpoint, string Filter, System.Collections.Generic.List<string> Select, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(maxresults),maxresults,1);
                await eventListener.AssertIsLessThanOrEqual(nameof(maxresults),maxresults,1000);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(Filter),Filter);
            }
        }

        /// <summary>You can restart a Compute Node only if it is in an idle or running state.</summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that you want to restart.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for rebooting the Compute Node.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesRebootNode(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeRebootOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesRebootNodeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/reboot"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesRebootNode_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>You can restart a Compute Node only if it is in an idle or running state.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for rebooting the Compute Node.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesRebootNodeViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeRebootOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesRebootNodeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/reboot"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesRebootNode_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>You can restart a Compute Node only if it is in an idle or running state.</summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that you want to restart.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the NodesRebootNode operation</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesRebootNodeViaJsonString(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesRebootNodeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/reboot"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesRebootNode_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesRebootNode" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesRebootNode_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesRebootNodeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Accepted:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onAccepted(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesRebootNode" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that you want to restart.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for rebooting the Compute Node.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesRebootNode_Validate(string poolId, string nodeId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeRebootOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// You can reinstall the operating system on a Compute Node only if it is in an
        /// idle or running state. This API can be invoked only on Pools created with the
        /// cloud service configuration property.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that you want to restart.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for reimaging the Compute Node.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesReimageNode(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeReimageOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesReimageNodeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/reimage"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesReimageNode_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// You can reinstall the operating system on a Compute Node only if it is in an
        /// idle or running state. This API can be invoked only on Pools created with the
        /// cloud service configuration property.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for reimaging the Compute Node.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesReimageNodeViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeReimageOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesReimageNodeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/reimage"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesReimageNode_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// You can reinstall the operating system on a Compute Node only if it is in an
        /// idle or running state. This API can be invoked only on Pools created with the
        /// cloud service configuration property.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that you want to restart.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the NodesReimageNode operation</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesReimageNodeViaJsonString(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesReimageNodeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/reimage"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesReimageNode_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesReimageNode" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesReimageNode_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesReimageNodeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Accepted:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onAccepted(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesReimageNode" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that you want to restart.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for reimaging the Compute Node.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesReimageNode_Validate(string poolId, string nodeId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeReimageOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// This operation replaces of all the updatable properties of the Account. For
        /// example, if the expiryTime element is not specified, the current value is
        /// replaced with the default value, not left unmodified. You can replace a user
        /// Account on a Compute Node only when it is in the idle or running state.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the machine on which you want to update a user Account.</param>
        /// <param name="userName">The name of the user Account to update.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for updating the user.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesReplaceNodeUser(string poolId, string nodeId, string userName, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeUserUpdateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesReplaceNodeUserOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/users/"
                        + global::System.Uri.EscapeDataString(userName)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Put, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesReplaceNodeUser_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This operation replaces of all the updatable properties of the Account. For
        /// example, if the expiryTime element is not specified, the current value is
        /// replaced with the default value, not left unmodified. You can replace a user
        /// Account on a Compute Node only when it is in the idle or running state.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for updating the user.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesReplaceNodeUserViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeUserUpdateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesReplaceNodeUserOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)/users/(?<userName>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}/users/{userName}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                var userName = _match.Groups["userName"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/users/"
                        + userName
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Put, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesReplaceNodeUser_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This operation replaces of all the updatable properties of the Account. For
        /// example, if the expiryTime element is not specified, the current value is
        /// replaced with the default value, not left unmodified. You can replace a user
        /// Account on a Compute Node only when it is in the idle or running state.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the machine on which you want to update a user Account.</param>
        /// <param name="userName">The name of the user Account to update.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the NodesReplaceNodeUser operation</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesReplaceNodeUserViaJsonString(string poolId, string nodeId, string userName, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesReplaceNodeUserOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/users/"
                        + global::System.Uri.EscapeDataString(userName)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Put, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesReplaceNodeUser_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesReplaceNodeUser" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesReplaceNodeUser_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesReplaceNodeUserOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesReplaceNodeUser" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the machine on which you want to update a user Account.</param>
        /// <param name="userName">The name of the user Account to update.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="body">The options to use for updating the user.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesReplaceNodeUser_Validate(string poolId, string nodeId, string userName, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, int? timeOut, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeUserUpdateOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(userName),userName);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>You can start a Compute Node only if it has been deallocated.</summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that you want to restart.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesStartNode(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesStartNodeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/start"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesStartNode_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>You can start a Compute Node only if it has been deallocated.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesStartNodeViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesStartNodeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/start"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesStartNode_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesStartNode" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesStartNode_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.INodesStartNodeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Accepted:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onAccepted(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesStartNode" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node that you want to restart.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesStartNode_Validate(string poolId, string nodeId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>
        /// This is for gathering Azure Batch service log files in an automated fashion
        /// from Compute Nodes if you are experiencing an error and wish to escalate to
        /// Azure support. The Azure Batch service log files should be shared with Azure
        /// support to aid in debugging issues with the Batch service.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node for which you want to get the Remote Desktop
        /// Protocol file.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Azure Batch service log files upload options.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesUploadNodeLogs(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IUploadBatchServiceLogsOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IUploadBatchServiceLogsResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/uploadbatchservicelogs"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesUploadNodeLogs_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This is for gathering Azure Batch service log files in an automated fashion
        /// from Compute Nodes if you are experiencing an error and wish to escalate to
        /// Azure support. The Azure Batch service log files should be shared with Azure
        /// support to aid in debugging issues with the Batch service.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Azure Batch service log files upload options.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesUploadNodeLogsViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IUploadBatchServiceLogsOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IUploadBatchServiceLogsResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/uploadbatchservicelogs"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesUploadNodeLogs_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This is for gathering Azure Batch service log files in an automated fashion
        /// from Compute Nodes if you are experiencing an error and wish to escalate to
        /// Azure support. The Azure Batch service log files should be shared with Azure
        /// support to aid in debugging issues with the Batch service.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Azure Batch service log files upload options.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IUploadBatchServiceLogsResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IUploadBatchServiceLogsResult> NodesUploadNodeLogsViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IUploadBatchServiceLogsOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)/nodes/(?<nodeId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}/nodes/{nodeId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                var nodeId = _match.Groups["nodeId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/nodes/"
                        + nodeId
                        + "/uploadbatchservicelogs"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.NodesUploadNodeLogsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// This is for gathering Azure Batch service log files in an automated fashion
        /// from Compute Nodes if you are experiencing an error and wish to escalate to
        /// Azure support. The Azure Batch service log files should be shared with Azure
        /// support to aid in debugging issues with the Batch service.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node for which you want to get the Remote Desktop
        /// Protocol file.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the NodesUploadNodeLogs operation</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task NodesUploadNodeLogsViaJsonString(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IUploadBatchServiceLogsResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/uploadbatchservicelogs"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.NodesUploadNodeLogs_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This is for gathering Azure Batch service log files in an automated fashion
        /// from Compute Nodes if you are experiencing an error and wish to escalate to
        /// Azure support. The Azure Batch service log files should be shared with Azure
        /// support to aid in debugging issues with the Batch service.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node for which you want to get the Remote Desktop
        /// Protocol file.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the NodesUploadNodeLogs operation</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IUploadBatchServiceLogsResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IUploadBatchServiceLogsResult> NodesUploadNodeLogsViaJsonStringWithResult(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/uploadbatchservicelogs"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.NodesUploadNodeLogsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// This is for gathering Azure Batch service log files in an automated fashion
        /// from Compute Nodes if you are experiencing an error and wish to escalate to
        /// Azure support. The Azure Batch service log files should be shared with Azure
        /// support to aid in debugging issues with the Batch service.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node for which you want to get the Remote Desktop
        /// Protocol file.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Azure Batch service log files upload options.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IUploadBatchServiceLogsResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IUploadBatchServiceLogsResult> NodesUploadNodeLogsWithResult(string poolId, string nodeId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IUploadBatchServiceLogsOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/nodes/"
                        + global::System.Uri.EscapeDataString(nodeId)
                        + "/uploadbatchservicelogs"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.NodesUploadNodeLogsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesUploadNodeLogsWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IUploadBatchServiceLogsResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IUploadBatchServiceLogsResult> NodesUploadNodeLogsWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.UploadBatchServiceLogsResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "NodesUploadNodeLogs" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesUploadNodeLogs_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IUploadBatchServiceLogsResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.UploadBatchServiceLogsResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="NodesUploadNodeLogs" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool that contains the Compute Node.</param>
        /// <param name="nodeId">The ID of the Compute Node for which you want to get the Remote Desktop
        /// Protocol file.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Azure Batch service log files upload options.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task NodesUploadNodeLogs_Validate(string poolId, string nodeId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IUploadBatchServiceLogsOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(nodeId),nodeId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// When naming Pools, avoid including sensitive information such as user names or
        /// secret project names. This information may appear in telemetry logs accessible
        /// to Microsoft Support engineers.
        /// </summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Pool to be created.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsCreatePool(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolCreateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsCreatePoolCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsCreatePool_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// When naming Pools, avoid including sensitive information such as user names or
        /// secret project names. This information may appear in telemetry logs accessible
        /// to Microsoft Support engineers.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Pool to be created.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsCreatePoolViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolCreateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsCreatePoolCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI ''");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsCreatePool_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// When naming Pools, avoid including sensitive information such as user names or
        /// secret project names. This information may appear in telemetry logs accessible
        /// to Microsoft Support engineers.
        /// </summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the PoolsCreatePool operation</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsCreatePoolViaJsonString(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsCreatePoolCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsCreatePool_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsCreatePool" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsCreatePool_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsCreatePoolCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Created:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onCreated(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PoolsCreatePool" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="body">The Pool to be created.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsCreatePool_Validate(string endpoint, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolCreateOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// When you request that a Pool be deleted, the following actions occur: the Pool
        /// state is set to deleting; any ongoing resize operation on the Pool are stopped;
        /// the Batch service starts resizing the Pool to zero Compute Nodes; any Tasks
        /// running on existing Compute Nodes are terminated and requeued (as if a resize
        /// Pool operation had been requested with the default requeue option); finally,
        /// the Pool is removed from the system. Because running Tasks are requeued, the
        /// user can rerun these Tasks by updating their Job to target a different Pool.
        /// The Tasks can then run on the new Pool. If you want to override the requeue
        /// behavior, then you should call resize Pool explicitly to shrink the Pool to
        /// zero size before deleting the Pool. If you call an delete Patch or Delete API
        /// on a Pool in the deleting state, it will fail with HTTP status code 409 with
        /// error code PoolBeingDeleted.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsDeletePool(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsDeletePoolAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsDeletePool_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// When you request that a Pool be deleted, the following actions occur: the Pool
        /// state is set to deleting; any ongoing resize operation on the Pool are stopped;
        /// the Batch service starts resizing the Pool to zero Compute Nodes; any Tasks
        /// running on existing Compute Nodes are terminated and requeued (as if a resize
        /// Pool operation had been requested with the default requeue option); finally,
        /// the Pool is removed from the system. Because running Tasks are requeued, the
        /// user can rerun these Tasks by updating their Job to target a different Pool.
        /// The Tasks can then run on the new Pool. If you want to override the requeue
        /// behavior, then you should call resize Pool explicitly to shrink the Pool to
        /// zero size before deleting the Pool. If you call an delete Patch or Delete API
        /// on a Pool in the deleting state, it will fail with HTTP status code 409 with
        /// error code PoolBeingDeleted.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsDeletePoolViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsDeletePoolAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsDeletePool_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsDeletePool" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsDeletePool_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsDeletePoolAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Accepted:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onAccepted(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PoolsDeletePool" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsDeletePool_Validate(string poolId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>Disables automatic scaling for a Pool.</summary>
        /// <param name="poolId">The ID of the Pool on which to disable automatic scaling.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsDisablePoolAutoScale(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsDisablePoolAutoScaleOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/disableautoscale"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsDisablePoolAutoScale_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Disables automatic scaling for a Pool.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsDisablePoolAutoScaleViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsDisablePoolAutoScaleOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/disableautoscale"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsDisablePoolAutoScale_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsDisablePoolAutoScale" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsDisablePoolAutoScale_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsDisablePoolAutoScaleOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PoolsDisablePoolAutoScale" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool on which to disable automatic scaling.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsDisablePoolAutoScale_Validate(string poolId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>
        /// You cannot enable automatic scaling on a Pool if a resize operation is in
        /// progress on the Pool. If automatic scaling of the Pool is currently disabled,
        /// you must specify a valid autoscale formula as part of the request. If automatic
        /// scaling of the Pool is already enabled, you may specify a new autoscale formula
        /// and/or a new evaluation interval. You cannot call this API for the same Pool
        /// more than once every 30 seconds.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for enabling automatic scaling.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsEnablePoolAutoScale(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolEnableAutoScaleOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsEnablePoolAutoScaleOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/enableautoscale"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsEnablePoolAutoScale_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// You cannot enable automatic scaling on a Pool if a resize operation is in
        /// progress on the Pool. If automatic scaling of the Pool is currently disabled,
        /// you must specify a valid autoscale formula as part of the request. If automatic
        /// scaling of the Pool is already enabled, you may specify a new autoscale formula
        /// and/or a new evaluation interval. You cannot call this API for the same Pool
        /// more than once every 30 seconds.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for enabling automatic scaling.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsEnablePoolAutoScaleViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolEnableAutoScaleOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsEnablePoolAutoScaleOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/enableautoscale"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsEnablePoolAutoScale_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// You cannot enable automatic scaling on a Pool if a resize operation is in
        /// progress on the Pool. If automatic scaling of the Pool is currently disabled,
        /// you must specify a valid autoscale formula as part of the request. If automatic
        /// scaling of the Pool is already enabled, you may specify a new autoscale formula
        /// and/or a new evaluation interval. You cannot call this API for the same Pool
        /// more than once every 30 seconds.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the PoolsEnablePoolAutoScale operation</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsEnablePoolAutoScaleViaJsonString(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsEnablePoolAutoScaleOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/enableautoscale"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsEnablePoolAutoScale_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsEnablePoolAutoScale" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsEnablePoolAutoScale_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsEnablePoolAutoScaleOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PoolsEnablePoolAutoScale" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for enabling automatic scaling.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsEnablePoolAutoScale_Validate(string poolId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolEnableAutoScaleOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// This API is primarily for validating an autoscale formula, as it simply returns
        /// the result without applying the formula to the Pool. The Pool must have auto
        /// scaling enabled in order to evaluate a formula.
        /// </summary>
        /// <param name="poolId">The ID of the Pool on which to evaluate the automatic scaling formula.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for evaluating the automatic scaling formula.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsEvaluatePoolAutoScale(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolEvaluateAutoScaleOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IAutoScaleRun>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/evaluateautoscale"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsEvaluatePoolAutoScale_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This API is primarily for validating an autoscale formula, as it simply returns
        /// the result without applying the formula to the Pool. The Pool must have auto
        /// scaling enabled in order to evaluate a formula.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for evaluating the automatic scaling formula.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsEvaluatePoolAutoScaleViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolEvaluateAutoScaleOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IAutoScaleRun>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/evaluateautoscale"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsEvaluatePoolAutoScale_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This API is primarily for validating an autoscale formula, as it simply returns
        /// the result without applying the formula to the Pool. The Pool must have auto
        /// scaling enabled in order to evaluate a formula.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for evaluating the automatic scaling formula.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IAutoScaleRun>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IAutoScaleRun> PoolsEvaluatePoolAutoScaleViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolEvaluateAutoScaleOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/evaluateautoscale"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.PoolsEvaluatePoolAutoScaleWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// This API is primarily for validating an autoscale formula, as it simply returns
        /// the result without applying the formula to the Pool. The Pool must have auto
        /// scaling enabled in order to evaluate a formula.
        /// </summary>
        /// <param name="poolId">The ID of the Pool on which to evaluate the automatic scaling formula.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the PoolsEvaluatePoolAutoScale operation</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsEvaluatePoolAutoScaleViaJsonString(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IAutoScaleRun>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/evaluateautoscale"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsEvaluatePoolAutoScale_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This API is primarily for validating an autoscale formula, as it simply returns
        /// the result without applying the formula to the Pool. The Pool must have auto
        /// scaling enabled in order to evaluate a formula.
        /// </summary>
        /// <param name="poolId">The ID of the Pool on which to evaluate the automatic scaling formula.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the PoolsEvaluatePoolAutoScale operation</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IAutoScaleRun>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IAutoScaleRun> PoolsEvaluatePoolAutoScaleViaJsonStringWithResult(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/evaluateautoscale"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.PoolsEvaluatePoolAutoScaleWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// This API is primarily for validating an autoscale formula, as it simply returns
        /// the result without applying the formula to the Pool. The Pool must have auto
        /// scaling enabled in order to evaluate a formula.
        /// </summary>
        /// <param name="poolId">The ID of the Pool on which to evaluate the automatic scaling formula.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for evaluating the automatic scaling formula.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IAutoScaleRun>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IAutoScaleRun> PoolsEvaluatePoolAutoScaleWithResult(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolEvaluateAutoScaleOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/evaluateautoscale"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.PoolsEvaluatePoolAutoScaleWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref= "PoolsEvaluatePoolAutoScaleWithResult" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IAutoScaleRun>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IAutoScaleRun> PoolsEvaluatePoolAutoScaleWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.AutoScaleRun.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsEvaluatePoolAutoScale" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsEvaluatePoolAutoScale_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IAutoScaleRun>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.AutoScaleRun.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PoolsEvaluatePoolAutoScale" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool on which to evaluate the automatic scaling formula.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for evaluating the automatic scaling formula.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsEvaluatePoolAutoScale_Validate(string poolId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolEvaluateAutoScaleOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>Gets information about the specified Pool.</summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsGetPool(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPool>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsGetPool_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Gets information about the specified Pool.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsGetPoolViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPool>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsGetPool_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Gets information about the specified Pool.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPool>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPool> PoolsGetPoolViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.PoolsGetPoolWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Gets information about the specified Pool.</summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPool>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPool> PoolsGetPoolWithResult(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.PoolsGetPoolWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsGetPoolWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPool>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPool> PoolsGetPoolWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchPool.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsGetPool" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsGetPool_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPool>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchPool.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PoolsGetPool" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsGetPool_Validate(string poolId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>
        /// Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
        /// numbers returned may not always be up to date. If you need exact node counts,
        /// use a list query.
        /// </summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-support-images.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsListPoolNodeCounts(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolNodeCountsListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/nodecounts"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsListPoolNodeCounts_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
        /// numbers returned may not always be up to date. If you need exact node counts,
        /// use a list query.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-support-images.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsListPoolNodeCountsViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolNodeCountsListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/nodecounts$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/nodecounts'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/nodecounts"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsListPoolNodeCounts_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
        /// numbers returned may not always be up to date. If you need exact node counts,
        /// use a list query.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-support-images.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolNodeCountsListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolNodeCountsListResult> PoolsListPoolNodeCountsViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/nodecounts$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/nodecounts'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/nodecounts"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.PoolsListPoolNodeCountsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
        /// numbers returned may not always be up to date. If you need exact node counts,
        /// use a list query.
        /// </summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-support-images.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolNodeCountsListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolNodeCountsListResult> PoolsListPoolNodeCountsWithResult(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/nodecounts"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.PoolsListPoolNodeCountsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsListPoolNodeCountsWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolNodeCountsListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolNodeCountsListResult> PoolsListPoolNodeCountsWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchPoolNodeCountsListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsListPoolNodeCounts" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsListPoolNodeCounts_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolNodeCountsListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchPoolNodeCountsListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PoolsListPoolNodeCounts" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-support-images.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsListPoolNodeCounts_Validate(string endpoint, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? maxresults, string Filter, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(maxresults),maxresults,1);
                await eventListener.AssertIsLessThanOrEqual(nameof(maxresults),maxresults,1000);
                await eventListener.AssertNotNull(nameof(Filter),Filter);
            }
        }

        /// <summary>
        /// If you do not specify a $filter clause including a poolId, the response
        /// includes all Pools that existed in the Account in the time range of the
        /// returned aggregation intervals. If you do not specify a $filter clause
        /// including a startTime or endTime these filters default to the start and end
        /// times of the last aggregation interval currently available; that is, only the
        /// last aggregation interval is returned.
        /// </summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="startTime">The earliest time from which to include metrics. This must be at least two and
        /// a half hours before the current time. If not specified this defaults to the
        /// start time of the last aggregation interval currently available.</param>
        /// <param name="endtime">The latest time from which to include metrics. This must be at least two hours
        /// before the current time. If not specified this defaults to the end time of the
        /// last aggregation interval currently available.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsListPoolUsageMetrics(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, global::System.DateTime? startTime, global::System.DateTime? endtime, string Filter, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListUsageMetricsResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/poolusagemetrics"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endtime ? global::System.String.Empty : "endtime=" + endtime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsListPoolUsageMetrics_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// If you do not specify a $filter clause including a poolId, the response
        /// includes all Pools that existed in the Account in the time range of the
        /// returned aggregation intervals. If you do not specify a $filter clause
        /// including a startTime or endTime these filters default to the start and end
        /// times of the last aggregation interval currently available; that is, only the
        /// last aggregation interval is returned.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="startTime">The earliest time from which to include metrics. This must be at least two and
        /// a half hours before the current time. If not specified this defaults to the
        /// start time of the last aggregation interval currently available.</param>
        /// <param name="endtime">The latest time from which to include metrics. This must be at least two hours
        /// before the current time. If not specified this defaults to the end time of the
        /// last aggregation interval currently available.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsListPoolUsageMetricsViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, global::System.DateTime? startTime, global::System.DateTime? endtime, string Filter, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListUsageMetricsResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/poolusagemetrics$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/poolusagemetrics'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/poolusagemetrics"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endtime ? global::System.String.Empty : "endtime=" + endtime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsListPoolUsageMetrics_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// If you do not specify a $filter clause including a poolId, the response
        /// includes all Pools that existed in the Account in the time range of the
        /// returned aggregation intervals. If you do not specify a $filter clause
        /// including a startTime or endTime these filters default to the start and end
        /// times of the last aggregation interval currently available; that is, only the
        /// last aggregation interval is returned.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="startTime">The earliest time from which to include metrics. This must be at least two and
        /// a half hours before the current time. If not specified this defaults to the
        /// start time of the last aggregation interval currently available.</param>
        /// <param name="endtime">The latest time from which to include metrics. This must be at least two hours
        /// before the current time. If not specified this defaults to the end time of the
        /// last aggregation interval currently available.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListUsageMetricsResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListUsageMetricsResult> PoolsListPoolUsageMetricsViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, global::System.DateTime? startTime, global::System.DateTime? endtime, string Filter, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/poolusagemetrics$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/poolusagemetrics'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/poolusagemetrics"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endtime ? global::System.String.Empty : "endtime=" + endtime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.PoolsListPoolUsageMetricsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// If you do not specify a $filter clause including a poolId, the response
        /// includes all Pools that existed in the Account in the time range of the
        /// returned aggregation intervals. If you do not specify a $filter clause
        /// including a startTime or endTime these filters default to the start and end
        /// times of the last aggregation interval currently available; that is, only the
        /// last aggregation interval is returned.
        /// </summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="startTime">The earliest time from which to include metrics. This must be at least two and
        /// a half hours before the current time. If not specified this defaults to the
        /// start time of the last aggregation interval currently available.</param>
        /// <param name="endtime">The latest time from which to include metrics. This must be at least two hours
        /// before the current time. If not specified this defaults to the end time of the
        /// last aggregation interval currently available.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListUsageMetricsResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListUsageMetricsResult> PoolsListPoolUsageMetricsWithResult(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, global::System.DateTime? startTime, global::System.DateTime? endtime, string Filter, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/poolusagemetrics"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (null == startTime ? global::System.String.Empty : "startTime=" + startTime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (null == endtime ? global::System.String.Empty : "endtime=" + endtime?.ToString(@"yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK",global::System.Globalization.CultureInfo.InvariantCulture))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.PoolsListPoolUsageMetricsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref= "PoolsListPoolUsageMetricsWithResult" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListUsageMetricsResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListUsageMetricsResult> PoolsListPoolUsageMetricsWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchPoolListUsageMetricsResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsListPoolUsageMetrics" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsListPoolUsageMetrics_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListUsageMetricsResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchPoolListUsageMetricsResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PoolsListPoolUsageMetrics" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="startTime">The earliest time from which to include metrics. This must be at least two and
        /// a half hours before the current time. If not specified this defaults to the
        /// start time of the last aggregation interval currently available.</param>
        /// <param name="endtime">The latest time from which to include metrics. This must be at least two hours
        /// before the current time. If not specified this defaults to the end time of the
        /// last aggregation interval currently available.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsListPoolUsageMetrics_Validate(string endpoint, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? maxresults, global::System.DateTime? startTime, global::System.DateTime? endtime, string Filter, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(maxresults),maxresults,1);
                await eventListener.AssertIsLessThanOrEqual(nameof(maxresults),maxresults,1000);
                await eventListener.AssertNotNull(nameof(Filter),Filter);
            }
        }

        /// <summary>Lists all of the Pools which be mounted.</summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-pools.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsListPools(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsListPools_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists all of the Pools which be mounted.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-pools.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsListPoolsViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsListPools_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists all of the Pools which be mounted.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-pools.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListResult> PoolsListPoolsViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.PoolsListPoolsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Lists all of the Pools which be mounted.</summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-pools.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListResult> PoolsListPoolsWithResult(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.PoolsListPoolsWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsListPoolsWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListResult> PoolsListPoolsWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchPoolListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsListPools" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsListPools_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchPoolListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PoolsListPools" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-pools.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsListPools_Validate(string endpoint, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(maxresults),maxresults,1);
                await eventListener.AssertIsLessThanOrEqual(nameof(maxresults),maxresults,1000);
                await eventListener.AssertNotNull(nameof(Filter),Filter);
            }
        }

        /// <summary>Lists all Virtual Machine Images supported by the Azure Batch service.</summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-support-images.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsListSupportedImages(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchAccountListSupportedImagesResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/supportedimages"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsListSupportedImages_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists all Virtual Machine Images supported by the Azure Batch service.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-support-images.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsListSupportedImagesViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchAccountListSupportedImagesResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/supportedimages$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/supportedimages'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/supportedimages"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsListSupportedImages_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists all Virtual Machine Images supported by the Azure Batch service.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-support-images.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchAccountListSupportedImagesResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchAccountListSupportedImagesResult> PoolsListSupportedImagesViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/supportedimages$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/supportedimages'");
                }

                // replace URI parameters with values from identity
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/supportedimages"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.PoolsListSupportedImagesWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Lists all Virtual Machine Images supported by the Azure Batch service.</summary>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-support-images.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchAccountListSupportedImagesResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchAccountListSupportedImagesResult> PoolsListSupportedImagesWithResult(string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/supportedimages"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.PoolsListSupportedImagesWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsListSupportedImagesWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchAccountListSupportedImagesResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchAccountListSupportedImagesResult> PoolsListSupportedImagesWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchAccountListSupportedImagesResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsListSupportedImages" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsListSupportedImages_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchAccountListSupportedImagesResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchAccountListSupportedImagesResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PoolsListSupportedImages" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-support-images.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsListSupportedImages_Validate(string endpoint, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? maxresults, string Filter, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(maxresults),maxresults,1);
                await eventListener.AssertIsLessThanOrEqual(nameof(maxresults),maxresults,1000);
                await eventListener.AssertNotNull(nameof(Filter),Filter);
            }
        }

        /// <summary>Gets basic properties of a Pool.</summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsPoolExists(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsPoolExistsOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Head, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsPoolExists_Call (request, onOk,onNotFound,onDefault,eventListener,sender);
            }
        }

        /// <summary>Gets basic properties of a Pool.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsPoolExistsViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsPoolExistsOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Head, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsPoolExists_Call (request, onOk,onNotFound,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsPoolExists" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onNotFound">a delegate that is called when the remote service returns 404 (NotFound).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsPoolExists_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsPoolExistsOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task> onNotFound, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        case global::System.Net.HttpStatusCode.NotFound:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNotFound(_response);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PoolsPoolExists" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsPoolExists_Validate(string poolId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>
        /// This operation can only run when the allocation state of the Pool is steady.
        /// When this operation runs, the allocation state changes from steady to resizing.
        /// Each request may remove up to 100 nodes.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for removing the node.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsRemoveNodes(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeRemoveOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsRemoveNodesAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/removenodes"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsRemoveNodes_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This operation can only run when the allocation state of the Pool is steady.
        /// When this operation runs, the allocation state changes from steady to resizing.
        /// Each request may remove up to 100 nodes.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for removing the node.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsRemoveNodesViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeRemoveOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsRemoveNodesAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/removenodes"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsRemoveNodes_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This operation can only run when the allocation state of the Pool is steady.
        /// When this operation runs, the allocation state changes from steady to resizing.
        /// Each request may remove up to 100 nodes.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the PoolsRemoveNodes operation</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsRemoveNodesViaJsonString(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsRemoveNodesAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/removenodes"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsRemoveNodes_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsRemoveNodes" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsRemoveNodes_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsRemoveNodesAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Accepted:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onAccepted(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PoolsRemoveNodes" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for removing the node.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsRemoveNodes_Validate(string poolId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeRemoveOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// This fully replaces all the updatable properties of the Pool. For example, if
        /// the Pool has a StartTask associated with it and if StartTask is not specified
        /// with this request, then the Batch service will remove the existing StartTask.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to update.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for replacing properties on the pool.</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsReplacePoolProperties(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolReplaceOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsReplacePoolPropertiesNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/updateproperties"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsReplacePoolProperties_Call (request, onNoContent,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This fully replaces all the updatable properties of the Pool. For example, if
        /// the Pool has a StartTask associated with it and if StartTask is not specified
        /// with this request, then the Batch service will remove the existing StartTask.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for replacing properties on the pool.</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsReplacePoolPropertiesViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolReplaceOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsReplacePoolPropertiesNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/updateproperties"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsReplacePoolProperties_Call (request, onNoContent,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This fully replaces all the updatable properties of the Pool. For example, if
        /// the Pool has a StartTask associated with it and if StartTask is not specified
        /// with this request, then the Batch service will remove the existing StartTask.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to update.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the PoolsReplacePoolProperties operation</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsReplacePoolPropertiesViaJsonString(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsReplacePoolPropertiesNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/updateproperties"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsReplacePoolProperties_Call (request, onNoContent,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsReplacePoolProperties" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsReplacePoolProperties_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsReplacePoolPropertiesNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.NoContent:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNoContent(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PoolsReplacePoolProperties" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to update.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for replacing properties on the pool.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsReplacePoolProperties_Validate(string poolId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolReplaceOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// You can only resize a Pool when its allocation state is steady. If the Pool is
        /// already resizing, the request fails with status code 409. When you resize a
        /// Pool, the Pool's allocation state changes from steady to resizing. You cannot
        /// resize Pools which are configured for automatic scaling. If you try to do this,
        /// the Batch service returns an error 409. If you resize a Pool downwards, the
        /// Batch service chooses which Compute Nodes to remove. To remove specific Compute
        /// Nodes, use the Pool remove Compute Nodes API instead.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for resizing the pool.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsResizePool(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolResizeOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsResizePoolAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/resize"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsResizePool_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// You can only resize a Pool when its allocation state is steady. If the Pool is
        /// already resizing, the request fails with status code 409. When you resize a
        /// Pool, the Pool's allocation state changes from steady to resizing. You cannot
        /// resize Pools which are configured for automatic scaling. If you try to do this,
        /// the Batch service returns an error 409. If you resize a Pool downwards, the
        /// Batch service chooses which Compute Nodes to remove. To remove specific Compute
        /// Nodes, use the Pool remove Compute Nodes API instead.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for resizing the pool.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsResizePoolViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolResizeOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsResizePoolAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/resize"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsResizePool_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// You can only resize a Pool when its allocation state is steady. If the Pool is
        /// already resizing, the request fails with status code 409. When you resize a
        /// Pool, the Pool's allocation state changes from steady to resizing. You cannot
        /// resize Pools which are configured for automatic scaling. If you try to do this,
        /// the Batch service returns an error 409. If you resize a Pool downwards, the
        /// Batch service chooses which Compute Nodes to remove. To remove specific Compute
        /// Nodes, use the Pool remove Compute Nodes API instead.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the PoolsResizePool operation</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsResizePoolViaJsonString(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsResizePoolAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/resize"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsResizePool_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsResizePool" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsResizePool_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsResizePoolAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Accepted:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onAccepted(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PoolsResizePool" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The options to use for resizing the pool.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsResizePool_Validate(string poolId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolResizeOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// This does not restore the Pool to its previous state before the resize
        /// operation: it only stops any further changes being made, and the Pool maintains
        /// its current state. After stopping, the Pool stabilizes at the number of Compute
        /// Nodes it was at when the stop operation was done. During the stop operation,
        /// the Pool allocation state changes first to stopping and then to steady. A
        /// resize operation need not be an explicit resize Pool request; this API can also
        /// be used to halt the initial sizing of the Pool when it is created.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsStopPoolResize(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsStopPoolResizeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "/stopresize"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsStopPoolResize_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This does not restore the Pool to its previous state before the resize
        /// operation: it only stops any further changes being made, and the Pool maintains
        /// its current state. After stopping, the Pool stabilizes at the number of Compute
        /// Nodes it was at when the stop operation was done. During the stop operation,
        /// the Pool allocation state changes first to stopping and then to steady. A
        /// resize operation need not be an explicit resize Pool request; this API can also
        /// be used to halt the initial sizing of the Pool when it is created.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsStopPoolResizeViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsStopPoolResizeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "/stopresize"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsStopPoolResize_Call (request, onAccepted,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsStopPoolResize" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onAccepted">a delegate that is called when the remote service returns 202 (Accepted).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsStopPoolResize_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsStopPoolResizeAcceptedResponseHeaders>, global::System.Threading.Tasks.Task> onAccepted, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Accepted:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onAccepted(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PoolsStopPoolResize" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsStopPoolResize_Validate(string poolId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>
        /// This only replaces the Pool properties specified in the request. For example,
        /// if the Pool has a StartTask associated with it, and a request does not specify
        /// a StartTask element, then the Pool keeps the existing StartTask.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The pool properties to update.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsUpdatePool(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolUpdateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsUpdatePoolOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Patch, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsUpdatePool_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This only replaces the Pool properties specified in the request. For example,
        /// if the Pool has a StartTask associated with it, and a request does not specify
        /// a StartTask element, then the Pool keeps the existing StartTask.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The pool properties to update.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsUpdatePoolViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolUpdateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsUpdatePoolOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/pools/(?<poolId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/pools/{poolId}'");
                }

                // replace URI parameters with values from identity
                var poolId = _match.Groups["poolId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + poolId
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Patch, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsUpdatePool_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// This only replaces the Pool properties specified in the request. For example,
        /// if the Pool has a StartTask associated with it, and a request does not specify
        /// a StartTask element, then the Pool keeps the existing StartTask.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the PoolsUpdatePool operation</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task PoolsUpdatePoolViaJsonString(string poolId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsUpdatePoolOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/pools/"
                        + global::System.Uri.EscapeDataString(poolId)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Patch, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.PoolsUpdatePool_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "PoolsUpdatePool" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsUpdatePool_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IPoolsUpdatePoolOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="PoolsUpdatePool" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="poolId">The ID of the Pool to get.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The pool properties to update.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task PoolsUpdatePool_Validate(string poolId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolUpdateOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(poolId),poolId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// The maximum lifetime of a Task from addition to completion is 180 days. If a
        /// Task has not completed within 180 days of being added it will be terminated by
        /// the Batch service and left in whatever state it was in at that time.
        /// </summary>
        /// <param name="jobId">The ID of the Job to which the Task is to be created.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Task to be created.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksCreateTask(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskCreateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksCreateTaskCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksCreateTask_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Note that each Task must have a unique ID. The Batch service may not return the
        /// results for each Task in the same order the Tasks were submitted in this
        /// request. If the server times out or the connection is closed during the
        /// request, the request may have been partially or fully processed, or not at all.
        /// In such cases, the user should re-issue the request. Note that it is up to the
        /// user to correctly handle failures when re-issuing a request. For example, you
        /// should use the same Task IDs during a retry so that if the prior operation
        /// succeeded, the retry will not create extra Tasks unexpectedly. If the response
        /// contains any Tasks which failed to add, a client can retry the request. In a
        /// retry, it is most efficient to resubmit only Tasks that failed to add, and to
        /// omit Tasks that were successfully added on the first attempt. The maximum
        /// lifetime of a Task from addition to completion is 180 days. If a Task has not
        /// completed within 180 days of being added it will be terminated by the Batch
        /// service and left in whatever state it was in at that time.
        /// </summary>
        /// <param name="jobId">The ID of the Job to which the Task collection is to be added.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Tasks to be added.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksCreateTaskCollection(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskGroup body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCreateTaskCollectionResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/addtaskcollection"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksCreateTaskCollection_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Note that each Task must have a unique ID. The Batch service may not return the
        /// results for each Task in the same order the Tasks were submitted in this
        /// request. If the server times out or the connection is closed during the
        /// request, the request may have been partially or fully processed, or not at all.
        /// In such cases, the user should re-issue the request. Note that it is up to the
        /// user to correctly handle failures when re-issuing a request. For example, you
        /// should use the same Task IDs during a retry so that if the prior operation
        /// succeeded, the retry will not create extra Tasks unexpectedly. If the response
        /// contains any Tasks which failed to add, a client can retry the request. In a
        /// retry, it is most efficient to resubmit only Tasks that failed to add, and to
        /// omit Tasks that were successfully added on the first attempt. The maximum
        /// lifetime of a Task from addition to completion is 180 days. If a Task has not
        /// completed within 180 days of being added it will be terminated by the Batch
        /// service and left in whatever state it was in at that time.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Tasks to be added.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksCreateTaskCollectionViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskGroup body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCreateTaskCollectionResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/addtaskcollection"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksCreateTaskCollection_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Note that each Task must have a unique ID. The Batch service may not return the
        /// results for each Task in the same order the Tasks were submitted in this
        /// request. If the server times out or the connection is closed during the
        /// request, the request may have been partially or fully processed, or not at all.
        /// In such cases, the user should re-issue the request. Note that it is up to the
        /// user to correctly handle failures when re-issuing a request. For example, you
        /// should use the same Task IDs during a retry so that if the prior operation
        /// succeeded, the retry will not create extra Tasks unexpectedly. If the response
        /// contains any Tasks which failed to add, a client can retry the request. In a
        /// retry, it is most efficient to resubmit only Tasks that failed to add, and to
        /// omit Tasks that were successfully added on the first attempt. The maximum
        /// lifetime of a Task from addition to completion is 180 days. If a Task has not
        /// completed within 180 days of being added it will be terminated by the Batch
        /// service and left in whatever state it was in at that time.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Tasks to be added.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCreateTaskCollectionResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCreateTaskCollectionResult> TasksCreateTaskCollectionViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskGroup body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/addtaskcollection"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.TasksCreateTaskCollectionWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Note that each Task must have a unique ID. The Batch service may not return the
        /// results for each Task in the same order the Tasks were submitted in this
        /// request. If the server times out or the connection is closed during the
        /// request, the request may have been partially or fully processed, or not at all.
        /// In such cases, the user should re-issue the request. Note that it is up to the
        /// user to correctly handle failures when re-issuing a request. For example, you
        /// should use the same Task IDs during a retry so that if the prior operation
        /// succeeded, the retry will not create extra Tasks unexpectedly. If the response
        /// contains any Tasks which failed to add, a client can retry the request. In a
        /// retry, it is most efficient to resubmit only Tasks that failed to add, and to
        /// omit Tasks that were successfully added on the first attempt. The maximum
        /// lifetime of a Task from addition to completion is 180 days. If a Task has not
        /// completed within 180 days of being added it will be terminated by the Batch
        /// service and left in whatever state it was in at that time.
        /// </summary>
        /// <param name="jobId">The ID of the Job to which the Task collection is to be added.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the TasksCreateTaskCollection operation</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksCreateTaskCollectionViaJsonString(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCreateTaskCollectionResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/addtaskcollection"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksCreateTaskCollection_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Note that each Task must have a unique ID. The Batch service may not return the
        /// results for each Task in the same order the Tasks were submitted in this
        /// request. If the server times out or the connection is closed during the
        /// request, the request may have been partially or fully processed, or not at all.
        /// In such cases, the user should re-issue the request. Note that it is up to the
        /// user to correctly handle failures when re-issuing a request. For example, you
        /// should use the same Task IDs during a retry so that if the prior operation
        /// succeeded, the retry will not create extra Tasks unexpectedly. If the response
        /// contains any Tasks which failed to add, a client can retry the request. In a
        /// retry, it is most efficient to resubmit only Tasks that failed to add, and to
        /// omit Tasks that were successfully added on the first attempt. The maximum
        /// lifetime of a Task from addition to completion is 180 days. If a Task has not
        /// completed within 180 days of being added it will be terminated by the Batch
        /// service and left in whatever state it was in at that time.
        /// </summary>
        /// <param name="jobId">The ID of the Job to which the Task collection is to be added.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the TasksCreateTaskCollection operation</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCreateTaskCollectionResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCreateTaskCollectionResult> TasksCreateTaskCollectionViaJsonStringWithResult(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/addtaskcollection"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.TasksCreateTaskCollectionWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Note that each Task must have a unique ID. The Batch service may not return the
        /// results for each Task in the same order the Tasks were submitted in this
        /// request. If the server times out or the connection is closed during the
        /// request, the request may have been partially or fully processed, or not at all.
        /// In such cases, the user should re-issue the request. Note that it is up to the
        /// user to correctly handle failures when re-issuing a request. For example, you
        /// should use the same Task IDs during a retry so that if the prior operation
        /// succeeded, the retry will not create extra Tasks unexpectedly. If the response
        /// contains any Tasks which failed to add, a client can retry the request. In a
        /// retry, it is most efficient to resubmit only Tasks that failed to add, and to
        /// omit Tasks that were successfully added on the first attempt. The maximum
        /// lifetime of a Task from addition to completion is 180 days. If a Task has not
        /// completed within 180 days of being added it will be terminated by the Batch
        /// service and left in whatever state it was in at that time.
        /// </summary>
        /// <param name="jobId">The ID of the Job to which the Task collection is to be added.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Tasks to be added.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCreateTaskCollectionResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCreateTaskCollectionResult> TasksCreateTaskCollectionWithResult(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskGroup body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/addtaskcollection"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.TasksCreateTaskCollectionWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// Actual wire call for <see cref= "TasksCreateTaskCollectionWithResult" /> method.
        /// </summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCreateTaskCollectionResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCreateTaskCollectionResult> TasksCreateTaskCollectionWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchCreateTaskCollectionResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksCreateTaskCollection" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksCreateTaskCollection_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchCreateTaskCollectionResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchCreateTaskCollectionResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="TasksCreateTaskCollection" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job to which the Task collection is to be added.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Tasks to be added.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksCreateTaskCollection_Validate(string jobId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskGroup body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// The maximum lifetime of a Task from addition to completion is 180 days. If a
        /// Task has not completed within 180 days of being added it will be terminated by
        /// the Batch service and left in whatever state it was in at that time.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Task to be created.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksCreateTaskViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskCreateOptions body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksCreateTaskCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/tasks"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksCreateTask_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// The maximum lifetime of a Task from addition to completion is 180 days. If a
        /// Task has not completed within 180 days of being added it will be terminated by
        /// the Batch service and left in whatever state it was in at that time.
        /// </summary>
        /// <param name="jobId">The ID of the Job to which the Task is to be created.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the TasksCreateTask operation</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksCreateTaskViaJsonString(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksCreateTaskCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksCreateTask_Call (request, onCreated,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksCreateTask" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onCreated">a delegate that is called when the remote service returns 201 (Created).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksCreateTask_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksCreateTaskCreatedResponseHeaders>, global::System.Threading.Tasks.Task> onCreated, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.Created:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onCreated(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="TasksCreateTask" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job to which the Task is to be created.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Task to be created.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksCreateTask_Validate(string jobId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskCreateOptions body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// When a Task is deleted, all of the files in its directory on the Compute Node
        /// where it ran are also deleted (regardless of the retention time). For
        /// multi-instance Tasks, the delete Task operation applies synchronously to the
        /// primary task; subtasks and their files are then deleted asynchronously in the
        /// background.
        /// </summary>
        /// <param name="jobId">The ID of the Job from which to delete the Task.</param>
        /// <param name="taskId">The ID of the Task to delete.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksDeleteTask(string jobId, string taskId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksDeleteTaskOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks/"
                        + global::System.Uri.EscapeDataString(taskId)
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksDeleteTask_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Deletes the specified Task file from the Compute Node where the Task ran.</summary>
        /// <param name="jobId">The ID of the Job that contains the Task.</param>
        /// <param name="taskId">The ID of the Task whose file you want to retrieve.</param>
        /// <param name="filePath">The path to the Task file that you want to get the content of.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="recursive">Whether to delete children of a directory. If the filePath parameter represents
        /// a directory instead of a file, you can set recursive to true to delete the
        /// directory and all of the files and subdirectories in it. If recursive is false
        /// then the directory must be empty or deletion will fail.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksDeleteTaskFile(string jobId, string taskId, string filePath, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, bool? recursive, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksDeleteTaskFileOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks/"
                        + global::System.Uri.EscapeDataString(taskId)
                        + "/files/"
                        + global::System.Uri.EscapeDataString(filePath)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == recursive ? global::System.String.Empty : "recursive=" + global::System.Uri.EscapeDataString(recursive.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksDeleteTaskFile_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Deletes the specified Task file from the Compute Node where the Task ran.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="recursive">Whether to delete children of a directory. If the filePath parameter represents
        /// a directory instead of a file, you can set recursive to true to delete the
        /// directory and all of the files and subdirectories in it. If recursive is false
        /// then the directory must be empty or deletion will fail.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksDeleteTaskFileViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, bool? recursive, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksDeleteTaskFileOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/tasks/(?<taskId>[^/]+)/files/(?<filePath>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/tasks/{taskId}/files/{filePath}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                var taskId = _match.Groups["taskId"].Value;
                var filePath = _match.Groups["filePath"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/tasks/"
                        + taskId
                        + "/files/"
                        + filePath
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == recursive ? global::System.String.Empty : "recursive=" + global::System.Uri.EscapeDataString(recursive.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksDeleteTaskFile_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksDeleteTaskFile" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksDeleteTaskFile_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksDeleteTaskFileOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="TasksDeleteTaskFile" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job that contains the Task.</param>
        /// <param name="taskId">The ID of the Task whose file you want to retrieve.</param>
        /// <param name="filePath">The path to the Task file that you want to get the content of.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="recursive">Whether to delete children of a directory. If the filePath parameter represents
        /// a directory instead of a file, you can set recursive to true to delete the
        /// directory and all of the files and subdirectories in it. If recursive is false
        /// then the directory must be empty or deletion will fail.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksDeleteTaskFile_Validate(string jobId, string taskId, string filePath, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, int? timeOut, bool? recursive, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(taskId),taskId);
                await eventListener.AssertNotNull(nameof(filePath),filePath);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>
        /// When a Task is deleted, all of the files in its directory on the Compute Node
        /// where it ran are also deleted (regardless of the retention time). For
        /// multi-instance Tasks, the delete Task operation applies synchronously to the
        /// primary task; subtasks and their files are then deleted asynchronously in the
        /// background.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksDeleteTaskViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksDeleteTaskOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/tasks/(?<taskId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/tasks/{taskId}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                var taskId = _match.Groups["taskId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/tasks/"
                        + taskId
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Delete, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksDeleteTask_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksDeleteTask" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksDeleteTask_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksDeleteTaskOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="TasksDeleteTask" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job from which to delete the Task.</param>
        /// <param name="taskId">The ID of the Task to delete.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksDeleteTask_Validate(string jobId, string taskId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(taskId),taskId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>
        /// For multi-instance Tasks, information such as affinityId, executionInfo and
        /// nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
        /// information about subtasks.
        /// </summary>
        /// <param name="jobId">The ID of the Job that contains the Task.</param>
        /// <param name="taskId">The ID of the Task to get information about.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksGetTask(string jobId, string taskId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTask>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks/"
                        + global::System.Uri.EscapeDataString(taskId)
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksGetTask_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Returns the content of the specified Task file.</summary>
        /// <param name="jobId">The ID of the Job that contains the Task.</param>
        /// <param name="taskId">The ID of the Task whose file you want to retrieve.</param>
        /// <param name="filePath">The path to the Task file that you want to get the content of.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ocpRange">The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksGetTaskFile(string jobId, string taskId, string filePath, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ocpRange, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<global::System.IO.Stream>, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksGetTaskFileOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks/"
                        + global::System.Uri.EscapeDataString(taskId)
                        + "/files/"
                        + global::System.Uri.EscapeDataString(filePath)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ocpRange)
                {
                    request.Headers.Add("ocp-range",ocpRange);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksGetTaskFile_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Gets the properties of the specified Task file.</summary>
        /// <param name="jobId">The ID of the Job that contains the Task.</param>
        /// <param name="taskId">The ID of the Task whose file you want to retrieve.</param>
        /// <param name="filePath">The path to the Task file that you want to get the content of.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksGetTaskFileProperties(string jobId, string taskId, string filePath, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksGetTaskFilePropertiesOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks/"
                        + global::System.Uri.EscapeDataString(taskId)
                        + "/files/"
                        + global::System.Uri.EscapeDataString(filePath)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Head, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksGetTaskFileProperties_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Gets the properties of the specified Task file.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksGetTaskFilePropertiesViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksGetTaskFilePropertiesOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/tasks/(?<taskId>[^/]+)/files/(?<filePath>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/tasks/{taskId}/files/{filePath}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                var taskId = _match.Groups["taskId"].Value;
                var filePath = _match.Groups["filePath"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/tasks/"
                        + taskId
                        + "/files/"
                        + filePath
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Head, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksGetTaskFileProperties_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksGetTaskFileProperties" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksGetTaskFileProperties_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksGetTaskFilePropertiesOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="TasksGetTaskFileProperties" /> method. Call this like the actual call, but you will get
        /// validation events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job that contains the Task.</param>
        /// <param name="taskId">The ID of the Task whose file you want to retrieve.</param>
        /// <param name="filePath">The path to the Task file that you want to get the content of.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksGetTaskFileProperties_Validate(string jobId, string taskId, string filePath, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, int? timeOut, string ifModifiedSince, string ifUnmodifiedSince, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(taskId),taskId);
                await eventListener.AssertNotNull(nameof(filePath),filePath);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
            }
        }

        /// <summary>Returns the content of the specified Task file.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ocpRange">The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksGetTaskFileViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ocpRange, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<global::System.IO.Stream>, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksGetTaskFileOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/tasks/(?<taskId>[^/]+)/files/(?<filePath>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/tasks/{taskId}/files/{filePath}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                var taskId = _match.Groups["taskId"].Value;
                var filePath = _match.Groups["filePath"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/tasks/"
                        + taskId
                        + "/files/"
                        + filePath
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ocpRange)
                {
                    request.Headers.Add("ocp-range",ocpRange);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksGetTaskFile_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Returns the content of the specified Task file.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ocpRange">The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<global::System.IO.Stream>" /> that will be complete when handling of
        /// the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<global::System.IO.Stream> TasksGetTaskFileViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ocpRange, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/tasks/(?<taskId>[^/]+)/files/(?<filePath>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/tasks/{taskId}/files/{filePath}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                var taskId = _match.Groups["taskId"].Value;
                var filePath = _match.Groups["filePath"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/tasks/"
                        + taskId
                        + "/files/"
                        + filePath
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ocpRange)
                {
                    request.Headers.Add("ocp-range",ocpRange);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.TasksGetTaskFileWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Returns the content of the specified Task file.</summary>
        /// <param name="jobId">The ID of the Job that contains the Task.</param>
        /// <param name="taskId">The ID of the Task whose file you want to retrieve.</param>
        /// <param name="filePath">The path to the Task file that you want to get the content of.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ocpRange">The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<global::System.IO.Stream>" /> that will be complete when handling of
        /// the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<global::System.IO.Stream> TasksGetTaskFileWithResult(string jobId, string taskId, string filePath, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ocpRange, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks/"
                        + global::System.Uri.EscapeDataString(taskId)
                        + "/files/"
                        + global::System.Uri.EscapeDataString(filePath)
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ocpRange)
                {
                    request.Headers.Add("ocp-range",ocpRange);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.TasksGetTaskFileWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksGetTaskFileWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<global::System.IO.Stream>" /> that will be complete when handling of
        /// the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<global::System.IO.Stream> TasksGetTaskFileWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStreamAsync();
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksGetTaskFile" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksGetTaskFile_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<global::System.IO.Stream>, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksGetTaskFileOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStreamAsync(), null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="TasksGetTaskFile" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job that contains the Task.</param>
        /// <param name="taskId">The ID of the Task whose file you want to retrieve.</param>
        /// <param name="filePath">The path to the Task file that you want to get the content of.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ocpRange">The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksGetTaskFile_Validate(string jobId, string taskId, string filePath, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, int? timeOut, string ifModifiedSince, string ifUnmodifiedSince, string ocpRange, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(taskId),taskId);
                await eventListener.AssertNotNull(nameof(filePath),filePath);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ocpRange),ocpRange);
            }
        }

        /// <summary>
        /// For multi-instance Tasks, information such as affinityId, executionInfo and
        /// nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
        /// information about subtasks.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksGetTaskViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTask>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/tasks/(?<taskId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/tasks/{taskId}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                var taskId = _match.Groups["taskId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/tasks/"
                        + taskId
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksGetTask_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// For multi-instance Tasks, information such as affinityId, executionInfo and
        /// nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
        /// information about subtasks.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTask>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTask> TasksGetTaskViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/tasks/(?<taskId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/tasks/{taskId}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                var taskId = _match.Groups["taskId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/tasks/"
                        + taskId
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.TasksGetTaskWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// For multi-instance Tasks, information such as affinityId, executionInfo and
        /// nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
        /// information about subtasks.
        /// </summary>
        /// <param name="jobId">The ID of the Job that contains the Task.</param>
        /// <param name="taskId">The ID of the Task to get information about.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTask>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTask> TasksGetTaskWithResult(string jobId, string taskId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks/"
                        + global::System.Uri.EscapeDataString(taskId)
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.TasksGetTaskWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksGetTaskWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTask>" /> that
        /// will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTask> TasksGetTaskWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchTask.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksGetTask" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksGetTask_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTask>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchTask.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="TasksGetTask" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job that contains the Task.</param>
        /// <param name="taskId">The ID of the Task to get information about.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksGetTask_Validate(string jobId, string taskId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(taskId),taskId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>If the Task is not a multi-instance Task then this returns an empty collection.</summary>
        /// <param name="jobId">The ID of the Job.</param>
        /// <param name="taskId">The ID of the Task.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksListSubTasks(string jobId, string taskId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, System.Collections.Generic.List<string> Select, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListSubtasksResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks/"
                        + global::System.Uri.EscapeDataString(taskId)
                        + "/subtasksinfo"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksListSubTasks_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>If the Task is not a multi-instance Task then this returns an empty collection.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksListSubTasksViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, System.Collections.Generic.List<string> Select, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListSubtasksResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/tasks/(?<taskId>[^/]+)/subtasksinfo$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/tasks/{taskId}/subtasksinfo'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                var taskId = _match.Groups["taskId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/tasks/"
                        + taskId
                        + "/subtasksinfo"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksListSubTasks_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>If the Task is not a multi-instance Task then this returns an empty collection.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListSubtasksResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListSubtasksResult> TasksListSubTasksViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, System.Collections.Generic.List<string> Select, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/tasks/(?<taskId>[^/]+)/subtasksinfo$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/tasks/{taskId}/subtasksinfo'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                var taskId = _match.Groups["taskId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/tasks/"
                        + taskId
                        + "/subtasksinfo"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.TasksListSubTasksWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>If the Task is not a multi-instance Task then this returns an empty collection.</summary>
        /// <param name="jobId">The ID of the Job.</param>
        /// <param name="taskId">The ID of the Task.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListSubtasksResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListSubtasksResult> TasksListSubTasksWithResult(string jobId, string taskId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, System.Collections.Generic.List<string> Select, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks/"
                        + global::System.Uri.EscapeDataString(taskId)
                        + "/subtasksinfo"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.TasksListSubTasksWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksListSubTasksWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListSubtasksResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListSubtasksResult> TasksListSubTasksWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchTaskListSubtasksResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksListSubTasks" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksListSubTasks_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListSubtasksResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchTaskListSubtasksResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="TasksListSubTasks" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job.</param>
        /// <param name="taskId">The ID of the Task.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksListSubTasks_Validate(string jobId, string taskId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string endpoint, System.Collections.Generic.List<string> Select, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(taskId),taskId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>Lists the files in a Task's directory on its Compute Node.</summary>
        /// <param name="jobId">The ID of the Job that contains the Task.</param>
        /// <param name="taskId">The ID of the Task whose files you want to list.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-task-files.</param>
        /// <param name="recursive">Whether to list children of the Task directory. This parameter can be used in
        /// combination with the filter parameter to list specific type of files.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksListTaskFiles(string jobId, string taskId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, bool? recursive, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks/"
                        + global::System.Uri.EscapeDataString(taskId)
                        + "/files"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null == recursive ? global::System.String.Empty : "recursive=" + global::System.Uri.EscapeDataString(recursive.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksListTaskFiles_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists the files in a Task's directory on its Compute Node.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-task-files.</param>
        /// <param name="recursive">Whether to list children of the Task directory. This parameter can be used in
        /// combination with the filter parameter to list specific type of files.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksListTaskFilesViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, bool? recursive, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/tasks/(?<taskId>[^/]+)/files$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/tasks/{taskId}/files'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                var taskId = _match.Groups["taskId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/tasks/"
                        + taskId
                        + "/files"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null == recursive ? global::System.String.Empty : "recursive=" + global::System.Uri.EscapeDataString(recursive.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksListTaskFiles_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Lists the files in a Task's directory on its Compute Node.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-task-files.</param>
        /// <param name="recursive">Whether to list children of the Task directory. This parameter can be used in
        /// combination with the filter parameter to list specific type of files.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult> TasksListTaskFilesViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, bool? recursive, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/tasks/(?<taskId>[^/]+)/files$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/tasks/{taskId}/files'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                var taskId = _match.Groups["taskId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/tasks/"
                        + taskId
                        + "/files"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null == recursive ? global::System.String.Empty : "recursive=" + global::System.Uri.EscapeDataString(recursive.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.TasksListTaskFilesWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Lists the files in a Task's directory on its Compute Node.</summary>
        /// <param name="jobId">The ID of the Job that contains the Task.</param>
        /// <param name="taskId">The ID of the Task whose files you want to list.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-task-files.</param>
        /// <param name="recursive">Whether to list children of the Task directory. This parameter can be used in
        /// combination with the filter parameter to list specific type of files.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult> TasksListTaskFilesWithResult(string jobId, string taskId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, bool? recursive, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks/"
                        + global::System.Uri.EscapeDataString(taskId)
                        + "/files"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null == recursive ? global::System.String.Empty : "recursive=" + global::System.Uri.EscapeDataString(recursive.ToString()))
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.TasksListTaskFilesWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksListTaskFilesWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult> TasksListTaskFilesWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchNodeFileListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksListTaskFiles" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksListTaskFiles_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodeFileListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchNodeFileListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="TasksListTaskFiles" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job that contains the Task.</param>
        /// <param name="taskId">The ID of the Task whose files you want to list.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-task-files.</param>
        /// <param name="recursive">Whether to list children of the Task directory. This parameter can be used in
        /// combination with the filter parameter to list specific type of files.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksListTaskFiles_Validate(string jobId, string taskId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? maxresults, string endpoint, string Filter, bool? recursive, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(taskId),taskId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(maxresults),maxresults,1);
                await eventListener.AssertIsLessThanOrEqual(nameof(maxresults),maxresults,1000);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(Filter),Filter);
            }
        }

        /// <summary>
        /// For multi-instance Tasks, information such as affinityId, executionInfo and
        /// nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
        /// information about subtasks.
        /// </summary>
        /// <param name="jobId">The ID of the Job.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-tasks.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksListTasks(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksListTasks_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// For multi-instance Tasks, information such as affinityId, executionInfo and
        /// nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
        /// information about subtasks.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-tasks.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksListTasksViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/tasks$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/tasks'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/tasks"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksListTasks_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// For multi-instance Tasks, information such as affinityId, executionInfo and
        /// nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
        /// information about subtasks.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-tasks.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListResult> TasksListTasksViaIdentityWithResult(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/tasks$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/tasks'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/tasks"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.TasksListTasksWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>
        /// For multi-instance Tasks, information such as affinityId, executionInfo and
        /// nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
        /// information about subtasks.
        /// </summary>
        /// <param name="jobId">The ID of the Job.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-tasks.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListResult> TasksListTasksWithResult(string jobId, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? timeOut, int? maxresults, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks"
                        + "?"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        + "&"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + (null == maxresults ? global::System.String.Empty : "maxresults=" + global::System.Uri.EscapeDataString(maxresults.ToString()))
                        + "&"
                        + (string.IsNullOrEmpty(Filter) ? global::System.String.Empty : "$filter=" + global::System.Uri.EscapeDataString(Filter))
                        + "&"
                        + (null != Select  && Select.Count > 0 ? "$select=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Select, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        + "&"
                        + (null != Expand  && Expand.Count > 0 ? "$expand=" + global::System.Uri.EscapeDataString(global::System.Linq.Enumerable.Aggregate(Expand, (current, each) => current + "," + ( null == each ? global::System.String.Empty : each.ToString()) )) : global::System.String.Empty)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Get, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return null; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return null; }
                // make the call
                return await this.TasksListTasksWithResult_Call (request, eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksListTasksWithResult" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListResult>"
        /// /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListResult> TasksListTasksWithResult_Call(global::System.Net.Http.HttpRequestMessage request, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return null; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchTaskListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers));
                            return await _result;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return null; }
                            var _result = _response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) );
                            // Error Response : default
                            var code = (await _result)?.Code;
                            var message = (await _result)?.MessageLang;
                            if ((null == code || null == message))
                            {
                                // Unrecognized Response. Create an error record based on what we have.
                                var ex = new Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>(_response, await _result);
                                throw ex;
                            }
                            else
                            {
                                throw new global::System.Exception($"[{code}] : {message}");
                            }
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksListTasks" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksListTasks_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTaskListResult>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchTaskListResult.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) .ReadHeaders(_response.Headers)));
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="TasksListTasks" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="maxresults">The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="Filter">An OData $filter clause. For more information on constructing this filter, see
        /// https://learn.microsoft.com/rest/api/batchservice/odata-filters-in-batch#list-tasks.</param>
        /// <param name="Select">An OData $select clause.</param>
        /// <param name="Expand">An OData $expand clause.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksListTasks_Validate(string jobId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, int? maxresults, string endpoint, string Filter, System.Collections.Generic.List<string> Select, System.Collections.Generic.List<string> Expand, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertIsGreaterThanOrEqual(nameof(maxresults),maxresults,1);
                await eventListener.AssertIsLessThanOrEqual(nameof(maxresults),maxresults,1000);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(Filter),Filter);
            }
        }

        /// <summary>
        /// Reactivation makes a Task eligible to be retried again up to its maximum retry
        /// count. The Task's state is changed to active. As the Task is no longer in the
        /// completed state, any previous exit code or failure information is no longer
        /// available after reactivation. Each time a Task is reactivated, its retry count
        /// is reset to 0. Reactivation will fail for Tasks that are not completed or that
        /// previously completed successfully (with an exit code of 0). Additionally, it
        /// will fail if the Job has completed (or is terminating or deleting).
        /// </summary>
        /// <param name="jobId">The ID of the Job containing the Task.</param>
        /// <param name="taskId">The ID of the Task to reactivate.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksReactivateTask(string jobId, string taskId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksReactivateTaskNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks/"
                        + global::System.Uri.EscapeDataString(taskId)
                        + "/reactivate"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksReactivateTask_Call (request, onNoContent,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// Reactivation makes a Task eligible to be retried again up to its maximum retry
        /// count. The Task's state is changed to active. As the Task is no longer in the
        /// completed state, any previous exit code or failure information is no longer
        /// available after reactivation. Each time a Task is reactivated, its retry count
        /// is reset to 0. Reactivation will fail for Tasks that are not completed or that
        /// previously completed successfully (with an exit code of 0). Additionally, it
        /// will fail if the Job has completed (or is terminating or deleting).
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksReactivateTaskViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksReactivateTaskNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/tasks/(?<taskId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/tasks/{taskId}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                var taskId = _match.Groups["taskId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/tasks/"
                        + taskId
                        + "/reactivate"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksReactivateTask_Call (request, onNoContent,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksReactivateTask" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksReactivateTask_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksReactivateTaskNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.NoContent:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNoContent(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="TasksReactivateTask" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job containing the Task.</param>
        /// <param name="taskId">The ID of the Task to reactivate.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksReactivateTask_Validate(string jobId, string taskId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(taskId),taskId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }

        /// <summary>replace the properties of the specified Task.</summary>
        /// <param name="jobId">The ID of the Job containing the Task.</param>
        /// <param name="taskId">The ID of the Task to update.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Task to update.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksReplaceTask(string jobId, string taskId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTask body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksReplaceTaskOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks/"
                        + global::System.Uri.EscapeDataString(taskId)
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Put, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksReplaceTask_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>replace the properties of the specified Task.</summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Task to update.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <param name="serializationMode">Allows the caller to choose the depth of the serialization. See <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode"/>.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksReplaceTaskViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTask body, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksReplaceTaskOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode serializationMode = Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeCreate|Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.SerializationMode.IncludeUpdate)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/tasks/(?<taskId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/tasks/{taskId}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                var taskId = _match.Groups["taskId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/tasks/"
                        + taskId
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Put, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(null != body ? body.ToJson(null, serializationMode).ToString() : @"{}", global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksReplaceTask_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>replace the properties of the specified Task.</summary>
        /// <param name="jobId">The ID of the Job containing the Task.</param>
        /// <param name="taskId">The ID of the Task to update.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="jsonString">Json string supplied to the TasksReplaceTask operation</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksReplaceTaskViaJsonString(string jobId, string taskId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.String jsonString, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksReplaceTaskOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks/"
                        + global::System.Uri.EscapeDataString(taskId)
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Put, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // set body content
                request.Content = new global::System.Net.Http.StringContent(jsonString, global::System.Text.Encoding.UTF8);
                request.Content.Headers.ContentType = global::System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BodyContentSet); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksReplaceTask_Call (request, onOk,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksReplaceTask" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onOk">a delegate that is called when the remote service returns 200 (OK).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksReplaceTask_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksReplaceTaskOkResponseHeaders>, global::System.Threading.Tasks.Task> onOk, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.OK:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onOk(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="TasksReplaceTask" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job containing the Task.</param>
        /// <param name="taskId">The ID of the Task to update.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="body">The Task to update.</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksReplaceTask_Validate(string jobId, string taskId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchTask body, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(taskId),taskId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
                await eventListener.AssertNotNull(nameof(body), body);
                await eventListener.AssertObjectIsValid(nameof(body), body);
            }
        }

        /// <summary>
        /// When the Task has been terminated, it moves to the completed state. For
        /// multi-instance Tasks, the terminate Task operation applies synchronously to the
        /// primary task; subtasks are then terminated asynchronously in the background.
        /// </summary>
        /// <param name="jobId">The ID of the Job containing the Task.</param>
        /// <param name="taskId">The ID of the Task to terminate.</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksTerminateTask(string jobId, string taskId, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksTerminateTaskNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + global::System.Uri.EscapeDataString(jobId)
                        + "/tasks/"
                        + global::System.Uri.EscapeDataString(taskId)
                        + "/terminate"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksTerminateTask_Call (request, onNoContent,onDefault,eventListener,sender);
            }
        }

        /// <summary>
        /// When the Task has been terminated, it moves to the completed state. For
        /// multi-instance Tasks, the terminate Task operation applies synchronously to the
        /// primary task; subtasks are then terminated asynchronously in the background.
        /// </summary>
        /// <param name="viaIdentity"></param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task TasksTerminateTaskViaIdentity(global::System.String viaIdentity, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, int? timeOut, string endpoint, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksTerminateTaskNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            var apiVersion = @"2024-07-01.20.0";
            // Constant Parameters
            using( NoSynchronizationContext )
            {
                // verify that Identity format is an exact match for uri

                var _match = new global::System.Text.RegularExpressions.Regex("^/jobs/(?<jobId>[^/]+)/tasks/(?<taskId>[^/]+)$", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(viaIdentity);
                if (!_match.Success)
                {
                    throw new global::System.Exception("Invalid identity for URI '/jobs/{jobId}/tasks/{taskId}'");
                }

                // replace URI parameters with values from identity
                var jobId = _match.Groups["jobId"].Value;
                var taskId = _match.Groups["taskId"].Value;
                // construct URL
                var pathAndQuery = global::System.Text.RegularExpressions.Regex.Replace(
                        "/jobs/"
                        + jobId
                        + "/tasks/"
                        + taskId
                        + "/terminate"
                        + "?"
                        + (null == timeOut ? global::System.String.Empty : "timeOut=" + global::System.Uri.EscapeDataString(timeOut.ToString()))
                        + "&"
                        + "api-version=" + global::System.Uri.EscapeDataString(apiVersion)
                        ,"\\?&*$|&*$|(\\?)&+|(&)&+","$1$2");

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.URLCreated, pathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // generate request object
                var _url = new global::System.Uri($"{endpoint}{pathAndQuery}");
                var request =  new global::System.Net.Http.HttpRequestMessage(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Method.Post, _url);
                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.RequestCreated, request.RequestUri.PathAndQuery); if( eventListener.Token.IsCancellationRequested ) { return; }

                // add headers parameters
                if (null != clientRequestId)
                {
                    request.Headers.Add("client-request-id",clientRequestId);
                }
                if (null != returnClientRequestId)
                {
                    request.Headers.Add("return-client-request-id",returnClientRequestId.ToString());
                }
                if (null != ocpDate)
                {
                    request.Headers.Add("ocp-date",ocpDate);
                }
                if (null != ifModifiedSince)
                {
                    request.Headers.Add("If-Modified-Since",ifModifiedSince);
                }
                if (null != ifUnmodifiedSince)
                {
                    request.Headers.Add("If-Unmodified-Since",ifUnmodifiedSince);
                }
                if (null != ifMatch)
                {
                    request.Headers.Add("If-Match",ifMatch);
                }
                if (null != ifNoneMatch)
                {
                    request.Headers.Add("If-None-Match",ifNoneMatch);
                }

                await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.HeaderParametersAdded); if( eventListener.Token.IsCancellationRequested ) { return; }
                // make the call
                await this.TasksTerminateTask_Call (request, onNoContent,onDefault,eventListener,sender);
            }
        }

        /// <summary>Actual wire call for <see cref= "TasksTerminateTask" /> method.</summary>
        /// <param name="request">the prepared HttpRequestMessage to send.</param>
        /// <param name="onNoContent">a delegate that is called when the remote service returns 204 (NoContent).</param>
        /// <param name="onDefault">a delegate that is called when the remote service returns default (any response code not handled
        /// elsewhere).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <param name="sender">an instance of an Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync pipeline to use to make the request.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksTerminateTask_Call(global::System.Net.Http.HttpRequestMessage request, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ITasksTerminateTaskNoContentResponseHeaders>, global::System.Threading.Tasks.Task> onNoContent, global::System.Func<global::System.Net.Http.HttpResponseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchError>, global::System.Threading.Tasks.Task> onDefault, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.ISendAsync sender)
        {
            using( NoSynchronizationContext )
            {
                global::System.Net.Http.HttpResponseMessage _response = null;
                try
                {
                    var sendTask = sender.SendAsync(request, eventListener);
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeCall, request); if( eventListener.Token.IsCancellationRequested ) { return; }
                    _response = await sendTask;
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.ResponseCreated, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Progress, "intentional placeholder", 100); if( eventListener.Token.IsCancellationRequested ) { return; }
                    var _contentType = _response.Content.Headers.ContentType?.MediaType;

                    switch ( _response.StatusCode )
                    {
                        case global::System.Net.HttpStatusCode.NoContent:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onNoContent(_response,null /* deserializeFromResponse doesn't support '-header-' C:\Users\wiboris\.autorest\@autorest_powershell@4.0.743\node_modules\@autorest\powershell\dist\llcsharp\schema\object.js*/);
                            break;
                        }
                        default:
                        {
                            await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.BeforeResponseDispatch, _response); if( eventListener.Token.IsCancellationRequested ) { return; }
                            await onDefault(_response,_response.Content.ReadAsStringAsync().ContinueWith( body => Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchError.FromJson(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Json.JsonNode.Parse(body.Result)) ));
                            break;
                        }
                    }
                }
                finally
                {
                    // finally statements
                    await eventListener.Signal(Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Events.Finally, request, _response);
                    _response?.Dispose();
                    request?.Dispose();
                }
            }
        }

        /// <summary>
        /// Validation method for <see cref="TasksTerminateTask" /> method. Call this like the actual call, but you will get validation
        /// events back.
        /// </summary>
        /// <param name="jobId">The ID of the Job containing the Task.</param>
        /// <param name="taskId">The ID of the Task to terminate.</param>
        /// <param name="timeOut">The maximum time that the server can spend processing the request, in seconds. The default is 30
        /// seconds. If the value is larger than 30, the default will be used instead.".</param>
        /// <param name="clientRequestId">The caller-generated request identity, in the form of a GUID with no decoration
        /// such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0.</param>
        /// <param name="returnClientRequestId">Whether the server should return the client-request-id in the response.</param>
        /// <param name="ocpDate">The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.</param>
        /// <param name="ifModifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// been modified since the specified time.</param>
        /// <param name="ifUnmodifiedSince">A timestamp indicating the last modified time of the resource known to the
        /// client. The operation will be performed only if the resource on the service has
        /// not been modified since the specified time.</param>
        /// <param name="ifMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service exactly matches the value specified by the client.</param>
        /// <param name="ifNoneMatch">An ETag value associated with the version of the resource known to the client.
        /// The operation will be performed only if the resource's current ETag on the
        /// service does not match the value specified by the client.</param>
        /// <param name="endpoint">Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com).</param>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener" /> instance that will receive events.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the response is completed.
        /// </returns>
        internal async global::System.Threading.Tasks.Task TasksTerminateTask_Validate(string jobId, string taskId, int? timeOut, string clientRequestId, bool? returnClientRequestId, string ocpDate, string ifModifiedSince, string ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string endpoint, Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IEventListener eventListener)
        {
            using( NoSynchronizationContext )
            {
                await eventListener.AssertNotNull(nameof(jobId),jobId);
                await eventListener.AssertNotNull(nameof(taskId),taskId);
                await eventListener.AssertNotNull(nameof(clientRequestId),clientRequestId);
                await eventListener.AssertNotNull(nameof(ocpDate),ocpDate);
                await eventListener.AssertNotNull(nameof(ifModifiedSince),ifModifiedSince);
                await eventListener.AssertNotNull(nameof(ifUnmodifiedSince),ifUnmodifiedSince);
                await eventListener.AssertNotNull(nameof(ifMatch),ifMatch);
                await eventListener.AssertNotNull(nameof(ifNoneMatch),ifNoneMatch);
                await eventListener.AssertNotNull(nameof(endpoint),endpoint);
                await eventListener.AssertRegEx(nameof(endpoint),endpoint,@"^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$");
            }
        }
    }
}