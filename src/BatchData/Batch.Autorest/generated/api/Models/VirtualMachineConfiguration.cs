// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Batch.Models
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Extensions;

    /// <summary>
    /// The configuration for Compute Nodes in a Pool based on the Azure Virtual
    /// Machines infrastructure.
    /// </summary>
    public partial class VirtualMachineConfiguration :
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVirtualMachineConfiguration,
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVirtualMachineConfigurationInternal
    {

        /// <summary>Backing field for <see cref="ContainerConfiguration" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchContainerConfiguration _containerConfiguration;

        /// <summary>
        /// The container configuration for the Pool. If specified, setup is performed on each Compute Node in the Pool to allow Tasks
        /// to run in containers. All regular Tasks and Job manager Tasks run on this Pool must specify the containerSettings property,
        /// and all other Tasks may specify it.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchContainerConfiguration ContainerConfiguration { get => (this._containerConfiguration = this._containerConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchContainerConfiguration()); set => this._containerConfiguration = value; }

        /// <summary>
        /// The collection of container Image names. This is the full Image reference, as would be specified to "docker pull". An
        /// Image will be sourced from the default Docker registry unless the Image is fully qualified with an alternative registry.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> ContainerConfigurationContainerImageName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchContainerConfigurationInternal)ContainerConfiguration).ContainerImageName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchContainerConfigurationInternal)ContainerConfiguration).ContainerImageName = value ?? null /* arrayOf */; }

        /// <summary>
        /// Additional private registries from which containers can be pulled. If any Images must be downloaded from a private registry
        /// which requires credentials, then those credentials must be provided here.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IContainerRegistryReference> ContainerConfigurationContainerRegistry { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchContainerConfigurationInternal)ContainerConfiguration).ContainerRegistry; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchContainerConfigurationInternal)ContainerConfiguration).ContainerRegistry = value ?? null /* arrayOf */; }

        /// <summary>The container technology to be used.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ContainerConfigurationType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchContainerConfigurationInternal)ContainerConfiguration).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchContainerConfigurationInternal)ContainerConfiguration).Type = value ?? null; }

        /// <summary>Backing field for <see cref="DataDisk" /> property.</summary>
        private System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IDataDisk> _dataDisk;

        /// <summary>
        /// The configuration for data disks attached to the Compute Nodes in the Pool. This property must be specified if the Compute
        /// Nodes in the Pool need to have empty data disks attached to them. This cannot be updated. Each Compute Node gets its own
        /// disk (the disk is not a file share). Existing disks cannot be attached, each attached disk is empty. When the Compute
        /// Node is removed from the Pool, the disk and all data associated with it is also deleted. The disk is not formatted after
        /// being attached, it must be formatted before use - for more information see https://learn.microsoft.com/azure/virtual-machines/linux/classic/attach-disk#initialize-a-new-data-disk-in-linux
        /// and https://learn.microsoft.com/azure/virtual-machines/windows/attach-disk-ps#add-an-empty-data-disk-to-a-virtual-machine.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IDataDisk> DataDisk { get => this._dataDisk; set => this._dataDisk = value; }

        /// <summary>Backing field for <see cref="DiskEncryptionConfiguration" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IDiskEncryptionConfiguration _diskEncryptionConfiguration;

        /// <summary>
        /// The disk encryption configuration for the pool. If specified, encryption is performed on each node in the pool during
        /// node provisioning.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IDiskEncryptionConfiguration DiskEncryptionConfiguration { get => (this._diskEncryptionConfiguration = this._diskEncryptionConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.DiskEncryptionConfiguration()); set => this._diskEncryptionConfiguration = value; }

        /// <summary>
        /// The list of disk targets Batch Service will encrypt on the compute node. The list of disk targets Batch Service will encrypt
        /// on the compute node.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> DiskEncryptionConfigurationTarget { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IDiskEncryptionConfigurationInternal)DiskEncryptionConfiguration).Target; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IDiskEncryptionConfigurationInternal)DiskEncryptionConfiguration).Target = value ?? null /* arrayOf */; }

        /// <summary>
        /// Specifies the ephemeral disk placement for operating system disk for all VMs in the pool. This property can be used by
        /// user in the request to choose the location e.g., cache disk space for Ephemeral OS disk provisioning. For more information
        /// on Ephemeral OS disk size requirements, please refer to Ephemeral OS disk size requirements for Windows VMs at https://learn.microsoft.com/azure/virtual-machines/windows/ephemeral-os-disks#size-requirements
        /// and Linux VMs at https://learn.microsoft.com/azure/virtual-machines/linux/ephemeral-os-disks#size-requirements.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string EphemeralOSDiskSettingPlacement { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).EphemeralOSDiskSettingPlacement; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).EphemeralOSDiskSettingPlacement = value ?? null; }

        /// <summary>Backing field for <see cref="Extension" /> property.</summary>
        private System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVMExtension> _extension;

        /// <summary>
        /// The virtual machine extension for the pool. If specified, the extensions mentioned in this configuration will be installed
        /// on each node.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVMExtension> Extension { get => this._extension; set => this._extension = value; }

        /// <summary>Backing field for <see cref="ImageReference" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReference _imageReference;

        /// <summary>
        /// A reference to the Azure Virtual Machines Marketplace Image or the custom Virtual Machine Image to use.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReference ImageReference { get => (this._imageReference = this._imageReference ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchVMImageReference()); set => this._imageReference = value; }

        /// <summary>
        /// The community gallery image unique identifier. This property is mutually exclusive with other properties and can be fetched
        /// from community gallery image GET call.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ImageReferenceCommunityGalleryImageId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReferenceInternal)ImageReference).CommunityGalleryImageId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReferenceInternal)ImageReference).CommunityGalleryImageId = value ?? null; }

        /// <summary>
        /// The specific version of the platform image or marketplace image used to create the node. This read-only field differs
        /// from 'version' only if the value specified for 'version' when the pool was created was 'latest'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ImageReferenceExactVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReferenceInternal)ImageReference).ExactVersion; }

        /// <summary>
        /// The offer type of the Azure Virtual Machines Marketplace Image. For example, UbuntuServer or WindowsServer.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ImageReferenceOffer { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReferenceInternal)ImageReference).Offer; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReferenceInternal)ImageReference).Offer = value ?? null; }

        /// <summary>
        /// The publisher of the Azure Virtual Machines Marketplace Image. For example, Canonical or MicrosoftWindowsServer.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ImageReferencePublisher { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReferenceInternal)ImageReference).Publisher; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReferenceInternal)ImageReference).Publisher = value ?? null; }

        /// <summary>
        /// The shared gallery image unique identifier. This property is mutually exclusive with other properties and can be fetched
        /// from shared gallery image GET call.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ImageReferenceSharedGalleryImageId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReferenceInternal)ImageReference).SharedGalleryImageId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReferenceInternal)ImageReference).SharedGalleryImageId = value ?? null; }

        /// <summary>
        /// The SKU of the Azure Virtual Machines Marketplace Image. For example, 18.04-LTS or 2019-Datacenter.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ImageReferenceSku { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReferenceInternal)ImageReference).Sku; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReferenceInternal)ImageReference).Sku = value ?? null; }

        /// <summary>
        /// The version of the Azure Virtual Machines Marketplace Image. A value of 'latest' can be specified to select the latest
        /// version of an Image. If omitted, the default is 'latest'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ImageReferenceVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReferenceInternal)ImageReference).Version; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReferenceInternal)ImageReference).Version = value ?? null; }

        /// <summary>
        /// The ARM resource identifier of the Azure Compute Gallery Image. Compute Nodes in the Pool will be created using this Image
        /// Id. This is of the form /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}/versions/{VersionId}
        /// or /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}
        /// for always defaulting to the latest image version. This property is mutually exclusive with other ImageReference properties.
        /// The Azure Compute Gallery Image must have replicas in the same region and must be in the same subscription as the Azure
        /// Batch account. If the image version is not specified in the imageId, the latest version will be used. For information
        /// about the firewall settings for the Batch Compute Node agent to communicate with the Batch service see https://learn.microsoft.com/azure/batch/nodes-and-pools#virtual-network-vnet-and-firewall-configuration.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ImageReferenceVirtualMachineImageId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReferenceInternal)ImageReference).VirtualMachineImageId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReferenceInternal)ImageReference).VirtualMachineImageId = value ?? null; }

        /// <summary>Backing field for <see cref="LicenseType" /> property.</summary>
        private string _licenseType;

        /// <summary>
        /// This only applies to Images that contain the Windows operating system, and
        /// should only be used when you hold valid on-premises licenses for the Compute
        /// Nodes which will be deployed. If omitted, no on-premises licensing discount is
        /// applied. Values are:
        /// Windows_Server - The on-premises license is for Windows
        /// Server.
        /// Windows_Client - The on-premises license is for Windows Client.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public string LicenseType { get => this._licenseType; set => this._licenseType = value; }

        /// <summary>The storage account type for managed disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ManagedDiskStorageAccountType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).ManagedDiskStorageAccountType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).ManagedDiskStorageAccountType = value ?? null; }

        /// <summary>Internal Acessors for ContainerConfiguration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchContainerConfiguration Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVirtualMachineConfigurationInternal.ContainerConfiguration { get => (this._containerConfiguration = this._containerConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchContainerConfiguration()); set { {_containerConfiguration = value;} } }

        /// <summary>Internal Acessors for DiskEncryptionConfiguration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IDiskEncryptionConfiguration Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVirtualMachineConfigurationInternal.DiskEncryptionConfiguration { get => (this._diskEncryptionConfiguration = this._diskEncryptionConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.DiskEncryptionConfiguration()); set { {_diskEncryptionConfiguration = value;} } }

        /// <summary>Internal Acessors for ImageReference</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReference Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVirtualMachineConfigurationInternal.ImageReference { get => (this._imageReference = this._imageReference ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchVMImageReference()); set { {_imageReference = value;} } }

        /// <summary>Internal Acessors for ImageReferenceExactVersion</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVirtualMachineConfigurationInternal.ImageReferenceExactVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReferenceInternal)ImageReference).ExactVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReferenceInternal)ImageReference).ExactVersion = value ?? null; }

        /// <summary>Internal Acessors for ManagedDiskSecurityProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMDiskSecurityProfile Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVirtualMachineConfigurationInternal.ManagedDiskSecurityProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).ManagedDiskSecurityProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).ManagedDiskSecurityProfile = value ?? null /* model class */; }

        /// <summary>Internal Acessors for NodePlacementConfiguration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodePlacementConfiguration Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVirtualMachineConfigurationInternal.NodePlacementConfiguration { get => (this._nodePlacementConfiguration = this._nodePlacementConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchNodePlacementConfiguration()); set { {_nodePlacementConfiguration = value;} } }

        /// <summary>Internal Acessors for OSDisk</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDisk Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVirtualMachineConfigurationInternal.OSDisk { get => (this._oSDisk = this._oSDisk ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchOSDisk()); set { {_oSDisk = value;} } }

        /// <summary>Internal Acessors for OSDiskEphemeralOsdiskSetting</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchDiffDiskSettings Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVirtualMachineConfigurationInternal.OSDiskEphemeralOsdiskSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).EphemeralOSDiskSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).EphemeralOSDiskSetting = value ?? null /* model class */; }

        /// <summary>Internal Acessors for OSDiskManagedDisk</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IManagedDisk Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVirtualMachineConfigurationInternal.OSDiskManagedDisk { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).ManagedDisk; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).ManagedDisk = value ?? null /* model class */; }

        /// <summary>Internal Acessors for SecurityProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ISecurityProfile Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVirtualMachineConfigurationInternal.SecurityProfile { get => (this._securityProfile = this._securityProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.SecurityProfile()); set { {_securityProfile = value;} } }

        /// <summary>Internal Acessors for SecurityProfileUefiSetting</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchUefiSettings Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVirtualMachineConfigurationInternal.SecurityProfileUefiSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ISecurityProfileInternal)SecurityProfile).UefiSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ISecurityProfileInternal)SecurityProfile).UefiSetting = value ?? null /* model class */; }

        /// <summary>Internal Acessors for ServiceArtifactReference</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IServiceArtifactReference Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVirtualMachineConfigurationInternal.ServiceArtifactReference { get => (this._serviceArtifactReference = this._serviceArtifactReference ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ServiceArtifactReference()); set { {_serviceArtifactReference = value;} } }

        /// <summary>Internal Acessors for WindowsConfiguration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IWindowsConfiguration Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVirtualMachineConfigurationInternal.WindowsConfiguration { get => (this._windowsConfiguration = this._windowsConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.WindowsConfiguration()); set { {_windowsConfiguration = value;} } }

        /// <summary>Backing field for <see cref="NodeAgentSkuId" /> property.</summary>
        private string _nodeAgentSkuId;

        /// <summary>
        /// The SKU of the Batch Compute Node agent to be provisioned on Compute Nodes in the Pool. The Batch Compute Node agent is
        /// a program that runs on each Compute Node in the Pool, and provides the command-and-control interface between the Compute
        /// Node and the Batch service. There are different implementations of the Compute Node agent, known as SKUs, for different
        /// operating systems. You must specify a Compute Node agent SKU which matches the selected Image reference. To get the list
        /// of supported Compute Node agent SKUs along with their list of verified Image references, see the 'List supported Compute
        /// Node agent SKUs' operation.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public string NodeAgentSkuId { get => this._nodeAgentSkuId; set => this._nodeAgentSkuId = value; }

        /// <summary>Backing field for <see cref="NodePlacementConfiguration" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodePlacementConfiguration _nodePlacementConfiguration;

        /// <summary>
        /// The node placement configuration for the pool. This configuration will specify rules on how nodes in the pool will be
        /// physically allocated.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodePlacementConfiguration NodePlacementConfiguration { get => (this._nodePlacementConfiguration = this._nodePlacementConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchNodePlacementConfiguration()); set => this._nodePlacementConfiguration = value; }

        /// <summary>
        /// Node placement Policy type on Batch Pools. Allocation policy used by Batch Service to provision the nodes. If not specified,
        /// Batch will use the regional policy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string NodePlacementConfigurationPolicy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodePlacementConfigurationInternal)NodePlacementConfiguration).Policy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodePlacementConfigurationInternal)NodePlacementConfiguration).Policy = value ?? null; }

        /// <summary>Backing field for <see cref="OSDisk" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDisk _oSDisk;

        /// <summary>Settings for the operating system disk of the Virtual Machine.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDisk OSDisk { get => (this._oSDisk = this._oSDisk ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchOSDisk()); set => this._oSDisk = value; }

        /// <summary>
        /// Specifies the caching requirements. Possible values are: None, ReadOnly, ReadWrite. The default values are: None for Standard
        /// storage. ReadOnly for Premium storage.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string OSDiskCaching { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).Caching; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).Caching = value ?? null; }

        /// <summary>The initial disk size in GB when creating new OS disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public int? OSDiskSizeGb { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).DiskSizeGb; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).DiskSizeGb = value ?? default(int); }

        /// <summary>Specifies whether writeAccelerator should be enabled or disabled on the disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public bool? OSDiskWriteAcceleratorEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).WriteAcceleratorEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).WriteAcceleratorEnabled = value ?? default(bool); }

        /// <summary>Backing field for <see cref="SecurityProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ISecurityProfile _securityProfile;

        /// <summary>
        /// Specifies the security profile settings for the virtual machine or virtual machine scale set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ISecurityProfile SecurityProfile { get => (this._securityProfile = this._securityProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.SecurityProfile()); set => this._securityProfile = value; }

        /// <summary>
        /// This property can be used by user in the request to enable or disable the Host Encryption for the virtual machine or virtual
        /// machine scale set. This will enable the encryption for all the disks including Resource/Temp disk at host itself. For
        /// more information on encryption at host requirements, please refer to https://learn.microsoft.com/azure/virtual-machines/disk-encryption#supported-vm-sizes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public bool? SecurityProfileEncryptionAtHost { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ISecurityProfileInternal)SecurityProfile).EncryptionAtHost; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ISecurityProfileInternal)SecurityProfile).EncryptionAtHost = value ?? default(bool); }

        /// <summary>
        /// Specifies the EncryptionType of the managed disk. It is set to VMGuestStateOnly for encryption of just the VMGuestState
        /// blob, and NonPersistedTPM for not persisting firmware state in the VMGuestState blob. **Note**: It can be set for only
        /// Confidential VMs and is required when using Confidential VMs.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string SecurityProfileSecurityEncryptionType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).SecurityProfileSecurityEncryptionType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDiskInternal)OSDisk).SecurityProfileSecurityEncryptionType = value ?? null; }

        /// <summary>
        /// Specifies the SecurityType of the virtual machine. It has to be set to any specified value to enable UefiSettings.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string SecurityProfileSecurityType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ISecurityProfileInternal)SecurityProfile).SecurityType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ISecurityProfileInternal)SecurityProfile).SecurityType = value ?? null; }

        /// <summary>Backing field for <see cref="ServiceArtifactReference" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IServiceArtifactReference _serviceArtifactReference;

        /// <summary>
        /// Specifies the service artifact reference id used to set same image version for all virtual machines in the scale set when
        /// using 'latest' image version. The service artifact reference id in the form of /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/serviceArtifacts/{serviceArtifactName}/vmArtifactsProfiles/{vmArtifactsProfilesName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IServiceArtifactReference ServiceArtifactReference { get => (this._serviceArtifactReference = this._serviceArtifactReference ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ServiceArtifactReference()); set => this._serviceArtifactReference = value; }

        /// <summary>
        /// The service artifact reference id of ServiceArtifactReference. The service artifact reference id in the form of /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/serviceArtifacts/{serviceArtifactName}/vmArtifactsProfiles/{vmArtifactsProfilesName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ServiceArtifactReferenceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IServiceArtifactReferenceInternal)ServiceArtifactReference).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IServiceArtifactReferenceInternal)ServiceArtifactReference).Id = value ?? null; }

        /// <summary>Specifies whether secure boot should be enabled on the virtual machine.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public bool? UefiSettingSecureBootEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ISecurityProfileInternal)SecurityProfile).UefiSettingSecureBootEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ISecurityProfileInternal)SecurityProfile).UefiSettingSecureBootEnabled = value ?? default(bool); }

        /// <summary>Specifies whether vTPM should be enabled on the virtual machine.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public bool? UefiSettingVTpmEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ISecurityProfileInternal)SecurityProfile).UefiSettingVTpmEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ISecurityProfileInternal)SecurityProfile).UefiSettingVTpmEnabled = value ?? default(bool); }

        /// <summary>
        /// Whether automatic updates are enabled on the virtual machine. If omitted, the default value is true.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public bool? WindowConfigurationEnableAutomaticUpdate { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IWindowsConfigurationInternal)WindowsConfiguration).EnableAutomaticUpdate; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IWindowsConfigurationInternal)WindowsConfiguration).EnableAutomaticUpdate = value ?? default(bool); }

        /// <summary>Backing field for <see cref="WindowsConfiguration" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IWindowsConfiguration _windowsConfiguration;

        /// <summary>
        /// Windows operating system settings on the virtual machine. This property must not be specified if the imageReference property
        /// specifies a Linux OS Image.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IWindowsConfiguration WindowsConfiguration { get => (this._windowsConfiguration = this._windowsConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.WindowsConfiguration()); set => this._windowsConfiguration = value; }

        /// <summary>Creates an new <see cref="VirtualMachineConfiguration" /> instance.</summary>
        public VirtualMachineConfiguration()
        {

        }
    }
    /// The configuration for Compute Nodes in a Pool based on the Azure Virtual
    /// Machines infrastructure.
    public partial interface IVirtualMachineConfiguration :
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IJsonSerializable
    {
        /// <summary>
        /// The collection of container Image names. This is the full Image reference, as would be specified to "docker pull". An
        /// Image will be sourced from the default Docker registry unless the Image is fully qualified with an alternative registry.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The collection of container Image names. This is the full Image reference, as would be specified to ""docker pull"". An Image will be sourced from the default Docker registry unless the Image is fully qualified with an alternative registry.",
        SerializedName = @"containerImageNames",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> ContainerConfigurationContainerImageName { get; set; }
        /// <summary>
        /// Additional private registries from which containers can be pulled. If any Images must be downloaded from a private registry
        /// which requires credentials, then those credentials must be provided here.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Additional private registries from which containers can be pulled. If any Images must be downloaded from a private registry which requires credentials, then those credentials must be provided here.",
        SerializedName = @"containerRegistries",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IContainerRegistryReference) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IContainerRegistryReference> ContainerConfigurationContainerRegistry { get; set; }
        /// <summary>The container technology to be used.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The container technology to be used.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("dockerCompatible", "criCompatible")]
        string ContainerConfigurationType { get; set; }
        /// <summary>
        /// The configuration for data disks attached to the Compute Nodes in the Pool. This property must be specified if the Compute
        /// Nodes in the Pool need to have empty data disks attached to them. This cannot be updated. Each Compute Node gets its own
        /// disk (the disk is not a file share). Existing disks cannot be attached, each attached disk is empty. When the Compute
        /// Node is removed from the Pool, the disk and all data associated with it is also deleted. The disk is not formatted after
        /// being attached, it must be formatted before use - for more information see https://learn.microsoft.com/azure/virtual-machines/linux/classic/attach-disk#initialize-a-new-data-disk-in-linux
        /// and https://learn.microsoft.com/azure/virtual-machines/windows/attach-disk-ps#add-an-empty-data-disk-to-a-virtual-machine.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The configuration for data disks attached to the Compute Nodes in the Pool. This property must be specified if the Compute Nodes in the Pool need to have empty data disks attached to them. This cannot be updated. Each Compute Node gets its own disk (the disk is not a file share). Existing disks cannot be attached, each attached disk is empty. When the Compute Node is removed from the Pool, the disk and all data associated with it is also deleted. The disk is not formatted after being attached, it must be formatted before use - for more information see https://learn.microsoft.com/azure/virtual-machines/linux/classic/attach-disk#initialize-a-new-data-disk-in-linux and https://learn.microsoft.com/azure/virtual-machines/windows/attach-disk-ps#add-an-empty-data-disk-to-a-virtual-machine.",
        SerializedName = @"dataDisks",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IDataDisk) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IDataDisk> DataDisk { get; set; }
        /// <summary>
        /// The list of disk targets Batch Service will encrypt on the compute node. The list of disk targets Batch Service will encrypt
        /// on the compute node.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The list of disk targets Batch Service will encrypt on the compute node. The list of disk targets Batch Service will encrypt on the compute node.",
        SerializedName = @"targets",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("osdisk", "temporarydisk")]
        System.Collections.Generic.List<string> DiskEncryptionConfigurationTarget { get; set; }
        /// <summary>
        /// Specifies the ephemeral disk placement for operating system disk for all VMs in the pool. This property can be used by
        /// user in the request to choose the location e.g., cache disk space for Ephemeral OS disk provisioning. For more information
        /// on Ephemeral OS disk size requirements, please refer to Ephemeral OS disk size requirements for Windows VMs at https://learn.microsoft.com/azure/virtual-machines/windows/ephemeral-os-disks#size-requirements
        /// and Linux VMs at https://learn.microsoft.com/azure/virtual-machines/linux/ephemeral-os-disks#size-requirements.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the ephemeral disk placement for operating system disk for all VMs in the pool. This property can be used by user in the request to choose the location e.g., cache disk space for Ephemeral OS disk provisioning. For more information on Ephemeral OS disk size requirements, please refer to Ephemeral OS disk size requirements for Windows VMs at https://learn.microsoft.com/azure/virtual-machines/windows/ephemeral-os-disks#size-requirements and Linux VMs at https://learn.microsoft.com/azure/virtual-machines/linux/ephemeral-os-disks#size-requirements.",
        SerializedName = @"placement",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("cachedisk")]
        string EphemeralOSDiskSettingPlacement { get; set; }
        /// <summary>
        /// The virtual machine extension for the pool. If specified, the extensions mentioned in this configuration will be installed
        /// on each node.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The virtual machine extension for the pool. If specified, the extensions mentioned in this configuration will be installed on each node.",
        SerializedName = @"extensions",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVMExtension) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVMExtension> Extension { get; set; }
        /// <summary>
        /// The community gallery image unique identifier. This property is mutually exclusive with other properties and can be fetched
        /// from community gallery image GET call.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The community gallery image unique identifier. This property is mutually exclusive with other properties and can be fetched from community gallery image GET call.",
        SerializedName = @"communityGalleryImageId",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceCommunityGalleryImageId { get; set; }
        /// <summary>
        /// The specific version of the platform image or marketplace image used to create the node. This read-only field differs
        /// from 'version' only if the value specified for 'version' when the pool was created was 'latest'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The specific version of the platform image or marketplace image used to create the node. This read-only field differs from 'version' only if the value specified for 'version' when the pool was created was 'latest'.",
        SerializedName = @"exactVersion",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceExactVersion { get;  }
        /// <summary>
        /// The offer type of the Azure Virtual Machines Marketplace Image. For example, UbuntuServer or WindowsServer.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The offer type of the Azure Virtual Machines Marketplace Image. For example, UbuntuServer or WindowsServer.",
        SerializedName = @"offer",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceOffer { get; set; }
        /// <summary>
        /// The publisher of the Azure Virtual Machines Marketplace Image. For example, Canonical or MicrosoftWindowsServer.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The publisher of the Azure Virtual Machines Marketplace Image. For example, Canonical or MicrosoftWindowsServer.",
        SerializedName = @"publisher",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferencePublisher { get; set; }
        /// <summary>
        /// The shared gallery image unique identifier. This property is mutually exclusive with other properties and can be fetched
        /// from shared gallery image GET call.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The shared gallery image unique identifier. This property is mutually exclusive with other properties and can be fetched from shared gallery image GET call.",
        SerializedName = @"sharedGalleryImageId",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceSharedGalleryImageId { get; set; }
        /// <summary>
        /// The SKU of the Azure Virtual Machines Marketplace Image. For example, 18.04-LTS or 2019-Datacenter.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The SKU of the Azure Virtual Machines Marketplace Image. For example, 18.04-LTS or 2019-Datacenter.",
        SerializedName = @"sku",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceSku { get; set; }
        /// <summary>
        /// The version of the Azure Virtual Machines Marketplace Image. A value of 'latest' can be specified to select the latest
        /// version of an Image. If omitted, the default is 'latest'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The version of the Azure Virtual Machines Marketplace Image. A value of 'latest' can be specified to select the latest version of an Image. If omitted, the default is 'latest'.",
        SerializedName = @"version",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceVersion { get; set; }
        /// <summary>
        /// The ARM resource identifier of the Azure Compute Gallery Image. Compute Nodes in the Pool will be created using this Image
        /// Id. This is of the form /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}/versions/{VersionId}
        /// or /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}
        /// for always defaulting to the latest image version. This property is mutually exclusive with other ImageReference properties.
        /// The Azure Compute Gallery Image must have replicas in the same region and must be in the same subscription as the Azure
        /// Batch account. If the image version is not specified in the imageId, the latest version will be used. For information
        /// about the firewall settings for the Batch Compute Node agent to communicate with the Batch service see https://learn.microsoft.com/azure/batch/nodes-and-pools#virtual-network-vnet-and-firewall-configuration.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The ARM resource identifier of the Azure Compute Gallery Image. Compute Nodes in the Pool will be created using this Image Id. This is of the form /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}/versions/{VersionId} or /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName} for always defaulting to the latest image version. This property is mutually exclusive with other ImageReference properties. The Azure Compute Gallery Image must have replicas in the same region and must be in the same subscription as the Azure Batch account. If the image version is not specified in the imageId, the latest version will be used. For information about the firewall settings for the Batch Compute Node agent to communicate with the Batch service see https://learn.microsoft.com/azure/batch/nodes-and-pools#virtual-network-vnet-and-firewall-configuration.",
        SerializedName = @"virtualMachineImageId",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceVirtualMachineImageId { get; set; }
        /// <summary>
        /// This only applies to Images that contain the Windows operating system, and
        /// should only be used when you hold valid on-premises licenses for the Compute
        /// Nodes which will be deployed. If omitted, no on-premises licensing discount is
        /// applied. Values are:
        /// Windows_Server - The on-premises license is for Windows
        /// Server.
        /// Windows_Client - The on-premises license is for Windows Client.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This only applies to Images that contain the Windows operating system, and
        should only be used when you hold valid on-premises licenses for the Compute
        Nodes which will be deployed. If omitted, no on-premises licensing discount is
        applied. Values are:

         Windows_Server - The on-premises license is for Windows
        Server.
         Windows_Client - The on-premises license is for Windows Client.
        ",
        SerializedName = @"licenseType",
        PossibleTypes = new [] { typeof(string) })]
        string LicenseType { get; set; }
        /// <summary>The storage account type for managed disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The storage account type for managed disk.",
        SerializedName = @"storageAccountType",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("standard_lrs", "premium_lrs", "standardssd_lrs")]
        string ManagedDiskStorageAccountType { get; set; }
        /// <summary>
        /// The SKU of the Batch Compute Node agent to be provisioned on Compute Nodes in the Pool. The Batch Compute Node agent is
        /// a program that runs on each Compute Node in the Pool, and provides the command-and-control interface between the Compute
        /// Node and the Batch service. There are different implementations of the Compute Node agent, known as SKUs, for different
        /// operating systems. You must specify a Compute Node agent SKU which matches the selected Image reference. To get the list
        /// of supported Compute Node agent SKUs along with their list of verified Image references, see the 'List supported Compute
        /// Node agent SKUs' operation.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The SKU of the Batch Compute Node agent to be provisioned on Compute Nodes in the Pool. The Batch Compute Node agent is a program that runs on each Compute Node in the Pool, and provides the command-and-control interface between the Compute Node and the Batch service. There are different implementations of the Compute Node agent, known as SKUs, for different operating systems. You must specify a Compute Node agent SKU which matches the selected Image reference. To get the list of supported Compute Node agent SKUs along with their list of verified Image references, see the 'List supported Compute Node agent SKUs' operation.",
        SerializedName = @"nodeAgentSKUId",
        PossibleTypes = new [] { typeof(string) })]
        string NodeAgentSkuId { get; set; }
        /// <summary>
        /// Node placement Policy type on Batch Pools. Allocation policy used by Batch Service to provision the nodes. If not specified,
        /// Batch will use the regional policy.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Node placement Policy type on Batch Pools. Allocation policy used by Batch Service to provision the nodes. If not specified, Batch will use the regional policy.",
        SerializedName = @"policy",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("regional", "zonal")]
        string NodePlacementConfigurationPolicy { get; set; }
        /// <summary>
        /// Specifies the caching requirements. Possible values are: None, ReadOnly, ReadWrite. The default values are: None for Standard
        /// storage. ReadOnly for Premium storage.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the caching requirements. Possible values are: None, ReadOnly, ReadWrite. The default values are: None for Standard storage. ReadOnly for Premium storage.",
        SerializedName = @"caching",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("none", "readonly", "readwrite")]
        string OSDiskCaching { get; set; }
        /// <summary>The initial disk size in GB when creating new OS disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The initial disk size in GB when creating new OS disk.",
        SerializedName = @"diskSizeGB",
        PossibleTypes = new [] { typeof(int) })]
        int? OSDiskSizeGb { get; set; }
        /// <summary>Specifies whether writeAccelerator should be enabled or disabled on the disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies whether writeAccelerator should be enabled or disabled on the disk.",
        SerializedName = @"writeAcceleratorEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? OSDiskWriteAcceleratorEnabled { get; set; }
        /// <summary>
        /// This property can be used by user in the request to enable or disable the Host Encryption for the virtual machine or virtual
        /// machine scale set. This will enable the encryption for all the disks including Resource/Temp disk at host itself. For
        /// more information on encryption at host requirements, please refer to https://learn.microsoft.com/azure/virtual-machines/disk-encryption#supported-vm-sizes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This property can be used by user in the request to enable or disable the Host Encryption for the virtual machine or virtual machine scale set. This will enable the encryption for all the disks including Resource/Temp disk at host itself. For more information on encryption at host requirements, please refer to https://learn.microsoft.com/azure/virtual-machines/disk-encryption#supported-vm-sizes.",
        SerializedName = @"encryptionAtHost",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SecurityProfileEncryptionAtHost { get; set; }
        /// <summary>
        /// Specifies the EncryptionType of the managed disk. It is set to VMGuestStateOnly for encryption of just the VMGuestState
        /// blob, and NonPersistedTPM for not persisting firmware state in the VMGuestState blob. **Note**: It can be set for only
        /// Confidential VMs and is required when using Confidential VMs.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the EncryptionType of the managed disk. It is set to VMGuestStateOnly for encryption of just the VMGuestState blob, and NonPersistedTPM for not persisting firmware state in the VMGuestState blob. **Note**: It can be set for only Confidential VMs and is required when using Confidential VMs.",
        SerializedName = @"securityEncryptionType",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("NonPersistedTPM", "VMGuestStateOnly")]
        string SecurityProfileSecurityEncryptionType { get; set; }
        /// <summary>
        /// Specifies the SecurityType of the virtual machine. It has to be set to any specified value to enable UefiSettings.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the SecurityType of the virtual machine. It has to be set to any specified value to enable UefiSettings.",
        SerializedName = @"securityType",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("trustedLaunch", "confidentialVM")]
        string SecurityProfileSecurityType { get; set; }
        /// <summary>
        /// The service artifact reference id of ServiceArtifactReference. The service artifact reference id in the form of /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/serviceArtifacts/{serviceArtifactName}/vmArtifactsProfiles/{vmArtifactsProfilesName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The service artifact reference id of ServiceArtifactReference. The service artifact reference id in the form of /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/serviceArtifacts/{serviceArtifactName}/vmArtifactsProfiles/{vmArtifactsProfilesName}",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(string) })]
        string ServiceArtifactReferenceId { get; set; }
        /// <summary>Specifies whether secure boot should be enabled on the virtual machine.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies whether secure boot should be enabled on the virtual machine.",
        SerializedName = @"secureBootEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? UefiSettingSecureBootEnabled { get; set; }
        /// <summary>Specifies whether vTPM should be enabled on the virtual machine.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies whether vTPM should be enabled on the virtual machine.",
        SerializedName = @"vTpmEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? UefiSettingVTpmEnabled { get; set; }
        /// <summary>
        /// Whether automatic updates are enabled on the virtual machine. If omitted, the default value is true.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Whether automatic updates are enabled on the virtual machine. If omitted, the default value is true.",
        SerializedName = @"enableAutomaticUpdates",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WindowConfigurationEnableAutomaticUpdate { get; set; }

    }
    /// The configuration for Compute Nodes in a Pool based on the Azure Virtual
    /// Machines infrastructure.
    internal partial interface IVirtualMachineConfigurationInternal

    {
        /// <summary>
        /// The container configuration for the Pool. If specified, setup is performed on each Compute Node in the Pool to allow Tasks
        /// to run in containers. All regular Tasks and Job manager Tasks run on this Pool must specify the containerSettings property,
        /// and all other Tasks may specify it.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchContainerConfiguration ContainerConfiguration { get; set; }
        /// <summary>
        /// The collection of container Image names. This is the full Image reference, as would be specified to "docker pull". An
        /// Image will be sourced from the default Docker registry unless the Image is fully qualified with an alternative registry.
        /// </summary>
        System.Collections.Generic.List<string> ContainerConfigurationContainerImageName { get; set; }
        /// <summary>
        /// Additional private registries from which containers can be pulled. If any Images must be downloaded from a private registry
        /// which requires credentials, then those credentials must be provided here.
        /// </summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IContainerRegistryReference> ContainerConfigurationContainerRegistry { get; set; }
        /// <summary>The container technology to be used.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("dockerCompatible", "criCompatible")]
        string ContainerConfigurationType { get; set; }
        /// <summary>
        /// The configuration for data disks attached to the Compute Nodes in the Pool. This property must be specified if the Compute
        /// Nodes in the Pool need to have empty data disks attached to them. This cannot be updated. Each Compute Node gets its own
        /// disk (the disk is not a file share). Existing disks cannot be attached, each attached disk is empty. When the Compute
        /// Node is removed from the Pool, the disk and all data associated with it is also deleted. The disk is not formatted after
        /// being attached, it must be formatted before use - for more information see https://learn.microsoft.com/azure/virtual-machines/linux/classic/attach-disk#initialize-a-new-data-disk-in-linux
        /// and https://learn.microsoft.com/azure/virtual-machines/windows/attach-disk-ps#add-an-empty-data-disk-to-a-virtual-machine.
        /// </summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IDataDisk> DataDisk { get; set; }
        /// <summary>
        /// The disk encryption configuration for the pool. If specified, encryption is performed on each node in the pool during
        /// node provisioning.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IDiskEncryptionConfiguration DiskEncryptionConfiguration { get; set; }
        /// <summary>
        /// The list of disk targets Batch Service will encrypt on the compute node. The list of disk targets Batch Service will encrypt
        /// on the compute node.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("osdisk", "temporarydisk")]
        System.Collections.Generic.List<string> DiskEncryptionConfigurationTarget { get; set; }
        /// <summary>
        /// Specifies the ephemeral disk placement for operating system disk for all VMs in the pool. This property can be used by
        /// user in the request to choose the location e.g., cache disk space for Ephemeral OS disk provisioning. For more information
        /// on Ephemeral OS disk size requirements, please refer to Ephemeral OS disk size requirements for Windows VMs at https://learn.microsoft.com/azure/virtual-machines/windows/ephemeral-os-disks#size-requirements
        /// and Linux VMs at https://learn.microsoft.com/azure/virtual-machines/linux/ephemeral-os-disks#size-requirements.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("cachedisk")]
        string EphemeralOSDiskSettingPlacement { get; set; }
        /// <summary>
        /// The virtual machine extension for the pool. If specified, the extensions mentioned in this configuration will be installed
        /// on each node.
        /// </summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IVMExtension> Extension { get; set; }
        /// <summary>
        /// A reference to the Azure Virtual Machines Marketplace Image or the custom Virtual Machine Image to use.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMImageReference ImageReference { get; set; }
        /// <summary>
        /// The community gallery image unique identifier. This property is mutually exclusive with other properties and can be fetched
        /// from community gallery image GET call.
        /// </summary>
        string ImageReferenceCommunityGalleryImageId { get; set; }
        /// <summary>
        /// The specific version of the platform image or marketplace image used to create the node. This read-only field differs
        /// from 'version' only if the value specified for 'version' when the pool was created was 'latest'.
        /// </summary>
        string ImageReferenceExactVersion { get; set; }
        /// <summary>
        /// The offer type of the Azure Virtual Machines Marketplace Image. For example, UbuntuServer or WindowsServer.
        /// </summary>
        string ImageReferenceOffer { get; set; }
        /// <summary>
        /// The publisher of the Azure Virtual Machines Marketplace Image. For example, Canonical or MicrosoftWindowsServer.
        /// </summary>
        string ImageReferencePublisher { get; set; }
        /// <summary>
        /// The shared gallery image unique identifier. This property is mutually exclusive with other properties and can be fetched
        /// from shared gallery image GET call.
        /// </summary>
        string ImageReferenceSharedGalleryImageId { get; set; }
        /// <summary>
        /// The SKU of the Azure Virtual Machines Marketplace Image. For example, 18.04-LTS or 2019-Datacenter.
        /// </summary>
        string ImageReferenceSku { get; set; }
        /// <summary>
        /// The version of the Azure Virtual Machines Marketplace Image. A value of 'latest' can be specified to select the latest
        /// version of an Image. If omitted, the default is 'latest'.
        /// </summary>
        string ImageReferenceVersion { get; set; }
        /// <summary>
        /// The ARM resource identifier of the Azure Compute Gallery Image. Compute Nodes in the Pool will be created using this Image
        /// Id. This is of the form /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}/versions/{VersionId}
        /// or /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageDefinitionName}
        /// for always defaulting to the latest image version. This property is mutually exclusive with other ImageReference properties.
        /// The Azure Compute Gallery Image must have replicas in the same region and must be in the same subscription as the Azure
        /// Batch account. If the image version is not specified in the imageId, the latest version will be used. For information
        /// about the firewall settings for the Batch Compute Node agent to communicate with the Batch service see https://learn.microsoft.com/azure/batch/nodes-and-pools#virtual-network-vnet-and-firewall-configuration.
        /// </summary>
        string ImageReferenceVirtualMachineImageId { get; set; }
        /// <summary>
        /// This only applies to Images that contain the Windows operating system, and
        /// should only be used when you hold valid on-premises licenses for the Compute
        /// Nodes which will be deployed. If omitted, no on-premises licensing discount is
        /// applied. Values are:
        /// Windows_Server - The on-premises license is for Windows
        /// Server.
        /// Windows_Client - The on-premises license is for Windows Client.
        /// </summary>
        string LicenseType { get; set; }
        /// <summary>Specifies the security profile settings for the managed disk.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchVMDiskSecurityProfile ManagedDiskSecurityProfile { get; set; }
        /// <summary>The storage account type for managed disk.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("standard_lrs", "premium_lrs", "standardssd_lrs")]
        string ManagedDiskStorageAccountType { get; set; }
        /// <summary>
        /// The SKU of the Batch Compute Node agent to be provisioned on Compute Nodes in the Pool. The Batch Compute Node agent is
        /// a program that runs on each Compute Node in the Pool, and provides the command-and-control interface between the Compute
        /// Node and the Batch service. There are different implementations of the Compute Node agent, known as SKUs, for different
        /// operating systems. You must specify a Compute Node agent SKU which matches the selected Image reference. To get the list
        /// of supported Compute Node agent SKUs along with their list of verified Image references, see the 'List supported Compute
        /// Node agent SKUs' operation.
        /// </summary>
        string NodeAgentSkuId { get; set; }
        /// <summary>
        /// The node placement configuration for the pool. This configuration will specify rules on how nodes in the pool will be
        /// physically allocated.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchNodePlacementConfiguration NodePlacementConfiguration { get; set; }
        /// <summary>
        /// Node placement Policy type on Batch Pools. Allocation policy used by Batch Service to provision the nodes. If not specified,
        /// Batch will use the regional policy.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("regional", "zonal")]
        string NodePlacementConfigurationPolicy { get; set; }
        /// <summary>Settings for the operating system disk of the Virtual Machine.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchOSDisk OSDisk { get; set; }
        /// <summary>
        /// Specifies the caching requirements. Possible values are: None, ReadOnly, ReadWrite. The default values are: None for Standard
        /// storage. ReadOnly for Premium storage.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("none", "readonly", "readwrite")]
        string OSDiskCaching { get; set; }
        /// <summary>
        /// Specifies the ephemeral Disk Settings for the operating system disk used by the compute node (VM).
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchDiffDiskSettings OSDiskEphemeralOsdiskSetting { get; set; }
        /// <summary>The managed disk parameters.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IManagedDisk OSDiskManagedDisk { get; set; }
        /// <summary>The initial disk size in GB when creating new OS disk.</summary>
        int? OSDiskSizeGb { get; set; }
        /// <summary>Specifies whether writeAccelerator should be enabled or disabled on the disk.</summary>
        bool? OSDiskWriteAcceleratorEnabled { get; set; }
        /// <summary>
        /// Specifies the security profile settings for the virtual machine or virtual machine scale set.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.ISecurityProfile SecurityProfile { get; set; }
        /// <summary>
        /// This property can be used by user in the request to enable or disable the Host Encryption for the virtual machine or virtual
        /// machine scale set. This will enable the encryption for all the disks including Resource/Temp disk at host itself. For
        /// more information on encryption at host requirements, please refer to https://learn.microsoft.com/azure/virtual-machines/disk-encryption#supported-vm-sizes.
        /// </summary>
        bool? SecurityProfileEncryptionAtHost { get; set; }
        /// <summary>
        /// Specifies the EncryptionType of the managed disk. It is set to VMGuestStateOnly for encryption of just the VMGuestState
        /// blob, and NonPersistedTPM for not persisting firmware state in the VMGuestState blob. **Note**: It can be set for only
        /// Confidential VMs and is required when using Confidential VMs.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("NonPersistedTPM", "VMGuestStateOnly")]
        string SecurityProfileSecurityEncryptionType { get; set; }
        /// <summary>
        /// Specifies the SecurityType of the virtual machine. It has to be set to any specified value to enable UefiSettings.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("trustedLaunch", "confidentialVM")]
        string SecurityProfileSecurityType { get; set; }
        /// <summary>
        /// Specifies the security settings like secure boot and vTPM used while creating the virtual machine. Specifies the security
        /// settings like secure boot and vTPM used while creating the virtual machine.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchUefiSettings SecurityProfileUefiSetting { get; set; }
        /// <summary>
        /// Specifies the service artifact reference id used to set same image version for all virtual machines in the scale set when
        /// using 'latest' image version. The service artifact reference id in the form of /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/serviceArtifacts/{serviceArtifactName}/vmArtifactsProfiles/{vmArtifactsProfilesName}
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IServiceArtifactReference ServiceArtifactReference { get; set; }
        /// <summary>
        /// The service artifact reference id of ServiceArtifactReference. The service artifact reference id in the form of /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/serviceArtifacts/{serviceArtifactName}/vmArtifactsProfiles/{vmArtifactsProfilesName}
        /// </summary>
        string ServiceArtifactReferenceId { get; set; }
        /// <summary>Specifies whether secure boot should be enabled on the virtual machine.</summary>
        bool? UefiSettingSecureBootEnabled { get; set; }
        /// <summary>Specifies whether vTPM should be enabled on the virtual machine.</summary>
        bool? UefiSettingVTpmEnabled { get; set; }
        /// <summary>
        /// Whether automatic updates are enabled on the virtual machine. If omitted, the default value is true.
        /// </summary>
        bool? WindowConfigurationEnableAutomaticUpdate { get; set; }
        /// <summary>
        /// Windows operating system settings on the virtual machine. This property must not be specified if the imageReference property
        /// specifies a Linux OS Image.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IWindowsConfiguration WindowsConfiguration { get; set; }

    }
}