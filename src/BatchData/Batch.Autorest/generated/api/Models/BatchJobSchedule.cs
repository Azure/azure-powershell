// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Batch.Models
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Extensions;

    /// <summary>
    /// A Job Schedule that allows recurring Jobs by specifying when to run Jobs and a
    /// specification used to create each Job.
    /// </summary>
    public partial class BatchJobSchedule :
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSchedule,
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal,
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IHeaderSerializable
    {

        /// <summary>Backing field for <see cref="ClientRequestId" /> property.</summary>
        private string _clientRequestId;

        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public string ClientRequestId { get => this._clientRequestId; set => this._clientRequestId = value; }

        /// <summary>Backing field for <see cref="CreationTime" /> property.</summary>
        private global::System.DateTime? _creationTime;

        /// <summary>The creation time of the Job Schedule.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public global::System.DateTime? CreationTime { get => this._creationTime; }

        /// <summary>Backing field for <see cref="DisplayName" /> property.</summary>
        private string _displayName;

        /// <summary>The display name for the schedule.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public string DisplayName { get => this._displayName; }

        /// <summary>Backing field for <see cref="ETag" /> property.</summary>
        private string _eTag;

        /// <summary>
        /// The ETag of the Job Schedule. This is an opaque string. You can use it to detect whether the Job Schedule has changed
        /// between requests. In particular, you can be pass the ETag with an Update Job Schedule request to specify that your changes
        /// should take effect only if nobody else has modified the schedule in the meantime.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public string ETag { get => this._eTag; }

        /// <summary>Backing field for <see cref="ETag1" /> property.</summary>
        private string _eTag1;

        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public string ETag1 { get => this._eTag1; set => this._eTag1 = value; }

        /// <summary>Backing field for <see cref="ExecutionInfo" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfo _executionInfo;

        /// <summary>Information about Jobs that have been and will be run under this schedule.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfo ExecutionInfo { get => (this._executionInfo = this._executionInfo ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobScheduleExecutionInfo()); }

        /// <summary>
        /// The time at which the schedule ended. This property is set only if the Job Schedule is in the completed state.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public global::System.DateTime? ExecutionInfoEndTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfoInternal)ExecutionInfo).EndTime; }

        /// <summary>
        /// The next time at which a Job will be created under this schedule. This property is meaningful only if the schedule is
        /// in the active state when the time comes around. For example, if the schedule is disabled, no Job will be created at nextRunTime
        /// unless the Job is enabled before then.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public global::System.DateTime? ExecutionInfoNextRunTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfoInternal)ExecutionInfo).NextRunTime; }

        /// <summary>Backing field for <see cref="Id" /> property.</summary>
        private string _id;

        /// <summary>A string that uniquely identifies the schedule within the Account.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public string Id { get => this._id; }

        /// <summary>Backing field for <see cref="JobScheduleStatistics" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatistics _jobScheduleStatistics;

        /// <summary>
        /// The lifetime resource usage statistics for the Job Schedule. The statistics may not be immediately available. The Batch
        /// service performs periodic roll-up of statistics. The typical delay is about 30 minutes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatistics JobScheduleStatistics { get => (this._jobScheduleStatistics = this._jobScheduleStatistics ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobScheduleStatistics()); }

        /// <summary>
        /// The total number of Tasks that failed during the given time range in Jobs created under the schedule. A Task fails if
        /// it exhausts its maximum retry count without returning exit code 0.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string JobScheduleStatisticsFailedTasksCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).FailedTasksCount; }

        /// <summary>
        /// The total kernel mode CPU time (summed across all cores and all Compute Nodes) consumed by all Tasks in all Jobs created
        /// under the schedule.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public global::System.TimeSpan? JobScheduleStatisticsKernelCpuTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).KernelCpuTime; }

        /// <summary>
        /// The time at which the statistics were last updated. All statistics are limited to the range between startTime and lastUpdateTime.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public global::System.DateTime? JobScheduleStatisticsLastUpdateTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).LastUpdateTime; }

        /// <summary>
        /// The total gibibytes read from disk by all Tasks in all Jobs created under the schedule.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public float? JobScheduleStatisticsReadIoGiB { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).ReadIoGiB; }

        /// <summary>
        /// The total number of disk read operations made by all Tasks in all Jobs created under the schedule.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string JobScheduleStatisticsReadIop { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).ReadIop; }

        /// <summary>The start time of the time range covered by the statistics.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public global::System.DateTime? JobScheduleStatisticsStartTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).StartTime; }

        /// <summary>
        /// The total number of Tasks successfully completed during the given time range in Jobs created under the schedule. A Task
        /// completes successfully if it returns exit code 0.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string JobScheduleStatisticsSucceededTasksCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).SucceededTasksCount; }

        /// <summary>
        /// The total number of retries during the given time range on all Tasks in all Jobs created under the schedule.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string JobScheduleStatisticsTaskRetriesCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).TaskRetriesCount; }

        /// <summary>The URL of the statistics.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string JobScheduleStatisticsUrl { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).Url; }

        /// <summary>
        /// The total user mode CPU time (summed across all cores and all Compute Nodes) consumed by all Tasks in all Jobs created
        /// under the schedule.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public global::System.TimeSpan? JobScheduleStatisticsUserCpuTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).UserCpuTime; }

        /// <summary>
        /// The total wait time of all Tasks in all Jobs created under the schedule. The wait time for a Task is defined as the elapsed
        /// time between the creation of the Task and the start of Task execution. (If the Task is retried due to failures, the wait
        /// time is the time to the most recent Task execution.). This value is only reported in the Account lifetime statistics;
        /// it is not included in the Job statistics.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public global::System.TimeSpan? JobScheduleStatisticsWaitTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).WaitTime; }

        /// <summary>
        /// The total wall clock time of all the Tasks in all the Jobs created under the schedule. The wall clock time is the elapsed
        /// time from when the Task started running on a Compute Node to when it finished (or to the last time the statistics were
        /// updated, if the Task had not finished by then). If a Task was retried, this includes the wall clock time of all the Task
        /// retries.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public global::System.TimeSpan? JobScheduleStatisticsWallClockTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).WallClockTime; }

        /// <summary>
        /// The total gibibytes written to disk by all Tasks in all Jobs created under the schedule.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public float? JobScheduleStatisticsWriteIoGiB { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).WriteIoGiB; }

        /// <summary>
        /// The total number of disk write operations made by all Tasks in all Jobs created under the schedule.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string JobScheduleStatisticsWriteIop { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).WriteIop; }

        /// <summary>Backing field for <see cref="JobSpecification" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSpecification _jobSpecification;

        /// <summary>The details of the Jobs to be created on this schedule.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSpecification JobSpecification { get => (this._jobSpecification = this._jobSpecification ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobSpecification()); set => this._jobSpecification = value; }

        /// <summary>Backing field for <see cref="LastModified" /> property.</summary>
        private global::System.DateTime? _lastModified;

        /// <summary>
        /// The last modified time of the Job Schedule. This is the last time at which the schedule level data, such as the Job specification
        /// or recurrence information, changed. It does not factor in job-level changes such as new Jobs being created or Jobs changing
        /// state.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public global::System.DateTime? LastModified { get => this._lastModified; }

        /// <summary>Backing field for <see cref="LastModified1" /> property.</summary>
        private string _lastModified1;

        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public string LastModified1 { get => this._lastModified1; set => this._lastModified1 = value; }

        /// <summary>Backing field for <see cref="Metadata" /> property.</summary>
        private System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchMetadataItem> _metadata;

        /// <summary>
        /// A list of name-value pairs associated with the schedule as metadata. The Batch service does not assign any meaning to
        /// metadata; it is solely for the use of user code.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchMetadataItem> Metadata { get => this._metadata; set => this._metadata = value; }

        /// <summary>Internal Acessors for CreationTime</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.CreationTime { get => this._creationTime; set { {_creationTime = value;} } }

        /// <summary>Internal Acessors for DisplayName</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.DisplayName { get => this._displayName; set { {_displayName = value;} } }

        /// <summary>Internal Acessors for ETag</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.ETag { get => this._eTag; set { {_eTag = value;} } }

        /// <summary>Internal Acessors for ExecutionInfo</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfo Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.ExecutionInfo { get => (this._executionInfo = this._executionInfo ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobScheduleExecutionInfo()); set { {_executionInfo = value;} } }

        /// <summary>Internal Acessors for ExecutionInfoEndTime</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.ExecutionInfoEndTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfoInternal)ExecutionInfo).EndTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfoInternal)ExecutionInfo).EndTime = value ?? default(global::System.DateTime); }

        /// <summary>Internal Acessors for ExecutionInfoNextRunTime</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.ExecutionInfoNextRunTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfoInternal)ExecutionInfo).NextRunTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfoInternal)ExecutionInfo).NextRunTime = value ?? default(global::System.DateTime); }

        /// <summary>Internal Acessors for ExecutionInfoRecentJob</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IRecentBatchJob Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.ExecutionInfoRecentJob { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfoInternal)ExecutionInfo).RecentJob; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfoInternal)ExecutionInfo).RecentJob = value ?? null /* model class */; }

        /// <summary>Internal Acessors for Id</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.Id { get => this._id; set { {_id = value;} } }

        /// <summary>Internal Acessors for JobScheduleStatistics</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatistics Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.JobScheduleStatistics { get => (this._jobScheduleStatistics = this._jobScheduleStatistics ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobScheduleStatistics()); set { {_jobScheduleStatistics = value;} } }

        /// <summary>Internal Acessors for JobScheduleStatisticsFailedTasksCount</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.JobScheduleStatisticsFailedTasksCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).FailedTasksCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).FailedTasksCount = value ?? null; }

        /// <summary>Internal Acessors for JobScheduleStatisticsKernelCpuTime</summary>
        global::System.TimeSpan? Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.JobScheduleStatisticsKernelCpuTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).KernelCpuTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).KernelCpuTime = value ?? default(global::System.TimeSpan); }

        /// <summary>Internal Acessors for JobScheduleStatisticsLastUpdateTime</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.JobScheduleStatisticsLastUpdateTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).LastUpdateTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).LastUpdateTime = value ?? default(global::System.DateTime); }

        /// <summary>Internal Acessors for JobScheduleStatisticsReadIoGiB</summary>
        float? Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.JobScheduleStatisticsReadIoGiB { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).ReadIoGiB; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).ReadIoGiB = value ?? default(float); }

        /// <summary>Internal Acessors for JobScheduleStatisticsReadIop</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.JobScheduleStatisticsReadIop { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).ReadIop; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).ReadIop = value ?? null; }

        /// <summary>Internal Acessors for JobScheduleStatisticsStartTime</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.JobScheduleStatisticsStartTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).StartTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).StartTime = value ?? default(global::System.DateTime); }

        /// <summary>Internal Acessors for JobScheduleStatisticsSucceededTasksCount</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.JobScheduleStatisticsSucceededTasksCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).SucceededTasksCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).SucceededTasksCount = value ?? null; }

        /// <summary>Internal Acessors for JobScheduleStatisticsTaskRetriesCount</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.JobScheduleStatisticsTaskRetriesCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).TaskRetriesCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).TaskRetriesCount = value ?? null; }

        /// <summary>Internal Acessors for JobScheduleStatisticsUrl</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.JobScheduleStatisticsUrl { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).Url; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).Url = value ?? null; }

        /// <summary>Internal Acessors for JobScheduleStatisticsUserCpuTime</summary>
        global::System.TimeSpan? Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.JobScheduleStatisticsUserCpuTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).UserCpuTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).UserCpuTime = value ?? default(global::System.TimeSpan); }

        /// <summary>Internal Acessors for JobScheduleStatisticsWaitTime</summary>
        global::System.TimeSpan? Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.JobScheduleStatisticsWaitTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).WaitTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).WaitTime = value ?? default(global::System.TimeSpan); }

        /// <summary>Internal Acessors for JobScheduleStatisticsWallClockTime</summary>
        global::System.TimeSpan? Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.JobScheduleStatisticsWallClockTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).WallClockTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).WallClockTime = value ?? default(global::System.TimeSpan); }

        /// <summary>Internal Acessors for JobScheduleStatisticsWriteIoGiB</summary>
        float? Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.JobScheduleStatisticsWriteIoGiB { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).WriteIoGiB; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).WriteIoGiB = value ?? default(float); }

        /// <summary>Internal Acessors for JobScheduleStatisticsWriteIop</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.JobScheduleStatisticsWriteIop { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).WriteIop; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatisticsInternal)JobScheduleStatistics).WriteIop = value ?? null; }

        /// <summary>Internal Acessors for LastModified</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.LastModified { get => this._lastModified; set { {_lastModified = value;} } }

        /// <summary>Internal Acessors for PreviousState</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.PreviousState { get => this._previousState; set { {_previousState = value;} } }

        /// <summary>Internal Acessors for PreviousStateTransitionTime</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.PreviousStateTransitionTime { get => this._previousStateTransitionTime; set { {_previousStateTransitionTime = value;} } }

        /// <summary>Internal Acessors for RecentJobId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.RecentJobId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfoInternal)ExecutionInfo).RecentJobId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfoInternal)ExecutionInfo).RecentJobId = value ?? null; }

        /// <summary>Internal Acessors for RecentJobUrl</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.RecentJobUrl { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfoInternal)ExecutionInfo).RecentJobUrl; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfoInternal)ExecutionInfo).RecentJobUrl = value ?? null; }

        /// <summary>Internal Acessors for Schedule</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleConfiguration Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.Schedule { get => (this._schedule = this._schedule ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobScheduleConfiguration()); set { {_schedule = value;} } }

        /// <summary>Internal Acessors for State</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.State { get => this._state; set { {_state = value;} } }

        /// <summary>Internal Acessors for StateTransitionTime</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.StateTransitionTime { get => this._stateTransitionTime; set { {_stateTransitionTime = value;} } }

        /// <summary>Internal Acessors for Url</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal.Url { get => this._url; set { {_url = value;} } }

        /// <summary>Backing field for <see cref="PreviousState" /> property.</summary>
        private string _previousState;

        /// <summary>
        /// The previous state of the Job Schedule. This property is not present if the Job Schedule is in its initial active state.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public string PreviousState { get => this._previousState; }

        /// <summary>Backing field for <see cref="PreviousStateTransitionTime" /> property.</summary>
        private global::System.DateTime? _previousStateTransitionTime;

        /// <summary>
        /// The time at which the Job Schedule entered its previous state. This property is not present if the Job Schedule is in
        /// its initial active state.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public global::System.DateTime? PreviousStateTransitionTime { get => this._previousStateTransitionTime; }

        /// <summary>The ID of the Job.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string RecentJobId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfoInternal)ExecutionInfo).RecentJobId; }

        /// <summary>The URL of the Job.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string RecentJobUrl { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfoInternal)ExecutionInfo).RecentJobUrl; }

        /// <summary>Backing field for <see cref="RequestId" /> property.</summary>
        private string _requestId;

        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public string RequestId { get => this._requestId; set => this._requestId = value; }

        /// <summary>Gets the resource group name</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public string ResourceGroupName { get => (new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(this.Id).Success ? new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(this.Id).Groups["resourceGroupName"].Value : null); }

        /// <summary>Backing field for <see cref="Schedule" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleConfiguration _schedule;

        /// <summary>
        /// The schedule according to which Jobs will be created. All times are fixed respective to UTC and are not impacted by daylight
        /// saving time.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleConfiguration Schedule { get => (this._schedule = this._schedule ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobScheduleConfiguration()); set => this._schedule = value; }

        /// <summary>
        /// A time after which no Job will be created under this Job Schedule. The schedule will move to the completed state as soon
        /// as this deadline is past and there is no active Job under this Job Schedule. If you do not specify a doNotRunAfter time,
        /// and you are creating a recurring Job Schedule, the Job Schedule will remain active until you explicitly terminate it.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public global::System.DateTime? ScheduleDoNotRunAfter { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleConfigurationInternal)Schedule).DoNotRunAfter; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleConfigurationInternal)Schedule).DoNotRunAfter = value ?? default(global::System.DateTime); }

        /// <summary>
        /// The earliest time at which any Job may be created under this Job Schedule. If you do not specify a doNotRunUntil time,
        /// the schedule becomes ready to create Jobs immediately.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public global::System.DateTime? ScheduleDoNotRunUntil { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleConfigurationInternal)Schedule).DoNotRunUntil; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleConfigurationInternal)Schedule).DoNotRunUntil = value ?? default(global::System.DateTime); }

        /// <summary>
        /// The time interval between the start times of two successive Jobs under the Job Schedule. A Job Schedule can have at most
        /// one active Job under it at any given time. Because a Job Schedule can have at most one active Job under it at any given
        /// time, if it is time to create a new Job under a Job Schedule, but the previous Job is still running, the Batch service
        /// will not create the new Job until the previous Job finishes. If the previous Job does not finish within the startWindow
        /// period of the new recurrenceInterval, then no new Job will be scheduled for that interval. For recurring Jobs, you should
        /// normally specify a jobManagerTask in the jobSpecification. If you do not use jobManagerTask, you will need an external
        /// process to monitor when Jobs are created, add Tasks to the Jobs and terminate the Jobs ready for the next recurrence.
        /// The default is that the schedule does not recur: one Job is created, within the startWindow after the doNotRunUntil time,
        /// and the schedule is complete as soon as that Job finishes. The minimum value is 1 minute. If you specify a lower value,
        /// the Batch service rejects the schedule with an error; if you are calling the REST API directly, the HTTP status code is
        /// 400 (Bad Request).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public global::System.TimeSpan? ScheduleRecurrenceInterval { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleConfigurationInternal)Schedule).RecurrenceInterval; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleConfigurationInternal)Schedule).RecurrenceInterval = value ?? default(global::System.TimeSpan); }

        /// <summary>
        /// The time interval, starting from the time at which the schedule indicates a Job should be created, within which a Job
        /// must be created. If a Job is not created within the startWindow interval, then the 'opportunity' is lost; no Job will
        /// be created until the next recurrence of the schedule. If the schedule is recurring, and the startWindow is longer than
        /// the recurrence interval, then this is equivalent to an infinite startWindow, because the Job that is 'due' in one recurrenceInterval
        /// is not carried forward into the next recurrence interval. The default is infinite. The minimum value is 1 minute. If you
        /// specify a lower value, the Batch service rejects the schedule with an error; if you are calling the REST API directly,
        /// the HTTP status code is 400 (Bad Request).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public global::System.TimeSpan? ScheduleStartWindow { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleConfigurationInternal)Schedule).StartWindow; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleConfigurationInternal)Schedule).StartWindow = value ?? default(global::System.TimeSpan); }

        /// <summary>Backing field for <see cref="State" /> property.</summary>
        private string _state;

        /// <summary>The current state of the Job Schedule.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public string State { get => this._state; }

        /// <summary>Backing field for <see cref="StateTransitionTime" /> property.</summary>
        private global::System.DateTime? _stateTransitionTime;

        /// <summary>The time at which the Job Schedule entered the current state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public global::System.DateTime? StateTransitionTime { get => this._stateTransitionTime; }

        /// <summary>Backing field for <see cref="Url" /> property.</summary>
        private string _url;

        /// <summary>The URL of the Job Schedule.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public string Url { get => this._url; }

        /// <summary>Creates an new <see cref="BatchJobSchedule" /> instance.</summary>
        public BatchJobSchedule()
        {

        }

        /// <param name="headers"></param>
        void Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IHeaderSerializable.ReadHeaders(global::System.Net.Http.Headers.HttpResponseHeaders headers)
        {
            if (headers.TryGetValues("ETag", out var __eTagHeader0))
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal)this).ETag1 = System.Linq.Enumerable.FirstOrDefault(__eTagHeader0) is string __headerETagHeader0 ? __headerETagHeader0 : (string)null;
            }
            if (headers.TryGetValues("Last-Modified", out var __lastModifiedHeader1))
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal)this).LastModified1 = System.Linq.Enumerable.FirstOrDefault(__lastModifiedHeader1) is string __headerLastModifiedHeader1 ? __headerLastModifiedHeader1 : (string)null;
            }
            if (headers.TryGetValues("client-request-id", out var __clientRequestIdHeader2))
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal)this).ClientRequestId = System.Linq.Enumerable.FirstOrDefault(__clientRequestIdHeader2) is string __headerClientRequestIdHeader2 ? __headerClientRequestIdHeader2 : (string)null;
            }
            if (headers.TryGetValues("request-id", out var __requestIdHeader3))
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleInternal)this).RequestId = System.Linq.Enumerable.FirstOrDefault(__requestIdHeader3) is string __headerRequestIdHeader3 ? __headerRequestIdHeader3 : (string)null;
            }
        }
    }
    /// A Job Schedule that allows recurring Jobs by specifying when to run Jobs and a
    /// specification used to create each Job.
    public partial interface IBatchJobSchedule :
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IJsonSerializable
    {
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"client-request-id",
        PossibleTypes = new [] { typeof(string) })]
        string ClientRequestId { get; set; }
        /// <summary>The creation time of the Job Schedule.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The creation time of the Job Schedule.",
        SerializedName = @"creationTime",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? CreationTime { get;  }
        /// <summary>The display name for the schedule.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The display name for the schedule.",
        SerializedName = @"displayName",
        PossibleTypes = new [] { typeof(string) })]
        string DisplayName { get;  }
        /// <summary>
        /// The ETag of the Job Schedule. This is an opaque string. You can use it to detect whether the Job Schedule has changed
        /// between requests. In particular, you can be pass the ETag with an Update Job Schedule request to specify that your changes
        /// should take effect only if nobody else has modified the schedule in the meantime.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The ETag of the Job Schedule. This is an opaque string. You can use it to detect whether the Job Schedule has changed between requests. In particular, you can be pass the ETag with an Update Job Schedule request to specify that your changes should take effect only if nobody else has modified the schedule in the meantime.",
        SerializedName = @"eTag",
        PossibleTypes = new [] { typeof(string) })]
        string ETag { get;  }

        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"ETag",
        PossibleTypes = new [] { typeof(string) })]
        string ETag1 { get; set; }
        /// <summary>
        /// The time at which the schedule ended. This property is set only if the Job Schedule is in the completed state.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The time at which the schedule ended. This property is set only if the Job Schedule is in the completed state.",
        SerializedName = @"endTime",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? ExecutionInfoEndTime { get;  }
        /// <summary>
        /// The next time at which a Job will be created under this schedule. This property is meaningful only if the schedule is
        /// in the active state when the time comes around. For example, if the schedule is disabled, no Job will be created at nextRunTime
        /// unless the Job is enabled before then.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The next time at which a Job will be created under this schedule. This property is meaningful only if the schedule is in the active state when the time comes around. For example, if the schedule is disabled, no Job will be created at nextRunTime unless the Job is enabled before then.",
        SerializedName = @"nextRunTime",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? ExecutionInfoNextRunTime { get;  }
        /// <summary>A string that uniquely identifies the schedule within the Account.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"A string that uniquely identifies the schedule within the Account.",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(string) })]
        string Id { get;  }
        /// <summary>
        /// The total number of Tasks that failed during the given time range in Jobs created under the schedule. A Task fails if
        /// it exhausts its maximum retry count without returning exit code 0.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The total number of Tasks that failed during the given time range in Jobs created under the schedule. A Task fails if it exhausts its maximum retry count without returning exit code 0.",
        SerializedName = @"numFailedTasks",
        PossibleTypes = new [] { typeof(string) })]
        string JobScheduleStatisticsFailedTasksCount { get;  }
        /// <summary>
        /// The total kernel mode CPU time (summed across all cores and all Compute Nodes) consumed by all Tasks in all Jobs created
        /// under the schedule.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The total kernel mode CPU time (summed across all cores and all Compute Nodes) consumed by all Tasks in all Jobs created under the schedule.",
        SerializedName = @"kernelCPUTime",
        PossibleTypes = new [] { typeof(global::System.TimeSpan) })]
        global::System.TimeSpan? JobScheduleStatisticsKernelCpuTime { get;  }
        /// <summary>
        /// The time at which the statistics were last updated. All statistics are limited to the range between startTime and lastUpdateTime.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The time at which the statistics were last updated. All statistics are limited to the range between startTime and lastUpdateTime.",
        SerializedName = @"lastUpdateTime",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? JobScheduleStatisticsLastUpdateTime { get;  }
        /// <summary>
        /// The total gibibytes read from disk by all Tasks in all Jobs created under the schedule.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The total gibibytes read from disk by all Tasks in all Jobs created under the schedule.",
        SerializedName = @"readIOGiB",
        PossibleTypes = new [] { typeof(float) })]
        float? JobScheduleStatisticsReadIoGiB { get;  }
        /// <summary>
        /// The total number of disk read operations made by all Tasks in all Jobs created under the schedule.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The total number of disk read operations made by all Tasks in all Jobs created under the schedule.",
        SerializedName = @"readIOps",
        PossibleTypes = new [] { typeof(string) })]
        string JobScheduleStatisticsReadIop { get;  }
        /// <summary>The start time of the time range covered by the statistics.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The start time of the time range covered by the statistics.",
        SerializedName = @"startTime",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? JobScheduleStatisticsStartTime { get;  }
        /// <summary>
        /// The total number of Tasks successfully completed during the given time range in Jobs created under the schedule. A Task
        /// completes successfully if it returns exit code 0.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The total number of Tasks successfully completed during the given time range in Jobs created under the schedule. A Task completes successfully if it returns exit code 0.",
        SerializedName = @"numSucceededTasks",
        PossibleTypes = new [] { typeof(string) })]
        string JobScheduleStatisticsSucceededTasksCount { get;  }
        /// <summary>
        /// The total number of retries during the given time range on all Tasks in all Jobs created under the schedule.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The total number of retries during the given time range on all Tasks in all Jobs created under the schedule.",
        SerializedName = @"numTaskRetries",
        PossibleTypes = new [] { typeof(string) })]
        string JobScheduleStatisticsTaskRetriesCount { get;  }
        /// <summary>The URL of the statistics.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The URL of the statistics.",
        SerializedName = @"url",
        PossibleTypes = new [] { typeof(string) })]
        string JobScheduleStatisticsUrl { get;  }
        /// <summary>
        /// The total user mode CPU time (summed across all cores and all Compute Nodes) consumed by all Tasks in all Jobs created
        /// under the schedule.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The total user mode CPU time (summed across all cores and all Compute Nodes) consumed by all Tasks in all Jobs created under the schedule.",
        SerializedName = @"userCPUTime",
        PossibleTypes = new [] { typeof(global::System.TimeSpan) })]
        global::System.TimeSpan? JobScheduleStatisticsUserCpuTime { get;  }
        /// <summary>
        /// The total wait time of all Tasks in all Jobs created under the schedule. The wait time for a Task is defined as the elapsed
        /// time between the creation of the Task and the start of Task execution. (If the Task is retried due to failures, the wait
        /// time is the time to the most recent Task execution.). This value is only reported in the Account lifetime statistics;
        /// it is not included in the Job statistics.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The total wait time of all Tasks in all Jobs created under the schedule. The wait time for a Task is defined as the elapsed time between the creation of the Task and the start of Task execution. (If the Task is retried due to failures, the wait time is the time to the most recent Task execution.). This value is only reported in the Account lifetime statistics; it is not included in the Job statistics.",
        SerializedName = @"waitTime",
        PossibleTypes = new [] { typeof(global::System.TimeSpan) })]
        global::System.TimeSpan? JobScheduleStatisticsWaitTime { get;  }
        /// <summary>
        /// The total wall clock time of all the Tasks in all the Jobs created under the schedule. The wall clock time is the elapsed
        /// time from when the Task started running on a Compute Node to when it finished (or to the last time the statistics were
        /// updated, if the Task had not finished by then). If a Task was retried, this includes the wall clock time of all the Task
        /// retries.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The total wall clock time of all the Tasks in all the Jobs created under the schedule. The wall clock time is the elapsed time from when the Task started running on a Compute Node to when it finished (or to the last time the statistics were updated, if the Task had not finished by then). If a Task was retried, this includes the wall clock time of all the Task retries.",
        SerializedName = @"wallClockTime",
        PossibleTypes = new [] { typeof(global::System.TimeSpan) })]
        global::System.TimeSpan? JobScheduleStatisticsWallClockTime { get;  }
        /// <summary>
        /// The total gibibytes written to disk by all Tasks in all Jobs created under the schedule.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The total gibibytes written to disk by all Tasks in all Jobs created under the schedule.",
        SerializedName = @"writeIOGiB",
        PossibleTypes = new [] { typeof(float) })]
        float? JobScheduleStatisticsWriteIoGiB { get;  }
        /// <summary>
        /// The total number of disk write operations made by all Tasks in all Jobs created under the schedule.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The total number of disk write operations made by all Tasks in all Jobs created under the schedule.",
        SerializedName = @"writeIOps",
        PossibleTypes = new [] { typeof(string) })]
        string JobScheduleStatisticsWriteIop { get;  }
        /// <summary>The details of the Jobs to be created on this schedule.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The details of the Jobs to be created on this schedule.",
        SerializedName = @"jobSpecification",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSpecification) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSpecification JobSpecification { get; set; }
        /// <summary>
        /// The last modified time of the Job Schedule. This is the last time at which the schedule level data, such as the Job specification
        /// or recurrence information, changed. It does not factor in job-level changes such as new Jobs being created or Jobs changing
        /// state.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The last modified time of the Job Schedule. This is the last time at which the schedule level data, such as the Job specification or recurrence information, changed. It does not factor in job-level changes such as new Jobs being created or Jobs changing state.",
        SerializedName = @"lastModified",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? LastModified { get;  }

        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"Last-Modified",
        PossibleTypes = new [] { typeof(string) })]
        string LastModified1 { get; set; }
        /// <summary>
        /// A list of name-value pairs associated with the schedule as metadata. The Batch service does not assign any meaning to
        /// metadata; it is solely for the use of user code.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"A list of name-value pairs associated with the schedule as metadata. The Batch service does not assign any meaning to metadata; it is solely for the use of user code.",
        SerializedName = @"metadata",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchMetadataItem) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchMetadataItem> Metadata { get; set; }
        /// <summary>
        /// The previous state of the Job Schedule. This property is not present if the Job Schedule is in its initial active state.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The previous state of the Job Schedule. This property is not present if the Job Schedule is in its initial active state.",
        SerializedName = @"previousState",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("active", "completed", "disabled", "terminating", "deleting")]
        string PreviousState { get;  }
        /// <summary>
        /// The time at which the Job Schedule entered its previous state. This property is not present if the Job Schedule is in
        /// its initial active state.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The time at which the Job Schedule entered its previous state. This property is not present if the Job Schedule is in its initial active state.",
        SerializedName = @"previousStateTransitionTime",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? PreviousStateTransitionTime { get;  }
        /// <summary>The ID of the Job.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The ID of the Job.",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(string) })]
        string RecentJobId { get;  }
        /// <summary>The URL of the Job.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The URL of the Job.",
        SerializedName = @"url",
        PossibleTypes = new [] { typeof(string) })]
        string RecentJobUrl { get;  }

        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"request-id",
        PossibleTypes = new [] { typeof(string) })]
        string RequestId { get; set; }
        /// <summary>
        /// A time after which no Job will be created under this Job Schedule. The schedule will move to the completed state as soon
        /// as this deadline is past and there is no active Job under this Job Schedule. If you do not specify a doNotRunAfter time,
        /// and you are creating a recurring Job Schedule, the Job Schedule will remain active until you explicitly terminate it.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"A time after which no Job will be created under this Job Schedule. The schedule will move to the completed state as soon as this deadline is past and there is no active Job under this Job Schedule. If you do not specify a doNotRunAfter time, and you are creating a recurring Job Schedule, the Job Schedule will remain active until you explicitly terminate it.",
        SerializedName = @"doNotRunAfter",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? ScheduleDoNotRunAfter { get; set; }
        /// <summary>
        /// The earliest time at which any Job may be created under this Job Schedule. If you do not specify a doNotRunUntil time,
        /// the schedule becomes ready to create Jobs immediately.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The earliest time at which any Job may be created under this Job Schedule. If you do not specify a doNotRunUntil time, the schedule becomes ready to create Jobs immediately.",
        SerializedName = @"doNotRunUntil",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? ScheduleDoNotRunUntil { get; set; }
        /// <summary>
        /// The time interval between the start times of two successive Jobs under the Job Schedule. A Job Schedule can have at most
        /// one active Job under it at any given time. Because a Job Schedule can have at most one active Job under it at any given
        /// time, if it is time to create a new Job under a Job Schedule, but the previous Job is still running, the Batch service
        /// will not create the new Job until the previous Job finishes. If the previous Job does not finish within the startWindow
        /// period of the new recurrenceInterval, then no new Job will be scheduled for that interval. For recurring Jobs, you should
        /// normally specify a jobManagerTask in the jobSpecification. If you do not use jobManagerTask, you will need an external
        /// process to monitor when Jobs are created, add Tasks to the Jobs and terminate the Jobs ready for the next recurrence.
        /// The default is that the schedule does not recur: one Job is created, within the startWindow after the doNotRunUntil time,
        /// and the schedule is complete as soon as that Job finishes. The minimum value is 1 minute. If you specify a lower value,
        /// the Batch service rejects the schedule with an error; if you are calling the REST API directly, the HTTP status code is
        /// 400 (Bad Request).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The time interval between the start times of two successive Jobs under the Job Schedule. A Job Schedule can have at most one active Job under it at any given time. Because a Job Schedule can have at most one active Job under it at any given time, if it is time to create a new Job under a Job Schedule, but the previous Job is still running, the Batch service will not create the new Job until the previous Job finishes. If the previous Job does not finish within the startWindow period of the new recurrenceInterval, then no new Job will be scheduled for that interval. For recurring Jobs, you should normally specify a jobManagerTask in the jobSpecification. If you do not use jobManagerTask, you will need an external process to monitor when Jobs are created, add Tasks to the Jobs and terminate the Jobs ready for the next recurrence. The default is that the schedule does not recur: one Job is created, within the startWindow after the doNotRunUntil time, and the schedule is complete as soon as that Job finishes. The minimum value is 1 minute. If you specify a lower value, the Batch service rejects the schedule with an error; if you are calling the REST API directly, the HTTP status code is 400 (Bad Request).",
        SerializedName = @"recurrenceInterval",
        PossibleTypes = new [] { typeof(global::System.TimeSpan) })]
        global::System.TimeSpan? ScheduleRecurrenceInterval { get; set; }
        /// <summary>
        /// The time interval, starting from the time at which the schedule indicates a Job should be created, within which a Job
        /// must be created. If a Job is not created within the startWindow interval, then the 'opportunity' is lost; no Job will
        /// be created until the next recurrence of the schedule. If the schedule is recurring, and the startWindow is longer than
        /// the recurrence interval, then this is equivalent to an infinite startWindow, because the Job that is 'due' in one recurrenceInterval
        /// is not carried forward into the next recurrence interval. The default is infinite. The minimum value is 1 minute. If you
        /// specify a lower value, the Batch service rejects the schedule with an error; if you are calling the REST API directly,
        /// the HTTP status code is 400 (Bad Request).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The time interval, starting from the time at which the schedule indicates a Job should be created, within which a Job must be created. If a Job is not created within the startWindow interval, then the 'opportunity' is lost; no Job will be created until the next recurrence of the schedule. If the schedule is recurring, and the startWindow is longer than the recurrence interval, then this is equivalent to an infinite startWindow, because the Job that is 'due' in one recurrenceInterval is not carried forward into the next recurrence interval. The default is infinite. The minimum value is 1 minute. If you specify a lower value, the Batch service rejects the schedule with an error; if you are calling the REST API directly, the HTTP status code is 400 (Bad Request).",
        SerializedName = @"startWindow",
        PossibleTypes = new [] { typeof(global::System.TimeSpan) })]
        global::System.TimeSpan? ScheduleStartWindow { get; set; }
        /// <summary>The current state of the Job Schedule.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The current state of the Job Schedule.",
        SerializedName = @"state",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("active", "completed", "disabled", "terminating", "deleting")]
        string State { get;  }
        /// <summary>The time at which the Job Schedule entered the current state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The time at which the Job Schedule entered the current state.",
        SerializedName = @"stateTransitionTime",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? StateTransitionTime { get;  }
        /// <summary>The URL of the Job Schedule.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The URL of the Job Schedule.",
        SerializedName = @"url",
        PossibleTypes = new [] { typeof(string) })]
        string Url { get;  }

    }
    /// A Job Schedule that allows recurring Jobs by specifying when to run Jobs and a
    /// specification used to create each Job.
    internal partial interface IBatchJobScheduleInternal

    {
        string ClientRequestId { get; set; }
        /// <summary>The creation time of the Job Schedule.</summary>
        global::System.DateTime? CreationTime { get; set; }
        /// <summary>The display name for the schedule.</summary>
        string DisplayName { get; set; }
        /// <summary>
        /// The ETag of the Job Schedule. This is an opaque string. You can use it to detect whether the Job Schedule has changed
        /// between requests. In particular, you can be pass the ETag with an Update Job Schedule request to specify that your changes
        /// should take effect only if nobody else has modified the schedule in the meantime.
        /// </summary>
        string ETag { get; set; }

        string ETag1 { get; set; }
        /// <summary>Information about Jobs that have been and will be run under this schedule.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleExecutionInfo ExecutionInfo { get; set; }
        /// <summary>
        /// The time at which the schedule ended. This property is set only if the Job Schedule is in the completed state.
        /// </summary>
        global::System.DateTime? ExecutionInfoEndTime { get; set; }
        /// <summary>
        /// The next time at which a Job will be created under this schedule. This property is meaningful only if the schedule is
        /// in the active state when the time comes around. For example, if the schedule is disabled, no Job will be created at nextRunTime
        /// unless the Job is enabled before then.
        /// </summary>
        global::System.DateTime? ExecutionInfoNextRunTime { get; set; }
        /// <summary>
        /// Information about the most recent Job under the Job Schedule. This property is present only if the at least one Job has
        /// run under the schedule.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IRecentBatchJob ExecutionInfoRecentJob { get; set; }
        /// <summary>A string that uniquely identifies the schedule within the Account.</summary>
        string Id { get; set; }
        /// <summary>
        /// The lifetime resource usage statistics for the Job Schedule. The statistics may not be immediately available. The Batch
        /// service performs periodic roll-up of statistics. The typical delay is about 30 minutes.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleStatistics JobScheduleStatistics { get; set; }
        /// <summary>
        /// The total number of Tasks that failed during the given time range in Jobs created under the schedule. A Task fails if
        /// it exhausts its maximum retry count without returning exit code 0.
        /// </summary>
        string JobScheduleStatisticsFailedTasksCount { get; set; }
        /// <summary>
        /// The total kernel mode CPU time (summed across all cores and all Compute Nodes) consumed by all Tasks in all Jobs created
        /// under the schedule.
        /// </summary>
        global::System.TimeSpan? JobScheduleStatisticsKernelCpuTime { get; set; }
        /// <summary>
        /// The time at which the statistics were last updated. All statistics are limited to the range between startTime and lastUpdateTime.
        /// </summary>
        global::System.DateTime? JobScheduleStatisticsLastUpdateTime { get; set; }
        /// <summary>
        /// The total gibibytes read from disk by all Tasks in all Jobs created under the schedule.
        /// </summary>
        float? JobScheduleStatisticsReadIoGiB { get; set; }
        /// <summary>
        /// The total number of disk read operations made by all Tasks in all Jobs created under the schedule.
        /// </summary>
        string JobScheduleStatisticsReadIop { get; set; }
        /// <summary>The start time of the time range covered by the statistics.</summary>
        global::System.DateTime? JobScheduleStatisticsStartTime { get; set; }
        /// <summary>
        /// The total number of Tasks successfully completed during the given time range in Jobs created under the schedule. A Task
        /// completes successfully if it returns exit code 0.
        /// </summary>
        string JobScheduleStatisticsSucceededTasksCount { get; set; }
        /// <summary>
        /// The total number of retries during the given time range on all Tasks in all Jobs created under the schedule.
        /// </summary>
        string JobScheduleStatisticsTaskRetriesCount { get; set; }
        /// <summary>The URL of the statistics.</summary>
        string JobScheduleStatisticsUrl { get; set; }
        /// <summary>
        /// The total user mode CPU time (summed across all cores and all Compute Nodes) consumed by all Tasks in all Jobs created
        /// under the schedule.
        /// </summary>
        global::System.TimeSpan? JobScheduleStatisticsUserCpuTime { get; set; }
        /// <summary>
        /// The total wait time of all Tasks in all Jobs created under the schedule. The wait time for a Task is defined as the elapsed
        /// time between the creation of the Task and the start of Task execution. (If the Task is retried due to failures, the wait
        /// time is the time to the most recent Task execution.). This value is only reported in the Account lifetime statistics;
        /// it is not included in the Job statistics.
        /// </summary>
        global::System.TimeSpan? JobScheduleStatisticsWaitTime { get; set; }
        /// <summary>
        /// The total wall clock time of all the Tasks in all the Jobs created under the schedule. The wall clock time is the elapsed
        /// time from when the Task started running on a Compute Node to when it finished (or to the last time the statistics were
        /// updated, if the Task had not finished by then). If a Task was retried, this includes the wall clock time of all the Task
        /// retries.
        /// </summary>
        global::System.TimeSpan? JobScheduleStatisticsWallClockTime { get; set; }
        /// <summary>
        /// The total gibibytes written to disk by all Tasks in all Jobs created under the schedule.
        /// </summary>
        float? JobScheduleStatisticsWriteIoGiB { get; set; }
        /// <summary>
        /// The total number of disk write operations made by all Tasks in all Jobs created under the schedule.
        /// </summary>
        string JobScheduleStatisticsWriteIop { get; set; }
        /// <summary>The details of the Jobs to be created on this schedule.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobSpecification JobSpecification { get; set; }
        /// <summary>
        /// The last modified time of the Job Schedule. This is the last time at which the schedule level data, such as the Job specification
        /// or recurrence information, changed. It does not factor in job-level changes such as new Jobs being created or Jobs changing
        /// state.
        /// </summary>
        global::System.DateTime? LastModified { get; set; }

        string LastModified1 { get; set; }
        /// <summary>
        /// A list of name-value pairs associated with the schedule as metadata. The Batch service does not assign any meaning to
        /// metadata; it is solely for the use of user code.
        /// </summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchMetadataItem> Metadata { get; set; }
        /// <summary>
        /// The previous state of the Job Schedule. This property is not present if the Job Schedule is in its initial active state.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("active", "completed", "disabled", "terminating", "deleting")]
        string PreviousState { get; set; }
        /// <summary>
        /// The time at which the Job Schedule entered its previous state. This property is not present if the Job Schedule is in
        /// its initial active state.
        /// </summary>
        global::System.DateTime? PreviousStateTransitionTime { get; set; }
        /// <summary>The ID of the Job.</summary>
        string RecentJobId { get; set; }
        /// <summary>The URL of the Job.</summary>
        string RecentJobUrl { get; set; }

        string RequestId { get; set; }
        /// <summary>
        /// The schedule according to which Jobs will be created. All times are fixed respective to UTC and are not impacted by daylight
        /// saving time.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobScheduleConfiguration Schedule { get; set; }
        /// <summary>
        /// A time after which no Job will be created under this Job Schedule. The schedule will move to the completed state as soon
        /// as this deadline is past and there is no active Job under this Job Schedule. If you do not specify a doNotRunAfter time,
        /// and you are creating a recurring Job Schedule, the Job Schedule will remain active until you explicitly terminate it.
        /// </summary>
        global::System.DateTime? ScheduleDoNotRunAfter { get; set; }
        /// <summary>
        /// The earliest time at which any Job may be created under this Job Schedule. If you do not specify a doNotRunUntil time,
        /// the schedule becomes ready to create Jobs immediately.
        /// </summary>
        global::System.DateTime? ScheduleDoNotRunUntil { get; set; }
        /// <summary>
        /// The time interval between the start times of two successive Jobs under the Job Schedule. A Job Schedule can have at most
        /// one active Job under it at any given time. Because a Job Schedule can have at most one active Job under it at any given
        /// time, if it is time to create a new Job under a Job Schedule, but the previous Job is still running, the Batch service
        /// will not create the new Job until the previous Job finishes. If the previous Job does not finish within the startWindow
        /// period of the new recurrenceInterval, then no new Job will be scheduled for that interval. For recurring Jobs, you should
        /// normally specify a jobManagerTask in the jobSpecification. If you do not use jobManagerTask, you will need an external
        /// process to monitor when Jobs are created, add Tasks to the Jobs and terminate the Jobs ready for the next recurrence.
        /// The default is that the schedule does not recur: one Job is created, within the startWindow after the doNotRunUntil time,
        /// and the schedule is complete as soon as that Job finishes. The minimum value is 1 minute. If you specify a lower value,
        /// the Batch service rejects the schedule with an error; if you are calling the REST API directly, the HTTP status code is
        /// 400 (Bad Request).
        /// </summary>
        global::System.TimeSpan? ScheduleRecurrenceInterval { get; set; }
        /// <summary>
        /// The time interval, starting from the time at which the schedule indicates a Job should be created, within which a Job
        /// must be created. If a Job is not created within the startWindow interval, then the 'opportunity' is lost; no Job will
        /// be created until the next recurrence of the schedule. If the schedule is recurring, and the startWindow is longer than
        /// the recurrence interval, then this is equivalent to an infinite startWindow, because the Job that is 'due' in one recurrenceInterval
        /// is not carried forward into the next recurrence interval. The default is infinite. The minimum value is 1 minute. If you
        /// specify a lower value, the Batch service rejects the schedule with an error; if you are calling the REST API directly,
        /// the HTTP status code is 400 (Bad Request).
        /// </summary>
        global::System.TimeSpan? ScheduleStartWindow { get; set; }
        /// <summary>The current state of the Job Schedule.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("active", "completed", "disabled", "terminating", "deleting")]
        string State { get; set; }
        /// <summary>The time at which the Job Schedule entered the current state.</summary>
        global::System.DateTime? StateTransitionTime { get; set; }
        /// <summary>The URL of the Job Schedule.</summary>
        string Url { get; set; }

    }
}