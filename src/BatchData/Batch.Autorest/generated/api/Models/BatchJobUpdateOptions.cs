// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Batch.Models
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Extensions;

    /// <summary>Parameters for updating an Azure Batch Job.</summary>
    public partial class BatchJobUpdateOptions :
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobUpdateOptions,
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobUpdateOptionsInternal
    {

        /// <summary>Backing field for <see cref="AllTasksCompleteMode" /> property.</summary>
        private string _allTasksCompleteMode;

        /// <summary>
        /// The action the Batch service should take when all Tasks in the Job are in the completed state. If omitted, the completion
        /// behavior is left unchanged. You may not change the value from terminatejob to noaction - that is, once you have engaged
        /// automatic Job termination, you cannot turn it off again. If you try to do this, the request fails with an 'invalid property
        /// value' error response; if you are calling the REST API directly, the HTTP status code is 400 (Bad Request).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public string AllTasksCompleteMode { get => this._allTasksCompleteMode; set => this._allTasksCompleteMode = value; }

        /// <summary>Backing field for <see cref="AllowTaskPreemption" /> property.</summary>
        private bool? _allowTaskPreemption;

        /// <summary>
        /// Whether Tasks in this job can be preempted by other high priority jobs. If the value is set to True, other high priority
        /// jobs submitted to the system will take precedence and will be able requeue tasks from this job. You can update a job's
        /// allowTaskPreemption after it has been created using the update job API.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public bool? AllowTaskPreemption { get => this._allowTaskPreemption; set => this._allowTaskPreemption = value; }

        /// <summary>
        /// A prefix to be added to the unique identifier when a Pool is automatically created. The Batch service assigns each auto
        /// Pool a unique identifier on creation. To distinguish between Pools created for different purposes, you can specify this
        /// element to add a prefix to the ID that is assigned. The prefix can be up to 20 characters long.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string AutoPoolSpecificationAutoPoolIdPrefix { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolInfoUpdateInternal)PoolInfo).AutoPoolSpecificationAutoPoolIdPrefix; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolInfoUpdateInternal)PoolInfo).AutoPoolSpecificationAutoPoolIdPrefix = value ?? null; }

        /// <summary>
        /// Whether to keep an auto Pool alive after its lifetime expires. If false, the Batch service deletes the Pool once its lifetime
        /// (as determined by the poolLifetimeOption setting) expires; that is, when the Job or Job Schedule completes. If true, the
        /// Batch service does not delete the Pool automatically. It is up to the user to delete auto Pools created with this option.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public bool? AutoPoolSpecificationKeepAlive { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolInfoUpdateInternal)PoolInfo).AutoPoolSpecificationKeepAlive; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolInfoUpdateInternal)PoolInfo).AutoPoolSpecificationKeepAlive = value ?? default(bool); }

        /// <summary>The Pool specification for the auto Pool.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolSpecificationUpdate AutoPoolSpecificationPool { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolInfoUpdateInternal)PoolInfo).AutoPoolSpecificationPool; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolInfoUpdateInternal)PoolInfo).AutoPoolSpecificationPool = value ?? null /* model class */; }

        /// <summary>
        /// The minimum lifetime of created auto Pools, and how multiple Jobs on a schedule are assigned to Pools.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string AutoPoolSpecificationPoolLifetimeOption { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolInfoUpdateInternal)PoolInfo).AutoPoolSpecificationPoolLifetimeOption; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolInfoUpdateInternal)PoolInfo).AutoPoolSpecificationPoolLifetimeOption = value ?? null; }

        /// <summary>Backing field for <see cref="Constraint" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobConstraints _constraint;

        /// <summary>
        /// The execution constraints for the Job. If omitted, the existing execution constraints are left unchanged.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobConstraints Constraint { get => (this._constraint = this._constraint ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobConstraints()); set => this._constraint = value; }

        /// <summary>
        /// The maximum number of times each Task may be retried. The Batch service retries a Task if its exit code is nonzero. Note
        /// that this value specifically controls the number of retries. The Batch service will try each Task once, and may then retry
        /// up to this limit. For example, if the maximum retry count is 3, Batch tries a Task up to 4 times (one initial try and
        /// 3 retries). If the maximum retry count is 0, the Batch service does not retry Tasks. If the maximum retry count is -1,
        /// the Batch service retries Tasks without limit. The default value is 0 (no retries).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public int? ConstraintMaxTaskRetryCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobConstraintsInternal)Constraint).MaxTaskRetryCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobConstraintsInternal)Constraint).MaxTaskRetryCount = value ?? default(int); }

        /// <summary>
        /// The maximum elapsed time that the Job may run, measured from the time the Job is created. If the Job does not complete
        /// within the time limit, the Batch service terminates it and any Tasks that are still running. In this case, the termination
        /// reason will be MaxWallClockTimeExpiry. If this property is not specified, there is no time limit on how long the Job may
        /// run.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public global::System.TimeSpan? ConstraintMaxWallClockTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobConstraintsInternal)Constraint).MaxWallClockTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobConstraintsInternal)Constraint).MaxWallClockTime = value ?? default(global::System.TimeSpan); }

        /// <summary>Backing field for <see cref="MaxParallelTask" /> property.</summary>
        private int? _maxParallelTask;

        /// <summary>
        /// The maximum number of tasks that can be executed in parallel for the job. The value of maxParallelTasks must be -1 or
        /// greater than 0 if specified. If not specified, the default value is -1, which means there's no limit to the number of
        /// tasks that can be run at once. You can update a job's maxParallelTasks after it has been created using the update job
        /// API.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public int? MaxParallelTask { get => this._maxParallelTask; set => this._maxParallelTask = value; }

        /// <summary>Backing field for <see cref="Metadata" /> property.</summary>
        private System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchMetadataItem> _metadata;

        /// <summary>
        /// A list of name-value pairs associated with the Job as metadata. If omitted, the existing Job metadata is left unchanged.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchMetadataItem> Metadata { get => this._metadata; set => this._metadata = value; }

        /// <summary>Internal Acessors for Constraint</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobConstraints Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobUpdateOptionsInternal.Constraint { get => (this._constraint = this._constraint ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobConstraints()); set { {_constraint = value;} } }

        /// <summary>Internal Acessors for NetworkConfiguration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobNetworkConfigurationUpdate Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobUpdateOptionsInternal.NetworkConfiguration { get => (this._networkConfiguration = this._networkConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobNetworkConfigurationUpdate()); set { {_networkConfiguration = value;} } }

        /// <summary>Internal Acessors for PoolInfo</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolInfoUpdate Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobUpdateOptionsInternal.PoolInfo { get => (this._poolInfo = this._poolInfo ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchPoolInfoUpdate()); set { {_poolInfo = value;} } }

        /// <summary>Internal Acessors for PoolInfoAutoPoolSpecification</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchAutoPoolSpecificationUpdate Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobUpdateOptionsInternal.PoolInfoAutoPoolSpecification { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolInfoUpdateInternal)PoolInfo).AutoPoolSpecification; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolInfoUpdateInternal)PoolInfo).AutoPoolSpecification = value ?? null /* model class */; }

        /// <summary>Backing field for <see cref="NetworkConfiguration" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobNetworkConfigurationUpdate _networkConfiguration;

        /// <summary>The network configuration for the Job.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobNetworkConfigurationUpdate NetworkConfiguration { get => (this._networkConfiguration = this._networkConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchJobNetworkConfigurationUpdate()); set => this._networkConfiguration = value; }

        /// <summary>
        /// Whether to withdraw Compute Nodes from the virtual network to DNC when the job is terminated or deleted. If true, nodes
        /// will remain joined to the virtual network to DNC. If false, nodes will automatically withdraw when the job ends. Defaults
        /// to false.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public bool? NetworkConfigurationSkipWithdrawFromVnet { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobNetworkConfigurationUpdateInternal)NetworkConfiguration).SkipWithdrawFromVnet; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobNetworkConfigurationUpdateInternal)NetworkConfiguration).SkipWithdrawFromVnet = value ?? default(bool); }

        /// <summary>
        /// The ARM resource identifier of the virtual network subnet which Compute Nodes running Tasks from the Job will join for
        /// the duration of the Task. The virtual network must be in the same region and subscription as the Azure Batch Account.
        /// The specified subnet should have enough free IP addresses to accommodate the number of Compute Nodes which will run Tasks
        /// from the Job. This can be up to the number of Compute Nodes in the Pool. The 'MicrosoftAzureBatch' service principal must
        /// have the 'Classic Virtual Machine Contributor' Role-Based Access Control (RBAC) role for the specified VNet so that Azure
        /// Batch service can schedule Tasks on the Nodes. This can be verified by checking if the specified VNet has any associated
        /// Network Security Groups (NSG). If communication to the Nodes in the specified subnet is denied by an NSG, then the Batch
        /// service will set the state of the Compute Nodes to unusable. This is of the form /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
        /// If the specified VNet has any associated Network Security Groups (NSG), then a few reserved system ports must be enabled
        /// for inbound communication from the Azure Batch service. For Pools created with a Virtual Machine configuration, enable
        /// ports 29876 and 29877, as well as port 22 for Linux and port 3389 for Windows. Port 443 is also required to be open for
        /// outbound connections for communications to Azure Storage. For more details see: https://learn.microsoft.com/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string NetworkConfigurationSubnetId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobNetworkConfigurationUpdateInternal)NetworkConfiguration).SubnetId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobNetworkConfigurationUpdateInternal)NetworkConfiguration).SubnetId = value ?? null; }

        /// <summary>Backing field for <see cref="PoolInfo" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolInfoUpdate _poolInfo;

        /// <summary>
        /// The Pool on which the Batch service runs the Job's Tasks. You may change the Pool for a Job only when the Job is disabled.
        /// The Patch Job call will fail if you include the poolInfo element and the Job is not disabled. If you specify an autoPoolSpecification
        /// in the poolInfo, only the keepAlive property of the autoPoolSpecification can be updated, and then only if the autoPoolSpecification
        /// has a poolLifetimeOption of Job (other job properties can be updated as normal). If omitted, the Job continues to run
        /// on its current Pool.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolInfoUpdate PoolInfo { get => (this._poolInfo = this._poolInfo ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.BatchPoolInfoUpdate()); set => this._poolInfo = value; }

        /// <summary>
        /// The ID of an existing Pool. All the Tasks of the Job will run on the specified Pool. You must ensure that the Pool referenced
        /// by this property exists. If the Pool does not exist at the time the Batch service tries to schedule a Job, no Tasks for
        /// the Job will run until you create a Pool with that id. Note that the Batch service will not reject the Job request; it
        /// will simply not run Tasks until the Pool exists. You must specify either the Pool ID or the auto Pool specification, but
        /// not both.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string PoolInfoPoolId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolInfoUpdateInternal)PoolInfo).PoolId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolInfoUpdateInternal)PoolInfo).PoolId = value ?? null; }

        /// <summary>Backing field for <see cref="Priority" /> property.</summary>
        private int? _priority;

        /// <summary>
        /// The priority of the Job. Priority values can range from -1000 to 1000, with -1000 being the lowest priority and 1000 being
        /// the highest priority. If omitted, the priority of the Job is left unchanged.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public int? Priority { get => this._priority; set => this._priority = value; }

        /// <summary>Creates an new <see cref="BatchJobUpdateOptions" /> instance.</summary>
        public BatchJobUpdateOptions()
        {

        }
    }
    /// Parameters for updating an Azure Batch Job.
    public partial interface IBatchJobUpdateOptions :
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IJsonSerializable
    {
        /// <summary>
        /// The action the Batch service should take when all Tasks in the Job are in the completed state. If omitted, the completion
        /// behavior is left unchanged. You may not change the value from terminatejob to noaction - that is, once you have engaged
        /// automatic Job termination, you cannot turn it off again. If you try to do this, the request fails with an 'invalid property
        /// value' error response; if you are calling the REST API directly, the HTTP status code is 400 (Bad Request).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The action the Batch service should take when all Tasks in the Job are in the completed state. If omitted, the completion behavior is left unchanged. You may not change the value from terminatejob to noaction - that is, once you have engaged automatic Job termination, you cannot turn it off again. If you try to do this, the request fails with an 'invalid property value' error response; if you are calling the REST API directly, the HTTP status code is 400 (Bad Request).",
        SerializedName = @"onAllTasksComplete",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("noaction", "terminatejob")]
        string AllTasksCompleteMode { get; set; }
        /// <summary>
        /// Whether Tasks in this job can be preempted by other high priority jobs. If the value is set to True, other high priority
        /// jobs submitted to the system will take precedence and will be able requeue tasks from this job. You can update a job's
        /// allowTaskPreemption after it has been created using the update job API.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Whether Tasks in this job can be preempted by other high priority jobs. If the value is set to True, other high priority jobs submitted to the system will take precedence and will be able requeue tasks from this job. You can update a job's allowTaskPreemption after it has been created using the update job API.",
        SerializedName = @"allowTaskPreemption",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AllowTaskPreemption { get; set; }
        /// <summary>
        /// A prefix to be added to the unique identifier when a Pool is automatically created. The Batch service assigns each auto
        /// Pool a unique identifier on creation. To distinguish between Pools created for different purposes, you can specify this
        /// element to add a prefix to the ID that is assigned. The prefix can be up to 20 characters long.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"A prefix to be added to the unique identifier when a Pool is automatically created. The Batch service assigns each auto Pool a unique identifier on creation. To distinguish between Pools created for different purposes, you can specify this element to add a prefix to the ID that is assigned. The prefix can be up to 20 characters long.",
        SerializedName = @"autoPoolIdPrefix",
        PossibleTypes = new [] { typeof(string) })]
        string AutoPoolSpecificationAutoPoolIdPrefix { get; set; }
        /// <summary>
        /// Whether to keep an auto Pool alive after its lifetime expires. If false, the Batch service deletes the Pool once its lifetime
        /// (as determined by the poolLifetimeOption setting) expires; that is, when the Job or Job Schedule completes. If true, the
        /// Batch service does not delete the Pool automatically. It is up to the user to delete auto Pools created with this option.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Whether to keep an auto Pool alive after its lifetime expires. If false, the Batch service deletes the Pool once its lifetime (as determined by the poolLifetimeOption setting) expires; that is, when the Job or Job Schedule completes. If true, the Batch service does not delete the Pool automatically. It is up to the user to delete auto Pools created with this option.",
        SerializedName = @"keepAlive",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AutoPoolSpecificationKeepAlive { get; set; }
        /// <summary>The Pool specification for the auto Pool.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The Pool specification for the auto Pool.",
        SerializedName = @"pool",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolSpecificationUpdate) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolSpecificationUpdate AutoPoolSpecificationPool { get; set; }
        /// <summary>
        /// The minimum lifetime of created auto Pools, and how multiple Jobs on a schedule are assigned to Pools.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The minimum lifetime of created auto Pools, and how multiple Jobs on a schedule are assigned to Pools.",
        SerializedName = @"poolLifetimeOption",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("jobschedule", "job")]
        string AutoPoolSpecificationPoolLifetimeOption { get; set; }
        /// <summary>
        /// The maximum number of times each Task may be retried. The Batch service retries a Task if its exit code is nonzero. Note
        /// that this value specifically controls the number of retries. The Batch service will try each Task once, and may then retry
        /// up to this limit. For example, if the maximum retry count is 3, Batch tries a Task up to 4 times (one initial try and
        /// 3 retries). If the maximum retry count is 0, the Batch service does not retry Tasks. If the maximum retry count is -1,
        /// the Batch service retries Tasks without limit. The default value is 0 (no retries).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The maximum number of times each Task may be retried. The Batch service retries a Task if its exit code is nonzero. Note that this value specifically controls the number of retries. The Batch service will try each Task once, and may then retry up to this limit. For example, if the maximum retry count is 3, Batch tries a Task up to 4 times (one initial try and 3 retries). If the maximum retry count is 0, the Batch service does not retry Tasks. If the maximum retry count is -1, the Batch service retries Tasks without limit. The default value is 0 (no retries).",
        SerializedName = @"maxTaskRetryCount",
        PossibleTypes = new [] { typeof(int) })]
        int? ConstraintMaxTaskRetryCount { get; set; }
        /// <summary>
        /// The maximum elapsed time that the Job may run, measured from the time the Job is created. If the Job does not complete
        /// within the time limit, the Batch service terminates it and any Tasks that are still running. In this case, the termination
        /// reason will be MaxWallClockTimeExpiry. If this property is not specified, there is no time limit on how long the Job may
        /// run.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The maximum elapsed time that the Job may run, measured from the time the Job is created. If the Job does not complete within the time limit, the Batch service terminates it and any Tasks that are still running. In this case, the termination reason will be MaxWallClockTimeExpiry. If this property is not specified, there is no time limit on how long the Job may run.",
        SerializedName = @"maxWallClockTime",
        PossibleTypes = new [] { typeof(global::System.TimeSpan) })]
        global::System.TimeSpan? ConstraintMaxWallClockTime { get; set; }
        /// <summary>
        /// The maximum number of tasks that can be executed in parallel for the job. The value of maxParallelTasks must be -1 or
        /// greater than 0 if specified. If not specified, the default value is -1, which means there's no limit to the number of
        /// tasks that can be run at once. You can update a job's maxParallelTasks after it has been created using the update job
        /// API.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The maximum number of tasks that can be executed in parallel for the job. The value of maxParallelTasks must be -1 or greater than 0 if specified. If not specified, the default value is -1, which means there's no limit to the number of tasks that can be run at once. You can update a job's maxParallelTasks after it has been created using the update job API.",
        SerializedName = @"maxParallelTasks",
        PossibleTypes = new [] { typeof(int) })]
        int? MaxParallelTask { get; set; }
        /// <summary>
        /// A list of name-value pairs associated with the Job as metadata. If omitted, the existing Job metadata is left unchanged.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"A list of name-value pairs associated with the Job as metadata. If omitted, the existing Job metadata is left unchanged.",
        SerializedName = @"metadata",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchMetadataItem) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchMetadataItem> Metadata { get; set; }
        /// <summary>
        /// Whether to withdraw Compute Nodes from the virtual network to DNC when the job is terminated or deleted. If true, nodes
        /// will remain joined to the virtual network to DNC. If false, nodes will automatically withdraw when the job ends. Defaults
        /// to false.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Whether to withdraw Compute Nodes from the virtual network to DNC when the job is terminated or deleted.  If true, nodes will remain joined to the virtual network to DNC. If false, nodes will automatically withdraw when the job ends. Defaults to false.",
        SerializedName = @"skipWithdrawFromVNet",
        PossibleTypes = new [] { typeof(bool) })]
        bool? NetworkConfigurationSkipWithdrawFromVnet { get; set; }
        /// <summary>
        /// The ARM resource identifier of the virtual network subnet which Compute Nodes running Tasks from the Job will join for
        /// the duration of the Task. The virtual network must be in the same region and subscription as the Azure Batch Account.
        /// The specified subnet should have enough free IP addresses to accommodate the number of Compute Nodes which will run Tasks
        /// from the Job. This can be up to the number of Compute Nodes in the Pool. The 'MicrosoftAzureBatch' service principal must
        /// have the 'Classic Virtual Machine Contributor' Role-Based Access Control (RBAC) role for the specified VNet so that Azure
        /// Batch service can schedule Tasks on the Nodes. This can be verified by checking if the specified VNet has any associated
        /// Network Security Groups (NSG). If communication to the Nodes in the specified subnet is denied by an NSG, then the Batch
        /// service will set the state of the Compute Nodes to unusable. This is of the form /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
        /// If the specified VNet has any associated Network Security Groups (NSG), then a few reserved system ports must be enabled
        /// for inbound communication from the Azure Batch service. For Pools created with a Virtual Machine configuration, enable
        /// ports 29876 and 29877, as well as port 22 for Linux and port 3389 for Windows. Port 443 is also required to be open for
        /// outbound connections for communications to Azure Storage. For more details see: https://learn.microsoft.com/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The ARM resource identifier of the virtual network subnet which Compute Nodes running Tasks from the Job will join for the duration of the Task. The virtual network must be in the same region and subscription as the Azure Batch Account. The specified subnet should have enough free IP addresses to accommodate the number of Compute Nodes which will run Tasks from the Job. This can be up to the number of Compute Nodes in the Pool. The 'MicrosoftAzureBatch' service principal must have the 'Classic Virtual Machine Contributor' Role-Based Access Control (RBAC) role for the specified VNet so that Azure Batch service can schedule Tasks on the Nodes. This can be verified by checking if the specified VNet has any associated Network Security Groups (NSG). If communication to the Nodes in the specified subnet is denied by an NSG, then the Batch service will set the state of the Compute Nodes to unusable. This is of the form /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}. If the specified VNet has any associated Network Security Groups (NSG), then a few reserved system ports must be enabled for inbound communication from the Azure Batch service. For Pools created with a Virtual Machine configuration, enable ports 29876 and 29877, as well as port 22 for Linux and port 3389 for Windows. Port 443 is also required to be open for outbound connections for communications to Azure Storage. For more details see: https://learn.microsoft.com/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.",
        SerializedName = @"subnetId",
        PossibleTypes = new [] { typeof(string) })]
        string NetworkConfigurationSubnetId { get; set; }
        /// <summary>
        /// The ID of an existing Pool. All the Tasks of the Job will run on the specified Pool. You must ensure that the Pool referenced
        /// by this property exists. If the Pool does not exist at the time the Batch service tries to schedule a Job, no Tasks for
        /// the Job will run until you create a Pool with that id. Note that the Batch service will not reject the Job request; it
        /// will simply not run Tasks until the Pool exists. You must specify either the Pool ID or the auto Pool specification, but
        /// not both.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The ID of an existing Pool. All the Tasks of the Job will run on the specified Pool. You must ensure that the Pool referenced by this property exists. If the Pool does not exist at the time the Batch service tries to schedule a Job, no Tasks for the Job will run until you create a Pool with that id. Note that the Batch service will not reject the Job request; it will simply not run Tasks until the Pool exists. You must specify either the Pool ID or the auto Pool specification, but not both.",
        SerializedName = @"poolId",
        PossibleTypes = new [] { typeof(string) })]
        string PoolInfoPoolId { get; set; }
        /// <summary>
        /// The priority of the Job. Priority values can range from -1000 to 1000, with -1000 being the lowest priority and 1000 being
        /// the highest priority. If omitted, the priority of the Job is left unchanged.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The priority of the Job. Priority values can range from -1000 to 1000, with -1000 being the lowest priority and 1000 being the highest priority. If omitted, the priority of the Job is left unchanged.",
        SerializedName = @"priority",
        PossibleTypes = new [] { typeof(int) })]
        int? Priority { get; set; }

    }
    /// Parameters for updating an Azure Batch Job.
    internal partial interface IBatchJobUpdateOptionsInternal

    {
        /// <summary>
        /// The action the Batch service should take when all Tasks in the Job are in the completed state. If omitted, the completion
        /// behavior is left unchanged. You may not change the value from terminatejob to noaction - that is, once you have engaged
        /// automatic Job termination, you cannot turn it off again. If you try to do this, the request fails with an 'invalid property
        /// value' error response; if you are calling the REST API directly, the HTTP status code is 400 (Bad Request).
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("noaction", "terminatejob")]
        string AllTasksCompleteMode { get; set; }
        /// <summary>
        /// Whether Tasks in this job can be preempted by other high priority jobs. If the value is set to True, other high priority
        /// jobs submitted to the system will take precedence and will be able requeue tasks from this job. You can update a job's
        /// allowTaskPreemption after it has been created using the update job API.
        /// </summary>
        bool? AllowTaskPreemption { get; set; }
        /// <summary>
        /// A prefix to be added to the unique identifier when a Pool is automatically created. The Batch service assigns each auto
        /// Pool a unique identifier on creation. To distinguish between Pools created for different purposes, you can specify this
        /// element to add a prefix to the ID that is assigned. The prefix can be up to 20 characters long.
        /// </summary>
        string AutoPoolSpecificationAutoPoolIdPrefix { get; set; }
        /// <summary>
        /// Whether to keep an auto Pool alive after its lifetime expires. If false, the Batch service deletes the Pool once its lifetime
        /// (as determined by the poolLifetimeOption setting) expires; that is, when the Job or Job Schedule completes. If true, the
        /// Batch service does not delete the Pool automatically. It is up to the user to delete auto Pools created with this option.
        /// </summary>
        bool? AutoPoolSpecificationKeepAlive { get; set; }
        /// <summary>The Pool specification for the auto Pool.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolSpecificationUpdate AutoPoolSpecificationPool { get; set; }
        /// <summary>
        /// The minimum lifetime of created auto Pools, and how multiple Jobs on a schedule are assigned to Pools.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Batch.PSArgumentCompleterAttribute("jobschedule", "job")]
        string AutoPoolSpecificationPoolLifetimeOption { get; set; }
        /// <summary>
        /// The execution constraints for the Job. If omitted, the existing execution constraints are left unchanged.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobConstraints Constraint { get; set; }
        /// <summary>
        /// The maximum number of times each Task may be retried. The Batch service retries a Task if its exit code is nonzero. Note
        /// that this value specifically controls the number of retries. The Batch service will try each Task once, and may then retry
        /// up to this limit. For example, if the maximum retry count is 3, Batch tries a Task up to 4 times (one initial try and
        /// 3 retries). If the maximum retry count is 0, the Batch service does not retry Tasks. If the maximum retry count is -1,
        /// the Batch service retries Tasks without limit. The default value is 0 (no retries).
        /// </summary>
        int? ConstraintMaxTaskRetryCount { get; set; }
        /// <summary>
        /// The maximum elapsed time that the Job may run, measured from the time the Job is created. If the Job does not complete
        /// within the time limit, the Batch service terminates it and any Tasks that are still running. In this case, the termination
        /// reason will be MaxWallClockTimeExpiry. If this property is not specified, there is no time limit on how long the Job may
        /// run.
        /// </summary>
        global::System.TimeSpan? ConstraintMaxWallClockTime { get; set; }
        /// <summary>
        /// The maximum number of tasks that can be executed in parallel for the job. The value of maxParallelTasks must be -1 or
        /// greater than 0 if specified. If not specified, the default value is -1, which means there's no limit to the number of
        /// tasks that can be run at once. You can update a job's maxParallelTasks after it has been created using the update job
        /// API.
        /// </summary>
        int? MaxParallelTask { get; set; }
        /// <summary>
        /// A list of name-value pairs associated with the Job as metadata. If omitted, the existing Job metadata is left unchanged.
        /// </summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchMetadataItem> Metadata { get; set; }
        /// <summary>The network configuration for the Job.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchJobNetworkConfigurationUpdate NetworkConfiguration { get; set; }
        /// <summary>
        /// Whether to withdraw Compute Nodes from the virtual network to DNC when the job is terminated or deleted. If true, nodes
        /// will remain joined to the virtual network to DNC. If false, nodes will automatically withdraw when the job ends. Defaults
        /// to false.
        /// </summary>
        bool? NetworkConfigurationSkipWithdrawFromVnet { get; set; }
        /// <summary>
        /// The ARM resource identifier of the virtual network subnet which Compute Nodes running Tasks from the Job will join for
        /// the duration of the Task. The virtual network must be in the same region and subscription as the Azure Batch Account.
        /// The specified subnet should have enough free IP addresses to accommodate the number of Compute Nodes which will run Tasks
        /// from the Job. This can be up to the number of Compute Nodes in the Pool. The 'MicrosoftAzureBatch' service principal must
        /// have the 'Classic Virtual Machine Contributor' Role-Based Access Control (RBAC) role for the specified VNet so that Azure
        /// Batch service can schedule Tasks on the Nodes. This can be verified by checking if the specified VNet has any associated
        /// Network Security Groups (NSG). If communication to the Nodes in the specified subnet is denied by an NSG, then the Batch
        /// service will set the state of the Compute Nodes to unusable. This is of the form /subscriptions/{subscription}/resourceGroups/{group}/providers/{provider}/virtualNetworks/{network}/subnets/{subnet}.
        /// If the specified VNet has any associated Network Security Groups (NSG), then a few reserved system ports must be enabled
        /// for inbound communication from the Azure Batch service. For Pools created with a Virtual Machine configuration, enable
        /// ports 29876 and 29877, as well as port 22 for Linux and port 3389 for Windows. Port 443 is also required to be open for
        /// outbound connections for communications to Azure Storage. For more details see: https://learn.microsoft.com/azure/batch/batch-api-basics#virtual-network-vnet-and-firewall-configuration.
        /// </summary>
        string NetworkConfigurationSubnetId { get; set; }
        /// <summary>
        /// The Pool on which the Batch service runs the Job's Tasks. You may change the Pool for a Job only when the Job is disabled.
        /// The Patch Job call will fail if you include the poolInfo element and the Job is not disabled. If you specify an autoPoolSpecification
        /// in the poolInfo, only the keepAlive property of the autoPoolSpecification can be updated, and then only if the autoPoolSpecification
        /// has a poolLifetimeOption of Job (other job properties can be updated as normal). If omitted, the Job continues to run
        /// on its current Pool.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchPoolInfoUpdate PoolInfo { get; set; }
        /// <summary>
        /// Characteristics for a temporary 'auto pool'. The Batch service will create this auto Pool when the Job is submitted. If
        /// auto Pool creation fails, the Batch service moves the Job to a completed state, and the Pool creation error is set in
        /// the Job's scheduling error property. The Batch service manages the lifetime (both creation and, unless keepAlive is specified,
        /// deletion) of the auto Pool. Any user actions that affect the lifetime of the auto Pool while the Job is active will result
        /// in unexpected behavior. You must specify either the Pool ID or the auto Pool specification, but not both.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.IBatchAutoPoolSpecificationUpdate PoolInfoAutoPoolSpecification { get; set; }
        /// <summary>
        /// The ID of an existing Pool. All the Tasks of the Job will run on the specified Pool. You must ensure that the Pool referenced
        /// by this property exists. If the Pool does not exist at the time the Batch service tries to schedule a Job, no Tasks for
        /// the Job will run until you create a Pool with that id. Note that the Batch service will not reject the Job request; it
        /// will simply not run Tasks until the Pool exists. You must specify either the Pool ID or the auto Pool specification, but
        /// not both.
        /// </summary>
        string PoolInfoPoolId { get; set; }
        /// <summary>
        /// The priority of the Job. Priority values can range from -1000 to 1000, with -1000 being the lowest priority and 1000 being
        /// the highest priority. If omitted, the priority of the Job is left unchanged.
        /// </summary>
        int? Priority { get; set; }

    }
}