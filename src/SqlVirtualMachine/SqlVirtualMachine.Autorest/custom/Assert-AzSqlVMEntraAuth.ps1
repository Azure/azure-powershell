
# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Code generated by Microsoft (R) AutoRest Code Generator.Changes may cause incorrect behavior and will be lost if the code
# is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Validates a SQL virtual machine Entra Authentication.
.Description
Validates a SQL virtual machine Entra Authentication.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Models.ISqlVirtualMachineIdentity
.Outputs
Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <ISqlVirtualMachineIdentity>: Identity Parameter
  [AvailabilityGroupListenerName <String>]: Name of the availability group listener.
  [Id <String>]: Resource identity path
  [ResourceGroupName <String>]: Name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
  [SqlVirtualMachineGroupName <String>]: Name of the SQL virtual machine group.
  [SqlVirtualMachineName <String>]: Name of the SQL virtual machine.
  [SubscriptionId <String>]: Subscription ID that identifies an Azure subscription.

.Link
https://learn.microsoft.com/powershell/module/az.sqlvirtualmachine/Assert-AzSqlVMEntraAuth
#>
function Assert-AzSqlVMEntraAuth {
    [CmdletBinding(DefaultParameterSetName = 'AssertExpanded', PositionalBinding = $false, SupportsShouldProcess, ConfirmImpact = 'Medium')]
    [OutputType([bool])]
    param(
        [Parameter(ParameterSetName = 'AssertExpanded', Mandatory)]
        [Alias('SqlVirtualMachineName', 'SqlVMName')]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category('Path')]
        [System.String]
        # Name of the SQL virtual machine.
        ${Name},

        [Parameter(ParameterSetName = 'AssertExpanded', Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category('Path')]
        [System.String]
        # Name of the resource group that contains the resource.
        # You can obtain this value from the Azure Resource Manager API or the portal.
        ${ResourceGroupName},

        [Parameter(ParameterSetName = 'AssertExpanded')]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.DefaultInfo(Script = '(Get-AzContext).Subscription.Id')]
        [System.String]
        # Subscription ID that identifies an Azure subscription.
        ${SubscriptionId},

        [Parameter(ParameterSetName = 'AssertViaIdentity', Mandatory, ValueFromPipeline)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Models.ISqlVirtualMachineIdentity]
        # Identity Parameter
        # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
        ${InputObject},
	
        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category('Body')]
        [System.String]
        # The client Id of the Managed Identity to query Microsoft Graph API.
        ${ManagedIdentityClientId},

        [Parameter(Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category('Body')]
        [System.String]
        # Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        ${IdentityType},	    

        [Parameter()]
        [Alias('AzureRMContext', 'AzureCredential')]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category('Azure')]
        [System.Management.Automation.PSObject]
        # The credentials, account, tenant, and subscription used for communication with Azure.
        ${DefaultProfile},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Run the command as a job
        ${AsJob},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Wait for .NET debugger to attach
        ${Break},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be appended to the front of the pipeline
        ${HttpPipelineAppend},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be prepended to the front of the pipeline
        ${HttpPipelinePrepend},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Run the command asynchronously
        ${NoWait},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category('Runtime')]
        [System.Uri]
        # The URI for the proxy server to use
        ${Proxy},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category('Runtime')]
        [System.Management.Automation.PSCredential]
        # Credentials for a proxy server to use for the remote call
        ${ProxyCredential},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Use the default credentials for the proxy
        ${ProxyUseDefaultCredentials}
    )

    process {
        
        try {
            $hasInputObject = $PSBoundParameters.Remove('InputObject')

            $null = $PSBoundParameters.Remove('ManagedIdentityClientId')
            $null = $PSBoundParameters.Remove('IdentityType')
        
            $hasAsJob = $PSBoundParameters.Remove('AsJob')
            $null = $PSBoundParameters.Remove('WhatIf')
            $null = $PSBoundParameters.Remove('Confirm')

            if ($hasInputObject) {
                $sqlvm = Get-AzSqlVM -InputObject $InputObject @PSBoundParameters
            }
            else {
                $sqlvm = Get-AzSqlVM @PSBoundParameters
            }
            $null = $PSBoundParameters.Remove('InputObject')
            $null = $PSBoundParameters.Remove('ResourceGroupName')
            $null = $PSBoundParameters.Remove('Name')
            $null = $PSBoundParameters.Remove('SubscriptionId')		
		
            if ($hasAsJob) {
                $PSBoundParameters.Add('AsJob', $true)
            }				
		
            $resourceId = $sqlvm.Id
            $subId = ($resourceId -split '/')[2] #subscription id from vm object
            if ($PSCmdlet.ShouldProcess("SQL virtual machine $($sqlvm.Name)", "Assert")) {
                if ($IdentityType -ne 'SystemAssigned' -and $IdentityType -ne 'UserAssigned') {
                    # If the value is neither 'SystemAssigned' nor 'UserAssigned', throw an error
                    throw "IdentityType is invalid. The supported types are SystemAssigned or UserAssigned."
                }
                else { 
                    Assert-All -VmName $sqlvm.Name -ResourceGroup $sqlvm.ResourceGroupName -MsiClientId $ManagedIdentityClientId -IdentityType $IdentityType -SubscriptionId $subId
                    Write-Output $true
                    return
                }
            }
        }
        catch {
            throw
        }
    }
}

<#
    .SYNOPSIS
    Given a VM, check if it's eligible for Azure Entra authentication
	
	.Description
	Given a VM, check if it's eligible for Azure Entra authentication

    .PARAMETER VmName
    Name of the VM

    .PARAMETER ResourceGroup
    Name of the resource group

    .PARAMETER SubscriptionId
    Subscription Id
    
    .PARAMETER MsiClientId
    The client Id of the Managed Identity to query Microsoft Graph API.
    
    .PARAMETER IdentityType
    Type of managed service identity   

    .OUTPUTS
    bool if the validation passed or not
#>
function Assert-All {	
    [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.DoNotExportAttribute()]
    param(
        [Parameter(Mandatory = $true)]
        [string] $VmName,
        [Parameter(Mandatory = $true)]
        [string] $ResourceGroup,
		[Parameter(Mandatory = $true)]
        [string] $SubscriptionId,
        [Parameter(Mandatory = $false)]
        [string] $MsiClientId,
        [Parameter(Mandatory = $false)]
        [string] $IdentityType)

    # All validations go here
    if ($IdentityType -eq 'SystemAssigned' -and -not($null -eq $MsiClientId -or $MsiClientId -eq '')) {
        Write-Error "Enable Azure Entra authentication with system-assigned managed identity, but the ManagedIdentityClientId is also provided." -ErrorAction Stop
    }
    if ($IdentityType -eq 'UserAssigned' -and ($null -eq $MsiClientId -or $MsiClientId -eq '')) {
        Write-Error "ManagedIdentityClientId should not be empty or null when using UserAssigned type." -ErrorAction Stop
    }

    # validate the SQL VM supports Azure Entra authentication, i.e. it is on Windows platform and is SQL 2022 or later    
    $null = Assert-SqlVMversion -ResourceGroupName $ResourceGroup -SqlVirtualMachineName $VmName -SubscriptionId $SubscriptionId
    # validate the MSI is valid on the Azure virtual machine
    $PrincipalId = Assert-MsiValidity -ResourceGroupName $ResourceGroup -SqlVirtualMachineName $VmName -MsiClientId $MsiClientId -SubscriptionId $SubscriptionId
    # validate the MSI has appropriate permission to query Microsoft Graph API
    $null = Assert-MsiWithEnoughPermission -PrincipalId $PrincipalId
    Write-Host "Sql virtual machine $($sqlvm.Name) is valid for Azure Entra authentication."
}

<#
    .SYNOPSIS
    Check if SQL VM version is minimum SQL2022
	
	.Description
	Check if SQL VM version is minimum SQL2022

    .PARAMETER SqlVirtualMachineName
    Name of the VM

    .PARAMETER ResourceGroupName
    Name of the resource group

    .PARAMETER SubscriptionId
    Subscription Id   
#>
function Assert-SqlVMversion {
    [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.DoNotExportAttribute()]
    param(
	    [Parameter(Mandatory = $true)]
        [string] $SubscriptionId,
        [Parameter(Mandatory = $true)]
        [string] $ResourceGroupName,
        [Parameter(Mandatory = $true)]
        [string] $SqlVirtualMachineName
    )
    try {
    # Get the SQL VM instance
	$vmExtensionName = 'SqlIaasExtension'
    $path = "/subscriptions/$SubscriptionId/resourceGroups/$ResourceGroupName/providers/Microsoft.Compute/virtualMachines/$SqlVirtualMachineName/extensions/$vmExtensionName" + "?`$expand=instanceView&api-version=2024-03-01"
	$jsonObject = Invoke-AzRestMethod -Method GET -Path $path | Select-Object -ExpandProperty Content | ConvertFrom-Json
    $resourceProviderPluginStatus = $jsonObject.properties.instanceView.substatuses | Where-Object { $_.code -like "*Resource Provider Plugin*"} 

    if ($resourceProviderPluginStatus) {
        $sqlVersion = $resourceProviderPluginStatus | Select-Object @{Name = 'SqlVersion'; Expression = { $_.Message | ConvertFrom-Json | Select-Object -ExpandProperty SqlVersion } }
        $osVersion = $resourceProviderPluginStatus | Select-Object @{Name = 'OSVersion'; Expression = { $_.Message | ConvertFrom-Json | Select-Object -ExpandProperty OSVersion } }
    } else {
        throw "Please make sure the VM is up and running."
    }
}
catch {
    throw "Unable to validate Azure Entra authentication due to an error: $_"
}

# Construct error message for unsupported SQL server version or OS platform.
$unsupportedError = "Azure Entra authentication requires SQL Server 2022 on Windows platform, but the current version of this SQL VM is $($sqlVersion.SqlVersion) - $($osVersion.OSVersion)"
	
if (-not $sqlVersion -or -not $osVersion) {
    throw $unsupportedError
}

try {
    $intVersion = [int]($sqlVersion.SqlVersion.Substring(3))
}
catch {
    throw $unsupportedError
}

if ($intVersion -lt 2022 -or -not $osVersion.OSVersion.StartsWith("WS")) {
    $unsupportedError += "`n Recommendation: Upgrade SQL Server to SQL Server 2022 or later."
    throw $unsupportedError
}
}

<#
    .SYNOPSIS
    Validate the provided MSI is associated with SQL VM or not
	
	.Description
	Validate the provided MSI is associated with SQL VM or not

    .PARAMETER SqlVirtualMachineName
    Name of the VM

    .PARAMETER ResourceGroupName
    Name of the resource group
	
	.PARAMETER MsiClientId
    Msi Client Id

    .PARAMETER SubscriptionId
    Subscription Id  
#>
function Assert-MsiValidity {
    [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.DoNotExportAttribute()]
    param(
        [Parameter(Mandatory = $true)]
        [string] $SubscriptionId,
        [Parameter(Mandatory = $true)]
        [string] $ResourceGroupName,
        [Parameter(Mandatory = $true)]
        [string] $SqlVirtualMachineName,
        [Parameter(Mandatory = $false)]
        [string] $MsiClientId
    )

    try {
        # Get the VM instance
        $path = "/subscriptions/$SubscriptionId/resourceGroups/$ResourceGroupName/providers/Microsoft.Compute/virtualMachines/$SqlVirtualMachineName/" + "?`$expand=instanceView&api-version=2024-03-01"
        $vm = Invoke-AzRestMethod -Method GET -Path $path | Select-Object -ExpandProperty Content | ConvertFrom-Json
    }
    catch {
        throw "Unable to validate Azure Entra authentication due to retrieving the Azure virtual machine instance encountering an error: $_"
    }

    # The system-assigned MSI case.
    if ($IdentityType -eq 'SystemAssigned') {
        if ($null -eq $vm.Identity -or $null -eq $vm.Identity.PrincipalId) {
            $azError = "Enable Azure Entra authentication with system-assigned managed identity, but the system-assigned managed identity is not enabled on this Azure virtual machine."
            $azError += "`n Recommendation: Enable the system-assigned managed identity on the Azure virtual machine: $SqlVirtualMachineName."
            throw $azError
        }

        return $vm.Identity.PrincipalId
    }

    # The user-assigned MSI case.
    if ($IdentityType -eq 'UserAssigned') {
    if ($null -eq $vm.Identity -or $null -eq $vm.Identity.UserAssignedIdentities) {
        $azError = "Enable Azure Entra authentication with user-assigned managed identity '$MsiClientId', but the managed identity is not attached to this Azure virtual machine."
        $azError += "`n Recommendation: Attach the user-assigned managed identity '$MsiClientId' to the Azure virtual machine $SqlVirtualMachineName."
        throw $azError
    }

    foreach ($key in $vm.identity.userAssignedIdentities.PSObject.Properties.Name) {
        $identity = $vm.identity.userAssignedIdentities.$key
        if ($identity.clientId -eq $MsiClientId) {
            return $identity.principalId
        }
    }
	
    $azError = "Enable Azure Entra authentication with user-assigned managed identity '$MsiClientId', but the managed identity is not attached to this Azure virtual machine."
    $azError += "`n Recommendation: Attach the user-assigned managed identity '$MsiClientId' to the Azure virtual machine $SqlVirtualMachineName."
    throw $azError
    }
}

<#
    .SYNOPSIS
    Validate the provided MSI has required permissions or not
	
	.Description
	Validate the provided MSI has required permissions or not
	
	.PARAMETER PrincipalId
    Msi Principal Id
#>
function Assert-MsiWithEnoughPermission {    
    [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.DoNotExportAttribute()]
    param(
        [Parameter(Mandatory = $true)]
        [string] $PrincipalId
    )    
		
    # Get directory roles assigned to the MSI
    $directoryRoles = Get-DirectoryRoleList -PrincipalId $PrincipalId

    # Check if the MSI has the "Directory Readers" role
    if ($directoryRoles.displayName -contains "Directory Readers") {
        return
    }

    # Retrieve app role IDs for required roles
    $appRoleIdMap = Find-RoleId

    # Retrieve all assigned app role IDs for the MSI
    $allAssignedRoleIds = Get-AssignedAppRoleList -PrincipalId $PrincipalId

    # Find missing roles
    $missingRoles = @("User.Read.All", "Application.Read.All", "GroupMember.Read.All") | Where-Object { $appRoleIdMap[$_] -notin $allAssignedRoleIds }

    if ($missingRoles.Count -gt 0) {
        $azError = "The managed identity is lacking the following roles for Azure Entra authentication: $($missingRoles -join ', ')."
        $azError += "`n Recommendation: Grant the managed identity EITHER the Directory.Readers role OR the three App roles 'User.Read.All', 'Application.Read.All', 'GroupMember.Read.All'"
        throw $azError
    }		
}

function Find-RoleId {
    [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.DoNotExportAttribute()]
    param()
    try {
        $graphurl = (Get-AzContext).Environment.ExtendedProperties.MicrosoftGraphUrl
        $uri = $graphurl + "/v1.0/servicePrincipals?" + "`$filter=displayName eq 'Microsoft Graph'"
        $result = Invoke-AzRestMethod -Method GET -Uri $uri | Select-Object -ExpandProperty Content | ConvertFrom-Json
        $servicePrincipals = $result.value

    }
    catch {
        throw "Querying Microsoft Graph API failed to find the service principal of Microsoft Graph Application: $_"
    }

    # If we failed to find the Microsoft Graph service application, fail the validation.
    if (!$servicePrincipals) {
        throw "Querying Microsoft Graph API failed to find the service principal of Microsoft Graph Application"
    }

    $appRoleIdMap = @{
        "User.Read.All"        = $null
        "Application.Read.All" = $null
        "GroupMember.Read.All" = $null
    }

    foreach ($appRole in $servicePrincipals.appRoles) {
        $roleName = $appRole.value
        if ($appRoleIdMap.ContainsKey($roleName)) {
            $appRoleIdMap[$roleName] = $appRole.id
        }
    }

    # If we failed to find all role definitions, fail the validation.
    $missingRoleDefs = $appRoleIdMap.Keys | Where-Object {$null -eq $appRoleIdMap[$_]}

    if ($missingRoleDefs) {
        $errorMessage = "Querying Microsoft Graph API failed to find the following roles: $($missingRoleDefs -join ', ')"
        Write-Warning $errorMessage
        throw $errorMessage
    }

    return $appRoleIdMap
}

function Get-DirectoryRoleList {	    
    [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.DoNotExportAttribute()]
    param(
        [Parameter(Mandatory = $true)]
        [string] $PrincipalId
    )
	
    try {
        $graphurl = (Get-AzContext).Environment.ExtendedProperties.MicrosoftGraphUrl
        $uri = $graphurl + "/v1.0/servicePrincipals/$PrincipalId/transitiveMemberOf/microsoft.graph.directoryRole"
        $RoleList = Invoke-AzRestMethod -Method GET -Uri $uri | Select-Object -ExpandProperty Content | ConvertFrom-Json
        return $RoleList.value
    }
    catch {
        throw "Microsoft Graph API Error: $_"
    }
}

function Get-AssignedAppRoleList {	    
    [Microsoft.Azure.PowerShell.Cmdlets.SqlVirtualMachine.DoNotExportAttribute()]
    param(
        [Parameter(Mandatory = $true)]
        [string] $PrincipalId
    )
	
    try {
        $graphurl = (Get-AzContext).Environment.ExtendedProperties.MicrosoftGraphUrl
        $uri = $graphurl + "/v1.0/servicePrincipals/$PrincipalId/appRoleAssignments"
        $RoleList = Invoke-AzRestMethod -Method GET -Uri $uri | Select-Object -ExpandProperty Content | ConvertFrom-Json
        return $RoleList.value.AppRoleId
    }
    catch {
        throw "Microsoft Graph API Error: $_"
    }
}