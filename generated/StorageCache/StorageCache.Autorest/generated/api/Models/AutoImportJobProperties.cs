// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models
{
    using static Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Extensions;

    /// <summary>Properties of the auto import job.</summary>
    public partial class AutoImportJobProperties :
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobProperties,
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal
    {

        /// <summary>Backing field for <see cref="AdminStatus" /> property.</summary>
        private string _adminStatus;

        /// <summary>
        /// The administrative status of the auto import job. Possible values: 'Enable', 'Disable'. Passing in a value of 'Disable'
        /// will disable the current active auto import job. By default it is set to 'Enable'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        public string AdminStatus { get => this._adminStatus; set => this._adminStatus = value; }

        /// <summary>Backing field for <see cref="AutoImportPrefix" /> property.</summary>
        private System.Collections.Generic.List<string> _autoImportPrefix;

        /// <summary>
        /// An array of blob paths/prefixes that get auto imported to the cluster namespace. It has '/' as the default value. Number
        /// of maximum allowed paths is 100.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        public System.Collections.Generic.List<string> AutoImportPrefix { get => this._autoImportPrefix; set => this._autoImportPrefix = value; }

        /// <summary>Backing field for <see cref="ConflictResolutionMode" /> property.</summary>
        private string _conflictResolutionMode;

        /// <summary>
        /// How the auto import job will handle conflicts. For example, if the auto import job is trying to bring in a directory,
        /// but a file is at that path, how it handles it. Fail indicates that the auto import job should stop immediately and not
        /// do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the auto
        /// import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or is currently released.
        /// OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please
        /// reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/blob-integration#conflict-resolution-mode for a
        /// thorough explanation of these resolution modes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        public string ConflictResolutionMode { get => this._conflictResolutionMode; set => this._conflictResolutionMode = value; }

        /// <summary>Backing field for <see cref="EnableDeletion" /> property.</summary>
        private bool? _enableDeletion;

        /// <summary>
        /// Whether or not to enable deletions during auto import. This only affects overwrite-dirty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        public bool? EnableDeletion { get => this._enableDeletion; set => this._enableDeletion = value; }

        /// <summary>Backing field for <see cref="MaximumError" /> property.</summary>
        private long? _maximumError;

        /// <summary>
        /// Total non-conflict-oriented errors (e.g., OS errors) Import will tolerate before exiting with failure. -1 means infinite.
        /// 0 means exit immediately on any error.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        public long? MaximumError { get => this._maximumError; set => this._maximumError = value; }

        /// <summary>Internal Acessors for ProvisioningState</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal.ProvisioningState { get => this._provisioningState; set { {_provisioningState = value;} } }

        /// <summary>Internal Acessors for Status</summary>
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesStatus Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal.Status { get => (this._status = this._status ?? new Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.AutoImportJobPropertiesStatus()); set { {_status = value;} } }

        /// <summary>Backing field for <see cref="ProvisioningState" /> property.</summary>
        private string _provisioningState;

        /// <summary>ARM provisioning state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        public string ProvisioningState { get => this._provisioningState; }

        /// <summary>Backing field for <see cref="Status" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesStatus _status;

        /// <summary>The status of the auto import job.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesStatus Status { get => (this._status = this._status ?? new Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.AutoImportJobPropertiesStatus()); }

        /// <summary>Creates an new <see cref="AutoImportJobProperties" /> instance.</summary>
        public AutoImportJobProperties()
        {

        }
    }
    /// Properties of the auto import job.
    public partial interface IAutoImportJobProperties :
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.IJsonSerializable
    {
        /// <summary>
        /// The administrative status of the auto import job. Possible values: 'Enable', 'Disable'. Passing in a value of 'Disable'
        /// will disable the current active auto import job. By default it is set to 'Enable'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The administrative status of the auto import job. Possible values: 'Enable', 'Disable'. Passing in a value of 'Disable' will disable the current active auto import job. By default it is set to 'Enable'.",
        SerializedName = @"adminStatus",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PSArgumentCompleterAttribute("Enable", "Disable")]
        string AdminStatus { get; set; }
        /// <summary>
        /// An array of blob paths/prefixes that get auto imported to the cluster namespace. It has '/' as the default value. Number
        /// of maximum allowed paths is 100.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = false,
        Description = @"An array of blob paths/prefixes that get auto imported to the cluster namespace. It has '/' as the default value. Number of maximum allowed paths is 100.",
        SerializedName = @"autoImportPrefixes",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> AutoImportPrefix { get; set; }
        /// <summary>
        /// How the auto import job will handle conflicts. For example, if the auto import job is trying to bring in a directory,
        /// but a file is at that path, how it handles it. Fail indicates that the auto import job should stop immediately and not
        /// do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the auto
        /// import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or is currently released.
        /// OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please
        /// reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/blob-integration#conflict-resolution-mode for a
        /// thorough explanation of these resolution modes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = false,
        Description = @"How the auto import job will handle conflicts. For example, if the auto import job is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the auto import job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the auto import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or is currently released. OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/blob-integration#conflict-resolution-mode for a thorough explanation of these resolution modes.",
        SerializedName = @"conflictResolutionMode",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PSArgumentCompleterAttribute("Fail", "Skip", "OverwriteIfDirty", "OverwriteAlways")]
        string ConflictResolutionMode { get; set; }
        /// <summary>
        /// Whether or not to enable deletions during auto import. This only affects overwrite-dirty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = false,
        Description = @"Whether or not to enable deletions during auto import. This only affects overwrite-dirty.",
        SerializedName = @"enableDeletions",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnableDeletion { get; set; }
        /// <summary>
        /// Total non-conflict-oriented errors (e.g., OS errors) Import will tolerate before exiting with failure. -1 means infinite.
        /// 0 means exit immediately on any error.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = false,
        Description = @"Total non-conflict-oriented errors (e.g., OS errors) Import will tolerate before exiting with failure. -1 means infinite. 0 means exit immediately on any error.",
        SerializedName = @"maximumErrors",
        PossibleTypes = new [] { typeof(long) })]
        long? MaximumError { get; set; }
        /// <summary>ARM provisioning state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"ARM provisioning state.",
        SerializedName = @"provisioningState",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PSArgumentCompleterAttribute("Succeeded", "Failed", "Creating", "Deleting", "Updating", "Canceled")]
        string ProvisioningState { get;  }
        /// <summary>The status of the auto import job.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The status of the auto import job.",
        SerializedName = @"status",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesStatus) })]
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesStatus Status { get;  }

    }
    /// Properties of the auto import job.
    internal partial interface IAutoImportJobPropertiesInternal

    {
        /// <summary>
        /// The administrative status of the auto import job. Possible values: 'Enable', 'Disable'. Passing in a value of 'Disable'
        /// will disable the current active auto import job. By default it is set to 'Enable'.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PSArgumentCompleterAttribute("Enable", "Disable")]
        string AdminStatus { get; set; }
        /// <summary>
        /// An array of blob paths/prefixes that get auto imported to the cluster namespace. It has '/' as the default value. Number
        /// of maximum allowed paths is 100.
        /// </summary>
        System.Collections.Generic.List<string> AutoImportPrefix { get; set; }
        /// <summary>
        /// How the auto import job will handle conflicts. For example, if the auto import job is trying to bring in a directory,
        /// but a file is at that path, how it handles it. Fail indicates that the auto import job should stop immediately and not
        /// do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the auto
        /// import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or is currently released.
        /// OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please
        /// reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/blob-integration#conflict-resolution-mode for a
        /// thorough explanation of these resolution modes.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PSArgumentCompleterAttribute("Fail", "Skip", "OverwriteIfDirty", "OverwriteAlways")]
        string ConflictResolutionMode { get; set; }
        /// <summary>
        /// Whether or not to enable deletions during auto import. This only affects overwrite-dirty.
        /// </summary>
        bool? EnableDeletion { get; set; }
        /// <summary>
        /// Total non-conflict-oriented errors (e.g., OS errors) Import will tolerate before exiting with failure. -1 means infinite.
        /// 0 means exit immediately on any error.
        /// </summary>
        long? MaximumError { get; set; }
        /// <summary>ARM provisioning state.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PSArgumentCompleterAttribute("Succeeded", "Failed", "Creating", "Deleting", "Updating", "Canceled")]
        string ProvisioningState { get; set; }
        /// <summary>The status of the auto import job.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesStatus Status { get; set; }

    }
}