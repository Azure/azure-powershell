// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models
{
    using static Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Extensions;

    /// <summary>
    /// An auto import job instance. Follows Azure Resource Manager standards: https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md
    /// </summary>
    public partial class AutoImportJob :
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJob,
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobInternal,
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.IValidates,
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.IHeaderSerializable
    {
        /// <summary>
        /// Backing field for Inherited model <see cref= "Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.ITrackedResource"
        /// />
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.ITrackedResource __trackedResource = new Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.TrackedResource();

        /// <summary>
        /// The administrative status of the auto import job. Possible values: 'Enable', 'Disable'. Passing in a value of 'Disable'
        /// will disable the current active auto import job. By default it is set to 'Enable'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inlined)]
        public string AdminStatus { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal)Property).AdminStatus; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal)Property).AdminStatus = value ?? null; }

        /// <summary>
        /// An array of blob paths/prefixes that get auto imported to the cluster namespace. It has '/' as the default value. Number
        /// of maximum allowed paths is 100.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> AutoImportPrefix { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal)Property).AutoImportPrefix; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal)Property).AutoImportPrefix = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="AzureAsyncOperation" /> property.</summary>
        private string _azureAsyncOperation;

        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        public string AzureAsyncOperation { get => this._azureAsyncOperation; set => this._azureAsyncOperation = value; }

        /// <summary>
        /// How the auto import job will handle conflicts. For example, if the auto import job is trying to bring in a directory,
        /// but a file is at that path, how it handles it. Fail indicates that the auto import job should stop immediately and not
        /// do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the auto
        /// import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or is currently released.
        /// OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please
        /// reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/blob-integration#conflict-resolution-mode for a
        /// thorough explanation of these resolution modes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inlined)]
        public string ConflictResolutionMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal)Property).ConflictResolutionMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal)Property).ConflictResolutionMode = value ?? null; }

        /// <summary>
        /// Whether or not to enable deletions during auto import. This only affects overwrite-dirty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inlined)]
        public bool? EnableDeletion { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal)Property).EnableDeletion; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal)Property).EnableDeletion = value ?? default(bool); }

        /// <summary>
        /// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inherited)]
        public string Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).Id; }

        /// <summary>The geo-location where the resource lives</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inherited)]
        public string Location { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.ITrackedResourceInternal)__trackedResource).Location; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.ITrackedResourceInternal)__trackedResource).Location = value ?? null; }

        /// <summary>
        /// Total non-conflict-oriented errors (e.g., OS errors) Import will tolerate before exiting with failure. -1 means infinite.
        /// 0 means exit immediately on any error.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inlined)]
        public long? MaximumError { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal)Property).MaximumError; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal)Property).MaximumError = value ?? default(long); }

        /// <summary>Internal Acessors for Property</summary>
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobProperties Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobInternal.Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.AutoImportJobProperties()); set { {_property = value;} } }

        /// <summary>Internal Acessors for ProvisioningState</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobInternal.ProvisioningState { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal)Property).ProvisioningState; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal)Property).ProvisioningState = value ?? null; }

        /// <summary>Internal Acessors for Status</summary>
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesStatus Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobInternal.Status { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal)Property).Status; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal)Property).Status = value ?? null /* model class */; }

        /// <summary>Internal Acessors for Id</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal.Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).Id = value ?? null; }

        /// <summary>Internal Acessors for Name</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal.Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).Name = value ?? null; }

        /// <summary>Internal Acessors for SystemData</summary>
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.ISystemData Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal.SystemData { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemData; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemData = value ?? null /* model class */; }

        /// <summary>Internal Acessors for SystemDataCreatedAt</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal.SystemDataCreatedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataCreatedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataCreatedAt = value ?? default(global::System.DateTime); }

        /// <summary>Internal Acessors for SystemDataCreatedBy</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal.SystemDataCreatedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataCreatedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataCreatedBy = value ?? null; }

        /// <summary>Internal Acessors for SystemDataCreatedByType</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal.SystemDataCreatedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataCreatedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataCreatedByType = value ?? null; }

        /// <summary>Internal Acessors for SystemDataLastModifiedAt</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal.SystemDataLastModifiedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedAt = value ?? default(global::System.DateTime); }

        /// <summary>Internal Acessors for SystemDataLastModifiedBy</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal.SystemDataLastModifiedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedBy = value ?? null; }

        /// <summary>Internal Acessors for SystemDataLastModifiedByType</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal.SystemDataLastModifiedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedByType = value ?? null; }

        /// <summary>Internal Acessors for Type</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal.Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).Type = value ?? null; }

        /// <summary>The name of the resource</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inherited)]
        public string Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).Name; }

        /// <summary>Backing field for <see cref="Property" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobProperties _property;

        /// <summary>Properties of the auto import job.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobProperties Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.AutoImportJobProperties()); set => this._property = value; }

        /// <summary>ARM provisioning state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inlined)]
        public string ProvisioningState { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal)Property).ProvisioningState; }

        /// <summary>Gets the resource group name</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Owned)]
        public string ResourceGroupName { get => (new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(this.Id).Success ? new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(this.Id).Groups["resourceGroupName"].Value : null); }

        /// <summary>The status of the auto import job.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesStatus Status { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesInternal)Property).Status; }

        /// <summary>
        /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inherited)]
        internal Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.ISystemData SystemData { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemData; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemData = value ?? null /* model class */; }

        /// <summary>The timestamp of resource creation (UTC).</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inherited)]
        public global::System.DateTime? SystemDataCreatedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataCreatedAt; }

        /// <summary>The identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inherited)]
        public string SystemDataCreatedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataCreatedBy; }

        /// <summary>The type of identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inherited)]
        public string SystemDataCreatedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataCreatedByType; }

        /// <summary>The timestamp of resource last modification (UTC)</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inherited)]
        public global::System.DateTime? SystemDataLastModifiedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedAt; }

        /// <summary>The identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inherited)]
        public string SystemDataLastModifiedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedBy; }

        /// <summary>The type of identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inherited)]
        public string SystemDataLastModifiedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedByType; }

        /// <summary>Resource tags.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inherited)]
        public Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.ITrackedResourceTags Tag { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.ITrackedResourceInternal)__trackedResource).Tag; set => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.ITrackedResourceInternal)__trackedResource).Tag = value ?? null /* model class */; }

        /// <summary>
        /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Origin(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PropertyOrigin.Inherited)]
        public string Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IResourceInternal)__trackedResource).Type; }

        /// <summary>Creates an new <see cref="AutoImportJob" /> instance.</summary>
        public AutoImportJob()
        {

        }

        /// <param name="headers"></param>
        void Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.IHeaderSerializable.ReadHeaders(global::System.Net.Http.Headers.HttpResponseHeaders headers)
        {
            if (headers.TryGetValues("azure-async-operation", out var __azureAsyncOperationHeader0))
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobInternal)this).AzureAsyncOperation = System.Linq.Enumerable.FirstOrDefault(__azureAsyncOperationHeader0) is string __headerAzureAsyncOperationHeader0 ? __headerAzureAsyncOperationHeader0 : (string)null;
            }
        }

        /// <summary>Validates that this object meets the validation criteria.</summary>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.IEventListener" /> instance that will receive validation
        /// events.</param>
        /// <returns>
        /// A <see cref = "global::System.Threading.Tasks.Task" /> that will be complete when validation is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task Validate(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.IEventListener eventListener)
        {
            await eventListener.AssertNotNull(nameof(__trackedResource), __trackedResource);
            await eventListener.AssertObjectIsValid(nameof(__trackedResource), __trackedResource);
        }
    }
    /// An auto import job instance. Follows Azure Resource Manager standards: https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md
    public partial interface IAutoImportJob :
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.IJsonSerializable,
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.ITrackedResource
    {
        /// <summary>
        /// The administrative status of the auto import job. Possible values: 'Enable', 'Disable'. Passing in a value of 'Disable'
        /// will disable the current active auto import job. By default it is set to 'Enable'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The administrative status of the auto import job. Possible values: 'Enable', 'Disable'. Passing in a value of 'Disable' will disable the current active auto import job. By default it is set to 'Enable'.",
        SerializedName = @"adminStatus",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PSArgumentCompleterAttribute("Enable", "Disable")]
        string AdminStatus { get; set; }
        /// <summary>
        /// An array of blob paths/prefixes that get auto imported to the cluster namespace. It has '/' as the default value. Number
        /// of maximum allowed paths is 100.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = false,
        Description = @"An array of blob paths/prefixes that get auto imported to the cluster namespace. It has '/' as the default value. Number of maximum allowed paths is 100.",
        SerializedName = @"autoImportPrefixes",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> AutoImportPrefix { get; set; }

        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"",
        SerializedName = @"azure-async-operation",
        PossibleTypes = new [] { typeof(string) })]
        string AzureAsyncOperation { get; set; }
        /// <summary>
        /// How the auto import job will handle conflicts. For example, if the auto import job is trying to bring in a directory,
        /// but a file is at that path, how it handles it. Fail indicates that the auto import job should stop immediately and not
        /// do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the auto
        /// import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or is currently released.
        /// OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please
        /// reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/blob-integration#conflict-resolution-mode for a
        /// thorough explanation of these resolution modes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = false,
        Description = @"How the auto import job will handle conflicts. For example, if the auto import job is trying to bring in a directory, but a file is at that path, how it handles it. Fail indicates that the auto import job should stop immediately and not do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the auto import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or is currently released. OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/blob-integration#conflict-resolution-mode for a thorough explanation of these resolution modes.",
        SerializedName = @"conflictResolutionMode",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PSArgumentCompleterAttribute("Fail", "Skip", "OverwriteIfDirty", "OverwriteAlways")]
        string ConflictResolutionMode { get; set; }
        /// <summary>
        /// Whether or not to enable deletions during auto import. This only affects overwrite-dirty.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = false,
        Description = @"Whether or not to enable deletions during auto import. This only affects overwrite-dirty.",
        SerializedName = @"enableDeletions",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnableDeletion { get; set; }
        /// <summary>
        /// Total non-conflict-oriented errors (e.g., OS errors) Import will tolerate before exiting with failure. -1 means infinite.
        /// 0 means exit immediately on any error.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = false,
        Description = @"Total non-conflict-oriented errors (e.g., OS errors) Import will tolerate before exiting with failure. -1 means infinite. 0 means exit immediately on any error.",
        SerializedName = @"maximumErrors",
        PossibleTypes = new [] { typeof(long) })]
        long? MaximumError { get; set; }
        /// <summary>ARM provisioning state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"ARM provisioning state.",
        SerializedName = @"provisioningState",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PSArgumentCompleterAttribute("Succeeded", "Failed", "Creating", "Deleting", "Updating", "Canceled")]
        string ProvisioningState { get;  }
        /// <summary>The status of the auto import job.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The status of the auto import job.",
        SerializedName = @"status",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesStatus) })]
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesStatus Status { get;  }

    }
    /// An auto import job instance. Follows Azure Resource Manager standards: https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md
    internal partial interface IAutoImportJobInternal :
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.ITrackedResourceInternal
    {
        /// <summary>
        /// The administrative status of the auto import job. Possible values: 'Enable', 'Disable'. Passing in a value of 'Disable'
        /// will disable the current active auto import job. By default it is set to 'Enable'.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PSArgumentCompleterAttribute("Enable", "Disable")]
        string AdminStatus { get; set; }
        /// <summary>
        /// An array of blob paths/prefixes that get auto imported to the cluster namespace. It has '/' as the default value. Number
        /// of maximum allowed paths is 100.
        /// </summary>
        System.Collections.Generic.List<string> AutoImportPrefix { get; set; }

        string AzureAsyncOperation { get; set; }
        /// <summary>
        /// How the auto import job will handle conflicts. For example, if the auto import job is trying to bring in a directory,
        /// but a file is at that path, how it handles it. Fail indicates that the auto import job should stop immediately and not
        /// do anything with the conflict. Skip indicates that it should pass over the conflict. OverwriteIfDirty causes the auto
        /// import job to delete and re-import the file or directory if it is a conflicting type, is dirty, or is currently released.
        /// OverwriteAlways extends OverwriteIfDirty to include releasing files that had been restored but were not dirty. Please
        /// reference https://learn.microsoft.com/en-us/azure/azure-managed-lustre/blob-integration#conflict-resolution-mode for a
        /// thorough explanation of these resolution modes.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PSArgumentCompleterAttribute("Fail", "Skip", "OverwriteIfDirty", "OverwriteAlways")]
        string ConflictResolutionMode { get; set; }
        /// <summary>
        /// Whether or not to enable deletions during auto import. This only affects overwrite-dirty.
        /// </summary>
        bool? EnableDeletion { get; set; }
        /// <summary>
        /// Total non-conflict-oriented errors (e.g., OS errors) Import will tolerate before exiting with failure. -1 means infinite.
        /// 0 means exit immediately on any error.
        /// </summary>
        long? MaximumError { get; set; }
        /// <summary>Properties of the auto import job.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobProperties Property { get; set; }
        /// <summary>ARM provisioning state.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.StorageCache.PSArgumentCompleterAttribute("Succeeded", "Failed", "Creating", "Deleting", "Updating", "Canceled")]
        string ProvisioningState { get; set; }
        /// <summary>The status of the auto import job.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.StorageCache.Models.IAutoImportJobPropertiesStatus Status { get; set; }

    }
}