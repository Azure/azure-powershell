// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models
{
    using static Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Extensions;

    /// <summary>A Linker to be updated.</summary>
    public partial class LinkerPatch :
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPatch,
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPatchInternal
    {

        /// <summary>The authentication type.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IAuthInfoBase AuthInfo { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).AuthInfo; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).AuthInfo = value ?? null /* model class */; }

        /// <summary>The application client type</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public string ClientType { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).ClientType; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).ClientType = value ?? null; }

        /// <summary>
        /// Optional, indicate whether to apply configurations on source application. If enable, generate configurations and applied
        /// to the source application. Default is enable. If optOut, no configuration change will be made on source.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public string ConfigurationInfoAction { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).ConfigurationInfoAction; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).ConfigurationInfoAction = value ?? null; }

        /// <summary>
        /// A dictionary of additional configurations to be added. Service will auto generate a set of basic configurations and this
        /// property is to full fill more customized configurations
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IConfigurationInfoAdditionalConfigurations ConfigurationInfoAdditionalConfiguration { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).ConfigurationInfoAdditionalConfiguration; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).ConfigurationInfoAdditionalConfiguration = value ?? null /* model class */; }

        /// <summary>
        /// Optional. A dictionary of default key name and customized key name mapping. If not specified, default key name will be
        /// used for generate configurations
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IConfigurationInfoCustomizedKeys ConfigurationInfoCustomizedKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).ConfigurationInfoCustomizedKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).ConfigurationInfoCustomizedKey = value ?? null /* model class */; }

        /// <summary>
        /// Indicates whether to clean up previous operation when Linker is updating or deleting
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public string ConfigurationInfoDeleteOrUpdateBehavior { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).ConfigurationInfoDeleteOrUpdateBehavior; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).ConfigurationInfoDeleteOrUpdateBehavior = value ?? null; }

        /// <summary>Allow Azure services to access the target service if true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public string FirewallRuleAzureService { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).FirewallRuleAzureService; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).FirewallRuleAzureService = value ?? null; }

        /// <summary>
        /// Allow caller client IP to access the target service if true. the property is used when connecting local application to
        /// target service.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public string FirewallRuleCallerClientIP { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).FirewallRuleCallerClientIP; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).FirewallRuleCallerClientIP = value ?? null; }

        /// <summary>
        /// This value specifies the set of IP addresses or IP address ranges in CIDR form to be included as the allowed list of client
        /// IPs for a given database account.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> FirewallRuleIPRange { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).FirewallRuleIPRange; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).FirewallRuleIPRange = value ?? null /* arrayOf */; }

        /// <summary>Internal Acessors for ConfigurationInfo</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IConfigurationInfo Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPatchInternal.ConfigurationInfo { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).ConfigurationInfo; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).ConfigurationInfo = value ?? null /* model class */; }

        /// <summary>Internal Acessors for Property</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerProperties Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPatchInternal.Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.LinkerProperties()); set { {_property = value;} } }

        /// <summary>Internal Acessors for ProvisioningState</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPatchInternal.ProvisioningState { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).ProvisioningState; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).ProvisioningState = value ?? null; }

        /// <summary>Internal Acessors for PublicNetworkSolution</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IPublicNetworkSolution Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPatchInternal.PublicNetworkSolution { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).PublicNetworkSolution; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).PublicNetworkSolution = value ?? null /* model class */; }

        /// <summary>Internal Acessors for PublicNetworkSolutionFirewallRule</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IFirewallRules Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPatchInternal.PublicNetworkSolutionFirewallRule { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).PublicNetworkSolutionFirewallRule; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).PublicNetworkSolutionFirewallRule = value ?? null /* model class */; }

        /// <summary>Internal Acessors for SecretStore</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ISecretStore Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPatchInternal.SecretStore { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).SecretStore; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).SecretStore = value ?? null /* model class */; }

        /// <summary>Internal Acessors for VNetSolution</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IVNetSolution Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPatchInternal.VNetSolution { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).VNetSolution; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).VNetSolution = value ?? null /* model class */; }

        /// <summary>Backing field for <see cref="Property" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerProperties _property;

        /// <summary>Linker properties</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerProperties Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.LinkerProperties()); set => this._property = value; }

        /// <summary>The provisioning state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public string ProvisioningState { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).ProvisioningState; }

        /// <summary>
        /// Optional. Indicates public network solution. If enable, enable public network access of target service with best try.
        /// Default is enable. If optOut, opt out public network access configuration.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public string PublicNetworkSolutionAction { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).PublicNetworkSolutionAction; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).PublicNetworkSolutionAction = value ?? null; }

        /// <summary>
        /// Indicates whether to clean up previous operation(such as firewall rules) when Linker is updating or deleting
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public string PublicNetworkSolutionDeleteOrUpdateBehavior { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).PublicNetworkSolutionDeleteOrUpdateBehavior; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).PublicNetworkSolutionDeleteOrUpdateBehavior = value ?? null; }

        /// <summary>connection scope in source service.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public string Scope { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).Scope; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).Scope = value ?? null; }

        /// <summary>The key vault id to store secret</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public string SecretStoreKeyVaultId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).SecretStoreKeyVaultId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).SecretStoreKeyVaultId = value ?? null; }

        /// <summary>The key vault secret name to store secret, only valid when storing one secret</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public string SecretStoreKeyVaultSecretName { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).SecretStoreKeyVaultSecretName; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).SecretStoreKeyVaultSecretName = value ?? null; }

        /// <summary>The target service properties</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ITargetServiceBase TargetService { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).TargetService; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).TargetService = value ?? null /* model class */; }

        /// <summary>
        /// Indicates whether to clean up previous operation when Linker is updating or deleting
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public string VNetSolutionDeleteOrUpdateBehavior { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).VNetSolutionDeleteOrUpdateBehavior; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).VNetSolutionDeleteOrUpdateBehavior = value ?? null; }

        /// <summary>Type of VNet solution.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Origin(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PropertyOrigin.Inlined)]
        public string VNetSolutionType { get => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).VNetSolutionType; set => ((Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerPropertiesInternal)Property).VNetSolutionType = value ?? null; }

        /// <summary>Creates an new <see cref="LinkerPatch" /> instance.</summary>
        public LinkerPatch()
        {

        }
    }
    /// A Linker to be updated.
    public partial interface ILinkerPatch :
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.IJsonSerializable
    {
        /// <summary>The authentication type.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The authentication type.",
        SerializedName = @"authInfo",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IAuthInfoBase) })]
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IAuthInfoBase AuthInfo { get; set; }
        /// <summary>The application client type</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The application client type",
        SerializedName = @"clientType",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("none", "dotnet", "java", "python", "go", "php", "ruby", "django", "nodejs", "springBoot", "kafka-springBoot")]
        string ClientType { get; set; }
        /// <summary>
        /// Optional, indicate whether to apply configurations on source application. If enable, generate configurations and applied
        /// to the source application. Default is enable. If optOut, no configuration change will be made on source.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional, indicate whether to apply configurations on source application. If enable, generate configurations and applied to the source application. Default is enable. If optOut, no configuration change will be made on source.",
        SerializedName = @"action",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("Internal", "enable", "optOut")]
        string ConfigurationInfoAction { get; set; }
        /// <summary>
        /// A dictionary of additional configurations to be added. Service will auto generate a set of basic configurations and this
        /// property is to full fill more customized configurations
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"A dictionary of additional configurations to be added. Service will auto generate a set of basic configurations and this property is to full fill more customized configurations",
        SerializedName = @"additionalConfigurations",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IConfigurationInfoAdditionalConfigurations) })]
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IConfigurationInfoAdditionalConfigurations ConfigurationInfoAdditionalConfiguration { get; set; }
        /// <summary>
        /// Optional. A dictionary of default key name and customized key name mapping. If not specified, default key name will be
        /// used for generate configurations
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. A dictionary of default key name and customized key name mapping. If not specified, default key name will be used for generate configurations",
        SerializedName = @"customizedKeys",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IConfigurationInfoCustomizedKeys) })]
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IConfigurationInfoCustomizedKeys ConfigurationInfoCustomizedKey { get; set; }
        /// <summary>
        /// Indicates whether to clean up previous operation when Linker is updating or deleting
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Indicates whether to clean up previous operation when Linker is updating or deleting",
        SerializedName = @"deleteOrUpdateBehavior",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("Default", "ForcedCleanup")]
        string ConfigurationInfoDeleteOrUpdateBehavior { get; set; }
        /// <summary>Allow Azure services to access the target service if true.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Allow Azure services to access the target service if true.",
        SerializedName = @"azureServices",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("true", "false")]
        string FirewallRuleAzureService { get; set; }
        /// <summary>
        /// Allow caller client IP to access the target service if true. the property is used when connecting local application to
        /// target service.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Allow caller client IP to access the target service if true. the property is used when connecting local application to target service.",
        SerializedName = @"callerClientIP",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("true", "false")]
        string FirewallRuleCallerClientIP { get; set; }
        /// <summary>
        /// This value specifies the set of IP addresses or IP address ranges in CIDR form to be included as the allowed list of client
        /// IPs for a given database account.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This value specifies the set of IP addresses or IP address ranges in CIDR form to be included as the allowed list of client IPs for a given database account.",
        SerializedName = @"ipRanges",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> FirewallRuleIPRange { get; set; }
        /// <summary>The provisioning state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The provisioning state. ",
        SerializedName = @"provisioningState",
        PossibleTypes = new [] { typeof(string) })]
        string ProvisioningState { get;  }
        /// <summary>
        /// Optional. Indicates public network solution. If enable, enable public network access of target service with best try.
        /// Default is enable. If optOut, opt out public network access configuration.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. Indicates public network solution. If enable, enable public network access of target service with best try. Default is enable. If optOut, opt out public network access configuration.",
        SerializedName = @"action",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("Internal", "enable", "optOut")]
        string PublicNetworkSolutionAction { get; set; }
        /// <summary>
        /// Indicates whether to clean up previous operation(such as firewall rules) when Linker is updating or deleting
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Indicates whether to clean up previous operation(such as firewall rules) when Linker is updating or deleting",
        SerializedName = @"deleteOrUpdateBehavior",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("Default", "ForcedCleanup")]
        string PublicNetworkSolutionDeleteOrUpdateBehavior { get; set; }
        /// <summary>connection scope in source service.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"connection scope in source service.",
        SerializedName = @"scope",
        PossibleTypes = new [] { typeof(string) })]
        string Scope { get; set; }
        /// <summary>The key vault id to store secret</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The key vault id to store secret",
        SerializedName = @"keyVaultId",
        PossibleTypes = new [] { typeof(string) })]
        string SecretStoreKeyVaultId { get; set; }
        /// <summary>The key vault secret name to store secret, only valid when storing one secret</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The key vault secret name to store secret, only valid when storing one secret",
        SerializedName = @"keyVaultSecretName",
        PossibleTypes = new [] { typeof(string) })]
        string SecretStoreKeyVaultSecretName { get; set; }
        /// <summary>The target service properties</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The target service properties",
        SerializedName = @"targetService",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ITargetServiceBase) })]
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ITargetServiceBase TargetService { get; set; }
        /// <summary>
        /// Indicates whether to clean up previous operation when Linker is updating or deleting
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Indicates whether to clean up previous operation when Linker is updating or deleting",
        SerializedName = @"deleteOrUpdateBehavior",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("Default", "ForcedCleanup")]
        string VNetSolutionDeleteOrUpdateBehavior { get; set; }
        /// <summary>Type of VNet solution.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Type of VNet solution.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("serviceEndpoint", "privateLink")]
        string VNetSolutionType { get; set; }

    }
    /// A Linker to be updated.
    internal partial interface ILinkerPatchInternal

    {
        /// <summary>The authentication type.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IAuthInfoBase AuthInfo { get; set; }
        /// <summary>The application client type</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("none", "dotnet", "java", "python", "go", "php", "ruby", "django", "nodejs", "springBoot", "kafka-springBoot")]
        string ClientType { get; set; }
        /// <summary>
        /// The connection information consumed by applications, including secrets, connection strings.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IConfigurationInfo ConfigurationInfo { get; set; }
        /// <summary>
        /// Optional, indicate whether to apply configurations on source application. If enable, generate configurations and applied
        /// to the source application. Default is enable. If optOut, no configuration change will be made on source.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("Internal", "enable", "optOut")]
        string ConfigurationInfoAction { get; set; }
        /// <summary>
        /// A dictionary of additional configurations to be added. Service will auto generate a set of basic configurations and this
        /// property is to full fill more customized configurations
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IConfigurationInfoAdditionalConfigurations ConfigurationInfoAdditionalConfiguration { get; set; }
        /// <summary>
        /// Optional. A dictionary of default key name and customized key name mapping. If not specified, default key name will be
        /// used for generate configurations
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IConfigurationInfoCustomizedKeys ConfigurationInfoCustomizedKey { get; set; }
        /// <summary>
        /// Indicates whether to clean up previous operation when Linker is updating or deleting
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("Default", "ForcedCleanup")]
        string ConfigurationInfoDeleteOrUpdateBehavior { get; set; }
        /// <summary>Allow Azure services to access the target service if true.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("true", "false")]
        string FirewallRuleAzureService { get; set; }
        /// <summary>
        /// Allow caller client IP to access the target service if true. the property is used when connecting local application to
        /// target service.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("true", "false")]
        string FirewallRuleCallerClientIP { get; set; }
        /// <summary>
        /// This value specifies the set of IP addresses or IP address ranges in CIDR form to be included as the allowed list of client
        /// IPs for a given database account.
        /// </summary>
        System.Collections.Generic.List<string> FirewallRuleIPRange { get; set; }
        /// <summary>Linker properties</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ILinkerProperties Property { get; set; }
        /// <summary>The provisioning state.</summary>
        string ProvisioningState { get; set; }
        /// <summary>The network solution.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IPublicNetworkSolution PublicNetworkSolution { get; set; }
        /// <summary>
        /// Optional. Indicates public network solution. If enable, enable public network access of target service with best try.
        /// Default is enable. If optOut, opt out public network access configuration.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("Internal", "enable", "optOut")]
        string PublicNetworkSolutionAction { get; set; }
        /// <summary>
        /// Indicates whether to clean up previous operation(such as firewall rules) when Linker is updating or deleting
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("Default", "ForcedCleanup")]
        string PublicNetworkSolutionDeleteOrUpdateBehavior { get; set; }
        /// <summary>
        /// Describe firewall rules of target service to make sure source application could connect to the target.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IFirewallRules PublicNetworkSolutionFirewallRule { get; set; }
        /// <summary>connection scope in source service.</summary>
        string Scope { get; set; }
        /// <summary>An option to store secret value in secure place</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ISecretStore SecretStore { get; set; }
        /// <summary>The key vault id to store secret</summary>
        string SecretStoreKeyVaultId { get; set; }
        /// <summary>The key vault secret name to store secret, only valid when storing one secret</summary>
        string SecretStoreKeyVaultSecretName { get; set; }
        /// <summary>The target service properties</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.ITargetServiceBase TargetService { get; set; }
        /// <summary>The VNet solution.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IVNetSolution VNetSolution { get; set; }
        /// <summary>
        /// Indicates whether to clean up previous operation when Linker is updating or deleting
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("Default", "ForcedCleanup")]
        string VNetSolutionDeleteOrUpdateBehavior { get; set; }
        /// <summary>Type of VNet solution.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.PSArgumentCompleterAttribute("serviceEndpoint", "privateLink")]
        string VNetSolutionType { get; set; }

    }
}