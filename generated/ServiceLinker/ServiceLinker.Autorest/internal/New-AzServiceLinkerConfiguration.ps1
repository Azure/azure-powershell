
# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Code generated by Microsoft (R) AutoRest Code Generator.Changes may cause incorrect behavior and will be lost if the code
# is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Generate configurations for a Linker.
.Description
Generate configurations for a Linker.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.Api20221101Preview.IConfigurationInfo
.Inputs
Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IServiceLinkerIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.Api20221101Preview.ISourceConfiguration
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IServiceLinkerIdentity>: Identity Parameter
  [ConnectorName <String>]: The name of resource.
  [DryrunName <String>]: The name of dryrun.
  [Id <String>]: Resource identity path
  [LinkerName <String>]: The name Linker resource.
  [Location <String>]: The name of Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [ResourceUri <String>]: The fully qualified Azure Resource manager identifier of the resource to be connected.
  [SubscriptionId <String>]: The ID of the target subscription.

PARAMETER <IConfigurationInfo>: The configuration information, used to generate configurations or save to applications
  [Action <ActionType?>]: Optional, indicate whether to apply configurations on source application. If enable, generate configurations and applied to the source application. Default is enable. If optOut, no configuration change will be made on source.
  [AdditionalConfiguration <IConfigurationInfoAdditionalConfigurations>]: A dictionary of additional configurations to be added. Service will auto generate a set of basic configurations and this property is to full fill more customized configurations
    [(Any) <String>]: This indicates any property can be added to this object.
  [CustomizedKey <IConfigurationInfoCustomizedKeys>]: Optional. A dictionary of default key name and customized key name mapping. If not specified, default key name will be used for generate configurations
    [(Any) <String>]: This indicates any property can be added to this object.
  [DeleteOrUpdateBehavior <DeleteOrUpdateBehavior?>]: Indicates whether to clean up previous operation when Linker is updating or deleting
.Link
https://learn.microsoft.com/powershell/module/az.servicelinker/new-azservicelinkerconfiguration
#>
function New-AzServiceLinkerConfiguration {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.Api20221101Preview.ISourceConfiguration])]
[CmdletBinding(DefaultParameterSetName='GenerateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Generate', Mandatory)]
    [Parameter(ParameterSetName='GenerateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Category('Path')]
    [System.String]
    # The name Linker resource.
    ${LinkerName},

    [Parameter(ParameterSetName='Generate', Mandatory)]
    [Parameter(ParameterSetName='GenerateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Category('Path')]
    [System.String]
    # The fully qualified Azure Resource manager identifier of the resource to be connected.
    ${ResourceUri},

    [Parameter(ParameterSetName='GenerateViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='GenerateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.IServiceLinkerIdentity]
    # Identity Parameter
    # To construct, see NOTES section for INPUTOBJECT properties and create a hash table.
    ${InputObject},

    [Parameter(ParameterSetName='Generate', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='GenerateViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.Api20221101Preview.IConfigurationInfo]
    # The configuration information, used to generate configurations or save to applications
    # To construct, see NOTES section for PARAMETER properties and create a hash table.
    ${Parameter},

    [Parameter(ParameterSetName='GenerateExpanded')]
    [Parameter(ParameterSetName='GenerateViaIdentityExpanded')]
    [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Support.ActionType])]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Support.ActionType]
    # Optional, indicate whether to apply configurations on source application.
    # If enable, generate configurations and applied to the source application.
    # Default is enable.
    # If optOut, no configuration change will be made on source.
    ${Action},

    [Parameter(ParameterSetName='GenerateExpanded')]
    [Parameter(ParameterSetName='GenerateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.Api20221101Preview.IConfigurationInfoAdditionalConfigurations]))]
    [System.Collections.Hashtable]
    # A dictionary of additional configurations to be added.
    # Service will auto generate a set of basic configurations and this property is to full fill more customized configurations
    ${AdditionalConfiguration},

    [Parameter(ParameterSetName='GenerateExpanded')]
    [Parameter(ParameterSetName='GenerateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Models.Api20221101Preview.IConfigurationInfoCustomizedKeys]))]
    [System.Collections.Hashtable]
    # Optional.
    # A dictionary of default key name and customized key name mapping.
    # If not specified, default key name will be used for generate configurations
    ${CustomizedKey},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.ServiceLinker.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Generate = 'Az.ServiceLinker.private\New-AzServiceLinkerConfiguration_Generate';
            GenerateExpanded = 'Az.ServiceLinker.private\New-AzServiceLinkerConfiguration_GenerateExpanded';
            GenerateViaIdentity = 'Az.ServiceLinker.private\New-AzServiceLinkerConfiguration_GenerateViaIdentity';
            GenerateViaIdentityExpanded = 'Az.ServiceLinker.private\New-AzServiceLinkerConfiguration_GenerateViaIdentityExpanded';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}
