// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace ADT.Models
{
    using static ADT.Runtime.Extensions;

    /// <summary>
    /// The allowed set of configurable rulesets for a FlowProfile resource, used during data replication. All rulesets are optional,
    /// and any ruleset configured will be applied to every applicable replicating data. Any data that fails a ruleset will be
    /// denied replication. If a ruleset is not configured then the ruleset is considered disabled and will not apply towards
    /// replicating data.
    /// </summary>
    public partial class FlowProfileRulesets :
        ADT.Models.IFlowProfileRulesets,
        ADT.Models.IFlowProfileRulesetsInternal
    {

        /// <summary>Internal Acessors for Antiviru</summary>
        ADT.Models.IAntivirusRuleset ADT.Models.IFlowProfileRulesetsInternal.Antiviru { get => (this._antiviru = this._antiviru ?? new ADT.Models.AntivirusRuleset()); set { {_antiviru = value;} } }

        /// <summary>Internal Acessors for Archive</summary>
        ADT.Models.IArchiveRuleset ADT.Models.IFlowProfileRulesetsInternal.Archive { get => (this._archive = this._archive ?? new ADT.Models.ArchiveRuleset()); set { {_archive = value;} } }

        /// <summary>Internal Acessors for DataSize</summary>
        ADT.Models.IDataSizeRuleset ADT.Models.IFlowProfileRulesetsInternal.DataSize { get => (this._dataSize = this._dataSize ?? new ADT.Models.DataSizeRuleset()); set { {_dataSize = value;} } }

        /// <summary>Internal Acessors for MimeFilter</summary>
        ADT.Models.IMimeFilterRuleset ADT.Models.IFlowProfileRulesetsInternal.MimeFilter { get => (this._mimeFilter = this._mimeFilter ?? new ADT.Models.MimeFilterRuleset()); set { {_mimeFilter = value;} } }

        /// <summary>Internal Acessors for TextMatching</summary>
        ADT.Models.ITextMatchingRuleset ADT.Models.IFlowProfileRulesetsInternal.TextMatching { get => (this._textMatching = this._textMatching ?? new ADT.Models.TextMatchingRuleset()); set { {_textMatching = value;} } }

        /// <summary>Internal Acessors for XmlFilter</summary>
        ADT.Models.IXmlFilterRuleset ADT.Models.IFlowProfileRulesetsInternal.XmlFilter { get => (this._xmlFilter = this._xmlFilter ?? new ADT.Models.XmlFilterRuleset()); set { {_xmlFilter = value;} } }

        /// <summary>Backing field for <see cref="Antiviru" /> property.</summary>
        private ADT.Models.IAntivirusRuleset _antiviru;

        /// <summary>Antivirus scanning rules for replicated data.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Owned)]
        internal ADT.Models.IAntivirusRuleset Antiviru { get => (this._antiviru = this._antiviru ?? new ADT.Models.AntivirusRuleset()); set => this._antiviru = value; }

        /// <summary>
        /// Optional. The list of antiviruses to be used as a scanning solution for replicating data.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> AntivirusAvSolution { get => ((ADT.Models.IAntivirusRulesetInternal)Antiviru).AvSolution; set => ((ADT.Models.IAntivirusRulesetInternal)Antiviru).AvSolution = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="Archive" /> property.</summary>
        private ADT.Models.IArchiveRuleset _archive;

        /// <summary>Rules for handling archive files during replication.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Owned)]
        internal ADT.Models.IArchiveRuleset Archive { get => (this._archive = this._archive ?? new ADT.Models.ArchiveRuleset()); set => this._archive = value; }

        /// <summary>
        /// Optional. Provides the multiplication value for an archive in total based on the initial object being validated. This
        /// value takes the root object size and multiplies it by this value to create a maximum. Once this maximum is exceeded, the
        /// archive is failed. Used to detect and block archives with suspiciously high compression (e.g., zip bombs).
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public double? ArchiveMaximumCompressionRatioLimit { get => ((ADT.Models.IArchiveRulesetInternal)Archive).MaximumCompressionRatioLimit; set => ((ADT.Models.IArchiveRulesetInternal)Archive).MaximumCompressionRatioLimit = value ?? default(double); }

        /// <summary>
        /// Optional. The maximum depth of nested archives that can be expanded. Limits how many layers of embedded archives will
        /// be processed. Archives exceeding the max limit will be denied for replication.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public long? ArchiveMaximumDepthLimit { get => ((ADT.Models.IArchiveRulesetInternal)Archive).MaximumDepthLimit; set => ((ADT.Models.IArchiveRulesetInternal)Archive).MaximumDepthLimit = value ?? default(long); }

        /// <summary>
        /// Optional. The combined maximum size (in bytes) of all extracted files that an expanded archive is allowed to reach. Archives
        /// exceeding the max limit will be denied for replication.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public long? ArchiveMaximumExpansionSizeLimit { get => ((ADT.Models.IArchiveRulesetInternal)Archive).MaximumExpansionSizeLimit; set => ((ADT.Models.IArchiveRulesetInternal)Archive).MaximumExpansionSizeLimit = value ?? default(long); }

        /// <summary>
        /// Optional. Default is 0. The minimum archive file size (in bytes) required to trigger expansion during replication. Any
        /// archive file size below the configured threshold will skip the rest of the configured rulesets for archives.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public long? ArchiveMinimumSizeForExpansion { get => ((ADT.Models.IArchiveRulesetInternal)Archive).MinimumSizeForExpansion; set => ((ADT.Models.IArchiveRulesetInternal)Archive).MinimumSizeForExpansion = value ?? default(long); }

        /// <summary>Backing field for <see cref="DataSize" /> property.</summary>
        private ADT.Models.IDataSizeRuleset _dataSize;

        /// <summary>Rules that enforce minimum and maximum data size limits.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Owned)]
        internal ADT.Models.IDataSizeRuleset DataSize { get => (this._dataSize = this._dataSize ?? new ADT.Models.DataSizeRuleset()); set => this._dataSize = value; }

        /// <summary>
        /// Optional. Specifies the maximum allowed size (in bytes) for files to be replicated. Any file size greater than maximum
        /// will be denied replication.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public long? DataSizeMaximum { get => ((ADT.Models.IDataSizeRulesetInternal)DataSize).Maximum; set => ((ADT.Models.IDataSizeRulesetInternal)DataSize).Maximum = value ?? default(long); }

        /// <summary>
        /// Optional. Default is 0. Specifies the minimum required size (in bytes) for a file to be eligible for replication. Any
        /// file size less than minimum will be denied replication.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public long? DataSizeMinimum { get => ((ADT.Models.IDataSizeRulesetInternal)DataSize).Minimum; set => ((ADT.Models.IDataSizeRulesetInternal)DataSize).Minimum = value ?? default(long); }

        /// <summary>Backing field for <see cref="MimeFilter" /> property.</summary>
        private ADT.Models.IMimeFilterRuleset _mimeFilter;

        /// <summary>Rules for filtering files based on MIME types.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Owned)]
        internal ADT.Models.IMimeFilterRuleset MimeFilter { get => (this._mimeFilter = this._mimeFilter ?? new ADT.Models.MimeFilterRuleset()); set => this._mimeFilter = value; }

        /// <summary>
        /// Defines the Media types (f.k.a MIME types) and associated file extensions to be filtered. For more detail, please refer
        /// to the MimeTypeFiler model.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<ADT.Models.IMimeTypeFilter> MimeFilterFilters { get => ((ADT.Models.IMimeFilterRulesetInternal)MimeFilter).Filter; set => ((ADT.Models.IMimeFilterRulesetInternal)MimeFilter).Filter = value ?? null /* arrayOf */; }

        /// <summary>
        /// Specifies whether the filter is an allow list or deny list. For more detail, please refer to the FilterType model.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public string MimeFilterType { get => ((ADT.Models.IMimeFilterRulesetInternal)MimeFilter).Type; set => ((ADT.Models.IMimeFilterRulesetInternal)MimeFilter).Type = value ?? null; }

        /// <summary>Backing field for <see cref="TextMatching" /> property.</summary>
        private ADT.Models.ITextMatchingRuleset _textMatching;

        /// <summary>Rules for detecting and blocking specific text patterns.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Owned)]
        internal ADT.Models.ITextMatchingRuleset TextMatching { get => (this._textMatching = this._textMatching ?? new ADT.Models.TextMatchingRuleset()); set => this._textMatching = value; }

        /// <summary>
        /// A list of text patterns to block, each with matching rules and case sensitivity options.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<ADT.Models.ITextMatch> TextMatchingDeny { get => ((ADT.Models.ITextMatchingRulesetInternal)TextMatching).Deny; set => ((ADT.Models.ITextMatchingRulesetInternal)TextMatching).Deny = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="XmlFilter" /> property.</summary>
        private ADT.Models.IXmlFilterRuleset _xmlFilter;

        /// <summary>Rules for filtering XML content using XSD schemas.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Owned)]
        internal ADT.Models.IXmlFilterRuleset XmlFilter { get => (this._xmlFilter = this._xmlFilter ?? new ADT.Models.XmlFilterRuleset()); set => this._xmlFilter = value; }

        /// <summary>The default XML namespace used for schema validation.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public string XmlFilterDefaultNamespace { get => ((ADT.Models.IXmlFilterRulesetInternal)XmlFilter).DefaultNamespace; set => ((ADT.Models.IXmlFilterRulesetInternal)XmlFilter).DefaultNamespace = value ?? null; }

        /// <summary>Defines the method for referencing the xml schema.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public string XmlFilterReference { get => ((ADT.Models.IXmlFilterRulesetInternal)XmlFilter).Reference; set => ((ADT.Models.IXmlFilterRulesetInternal)XmlFilter).Reference = value ?? null; }

        /// <summary>The inline XSD schema to be used for validation.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public string XmlFilterSchema { get => ((ADT.Models.IXmlFilterRulesetInternal)XmlFilter).Schema; set => ((ADT.Models.IXmlFilterRulesetInternal)XmlFilter).Schema = value ?? null; }

        /// <summary>Creates an new <see cref="FlowProfileRulesets" /> instance.</summary>
        public FlowProfileRulesets()
        {

        }
    }
    /// The allowed set of configurable rulesets for a FlowProfile resource, used during data replication. All rulesets are optional,
    /// and any ruleset configured will be applied to every applicable replicating data. Any data that fails a ruleset will be
    /// denied replication. If a ruleset is not configured then the ruleset is considered disabled and will not apply towards
    /// replicating data.
    public partial interface IFlowProfileRulesets :
        ADT.Runtime.IJsonSerializable
    {
        /// <summary>
        /// Optional. The list of antiviruses to be used as a scanning solution for replicating data.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. The list of antiviruses to be used as a scanning solution for replicating data.",
        SerializedName = @"avSolutions",
        PossibleTypes = new [] { typeof(string) })]
        [global::ADT.PSArgumentCompleterAttribute("Defender", "ClamAv")]
        System.Collections.Generic.List<string> AntivirusAvSolution { get; set; }
        /// <summary>
        /// Optional. Provides the multiplication value for an archive in total based on the initial object being validated. This
        /// value takes the root object size and multiplies it by this value to create a maximum. Once this maximum is exceeded, the
        /// archive is failed. Used to detect and block archives with suspiciously high compression (e.g., zip bombs).
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. Provides the multiplication value for an archive in total based on the initial object being validated. This value takes the root object size and multiplies it by this value to create a maximum. Once this maximum is exceeded, the archive is failed. Used to detect and block archives with suspiciously high compression (e.g., zip bombs).",
        SerializedName = @"maximumCompressionRatioLimit",
        PossibleTypes = new [] { typeof(double) })]
        double? ArchiveMaximumCompressionRatioLimit { get; set; }
        /// <summary>
        /// Optional. The maximum depth of nested archives that can be expanded. Limits how many layers of embedded archives will
        /// be processed. Archives exceeding the max limit will be denied for replication.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. The maximum depth of nested archives that can be expanded. Limits how many layers of embedded archives will be processed. Archives exceeding the max limit will be denied for replication.",
        SerializedName = @"maximumDepthLimit",
        PossibleTypes = new [] { typeof(long) })]
        long? ArchiveMaximumDepthLimit { get; set; }
        /// <summary>
        /// Optional. The combined maximum size (in bytes) of all extracted files that an expanded archive is allowed to reach. Archives
        /// exceeding the max limit will be denied for replication.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. The combined maximum size (in bytes) of all extracted files that an expanded archive is allowed to reach. Archives exceeding the max limit will be denied for replication.",
        SerializedName = @"maximumExpansionSizeLimit",
        PossibleTypes = new [] { typeof(long) })]
        long? ArchiveMaximumExpansionSizeLimit { get; set; }
        /// <summary>
        /// Optional. Default is 0. The minimum archive file size (in bytes) required to trigger expansion during replication. Any
        /// archive file size below the configured threshold will skip the rest of the configured rulesets for archives.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. Default is 0. The minimum archive file size (in bytes) required to trigger expansion during replication. Any archive file size below the configured threshold will skip the rest of the configured rulesets for archives.",
        SerializedName = @"minimumSizeForExpansion",
        PossibleTypes = new [] { typeof(long) })]
        long? ArchiveMinimumSizeForExpansion { get; set; }
        /// <summary>
        /// Optional. Specifies the maximum allowed size (in bytes) for files to be replicated. Any file size greater than maximum
        /// will be denied replication.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. Specifies the maximum allowed size (in bytes) for files to be replicated. Any file size greater than maximum will be denied replication.",
        SerializedName = @"maximum",
        PossibleTypes = new [] { typeof(long) })]
        long? DataSizeMaximum { get; set; }
        /// <summary>
        /// Optional. Default is 0. Specifies the minimum required size (in bytes) for a file to be eligible for replication. Any
        /// file size less than minimum will be denied replication.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. Default is 0. Specifies the minimum required size (in bytes) for a file to be eligible for replication. Any file size less than minimum will be denied replication.",
        SerializedName = @"minimum",
        PossibleTypes = new [] { typeof(long) })]
        long? DataSizeMinimum { get; set; }
        /// <summary>
        /// Defines the Media types (f.k.a MIME types) and associated file extensions to be filtered. For more detail, please refer
        /// to the MimeTypeFiler model.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Defines the Media types (f.k.a MIME types) and associated file extensions to be filtered. For more detail, please refer to the MimeTypeFiler model.",
        SerializedName = @"filters",
        PossibleTypes = new [] { typeof(ADT.Models.IMimeTypeFilter) })]
        System.Collections.Generic.List<ADT.Models.IMimeTypeFilter> MimeFilterFilters { get; set; }
        /// <summary>
        /// Specifies whether the filter is an allow list or deny list. For more detail, please refer to the FilterType model.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies whether the filter is an allow list or deny list. For more detail, please refer to the FilterType model.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(string) })]
        [global::ADT.PSArgumentCompleterAttribute("Allow", "Deny")]
        string MimeFilterType { get; set; }
        /// <summary>
        /// A list of text patterns to block, each with matching rules and case sensitivity options.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"A list of text patterns to block, each with matching rules and case sensitivity options.",
        SerializedName = @"deny",
        PossibleTypes = new [] { typeof(ADT.Models.ITextMatch) })]
        System.Collections.Generic.List<ADT.Models.ITextMatch> TextMatchingDeny { get; set; }
        /// <summary>The default XML namespace used for schema validation.</summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The default XML namespace used for schema validation.",
        SerializedName = @"defaultNamespace",
        PossibleTypes = new [] { typeof(string) })]
        string XmlFilterDefaultNamespace { get; set; }
        /// <summary>Defines the method for referencing the xml schema.</summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Defines the method for referencing the xml schema.",
        SerializedName = @"reference",
        PossibleTypes = new [] { typeof(string) })]
        [global::ADT.PSArgumentCompleterAttribute("Inline")]
        string XmlFilterReference { get; set; }
        /// <summary>The inline XSD schema to be used for validation.</summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The inline XSD schema to be used for validation.",
        SerializedName = @"schema",
        PossibleTypes = new [] { typeof(string) })]
        string XmlFilterSchema { get; set; }

    }
    /// The allowed set of configurable rulesets for a FlowProfile resource, used during data replication. All rulesets are optional,
    /// and any ruleset configured will be applied to every applicable replicating data. Any data that fails a ruleset will be
    /// denied replication. If a ruleset is not configured then the ruleset is considered disabled and will not apply towards
    /// replicating data.
    internal partial interface IFlowProfileRulesetsInternal

    {
        /// <summary>Antivirus scanning rules for replicated data.</summary>
        ADT.Models.IAntivirusRuleset Antiviru { get; set; }
        /// <summary>
        /// Optional. The list of antiviruses to be used as a scanning solution for replicating data.
        /// </summary>
        [global::ADT.PSArgumentCompleterAttribute("Defender", "ClamAv")]
        System.Collections.Generic.List<string> AntivirusAvSolution { get; set; }
        /// <summary>Rules for handling archive files during replication.</summary>
        ADT.Models.IArchiveRuleset Archive { get; set; }
        /// <summary>
        /// Optional. Provides the multiplication value for an archive in total based on the initial object being validated. This
        /// value takes the root object size and multiplies it by this value to create a maximum. Once this maximum is exceeded, the
        /// archive is failed. Used to detect and block archives with suspiciously high compression (e.g., zip bombs).
        /// </summary>
        double? ArchiveMaximumCompressionRatioLimit { get; set; }
        /// <summary>
        /// Optional. The maximum depth of nested archives that can be expanded. Limits how many layers of embedded archives will
        /// be processed. Archives exceeding the max limit will be denied for replication.
        /// </summary>
        long? ArchiveMaximumDepthLimit { get; set; }
        /// <summary>
        /// Optional. The combined maximum size (in bytes) of all extracted files that an expanded archive is allowed to reach. Archives
        /// exceeding the max limit will be denied for replication.
        /// </summary>
        long? ArchiveMaximumExpansionSizeLimit { get; set; }
        /// <summary>
        /// Optional. Default is 0. The minimum archive file size (in bytes) required to trigger expansion during replication. Any
        /// archive file size below the configured threshold will skip the rest of the configured rulesets for archives.
        /// </summary>
        long? ArchiveMinimumSizeForExpansion { get; set; }
        /// <summary>Rules that enforce minimum and maximum data size limits.</summary>
        ADT.Models.IDataSizeRuleset DataSize { get; set; }
        /// <summary>
        /// Optional. Specifies the maximum allowed size (in bytes) for files to be replicated. Any file size greater than maximum
        /// will be denied replication.
        /// </summary>
        long? DataSizeMaximum { get; set; }
        /// <summary>
        /// Optional. Default is 0. Specifies the minimum required size (in bytes) for a file to be eligible for replication. Any
        /// file size less than minimum will be denied replication.
        /// </summary>
        long? DataSizeMinimum { get; set; }
        /// <summary>Rules for filtering files based on MIME types.</summary>
        ADT.Models.IMimeFilterRuleset MimeFilter { get; set; }
        /// <summary>
        /// Defines the Media types (f.k.a MIME types) and associated file extensions to be filtered. For more detail, please refer
        /// to the MimeTypeFiler model.
        /// </summary>
        System.Collections.Generic.List<ADT.Models.IMimeTypeFilter> MimeFilterFilters { get; set; }
        /// <summary>
        /// Specifies whether the filter is an allow list or deny list. For more detail, please refer to the FilterType model.
        /// </summary>
        [global::ADT.PSArgumentCompleterAttribute("Allow", "Deny")]
        string MimeFilterType { get; set; }
        /// <summary>Rules for detecting and blocking specific text patterns.</summary>
        ADT.Models.ITextMatchingRuleset TextMatching { get; set; }
        /// <summary>
        /// A list of text patterns to block, each with matching rules and case sensitivity options.
        /// </summary>
        System.Collections.Generic.List<ADT.Models.ITextMatch> TextMatchingDeny { get; set; }
        /// <summary>Rules for filtering XML content using XSD schemas.</summary>
        ADT.Models.IXmlFilterRuleset XmlFilter { get; set; }
        /// <summary>The default XML namespace used for schema validation.</summary>
        string XmlFilterDefaultNamespace { get; set; }
        /// <summary>Defines the method for referencing the xml schema.</summary>
        [global::ADT.PSArgumentCompleterAttribute("Inline")]
        string XmlFilterReference { get; set; }
        /// <summary>The inline XSD schema to be used for validation.</summary>
        string XmlFilterSchema { get; set; }

    }
}