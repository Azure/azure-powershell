// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace ADT.Models
{
    using static ADT.Runtime.Extensions;

    /// <summary>
    /// Rules for regulating supported archive files (BZip2, Cpio, Deb, GZip, Rpm, Tar, Zip) during data replication. All properties
    /// are optional and only the configured options will be applied against archives. As an example, suppose minimumSizeForExpansion
    /// is 10 MiB and maximumExpansionSizeLimit is 1 GiB. Then all archives smaller than 10 MiB will be treated as though the
    /// archive ruleset is disabled, although other rulesets will apply as usual. Furthermore, all archives at least 10 MiB in
    /// size but with a decompressed size greater than 1 GiB will fail the ruleset. All other archives will have their contents
    /// extracted and each extracted element will be applied to all rulesets.
    /// </summary>
    public partial class ArchiveRuleset :
        ADT.Models.IArchiveRuleset,
        ADT.Models.IArchiveRulesetInternal
    {

        /// <summary>Backing field for <see cref="MaximumCompressionRatioLimit" /> property.</summary>
        private double? _maximumCompressionRatioLimit;

        /// <summary>
        /// Optional. Provides the multiplication value for an archive in total based on the initial object being validated. This
        /// value takes the root object size and multiplies it by this value to create a maximum. Once this maximum is exceeded, the
        /// archive is failed. Used to detect and block archives with suspiciously high compression (e.g., zip bombs).
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Owned)]
        public double? MaximumCompressionRatioLimit { get => this._maximumCompressionRatioLimit; set => this._maximumCompressionRatioLimit = value; }

        /// <summary>Backing field for <see cref="MaximumDepthLimit" /> property.</summary>
        private long? _maximumDepthLimit;

        /// <summary>
        /// Optional. The maximum depth of nested archives that can be expanded. Limits how many layers of embedded archives will
        /// be processed. Archives exceeding the max limit will be denied for replication.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Owned)]
        public long? MaximumDepthLimit { get => this._maximumDepthLimit; set => this._maximumDepthLimit = value; }

        /// <summary>Backing field for <see cref="MaximumExpansionSizeLimit" /> property.</summary>
        private long? _maximumExpansionSizeLimit;

        /// <summary>
        /// Optional. The combined maximum size (in bytes) of all extracted files that an expanded archive is allowed to reach. Archives
        /// exceeding the max limit will be denied for replication.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Owned)]
        public long? MaximumExpansionSizeLimit { get => this._maximumExpansionSizeLimit; set => this._maximumExpansionSizeLimit = value; }

        /// <summary>Backing field for <see cref="MinimumSizeForExpansion" /> property.</summary>
        private long? _minimumSizeForExpansion;

        /// <summary>
        /// Optional. Default is 0. The minimum archive file size (in bytes) required to trigger expansion during replication. Any
        /// archive file size below the configured threshold will skip the rest of the configured rulesets for archives.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Owned)]
        public long? MinimumSizeForExpansion { get => this._minimumSizeForExpansion; set => this._minimumSizeForExpansion = value; }

        /// <summary>Creates an new <see cref="ArchiveRuleset" /> instance.</summary>
        public ArchiveRuleset()
        {

        }
    }
    /// Rules for regulating supported archive files (BZip2, Cpio, Deb, GZip, Rpm, Tar, Zip) during data replication. All properties
    /// are optional and only the configured options will be applied against archives. As an example, suppose minimumSizeForExpansion
    /// is 10 MiB and maximumExpansionSizeLimit is 1 GiB. Then all archives smaller than 10 MiB will be treated as though the
    /// archive ruleset is disabled, although other rulesets will apply as usual. Furthermore, all archives at least 10 MiB in
    /// size but with a decompressed size greater than 1 GiB will fail the ruleset. All other archives will have their contents
    /// extracted and each extracted element will be applied to all rulesets.
    public partial interface IArchiveRuleset :
        ADT.Runtime.IJsonSerializable
    {
        /// <summary>
        /// Optional. Provides the multiplication value for an archive in total based on the initial object being validated. This
        /// value takes the root object size and multiplies it by this value to create a maximum. Once this maximum is exceeded, the
        /// archive is failed. Used to detect and block archives with suspiciously high compression (e.g., zip bombs).
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. Provides the multiplication value for an archive in total based on the initial object being validated. This value takes the root object size and multiplies it by this value to create a maximum. Once this maximum is exceeded, the archive is failed. Used to detect and block archives with suspiciously high compression (e.g., zip bombs).",
        SerializedName = @"maximumCompressionRatioLimit",
        PossibleTypes = new [] { typeof(double) })]
        double? MaximumCompressionRatioLimit { get; set; }
        /// <summary>
        /// Optional. The maximum depth of nested archives that can be expanded. Limits how many layers of embedded archives will
        /// be processed. Archives exceeding the max limit will be denied for replication.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. The maximum depth of nested archives that can be expanded. Limits how many layers of embedded archives will be processed. Archives exceeding the max limit will be denied for replication.",
        SerializedName = @"maximumDepthLimit",
        PossibleTypes = new [] { typeof(long) })]
        long? MaximumDepthLimit { get; set; }
        /// <summary>
        /// Optional. The combined maximum size (in bytes) of all extracted files that an expanded archive is allowed to reach. Archives
        /// exceeding the max limit will be denied for replication.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. The combined maximum size (in bytes) of all extracted files that an expanded archive is allowed to reach. Archives exceeding the max limit will be denied for replication.",
        SerializedName = @"maximumExpansionSizeLimit",
        PossibleTypes = new [] { typeof(long) })]
        long? MaximumExpansionSizeLimit { get; set; }
        /// <summary>
        /// Optional. Default is 0. The minimum archive file size (in bytes) required to trigger expansion during replication. Any
        /// archive file size below the configured threshold will skip the rest of the configured rulesets for archives.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. Default is 0. The minimum archive file size (in bytes) required to trigger expansion during replication. Any archive file size below the configured threshold will skip the rest of the configured rulesets for archives.",
        SerializedName = @"minimumSizeForExpansion",
        PossibleTypes = new [] { typeof(long) })]
        long? MinimumSizeForExpansion { get; set; }

    }
    /// Rules for regulating supported archive files (BZip2, Cpio, Deb, GZip, Rpm, Tar, Zip) during data replication. All properties
    /// are optional and only the configured options will be applied against archives. As an example, suppose minimumSizeForExpansion
    /// is 10 MiB and maximumExpansionSizeLimit is 1 GiB. Then all archives smaller than 10 MiB will be treated as though the
    /// archive ruleset is disabled, although other rulesets will apply as usual. Furthermore, all archives at least 10 MiB in
    /// size but with a decompressed size greater than 1 GiB will fail the ruleset. All other archives will have their contents
    /// extracted and each extracted element will be applied to all rulesets.
    internal partial interface IArchiveRulesetInternal

    {
        /// <summary>
        /// Optional. Provides the multiplication value for an archive in total based on the initial object being validated. This
        /// value takes the root object size and multiplies it by this value to create a maximum. Once this maximum is exceeded, the
        /// archive is failed. Used to detect and block archives with suspiciously high compression (e.g., zip bombs).
        /// </summary>
        double? MaximumCompressionRatioLimit { get; set; }
        /// <summary>
        /// Optional. The maximum depth of nested archives that can be expanded. Limits how many layers of embedded archives will
        /// be processed. Archives exceeding the max limit will be denied for replication.
        /// </summary>
        long? MaximumDepthLimit { get; set; }
        /// <summary>
        /// Optional. The combined maximum size (in bytes) of all extracted files that an expanded archive is allowed to reach. Archives
        /// exceeding the max limit will be denied for replication.
        /// </summary>
        long? MaximumExpansionSizeLimit { get; set; }
        /// <summary>
        /// Optional. Default is 0. The minimum archive file size (in bytes) required to trigger expansion during replication. Any
        /// archive file size below the configured threshold will skip the rest of the configured rulesets for archives.
        /// </summary>
        long? MinimumSizeForExpansion { get; set; }

    }
}