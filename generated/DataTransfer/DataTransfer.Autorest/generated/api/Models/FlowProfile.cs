// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace ADT.Models
{
    using static ADT.Runtime.Extensions;

    /// <summary>
    /// Represents a FlowProfile Azure resource, which defines a data replication scenario with a specific data classification
    /// and a set of configurable policy rules.
    /// </summary>
    public partial class FlowProfile :
        ADT.Models.IFlowProfile,
        ADT.Models.IFlowProfileInternal,
        ADT.Runtime.IValidates
    {
        /// <summary>Backing field for Inherited model <see cref= "ADT.Models.ITrackedResource" /></summary>
        private ADT.Models.ITrackedResource __trackedResource = new ADT.Models.TrackedResource();

        /// <summary>Internal Acessors for FlowProfileId</summary>
        string ADT.Models.IFlowProfileInternal.FlowProfileId { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).FlowProfileId; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).FlowProfileId = value ?? null; }

        /// <summary>Internal Acessors for Identity</summary>
        ADT.Models.IManagedServiceIdentity ADT.Models.IFlowProfileInternal.Identity { get => (this._identity = this._identity ?? new ADT.Models.ManagedServiceIdentity()); set { {_identity = value;} } }

        /// <summary>Internal Acessors for IdentityPrincipalId</summary>
        string ADT.Models.IFlowProfileInternal.IdentityPrincipalId { get => ((ADT.Models.IManagedServiceIdentityInternal)Identity).PrincipalId; set => ((ADT.Models.IManagedServiceIdentityInternal)Identity).PrincipalId = value ?? null; }

        /// <summary>Internal Acessors for IdentityTenantId</summary>
        string ADT.Models.IFlowProfileInternal.IdentityTenantId { get => ((ADT.Models.IManagedServiceIdentityInternal)Identity).TenantId; set => ((ADT.Models.IManagedServiceIdentityInternal)Identity).TenantId = value ?? null; }

        /// <summary>Internal Acessors for Property</summary>
        ADT.Models.IFlowProfileProperties ADT.Models.IFlowProfileInternal.Property { get => (this._property = this._property ?? new ADT.Models.FlowProfileProperties()); set { {_property = value;} } }

        /// <summary>Internal Acessors for ProvisioningState</summary>
        string ADT.Models.IFlowProfileInternal.ProvisioningState { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).ProvisioningState; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).ProvisioningState = value ?? null; }

        /// <summary>Internal Acessors for Ruleset</summary>
        ADT.Models.IFlowProfileRulesets ADT.Models.IFlowProfileInternal.Ruleset { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).Ruleset; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).Ruleset = value ?? null /* model class */; }

        /// <summary>Internal Acessors for RulesetAntiviru</summary>
        ADT.Models.IAntivirusRuleset ADT.Models.IFlowProfileInternal.RulesetAntiviru { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).RulesetAntiviru; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).RulesetAntiviru = value ?? null /* model class */; }

        /// <summary>Internal Acessors for RulesetArchive</summary>
        ADT.Models.IArchiveRuleset ADT.Models.IFlowProfileInternal.RulesetArchive { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).RulesetArchive; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).RulesetArchive = value ?? null /* model class */; }

        /// <summary>Internal Acessors for RulesetDataSize</summary>
        ADT.Models.IDataSizeRuleset ADT.Models.IFlowProfileInternal.RulesetDataSize { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).RulesetDataSize; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).RulesetDataSize = value ?? null /* model class */; }

        /// <summary>Internal Acessors for RulesetMimeFilter</summary>
        ADT.Models.IMimeFilterRuleset ADT.Models.IFlowProfileInternal.RulesetMimeFilter { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).RulesetMimeFilter; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).RulesetMimeFilter = value ?? null /* model class */; }

        /// <summary>Internal Acessors for RulesetTextMatching</summary>
        ADT.Models.ITextMatchingRuleset ADT.Models.IFlowProfileInternal.RulesetTextMatching { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).RulesetTextMatching; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).RulesetTextMatching = value ?? null /* model class */; }

        /// <summary>Internal Acessors for RulesetXmlFilter</summary>
        ADT.Models.IXmlFilterRuleset ADT.Models.IFlowProfileInternal.RulesetXmlFilter { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).RulesetXmlFilter; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).RulesetXmlFilter = value ?? null /* model class */; }

        /// <summary>Internal Acessors for Id</summary>
        string ADT.Models.IResourceInternal.Id { get => ((ADT.Models.IResourceInternal)__trackedResource).Id; set => ((ADT.Models.IResourceInternal)__trackedResource).Id = value ?? null; }

        /// <summary>Internal Acessors for Name</summary>
        string ADT.Models.IResourceInternal.Name { get => ((ADT.Models.IResourceInternal)__trackedResource).Name; set => ((ADT.Models.IResourceInternal)__trackedResource).Name = value ?? null; }

        /// <summary>Internal Acessors for SystemData</summary>
        ADT.Models.ISystemData ADT.Models.IResourceInternal.SystemData { get => ((ADT.Models.IResourceInternal)__trackedResource).SystemData; set => ((ADT.Models.IResourceInternal)__trackedResource).SystemData = value ?? null /* model class */; }

        /// <summary>Internal Acessors for SystemDataCreatedAt</summary>
        global::System.DateTime? ADT.Models.IResourceInternal.SystemDataCreatedAt { get => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataCreatedAt; set => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataCreatedAt = value ?? default(global::System.DateTime); }

        /// <summary>Internal Acessors for SystemDataCreatedBy</summary>
        string ADT.Models.IResourceInternal.SystemDataCreatedBy { get => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataCreatedBy; set => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataCreatedBy = value ?? null; }

        /// <summary>Internal Acessors for SystemDataCreatedByType</summary>
        string ADT.Models.IResourceInternal.SystemDataCreatedByType { get => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataCreatedByType; set => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataCreatedByType = value ?? null; }

        /// <summary>Internal Acessors for SystemDataLastModifiedAt</summary>
        global::System.DateTime? ADT.Models.IResourceInternal.SystemDataLastModifiedAt { get => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedAt; set => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedAt = value ?? default(global::System.DateTime); }

        /// <summary>Internal Acessors for SystemDataLastModifiedBy</summary>
        string ADT.Models.IResourceInternal.SystemDataLastModifiedBy { get => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedBy; set => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedBy = value ?? null; }

        /// <summary>Internal Acessors for SystemDataLastModifiedByType</summary>
        string ADT.Models.IResourceInternal.SystemDataLastModifiedByType { get => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedByType; set => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedByType = value ?? null; }

        /// <summary>Internal Acessors for Type</summary>
        string ADT.Models.IResourceInternal.Type { get => ((ADT.Models.IResourceInternal)__trackedResource).Type; set => ((ADT.Models.IResourceInternal)__trackedResource).Type = value ?? null; }

        /// <summary>
        /// Optional. The list of antiviruses to be used as a scanning solution for replicating data.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> AntivirusAvSolution { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).AntivirusAvSolution; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).AntivirusAvSolution = value ?? null /* arrayOf */; }

        /// <summary>
        /// Optional. Provides the multiplication value for an archive in total based on the initial object being validated. This
        /// value takes the root object size and multiplies it by this value to create a maximum. Once this maximum is exceeded, the
        /// archive is failed. Used to detect and block archives with suspiciously high compression (e.g., zip bombs).
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public double? ArchiveMaximumCompressionRatioLimit { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).ArchiveMaximumCompressionRatioLimit; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).ArchiveMaximumCompressionRatioLimit = value ?? default(double); }

        /// <summary>
        /// Optional. The maximum depth of nested archives that can be expanded. Limits how many layers of embedded archives will
        /// be processed. Archives exceeding the max limit will be denied for replication.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public long? ArchiveMaximumDepthLimit { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).ArchiveMaximumDepthLimit; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).ArchiveMaximumDepthLimit = value ?? default(long); }

        /// <summary>
        /// Optional. The combined maximum size (in bytes) of all extracted files that an expanded archive is allowed to reach. Archives
        /// exceeding the max limit will be denied for replication.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public long? ArchiveMaximumExpansionSizeLimit { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).ArchiveMaximumExpansionSizeLimit; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).ArchiveMaximumExpansionSizeLimit = value ?? default(long); }

        /// <summary>
        /// Optional. Default is 0. The minimum archive file size (in bytes) required to trigger expansion during replication. Any
        /// archive file size below the configured threshold will skip the rest of the configured rulesets for archives.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public long? ArchiveMinimumSizeForExpansion { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).ArchiveMinimumSizeForExpansion; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).ArchiveMinimumSizeForExpansion = value ?? default(long); }

        /// <summary>
        /// Optional. Specifies the maximum allowed size (in bytes) for files to be replicated. Any file size greater than maximum
        /// will be denied replication.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public long? DataSizeMaximum { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).DataSizeMaximum; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).DataSizeMaximum = value ?? default(long); }

        /// <summary>
        /// Optional. Default is 0. Specifies the minimum required size (in bytes) for a file to be eligible for replication. Any
        /// file size less than minimum will be denied replication.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public long? DataSizeMinimum { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).DataSizeMinimum; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).DataSizeMinimum = value ?? default(long); }

        /// <summary>A user-defined description of the FlowProfile.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public string Description { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).Description; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).Description = value ?? null; }

        /// <summary>
        /// A guid represented as a string for the FlowProfile resource, assigned by the system.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public string FlowProfileId { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).FlowProfileId; }

        /// <summary>
        /// Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inherited)]
        public string Id { get => ((ADT.Models.IResourceInternal)__trackedResource).Id; }

        /// <summary>Backing field for <see cref="Identity" /> property.</summary>
        private ADT.Models.IManagedServiceIdentity _identity;

        /// <summary>The managed service identities assigned to this resource.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Owned)]
        internal ADT.Models.IManagedServiceIdentity Identity { get => (this._identity = this._identity ?? new ADT.Models.ManagedServiceIdentity()); set => this._identity = value; }

        /// <summary>
        /// The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public string IdentityPrincipalId { get => ((ADT.Models.IManagedServiceIdentityInternal)Identity).PrincipalId; }

        /// <summary>
        /// The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public string IdentityTenantId { get => ((ADT.Models.IManagedServiceIdentityInternal)Identity).TenantId; }

        /// <summary>
        /// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public string IdentityType { get => ((ADT.Models.IManagedServiceIdentityInternal)Identity).Type; set => ((ADT.Models.IManagedServiceIdentityInternal)Identity).Type = value ?? null; }

        /// <summary>
        /// The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM
        /// resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
        /// The dictionary values can be empty objects ({}) in requests.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public ADT.Models.IUserAssignedIdentities IdentityUserAssignedIdentity { get => ((ADT.Models.IManagedServiceIdentityInternal)Identity).UserAssignedIdentity; set => ((ADT.Models.IManagedServiceIdentityInternal)Identity).UserAssignedIdentity = value ?? null /* model class */; }

        /// <summary>The geo-location where the resource lives</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inherited)]
        public string Location { get => ((ADT.Models.ITrackedResourceInternal)__trackedResource).Location; set => ((ADT.Models.ITrackedResourceInternal)__trackedResource).Location = value ?? null; }

        /// <summary>
        /// Defines the Media types (f.k.a MIME types) and associated file extensions to be filtered. For more detail, please refer
        /// to the MimeTypeFiler model.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<ADT.Models.IMimeTypeFilter> MimeFilter { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).MimeFilter; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).MimeFilter = value ?? null /* arrayOf */; }

        /// <summary>
        /// Specifies whether the filter is an allow list or deny list. For more detail, please refer to the FilterType model.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public string MimeFilterType { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).MimeFilterType; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).MimeFilterType = value ?? null; }

        /// <summary>The name of the resource</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inherited)]
        public string Name { get => ((ADT.Models.IResourceInternal)__trackedResource).Name; }

        /// <summary>Backing field for <see cref="Property" /> property.</summary>
        private ADT.Models.IFlowProfileProperties _property;

        /// <summary>
        /// The set of configuration properties that define the behavior and rules of the FlowProfile.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Owned)]
        internal ADT.Models.IFlowProfileProperties Property { get => (this._property = this._property ?? new ADT.Models.FlowProfileProperties()); set => this._property = value; }

        /// <summary>The current provisioning state of the FlowProfile.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public string ProvisioningState { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).ProvisioningState; }

        /// <summary>
        /// The data replication scenario handled by this FlowProfile. Please not, that this value cannot be updated after creation.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public string ReplicationScenario { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).ReplicationScenario; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).ReplicationScenario = value ?? null; }

        /// <summary>Gets the resource group name</summary>
        [ADT.Origin(ADT.PropertyOrigin.Owned)]
        public string ResourceGroupName { get => (new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(this.Id).Success ? new global::System.Text.RegularExpressions.Regex("^/subscriptions/(?<subscriptionId>[^/]+)/resourceGroups/(?<resourceGroupName>[^/]+)/providers/", global::System.Text.RegularExpressions.RegexOptions.IgnoreCase).Match(this.Id).Groups["resourceGroupName"].Value : null); }

        /// <summary>The operational status of the FlowProfile.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public string Status { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).Status; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).Status = value ?? null; }

        /// <summary>
        /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inherited)]
        internal ADT.Models.ISystemData SystemData { get => ((ADT.Models.IResourceInternal)__trackedResource).SystemData; set => ((ADT.Models.IResourceInternal)__trackedResource).SystemData = value ?? null /* model class */; }

        /// <summary>The timestamp of resource creation (UTC).</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inherited)]
        public global::System.DateTime? SystemDataCreatedAt { get => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataCreatedAt; }

        /// <summary>The identity that created the resource.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inherited)]
        public string SystemDataCreatedBy { get => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataCreatedBy; }

        /// <summary>The type of identity that created the resource.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inherited)]
        public string SystemDataCreatedByType { get => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataCreatedByType; }

        /// <summary>The timestamp of resource last modification (UTC)</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inherited)]
        public global::System.DateTime? SystemDataLastModifiedAt { get => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedAt; }

        /// <summary>The identity that last modified the resource.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inherited)]
        public string SystemDataLastModifiedBy { get => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedBy; }

        /// <summary>The type of identity that last modified the resource.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inherited)]
        public string SystemDataLastModifiedByType { get => ((ADT.Models.IResourceInternal)__trackedResource).SystemDataLastModifiedByType; }

        /// <summary>Resource tags.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inherited)]
        public ADT.Models.ITrackedResourceTags Tag { get => ((ADT.Models.ITrackedResourceInternal)__trackedResource).Tag; set => ((ADT.Models.ITrackedResourceInternal)__trackedResource).Tag = value ?? null /* model class */; }

        /// <summary>
        /// A list of text patterns to block, each with matching rules and case sensitivity options.
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<ADT.Models.ITextMatch> TextMatchingDeny { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).TextMatchingDeny; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).TextMatchingDeny = value ?? null /* arrayOf */; }

        /// <summary>
        /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        /// </summary>
        [ADT.Origin(ADT.PropertyOrigin.Inherited)]
        public string Type { get => ((ADT.Models.IResourceInternal)__trackedResource).Type; }

        /// <summary>The default XML namespace used for schema validation.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public string XmlFilterDefaultNamespace { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).XmlFilterDefaultNamespace; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).XmlFilterDefaultNamespace = value ?? null; }

        /// <summary>Defines the method for referencing the xml schema.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public string XmlFilterReference { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).XmlFilterReference; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).XmlFilterReference = value ?? null; }

        /// <summary>The inline XSD schema to be used for validation.</summary>
        [ADT.Origin(ADT.PropertyOrigin.Inlined)]
        public string XmlFilterSchema { get => ((ADT.Models.IFlowProfilePropertiesInternal)Property).XmlFilterSchema; set => ((ADT.Models.IFlowProfilePropertiesInternal)Property).XmlFilterSchema = value ?? null; }

        /// <summary>Creates an new <see cref="FlowProfile" /> instance.</summary>
        public FlowProfile()
        {

        }

        /// <summary>Validates that this object meets the validation criteria.</summary>
        /// <param name="eventListener">an <see cref="ADT.Runtime.IEventListener" /> instance that will receive validation
        /// events.</param>
        /// <returns>
        /// A <see cref = "global::System.Threading.Tasks.Task" /> that will be complete when validation is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task Validate(ADT.Runtime.IEventListener eventListener)
        {
            await eventListener.AssertNotNull(nameof(__trackedResource), __trackedResource);
            await eventListener.AssertObjectIsValid(nameof(__trackedResource), __trackedResource);
        }
    }
    /// Represents a FlowProfile Azure resource, which defines a data replication scenario with a specific data classification
    /// and a set of configurable policy rules.
    public partial interface IFlowProfile :
        ADT.Runtime.IJsonSerializable,
        ADT.Models.ITrackedResource
    {
        /// <summary>
        /// Optional. The list of antiviruses to be used as a scanning solution for replicating data.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. The list of antiviruses to be used as a scanning solution for replicating data.",
        SerializedName = @"avSolutions",
        PossibleTypes = new [] { typeof(string) })]
        [global::ADT.PSArgumentCompleterAttribute("Defender", "ClamAv")]
        System.Collections.Generic.List<string> AntivirusAvSolution { get; set; }
        /// <summary>
        /// Optional. Provides the multiplication value for an archive in total based on the initial object being validated. This
        /// value takes the root object size and multiplies it by this value to create a maximum. Once this maximum is exceeded, the
        /// archive is failed. Used to detect and block archives with suspiciously high compression (e.g., zip bombs).
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. Provides the multiplication value for an archive in total based on the initial object being validated. This value takes the root object size and multiplies it by this value to create a maximum. Once this maximum is exceeded, the archive is failed. Used to detect and block archives with suspiciously high compression (e.g., zip bombs).",
        SerializedName = @"maximumCompressionRatioLimit",
        PossibleTypes = new [] { typeof(double) })]
        double? ArchiveMaximumCompressionRatioLimit { get; set; }
        /// <summary>
        /// Optional. The maximum depth of nested archives that can be expanded. Limits how many layers of embedded archives will
        /// be processed. Archives exceeding the max limit will be denied for replication.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. The maximum depth of nested archives that can be expanded. Limits how many layers of embedded archives will be processed. Archives exceeding the max limit will be denied for replication.",
        SerializedName = @"maximumDepthLimit",
        PossibleTypes = new [] { typeof(long) })]
        long? ArchiveMaximumDepthLimit { get; set; }
        /// <summary>
        /// Optional. The combined maximum size (in bytes) of all extracted files that an expanded archive is allowed to reach. Archives
        /// exceeding the max limit will be denied for replication.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. The combined maximum size (in bytes) of all extracted files that an expanded archive is allowed to reach. Archives exceeding the max limit will be denied for replication.",
        SerializedName = @"maximumExpansionSizeLimit",
        PossibleTypes = new [] { typeof(long) })]
        long? ArchiveMaximumExpansionSizeLimit { get; set; }
        /// <summary>
        /// Optional. Default is 0. The minimum archive file size (in bytes) required to trigger expansion during replication. Any
        /// archive file size below the configured threshold will skip the rest of the configured rulesets for archives.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. Default is 0. The minimum archive file size (in bytes) required to trigger expansion during replication. Any archive file size below the configured threshold will skip the rest of the configured rulesets for archives.",
        SerializedName = @"minimumSizeForExpansion",
        PossibleTypes = new [] { typeof(long) })]
        long? ArchiveMinimumSizeForExpansion { get; set; }
        /// <summary>
        /// Optional. Specifies the maximum allowed size (in bytes) for files to be replicated. Any file size greater than maximum
        /// will be denied replication.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. Specifies the maximum allowed size (in bytes) for files to be replicated. Any file size greater than maximum will be denied replication.",
        SerializedName = @"maximum",
        PossibleTypes = new [] { typeof(long) })]
        long? DataSizeMaximum { get; set; }
        /// <summary>
        /// Optional. Default is 0. Specifies the minimum required size (in bytes) for a file to be eligible for replication. Any
        /// file size less than minimum will be denied replication.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional. Default is 0. Specifies the minimum required size (in bytes) for a file to be eligible for replication. Any file size less than minimum will be denied replication.",
        SerializedName = @"minimum",
        PossibleTypes = new [] { typeof(long) })]
        long? DataSizeMinimum { get; set; }
        /// <summary>A user-defined description of the FlowProfile.</summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"A user-defined description of the FlowProfile.",
        SerializedName = @"description",
        PossibleTypes = new [] { typeof(string) })]
        string Description { get; set; }
        /// <summary>
        /// A guid represented as a string for the FlowProfile resource, assigned by the system.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"A guid represented as a string for the FlowProfile resource, assigned by the system.",
        SerializedName = @"flowProfileId",
        PossibleTypes = new [] { typeof(string) })]
        string FlowProfileId { get;  }
        /// <summary>
        /// The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.",
        SerializedName = @"principalId",
        PossibleTypes = new [] { typeof(string) })]
        string IdentityPrincipalId { get;  }
        /// <summary>
        /// The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.",
        SerializedName = @"tenantId",
        PossibleTypes = new [] { typeof(string) })]
        string IdentityTenantId { get;  }
        /// <summary>
        /// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(string) })]
        [global::ADT.PSArgumentCompleterAttribute("None", "SystemAssigned", "UserAssigned", "SystemAssigned,UserAssigned")]
        string IdentityType { get; set; }
        /// <summary>
        /// The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM
        /// resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
        /// The dictionary values can be empty objects ({}) in requests.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.",
        SerializedName = @"userAssignedIdentities",
        PossibleTypes = new [] { typeof(ADT.Models.IUserAssignedIdentities) })]
        ADT.Models.IUserAssignedIdentities IdentityUserAssignedIdentity { get; set; }
        /// <summary>
        /// Defines the Media types (f.k.a MIME types) and associated file extensions to be filtered. For more detail, please refer
        /// to the MimeTypeFiler model.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Defines the Media types (f.k.a MIME types) and associated file extensions to be filtered. For more detail, please refer to the MimeTypeFiler model.",
        SerializedName = @"filters",
        PossibleTypes = new [] { typeof(ADT.Models.IMimeTypeFilter) })]
        System.Collections.Generic.List<ADT.Models.IMimeTypeFilter> MimeFilter { get; set; }
        /// <summary>
        /// Specifies whether the filter is an allow list or deny list. For more detail, please refer to the FilterType model.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies whether the filter is an allow list or deny list. For more detail, please refer to the FilterType model.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(string) })]
        [global::ADT.PSArgumentCompleterAttribute("Allow", "Deny")]
        string MimeFilterType { get; set; }
        /// <summary>The current provisioning state of the FlowProfile.</summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The current provisioning state of the FlowProfile.",
        SerializedName = @"provisioningState",
        PossibleTypes = new [] { typeof(string) })]
        [global::ADT.PSArgumentCompleterAttribute("Succeeded", "Failed", "Canceled", "Accepted")]
        string ProvisioningState { get;  }
        /// <summary>
        /// The data replication scenario handled by this FlowProfile. Please not, that this value cannot be updated after creation.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The data replication scenario handled by this FlowProfile. Please not, that this value cannot be updated after creation.",
        SerializedName = @"replicationScenario",
        PossibleTypes = new [] { typeof(string) })]
        [global::ADT.PSArgumentCompleterAttribute("Messaging", "API", "Stream", "Files", "SoftwareArtifacts", "Complex")]
        string ReplicationScenario { get; set; }
        /// <summary>The operational status of the FlowProfile.</summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The operational status of the FlowProfile.",
        SerializedName = @"status",
        PossibleTypes = new [] { typeof(string) })]
        [global::ADT.PSArgumentCompleterAttribute("Obsolete", "Enabled")]
        string Status { get; set; }
        /// <summary>
        /// A list of text patterns to block, each with matching rules and case sensitivity options.
        /// </summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"A list of text patterns to block, each with matching rules and case sensitivity options.",
        SerializedName = @"deny",
        PossibleTypes = new [] { typeof(ADT.Models.ITextMatch) })]
        System.Collections.Generic.List<ADT.Models.ITextMatch> TextMatchingDeny { get; set; }
        /// <summary>The default XML namespace used for schema validation.</summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The default XML namespace used for schema validation.",
        SerializedName = @"defaultNamespace",
        PossibleTypes = new [] { typeof(string) })]
        string XmlFilterDefaultNamespace { get; set; }
        /// <summary>Defines the method for referencing the xml schema.</summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Defines the method for referencing the xml schema.",
        SerializedName = @"reference",
        PossibleTypes = new [] { typeof(string) })]
        [global::ADT.PSArgumentCompleterAttribute("Inline")]
        string XmlFilterReference { get; set; }
        /// <summary>The inline XSD schema to be used for validation.</summary>
        [ADT.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The inline XSD schema to be used for validation.",
        SerializedName = @"schema",
        PossibleTypes = new [] { typeof(string) })]
        string XmlFilterSchema { get; set; }

    }
    /// Represents a FlowProfile Azure resource, which defines a data replication scenario with a specific data classification
    /// and a set of configurable policy rules.
    internal partial interface IFlowProfileInternal :
        ADT.Models.ITrackedResourceInternal
    {
        /// <summary>
        /// Optional. The list of antiviruses to be used as a scanning solution for replicating data.
        /// </summary>
        [global::ADT.PSArgumentCompleterAttribute("Defender", "ClamAv")]
        System.Collections.Generic.List<string> AntivirusAvSolution { get; set; }
        /// <summary>
        /// Optional. Provides the multiplication value for an archive in total based on the initial object being validated. This
        /// value takes the root object size and multiplies it by this value to create a maximum. Once this maximum is exceeded, the
        /// archive is failed. Used to detect and block archives with suspiciously high compression (e.g., zip bombs).
        /// </summary>
        double? ArchiveMaximumCompressionRatioLimit { get; set; }
        /// <summary>
        /// Optional. The maximum depth of nested archives that can be expanded. Limits how many layers of embedded archives will
        /// be processed. Archives exceeding the max limit will be denied for replication.
        /// </summary>
        long? ArchiveMaximumDepthLimit { get; set; }
        /// <summary>
        /// Optional. The combined maximum size (in bytes) of all extracted files that an expanded archive is allowed to reach. Archives
        /// exceeding the max limit will be denied for replication.
        /// </summary>
        long? ArchiveMaximumExpansionSizeLimit { get; set; }
        /// <summary>
        /// Optional. Default is 0. The minimum archive file size (in bytes) required to trigger expansion during replication. Any
        /// archive file size below the configured threshold will skip the rest of the configured rulesets for archives.
        /// </summary>
        long? ArchiveMinimumSizeForExpansion { get; set; }
        /// <summary>
        /// Optional. Specifies the maximum allowed size (in bytes) for files to be replicated. Any file size greater than maximum
        /// will be denied replication.
        /// </summary>
        long? DataSizeMaximum { get; set; }
        /// <summary>
        /// Optional. Default is 0. Specifies the minimum required size (in bytes) for a file to be eligible for replication. Any
        /// file size less than minimum will be denied replication.
        /// </summary>
        long? DataSizeMinimum { get; set; }
        /// <summary>A user-defined description of the FlowProfile.</summary>
        string Description { get; set; }
        /// <summary>
        /// A guid represented as a string for the FlowProfile resource, assigned by the system.
        /// </summary>
        string FlowProfileId { get; set; }
        /// <summary>The managed service identities assigned to this resource.</summary>
        ADT.Models.IManagedServiceIdentity Identity { get; set; }
        /// <summary>
        /// The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
        /// </summary>
        string IdentityPrincipalId { get; set; }
        /// <summary>
        /// The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
        /// </summary>
        string IdentityTenantId { get; set; }
        /// <summary>
        /// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
        /// </summary>
        [global::ADT.PSArgumentCompleterAttribute("None", "SystemAssigned", "UserAssigned", "SystemAssigned,UserAssigned")]
        string IdentityType { get; set; }
        /// <summary>
        /// The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM
        /// resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
        /// The dictionary values can be empty objects ({}) in requests.
        /// </summary>
        ADT.Models.IUserAssignedIdentities IdentityUserAssignedIdentity { get; set; }
        /// <summary>
        /// Defines the Media types (f.k.a MIME types) and associated file extensions to be filtered. For more detail, please refer
        /// to the MimeTypeFiler model.
        /// </summary>
        System.Collections.Generic.List<ADT.Models.IMimeTypeFilter> MimeFilter { get; set; }
        /// <summary>
        /// Specifies whether the filter is an allow list or deny list. For more detail, please refer to the FilterType model.
        /// </summary>
        [global::ADT.PSArgumentCompleterAttribute("Allow", "Deny")]
        string MimeFilterType { get; set; }
        /// <summary>
        /// The set of configuration properties that define the behavior and rules of the FlowProfile.
        /// </summary>
        ADT.Models.IFlowProfileProperties Property { get; set; }
        /// <summary>The current provisioning state of the FlowProfile.</summary>
        [global::ADT.PSArgumentCompleterAttribute("Succeeded", "Failed", "Canceled", "Accepted")]
        string ProvisioningState { get; set; }
        /// <summary>
        /// The data replication scenario handled by this FlowProfile. Please not, that this value cannot be updated after creation.
        /// </summary>
        [global::ADT.PSArgumentCompleterAttribute("Messaging", "API", "Stream", "Files", "SoftwareArtifacts", "Complex")]
        string ReplicationScenario { get; set; }
        /// <summary>A set of configurable rulesets applied to this FlowProfile.</summary>
        ADT.Models.IFlowProfileRulesets Ruleset { get; set; }
        /// <summary>Antivirus scanning rules for replicated data.</summary>
        ADT.Models.IAntivirusRuleset RulesetAntiviru { get; set; }
        /// <summary>Rules for handling archive files during replication.</summary>
        ADT.Models.IArchiveRuleset RulesetArchive { get; set; }
        /// <summary>Rules that enforce minimum and maximum data size limits.</summary>
        ADT.Models.IDataSizeRuleset RulesetDataSize { get; set; }
        /// <summary>Rules for filtering files based on MIME types.</summary>
        ADT.Models.IMimeFilterRuleset RulesetMimeFilter { get; set; }
        /// <summary>Rules for detecting and blocking specific text patterns.</summary>
        ADT.Models.ITextMatchingRuleset RulesetTextMatching { get; set; }
        /// <summary>Rules for filtering XML content using XSD schemas.</summary>
        ADT.Models.IXmlFilterRuleset RulesetXmlFilter { get; set; }
        /// <summary>The operational status of the FlowProfile.</summary>
        [global::ADT.PSArgumentCompleterAttribute("Obsolete", "Enabled")]
        string Status { get; set; }
        /// <summary>
        /// A list of text patterns to block, each with matching rules and case sensitivity options.
        /// </summary>
        System.Collections.Generic.List<ADT.Models.ITextMatch> TextMatchingDeny { get; set; }
        /// <summary>The default XML namespace used for schema validation.</summary>
        string XmlFilterDefaultNamespace { get; set; }
        /// <summary>Defines the method for referencing the xml schema.</summary>
        [global::ADT.PSArgumentCompleterAttribute("Inline")]
        string XmlFilterReference { get; set; }
        /// <summary>The inline XSD schema to be used for validation.</summary>
        string XmlFilterSchema { get; set; }

    }
}