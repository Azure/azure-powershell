
# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Code generated by Microsoft (R) AutoRest Code Generator.Changes may cause incorrect behavior and will be lost if the code
# is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Add VMs to the VM Cluster
.Description
Add VMs to the VM Cluster
.Example
$resourceGroup = "PowerShellTestRg"

$dbServerList = Get-AzOracleDbServer -Cloudexadatainfrastructurename "OFake_PowerShellTestExaInfra" -ResourceGroupName $resourceGroup
$dbServerOcid1 = $dbServerList[0].Ocid
$dbServersToAdd = @($dbServerOcid1)

Add-AzOracleCloudVMClusterVM -Cloudvmclustername "OFake_PowerShellTestVmCluster" -ResourceGroupName $resourceGroup -DbServer $dbServersToAdd

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudVMCluster
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/add-azoraclecloudvmclustervm
#>
function Add-AzOracleCloudVMClusterVM {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudVMCluster])]
[CmdletBinding(DefaultParameterSetName='AddExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='AddExpanded', Mandatory)]
    [Parameter(ParameterSetName='AddViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='AddViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # CloudVmCluster name
    ${Cloudvmclustername},

    [Parameter(ParameterSetName='AddExpanded', Mandatory)]
    [Parameter(ParameterSetName='AddViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='AddViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='AddExpanded')]
    [Parameter(ParameterSetName='AddViaJsonFilePath')]
    [Parameter(ParameterSetName='AddViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='AddViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='AddExpanded', Mandatory)]
    [Parameter(ParameterSetName='AddViaIdentityExpanded', Mandatory)]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String[]]
    # Db servers ocids
    ${DbServer},

    [Parameter(ParameterSetName='AddViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Add operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='AddViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Add operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            AddExpanded = 'Az.Oracle.private\Add-AzOracleCloudVMClusterVM_AddExpanded';
            AddViaIdentityExpanded = 'Az.Oracle.private\Add-AzOracleCloudVMClusterVM_AddViaIdentityExpanded';
            AddViaJsonFilePath = 'Az.Oracle.private\Add-AzOracleCloudVMClusterVM_AddViaJsonFilePath';
            AddViaJsonString = 'Az.Oracle.private\Add-AzOracleCloudVMClusterVM_AddViaJsonString';
        }
        if (('AddExpanded', 'AddViaJsonFilePath', 'AddViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a AutonomousDatabaseBackup
.Description
Get a AutonomousDatabaseBackup
.Example
Get-AzOracleAutonomousDatabaseBackup -Autonomousdatabasename "OFakePowerShellTestAdbs" -ResourceGroupName "PowerShellTestRg"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabaseBackup
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

AUTONOMOUSDATABASEINPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoracleautonomousdatabasebackup
#>
function Get-AzOracleAutonomousDatabaseBackup {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabaseBackup])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityAutonomousDatabase', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # AutonomousDatabaseBackup id
    ${Adbbackupid},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The database name.
    ${Autonomousdatabasename},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityAutonomousDatabase', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${AutonomousDatabaseInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleAutonomousDatabaseBackup_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleAutonomousDatabaseBackup_GetViaIdentity';
            GetViaIdentityAutonomousDatabase = 'Az.Oracle.private\Get-AzOracleAutonomousDatabaseBackup_GetViaIdentityAutonomousDatabase';
            List = 'Az.Oracle.private\Get-AzOracleAutonomousDatabaseBackup_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a AutonomousDatabaseCharacterSet
.Description
Get a AutonomousDatabaseCharacterSet
.Example
(Get-AzOracleAutonomousDatabaseCharacterSet -Location "eastus").CharacterSet

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabaseCharacterSet
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

LOCATIONINPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoracleautonomousdatabasecharacterset
#>
function Get-AzOracleAutonomousDatabaseCharacterSet {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabaseCharacterSet])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # AutonomousDatabaseCharacterSet name
    ${Adbscharsetname},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the Azure region.
    ${Location},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${LocationInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleAutonomousDatabaseCharacterSet_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleAutonomousDatabaseCharacterSet_GetViaIdentity';
            GetViaIdentityLocation = 'Az.Oracle.private\Get-AzOracleAutonomousDatabaseCharacterSet_GetViaIdentityLocation';
            List = 'Az.Oracle.private\Get-AzOracleAutonomousDatabaseCharacterSet_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a AutonomousDatabaseNationalCharacterSet
.Description
Get a AutonomousDatabaseNationalCharacterSet
.Example
(Get-AzOracleAutonomousDatabaseNationalCharacterSet -Location "eastus").CharacterSet

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabaseNationalCharacterSet
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

LOCATIONINPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoracleautonomousdatabasenationalcharacterset
#>
function Get-AzOracleAutonomousDatabaseNationalCharacterSet {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabaseNationalCharacterSet])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # AutonomousDatabaseNationalCharacterSets name
    ${Adbsncharsetname},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the Azure region.
    ${Location},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${LocationInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleAutonomousDatabaseNationalCharacterSet_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleAutonomousDatabaseNationalCharacterSet_GetViaIdentity';
            GetViaIdentityLocation = 'Az.Oracle.private\Get-AzOracleAutonomousDatabaseNationalCharacterSet_GetViaIdentityLocation';
            List = 'Az.Oracle.private\Get-AzOracleAutonomousDatabaseNationalCharacterSet_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a AutonomousDbVersion
.Description
Get a AutonomousDbVersion
.Example
Get-AzOracleAutonomousDatabaseVersion -Location "eastus"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDbVersion
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

LOCATIONINPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoracleautonomousdatabaseversion
#>
function Get-AzOracleAutonomousDatabaseVersion {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDbVersion])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # AutonomousDbVersion name
    ${Autonomousdbversionsname},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the Azure region.
    ${Location},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${LocationInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleAutonomousDatabaseVersion_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleAutonomousDatabaseVersion_GetViaIdentity';
            GetViaIdentityLocation = 'Az.Oracle.private\Get-AzOracleAutonomousDatabaseVersion_GetViaIdentityLocation';
            List = 'Az.Oracle.private\Get-AzOracleAutonomousDatabaseVersion_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a AutonomousDatabase
.Description
Get a AutonomousDatabase
.Example
Get-AzOracleAutonomousDatabase

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabase
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoracleautonomousdatabase
#>
function Get-AzOracleAutonomousDatabase {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabase])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Alias('Autonomousdatabasename')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The database name.
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List1', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Parameter(ParameterSetName='List1')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleAutonomousDatabase_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleAutonomousDatabase_GetViaIdentity';
            List = 'Az.Oracle.private\Get-AzOracleAutonomousDatabase_List';
            List1 = 'Az.Oracle.private\Get-AzOracleAutonomousDatabase_List1';
        }
        if (('Get', 'List', 'List1') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a CloudExadataInfrastructure
.Description
Get a CloudExadataInfrastructure
.Example
Get-AzOracleCloudExadataInfrastructure
.Example
Get-AzOracleCloudExadataInfrastructure -Name "OFake_PowerShellTestExaInfra" -ResourceGroupName "PowerShellTestRg"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudExadataInfrastructure
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoraclecloudexadatainfrastructure
#>
function Get-AzOracleCloudExadataInfrastructure {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudExadataInfrastructure])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Alias('Cloudexadatainfrastructurename')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # CloudExadataInfrastructure name
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List1', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Parameter(ParameterSetName='List1')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleCloudExadataInfrastructure_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleCloudExadataInfrastructure_GetViaIdentity';
            List = 'Az.Oracle.private\Get-AzOracleCloudExadataInfrastructure_List';
            List1 = 'Az.Oracle.private\Get-AzOracleCloudExadataInfrastructure_List1';
        }
        if (('Get', 'List', 'List1') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a CloudVmCluster
.Description
Get a CloudVmCluster
.Example
Get-AzOracleCloudVMCluster

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudVMCluster
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoraclecloudvmcluster
#>
function Get-AzOracleCloudVMCluster {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudVMCluster])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Alias('Cloudvmclustername')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # CloudVmCluster name
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List1', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Parameter(ParameterSetName='List1')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleCloudVMCluster_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleCloudVMCluster_GetViaIdentity';
            List = 'Az.Oracle.private\Get-AzOracleCloudVMCluster_List';
            List1 = 'Az.Oracle.private\Get-AzOracleCloudVMCluster_List1';
        }
        if (('Get', 'List', 'List1') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a DbNode
.Description
Get a DbNode
.Example
Get-AzOracleDbNode -Cloudvmclustername "OFake_PowerShellTestVmCluster" -ResourceGroupName "PowerShellTestRg"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDbNode
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CLOUDVMCLUSTERINPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoracledbnode
#>
function Get-AzOracleDbNode {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDbNode])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # CloudVmCluster name
    ${Cloudvmclustername},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityCloudVMCluster', Mandatory)]
    [Alias('Dbnodeocid')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # DbNode OCID.
    ${Ocid},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityCloudVMCluster', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${CloudVMClusterInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleDbNode_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleDbNode_GetViaIdentity';
            GetViaIdentityCloudVMCluster = 'Az.Oracle.private\Get-AzOracleDbNode_GetViaIdentityCloudVMCluster';
            List = 'Az.Oracle.private\Get-AzOracleDbNode_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a DbServer
.Description
Get a DbServer
.Example
Get-AzOracleDbServer -Cloudexadatainfrastructurename "OFake_PowerShellTestExaInfra" -ResourceGroupName "PowerShellTestRg"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDbServer
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CLOUDEXADATAINFRASTRUCTUREINPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoracledbserver
#>
function Get-AzOracleDbServer {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDbServer])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # CloudExadataInfrastructure name
    ${Cloudexadatainfrastructurename},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityCloudExadataInfrastructure', Mandatory)]
    [Alias('Dbserverocid')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # DbServer OCID.
    ${Ocid},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityCloudExadataInfrastructure', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${CloudExadataInfrastructureInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleDbServer_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleDbServer_GetViaIdentity';
            GetViaIdentityCloudExadataInfrastructure = 'Az.Oracle.private\Get-AzOracleDbServer_GetViaIdentityCloudExadataInfrastructure';
            List = 'Az.Oracle.private\Get-AzOracleDbServer_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a DbSystemShape
.Description
Get a DbSystemShape
.Example
Get-AzOracleDbSystemShape -Location "eastus"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDbSystemShape
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

LOCATIONINPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoracledbsystemshape
#>
function Get-AzOracleDbSystemShape {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDbSystemShape])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the Azure region.
    ${Location},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory)]
    [Alias('Dbsystemshapename')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # DbSystemShape name
    ${Name},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${LocationInputObject},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Query')]
    [System.String]
    # Filters the result for the given Azure Availability Zone
    ${Zone},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleDbSystemShape_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleDbSystemShape_GetViaIdentity';
            GetViaIdentityLocation = 'Az.Oracle.private\Get-AzOracleDbSystemShape_GetViaIdentityLocation';
            List = 'Az.Oracle.private\Get-AzOracleDbSystemShape_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a DnsPrivateView
.Description
Get a DnsPrivateView
.Example
Get-AzOracleDnsPrivateView -Location "eastus"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDnsPrivateView
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

LOCATIONINPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoraclednsprivateview
#>
function Get-AzOracleDnsPrivateView {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDnsPrivateView])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the Azure region.
    ${Location},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory)]
    [Alias('Dnsprivateviewocid')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # DnsPrivateView OCID
    ${Ocid},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${LocationInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleDnsPrivateView_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleDnsPrivateView_GetViaIdentity';
            GetViaIdentityLocation = 'Az.Oracle.private\Get-AzOracleDnsPrivateView_GetViaIdentityLocation';
            List = 'Az.Oracle.private\Get-AzOracleDnsPrivateView_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a DnsPrivateZone
.Description
Get a DnsPrivateZone
.Example
Get-AzOracleDnsPrivateZone -Location "eastus"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDnsPrivateZone
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

LOCATIONINPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoraclednsprivatezone
#>
function Get-AzOracleDnsPrivateZone {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDnsPrivateZone])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the Azure region.
    ${Location},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory)]
    [Alias('Dnsprivatezonename')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # DnsPrivateZone name
    ${Name},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${LocationInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleDnsPrivateZone_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleDnsPrivateZone_GetViaIdentity';
            GetViaIdentityLocation = 'Az.Oracle.private\Get-AzOracleDnsPrivateZone_GetViaIdentityLocation';
            List = 'Az.Oracle.private\Get-AzOracleDnsPrivateZone_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a ExadbVmCluster
.Description
Get a ExadbVmCluster
.Example
Get-AzOracleExadbVMCluster

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExadbVMCluster
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoracleexadbvmcluster
#>
function Get-AzOracleExadbVMCluster {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExadbVMCluster])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Alias('ExadbVMClusterName')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the ExadbVmCluster
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List1', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Parameter(ParameterSetName='List1')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleExadbVMCluster_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleExadbVMCluster_GetViaIdentity';
            List = 'Az.Oracle.private\Get-AzOracleExadbVMCluster_List';
            List1 = 'Az.Oracle.private\Get-AzOracleExadbVMCluster_List1';
        }
        if (('Get', 'List', 'List1') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a ExascaleDbNode
.Description
Get a ExascaleDbNode
.Example
Get-AzOracleExascaleDbNode -Exadbvmclustername "OFake_PowerShellTestVmCluster" -ResourceGroupName "PowerShellTestRg"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExascaleDbNode
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

EXADBVMCLUSTERINPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoracleexascaledbnode
#>
function Get-AzOracleExascaleDbNode {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExascaleDbNode])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the ExadbVmCluster
    ${ExadbVMClusterName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityExadbVMCluster', Mandatory)]
    [Alias('ExascaleDbNodeName')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the ExascaleDbNode
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityExadbVMCluster', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${ExadbVMClusterInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleExascaleDbNode_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleExascaleDbNode_GetViaIdentity';
            GetViaIdentityExadbVMCluster = 'Az.Oracle.private\Get-AzOracleExascaleDbNode_GetViaIdentityExadbVMCluster';
            List = 'Az.Oracle.private\Get-AzOracleExascaleDbNode_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a ExascaleDbStorageVault
.Description
Get a ExascaleDbStorageVault
.Example
Get-AzOracleCloudVMCluster

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExascaleDbStorageVault
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoracleexascaledbstoragevault
#>
function Get-AzOracleExascaleDbStorageVault {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExascaleDbStorageVault])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Alias('ExascaleDbStorageVaultName')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the ExascaleDbStorageVault
    ${Name},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List1', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Parameter(ParameterSetName='List1')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleExascaleDbStorageVault_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleExascaleDbStorageVault_GetViaIdentity';
            List = 'Az.Oracle.private\Get-AzOracleExascaleDbStorageVault_List';
            List1 = 'Az.Oracle.private\Get-AzOracleExascaleDbStorageVault_List1';
        }
        if (('Get', 'List', 'List1') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a FlexComponent
.Description
Get a FlexComponent
.Example
Get-AzOracleFlexComponent -Location "eastus"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IFlexComponent
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

LOCATIONINPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoracleflexcomponent
#>
function Get-AzOracleFlexComponent {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IFlexComponent])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the Azure region.
    ${Location},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory)]
    [Alias('FlexComponentName')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the FlexComponent
    ${Name},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${LocationInputObject},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("Exadata.X9M", "Exadata.X11M", "ExaDbXS")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Query')]
    [System.String]
    # If provided, filters the results for the given shape
    ${Shape},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleFlexComponent_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleFlexComponent_GetViaIdentity';
            GetViaIdentityLocation = 'Az.Oracle.private\Get-AzOracleFlexComponent_GetViaIdentityLocation';
            List = 'Az.Oracle.private\Get-AzOracleFlexComponent_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a GiMinorVersion
.Description
Get a GiMinorVersion
.Example
Get-AzOracleGiVersion -Location "eastus"  -Shape "EXADATA"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IGiMinorVersion
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

GIVERSIONINPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

LOCATIONINPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoraclegiminorversion
#>
function Get-AzOracleGiMinorVersion {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IGiMinorVersion])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # GiVersion name
    ${Giversionname},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the Azure region.
    ${Location},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityGiVersion', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory)]
    [Alias('GiMinorVersionName')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the GiMinorVersion
    ${Name},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityGiVersion', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${GiVersionInputObject},

    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${LocationInputObject},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("EXADATA", "EXADB_XS")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Query')]
    [System.String]
    # If provided, filters the results to the set of database versions which are supported for the given shape family.
    ${ShapeFamily},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Query')]
    [System.String]
    # Filters the result for the given Azure Availability Zone
    ${Zone},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleGiMinorVersion_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleGiMinorVersion_GetViaIdentity';
            GetViaIdentityGiVersion = 'Az.Oracle.private\Get-AzOracleGiMinorVersion_GetViaIdentityGiVersion';
            GetViaIdentityLocation = 'Az.Oracle.private\Get-AzOracleGiMinorVersion_GetViaIdentityLocation';
            List = 'Az.Oracle.private\Get-AzOracleGiMinorVersion_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Get a GiVersion
.Description
Get a GiVersion
.Example
Get-AzOracleGiVersion -Location "eastus"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IGiVersion
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

LOCATIONINPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/get-azoraclegiversion
#>
function Get-AzOracleGiVersion {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IGiVersion])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='List', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the Azure region.
    ${Location},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory)]
    [Alias('Giversionname')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # GiVersion name
    ${Name},

    [Parameter(ParameterSetName='Get')]
    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='GetViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='GetViaIdentityLocation', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${LocationInputObject},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("Exadata.X9M", "Exadata.X11M", "ExaDbXS")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Query')]
    [System.String]
    # If provided, filters the results for the given shape
    ${Shape},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Query')]
    [System.String]
    # Filters the result for the given Azure Availability Zone
    ${Zone},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Get = 'Az.Oracle.private\Get-AzOracleGiVersion_Get';
            GetViaIdentity = 'Az.Oracle.private\Get-AzOracleGiVersion_GetViaIdentity';
            GetViaIdentityLocation = 'Az.Oracle.private\Get-AzOracleGiVersion_GetViaIdentityLocation';
            List = 'Az.Oracle.private\Get-AzOracleGiVersion_List';
        }
        if (('Get', 'List') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
VM actions on DbNode of VM Cluster by the provided filter
.Description
VM actions on DbNode of VM Cluster by the provided filter
.Example
$vmClusterName = "OFake_PowerShellTestVmCluster"
$resourceGroup = "PowerShellTestRg"
$stopActionName = "Stop"
            
$dbNodeList = Get-AzOracleDbNode -Cloudvmclustername $vmClusterName -ResourceGroupName $resourceGroup
$dbNodeOcid1 = $dbNodeList[0].Name
            
Invoke-AzOracleActionDbNode -ResourceGroupName $resourceGroup -Cloudvmclustername $vmClusterName -Dbnodeocid $dbNodeOcid1  -Action $stopActionName
.Example
$vmClusterName = "OFake_PowerShellTestVmCluster"
$resourceGroup = "PowerShellTestRg"
$startActionName = "Start"
            
$dbNodeList = Get-AzOracleDbNode -Cloudvmclustername $vmClusterName -ResourceGroupName $resourceGroup
$dbNodeOcid1 = $dbNodeList[0].Name
            
Invoke-AzOracleActionDbNode -Cloudvmclustername $vmClusterName -Dbnodeocid $dbNodeOcid1 -ResourceGroupName $resourceGroup -Action $startActionName

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDbNode
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CLOUDVMCLUSTERINPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/invoke-azoracleactiondbnode
#>
function Invoke-AzOracleActionDbNode {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDbNode])]
[CmdletBinding(DefaultParameterSetName='ActionExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='ActionExpanded', Mandatory)]
    [Parameter(ParameterSetName='ActionViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='ActionViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # CloudVmCluster name
    ${Cloudvmclustername},

    [Parameter(ParameterSetName='ActionExpanded', Mandatory)]
    [Parameter(ParameterSetName='ActionViaIdentityCloudVMClusterExpanded', Mandatory)]
    [Parameter(ParameterSetName='ActionViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='ActionViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # DbNode OCID.
    ${Dbnodeocid},

    [Parameter(ParameterSetName='ActionExpanded', Mandatory)]
    [Parameter(ParameterSetName='ActionViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='ActionViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='ActionExpanded')]
    [Parameter(ParameterSetName='ActionViaJsonFilePath')]
    [Parameter(ParameterSetName='ActionViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='ActionViaIdentityCloudVMClusterExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${CloudVMClusterInputObject},

    [Parameter(ParameterSetName='ActionViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='ActionExpanded', Mandatory)]
    [Parameter(ParameterSetName='ActionViaIdentityCloudVMClusterExpanded', Mandatory)]
    [Parameter(ParameterSetName='ActionViaIdentityExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("Start", "Stop", "SoftReset", "Reset")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Db action
    ${Action},

    [Parameter(ParameterSetName='ActionViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Action operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='ActionViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Action operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            ActionExpanded = 'Az.Oracle.private\Invoke-AzOracleActionDbNode_ActionExpanded';
            ActionViaIdentityCloudVMClusterExpanded = 'Az.Oracle.private\Invoke-AzOracleActionDbNode_ActionViaIdentityCloudVMClusterExpanded';
            ActionViaIdentityExpanded = 'Az.Oracle.private\Invoke-AzOracleActionDbNode_ActionViaIdentityExpanded';
            ActionViaJsonFilePath = 'Az.Oracle.private\Invoke-AzOracleActionDbNode_ActionViaJsonFilePath';
            ActionViaJsonString = 'Az.Oracle.private\Invoke-AzOracleActionDbNode_ActionViaJsonString';
        }
        if (('ActionExpanded', 'ActionViaJsonFilePath', 'ActionViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
VM actions on DbNode of ExadbVmCluster by the provided filter
.Description
VM actions on DbNode of ExadbVmCluster by the provided filter
.Example
$vmClusterName = "OFake_PowerShellTestVmCluster"
$resourceGroup = "PowerShellTestRg"
$stopActionName = "Stop"
            
$dbNodeList = Get-AzOracleExascaleDbNode -Exadbvmclustername $vmClusterName -ResourceGroupName $resourceGroup
$dbNodeOcid1 = $dbNodeList[0].Name
            
Invoke-AzOracleActionExascaleDbNode -ExadbVMClusterName $vmClusterName -ExascaleDbNodeName $dbNodeOcid1 -ResourceGroupName $resourceGroup -Action $stopActionName

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDbNodeAction
.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDbActionResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IDbNodeAction>: DbNode action object
  Action <String>: Db action

EXADBVMCLUSTERINPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/invoke-azoracleactionexascaledbnode
#>
function Invoke-AzOracleActionExascaleDbNode {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDbActionResponse])]
[CmdletBinding(DefaultParameterSetName='ActionExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='ActionExpanded', Mandatory)]
    [Parameter(ParameterSetName='ActionViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='ActionViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the ExadbVmCluster
    ${ExadbVMClusterName},

    [Parameter(ParameterSetName='ActionExpanded', Mandatory)]
    [Parameter(ParameterSetName='ActionViaIdentityExadbVMCluster', Mandatory)]
    [Parameter(ParameterSetName='ActionViaIdentityExadbVMClusterExpanded', Mandatory)]
    [Parameter(ParameterSetName='ActionViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='ActionViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the ExascaleDbNode
    ${ExascaleDbNodeName},

    [Parameter(ParameterSetName='ActionExpanded', Mandatory)]
    [Parameter(ParameterSetName='ActionViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='ActionViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='ActionExpanded')]
    [Parameter(ParameterSetName='ActionViaJsonFilePath')]
    [Parameter(ParameterSetName='ActionViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='ActionViaIdentityExadbVMCluster', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ActionViaIdentityExadbVMClusterExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${ExadbVMClusterInputObject},

    [Parameter(ParameterSetName='ActionViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='ActionExpanded', Mandatory)]
    [Parameter(ParameterSetName='ActionViaIdentityExadbVMClusterExpanded', Mandatory)]
    [Parameter(ParameterSetName='ActionViaIdentityExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("Start", "Stop", "SoftReset", "Reset")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Db action
    ${Action},

    [Parameter(ParameterSetName='ActionViaIdentityExadbVMCluster', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDbNodeAction]
    # DbNode action object
    ${Body},

    [Parameter(ParameterSetName='ActionViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Action operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='ActionViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Action operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            ActionExpanded = 'Az.Oracle.private\Invoke-AzOracleActionExascaleDbNode_ActionExpanded';
            ActionViaIdentityExadbVMCluster = 'Az.Oracle.private\Invoke-AzOracleActionExascaleDbNode_ActionViaIdentityExadbVMCluster';
            ActionViaIdentityExadbVMClusterExpanded = 'Az.Oracle.private\Invoke-AzOracleActionExascaleDbNode_ActionViaIdentityExadbVMClusterExpanded';
            ActionViaIdentityExpanded = 'Az.Oracle.private\Invoke-AzOracleActionExascaleDbNode_ActionViaIdentityExpanded';
            ActionViaJsonFilePath = 'Az.Oracle.private\Invoke-AzOracleActionExascaleDbNode_ActionViaJsonFilePath';
            ActionViaJsonString = 'Az.Oracle.private\Invoke-AzOracleActionExascaleDbNode_ActionViaJsonString';
        }
        if (('ActionExpanded', 'ActionViaJsonFilePath', 'ActionViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Perform switchover action on Autonomous Database
.Description
Perform switchover action on Autonomous Database
.Example
Invoke-AzOracleSwitchoverAutonomousDatabase -Autonomousdatabasename "OFakePowerShellTestAdbs" -ResourceGroupName "PowerShellTestRg" -PeerDbId "PeerDbId"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabase
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/invoke-azoracleswitchoverautonomousdatabase
#>
function Invoke-AzOracleSwitchoverAutonomousDatabase {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabase])]
[CmdletBinding(DefaultParameterSetName='SwitchoverExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='SwitchoverExpanded', Mandatory)]
    [Parameter(ParameterSetName='SwitchoverViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='SwitchoverViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The database name.
    ${Autonomousdatabasename},

    [Parameter(ParameterSetName='SwitchoverExpanded', Mandatory)]
    [Parameter(ParameterSetName='SwitchoverViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='SwitchoverViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='SwitchoverExpanded')]
    [Parameter(ParameterSetName='SwitchoverViaJsonFilePath')]
    [Parameter(ParameterSetName='SwitchoverViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='SwitchoverViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='SwitchoverExpanded')]
    [Parameter(ParameterSetName='SwitchoverViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The Azure resource ID of the Disaster Recovery peer database, which is located in a different region from the current peer database.
    ${PeerDbId},

    [Parameter(ParameterSetName='SwitchoverExpanded')]
    [Parameter(ParameterSetName='SwitchoverViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The location of the Disaster Recovery peer database.
    ${PeerDbLocation},

    [Parameter(ParameterSetName='SwitchoverExpanded')]
    [Parameter(ParameterSetName='SwitchoverViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Ocid of the Disaster Recovery peer database, which is located in a different region from the current peer database.
    ${PeerDbOcid},

    [Parameter(ParameterSetName='SwitchoverViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Switchover operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='SwitchoverViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Switchover operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            SwitchoverExpanded = 'Az.Oracle.private\Invoke-AzOracleSwitchoverAutonomousDatabase_SwitchoverExpanded';
            SwitchoverViaIdentityExpanded = 'Az.Oracle.private\Invoke-AzOracleSwitchoverAutonomousDatabase_SwitchoverViaIdentityExpanded';
            SwitchoverViaJsonFilePath = 'Az.Oracle.private\Invoke-AzOracleSwitchoverAutonomousDatabase_SwitchoverViaJsonFilePath';
            SwitchoverViaJsonString = 'Az.Oracle.private\Invoke-AzOracleSwitchoverAutonomousDatabase_SwitchoverViaJsonString';
        }
        if (('SwitchoverExpanded', 'SwitchoverViaJsonFilePath', 'SwitchoverViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create a AutonomousDatabaseBackup
.Description
Create a AutonomousDatabaseBackup
.Example
New-AzOracleAutonomousDatabaseBackup -Adbbackupid "testBackupId" -Autonomousdatabasename "OFakePowerShellTestAdbs" -ResourceGroupName "PowerShellTestRg" -RetentionPeriodInDay 90

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabaseBackup
.Link
https://learn.microsoft.com/powershell/module/az.oracle/new-azoracleautonomousdatabasebackup
#>
function New-AzOracleAutonomousDatabaseBackup {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabaseBackup])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # AutonomousDatabaseBackup id
    ${Adbbackupid},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The database name.
    ${Autonomousdatabasename},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The user-friendly name for the backup.
    # The name does not have to be unique.
    ${DisplayName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # Retention period, in days
    ${RetentionPeriodInDay},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.Oracle.private\New-AzOracleAutonomousDatabaseBackup_CreateExpanded';
            CreateViaJsonFilePath = 'Az.Oracle.private\New-AzOracleAutonomousDatabaseBackup_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.Oracle.private\New-AzOracleAutonomousDatabaseBackup_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create a AutonomousDatabase
.Description
Create a AutonomousDatabase
.Example
$subscriptionId = "00000000-0000-0000-0000-000000000000"
$resourceGroup = "PowerShellTestRg"

$vnetName = "PSTestVnet"
$vnetId = "/subscriptions/$($subscriptionId)/resourceGroups/$($resourceGroup)/providers/Microsoft.Network/virtualNetworks/$($vnetName)"

$subnetName = "delegated"
$subnetId = "/subscriptions/$($subscriptionId)/resourceGroups/$($resourceGroup)/providers/Microsoft.Network/virtualNetworks/$($vnetName)/subnets/$($subnetName)"

[SecureString]$adbsAdminPassword = ConvertTo-SecureString -String "PowerShellTestPass123" -AsPlainText -Force

$adbsName = "OFakePowerShellTestAdbs"
New-AzOracleAutonomousDatabase -Name $adbsName -ResourceGroupName $resourceGroup -Location "eastus" -DisplayName $adbsName -DbWorkload "OLTP" -ComputeCount 2.0 -ComputeModel "ECPU" -DbVersion "19c" -DataStorageSizeInGb 32 -AdminPassword $adbsAdminPassword -LicenseModel "BringYourOwnLicense" -SubnetId $subnetId -VnetId $vnetId -DataBaseType "Regular" -CharacterSet "AL32UTF8" -NcharacterSet "AL16UTF16"

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabase
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CUSTOMERCONTACT <ICustomerContact[]>: Customer Contacts.
  Email <String>: The email address used by Oracle to send notifications regarding databases and infrastructure.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/new-azoracleautonomousdatabase
#>
function New-AzOracleAutonomousDatabase {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabase])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('Autonomousdatabasename')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The database name.
    ${Name},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The geo-location where the resource lives
    ${Location},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Security.SecureString]
    # Admin password.
    ${AdminPassword},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Autonomous Database ID
    ${AutonomousDatabaseId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("Early", "Regular")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The maintenance schedule type of the Autonomous Database Serverless.
    ${AutonomousMaintenanceScheduleType},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # Retention period, in days, for long-term backups
    ${BackupRetentionPeriodInDay},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The character set for the autonomous database.
    ${CharacterSet},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Single]
    # The compute amount (CPUs) available to the database.
    ${ComputeCount},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("ECPU", "OCPU")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The compute model of the Autonomous Database.
    ${ComputeModel},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The number of CPU cores to be made available to the database.
    ${CpuCoreCount},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICustomerContact[]]
    # Customer Contacts.
    ${CustomerContact},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("Regular", "Clone", "CloneFromBackupTimestamp", "CrossRegionDisasterRecovery")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Database type to be created.
    ${DataBaseType},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The size, in gigabytes, of the data volume that will be created and attached to the database.
    ${DataStorageSizeInGb},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The quantity of data in the database, in terabytes.
    ${DataStorageSizeInTb},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("StandardEdition", "EnterpriseEdition")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The Oracle Database Edition that applies to the Autonomous databases.
    ${DatabaseEdition},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Name of the day of the week.
    ${DayOfWeekName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # A valid Oracle Database version for Autonomous Database.
    ${DbVersion},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("OLTP", "DW", "AJD", "APEX")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The Autonomous Database workload type
    ${DbWorkload},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The user-friendly name for the Autonomous Database.
    ${DisplayName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Indicates if auto scaling is enabled for the Autonomous Database CPU core count.
    ${IsAutoScalingEnabled},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Indicates if auto scaling is enabled for the Autonomous Database storage.
    ${IsAutoScalingForStorageEnabled},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Indicates whether the Autonomous Database has local or called in-region Data Guard enabled.
    ${IsLocalDataGuardEnabled},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Specifies if the Autonomous Database requires mTLS connections.
    ${IsMtlsConnectionRequired},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Specifies if the Autonomous Database preview version is being provisioned.
    ${IsPreviewVersionWithServiceTermsAccepted},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("LicenseIncluded", "BringYourOwnLicense")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The Oracle license model that applies to the Oracle Autonomous Database.
    # The default is LICENSE_INCLUDED.
    ${LicenseModel},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The character set for the Autonomous Database.
    ${NcharacterSet},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The private endpoint Ip address for the resource.
    ${PrivateEndpointIP},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The resource's private endpoint label.
    ${PrivateEndpointLabel},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # auto start time.
    # value must be of ISO-8601 format HH:mm
    ${ScheduledStartTime},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # auto stop time.
    # value must be of ISO-8601 format HH:mm
    ${ScheduledStopTime},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Client subnet
    ${SubnetId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ITrackedResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # VNET for network connectivity
    ${VnetId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String[]]
    # The client IP access control list (ACL).
    # This is an array of CIDR notations and/or IP addresses.
    # Values should be separate strings, separated by commas.
    # Example: ['1.1.1.1','1.1.1.0/24','1.1.2.25']
    ${WhitelistedIP},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.Oracle.private\New-AzOracleAutonomousDatabase_CreateExpanded';
            CreateViaJsonFilePath = 'Az.Oracle.private\New-AzOracleAutonomousDatabase_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.Oracle.private\New-AzOracleAutonomousDatabase_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create a CloudExadataInfrastructure
.Description
Create a CloudExadataInfrastructure
.Example
New-AzOracleCloudExadataInfrastructure -Name "OFake_PowerShellTestExaInfra" -ResourceGroupName "PowerShellTestRg" -Location "eastus" -Zone @("2") -Shape "Exadata.X9M" -ComputeCount 3 -StorageCount 3 -DisplayName "OFake_PowerShellTestExaInfra"

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudExadataInfrastructure
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CUSTOMERCONTACT <ICustomerContact[]>: The list of customer email addresses that receive information from Oracle about the specified OCI Database service resource. Oracle uses these email addresses to send notifications about planned and unplanned software maintenance updates, information about system hardware, and other information needed by administrators. Up to 10 email addresses can be added to the customer contacts for a cloud Exadata infrastructure instance. 
  Email <String>: The email address used by Oracle to send notifications regarding databases and infrastructure.

MAINTENANCEWINDOWDAYSOFWEEK <IDayOfWeek[]>: Days during the week when maintenance should be performed.
  Name <String>: Name of the day of the week.

MAINTENANCEWINDOWMONTH <IMonth[]>: Months during the year when maintenance should be performed.
  Name <String>: Name of the month of the year.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/new-azoraclecloudexadatainfrastructure
#>
function New-AzOracleCloudExadataInfrastructure {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudExadataInfrastructure])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('Cloudexadatainfrastructurename')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # CloudExadataInfrastructure name
    ${Name},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The geo-location where the resource lives
    ${Location},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String[]]
    # CloudExadataInfrastructure zones
    ${Zone},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The number of compute servers for the cloud Exadata infrastructure.
    ${ComputeCount},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICustomerContact[]]
    # The list of customer email addresses that receive information from Oracle about the specified OCI Database service resource.
    # Oracle uses these email addresses to send notifications about planned and unplanned software maintenance updates, information about system hardware, and other information needed by administrators.
    # Up to 10 email addresses can be added to the customer contacts for a cloud Exadata infrastructure instance.
    ${CustomerContact},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The database server model type of the cloud Exadata infrastructure resource.
    ${DatabaseServerType},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The name for the Exadata infrastructure.
    ${DisplayName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # Determines the amount of time the system will wait before the start of each database server patching operation.
    # Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
    ${MaintenanceWindowCustomActionTimeoutInMin},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDayOfWeek[]]
    # Days during the week when maintenance should be performed.
    ${MaintenanceWindowDaysOfWeek},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32[]]
    # The window of hours during the day when maintenance should be performed.
    # The window is a 4 hour slot.
    # Valid values are - 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
    ${MaintenanceWindowHoursOfDay},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
    ${MaintenanceWindowIsCustomActionTimeoutEnabled},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # is Monthly Patching Enabled
    ${MaintenanceWindowIsMonthlyPatchingEnabled},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # Lead time window allows user to set a lead time to prepare for a down time.
    # The lead time is in weeks and valid value is between 1 to 4.
    ${MaintenanceWindowLeadTimeInWeek},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IMonth[]]
    # Months during the year when maintenance should be performed.
    ${MaintenanceWindowMonth},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("Rolling", "NonRolling")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Cloud Exadata infrastructure node patching method.
    ${MaintenanceWindowPatchingMode},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("NoPreference", "CustomPreference")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The maintenance window scheduling preference.
    ${MaintenanceWindowPreference},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32[]]
    # Weeks during the month when maintenance should be performed.
    # Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days.
    # Weeks start and end based on calendar dates, not days of the week.
    # For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2.
    # Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days.
    # Note that this parameter works in conjunction with the daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
    ${MaintenanceWindowWeeksOfMonth},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The model name of the cloud Exadata infrastructure resource.
    ${Shape},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The number of storage servers for the cloud Exadata infrastructure.
    ${StorageCount},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The storage server model type of the cloud Exadata infrastructure resource.
    ${StorageServerType},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ITrackedResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.Oracle.private\New-AzOracleCloudExadataInfrastructure_CreateExpanded';
            CreateViaJsonFilePath = 'Az.Oracle.private\New-AzOracleCloudExadataInfrastructure_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.Oracle.private\New-AzOracleCloudExadataInfrastructure_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create a CloudVmCluster
.Description
Create a CloudVmCluster
.Example
$subscriptionId = "00000000-0000-0000-0000-000000000000"
$resourceGroup = "PowerShellTestRg"

$vnetName = "PSTestVnet"
$vnetId = "/subscriptions/$($subscriptionId)/resourceGroups/$($resourceGroup)/providers/Microsoft.Network/virtualNetworks/$($vnetName)"

$subnetName = "delegated"
$subnetId = "/subscriptions/$($subscriptionId)/resourceGroups/$($resourceGroup)/providers/Microsoft.Network/virtualNetworks/$($vnetName)/subnets/$($subnetName)"
    
$sshPublicKey = "ssh-rsa xxx"

$resourceGroup = "PowerShellTestRg"
$exaInfraName = "OFake_PowerShellTestExaInfra"
$exaInfra = Get-AzOracleCloudExadataInfrastructure -Name $exaInfraName -ResourceGroupName $resourceGroup
$exaInfraId = $exaInfra.Id

$dbServerList = Get-AzOracleDbServer -Cloudexadatainfrastructurename $exaInfraName -ResourceGroupName $resourceGroup
$dbServerOcid1 = $dbServerList[0].Ocid
$dbServerOcid2 = $dbServerList[1].Ocid

$vmClusterName = "OFake_PowerShellTestVmCluster"
New-AzOracleCloudVMCluster -Name $vmClusterName -ResourceGroupName $resourceGroup -Location "eastus" -DisplayName $vmClusterName -HostName "host" -CpuCoreCount 4 -CloudExadataInfrastructureId $exaInfraId -SshPublicKey $sshPublicKey -VnetId $vnetId -GiVersion "19.0.0.0" -SubnetId $subnetId -LicenseModel "LicenseIncluded" -ClusterName "TestVMC" -MemorySizeInGb 90 -DbNodeStorageSizeInGb 180 -DataStorageSizeInTb 2.0 -DataStoragePercentage 80 -TimeZone "UTC" -DbServer @($dbServerOcid1, $dbServerOcid2)       

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudVMCluster
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

NSGCIDR <INsgCidr[]>: CIDR blocks for additional NSG ingress rules. The VNET CIDRs used to provision the VM Cluster will be added by default.
  Source <String>: Conceptually, this is the range of IP addresses that a packet coming into the instance can come from.
  [DestinationPortRangeMax <Int32?>]: The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
  [DestinationPortRangeMin <Int32?>]: The minimum port number, which must not be greater than the maximum port number.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/new-azoraclecloudvmcluster
#>
function New-AzOracleCloudVMCluster {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudVMCluster])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('Cloudvmclustername')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # CloudVmCluster name
    ${Name},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The geo-location where the resource lives
    ${Location},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Client OCI backup subnet CIDR, default is 192.168.252.0/22
    ${BackupSubnetCidr},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Cloud Exadata Infrastructure ID
    ${CloudExadataInfrastructureId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The cluster name for cloud VM cluster.
    # The cluster name must begin with an alphabetic character, and may contain hyphens (-).
    # Underscores (_) are not permitted.
    # The cluster name can be no longer than 11 characters and is not case sensitive.
    ${ClusterName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The number of CPU cores enabled on the cloud VM cluster.
    ${CpuCoreCount},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS.
    ${DataCollectionOptionIsDiagnosticsEventsEnabled},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS.
    ${DataCollectionOptionIsHealthMonitoringEnabled},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS.
    ${DataCollectionOptionIsIncidentLogsEnabled},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The percentage assigned to DATA storage (user data and database files).
    # The remaining percentage is assigned to RECO storage (database redo logs, archive logs, and recovery manager backups).
    # Accepted values are 35, 40, 60 and 80.
    # The default is 80 percent assigned to DATA storage.
    # See [Storage Configuration](/Content/Database/Concepts/exaoverview.htm#Exadata) in the Exadata documentation for details on the impact of the configuration settings on storage.
    ${DataStoragePercentage},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Double]
    # The data disk group size to be allocated in TBs.
    ${DataStorageSizeInTb},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The local node storage to be allocated in GBs.
    ${DbNodeStorageSizeInGb},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String[]]
    # The list of DB servers.
    ${DbServer},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Display Name
    ${DisplayName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The domain name for the cloud VM cluster.
    ${Domain},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Oracle Grid Infrastructure (GI) software version
    ${GiVersion},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The hostname for the cloud VM cluster.
    ${Hostname},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If true, database backup on local Exadata storage is configured for the cloud VM cluster.
    # If false, database backup on local Exadata storage is not available in the cloud VM cluster.
    ${IsLocalBackupEnabled},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If true, sparse disk group is configured for the cloud VM cluster.
    # If false, sparse disk group is not created.
    ${IsSparseDiskgroupEnabled},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("LicenseIncluded", "BringYourOwnLicense")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The Oracle license model that applies to the cloud VM cluster.
    # The default is LICENSE_INCLUDED.
    ${LicenseModel},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The memory to be allocated in GBs.
    ${MemorySizeInGb},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.INsgCidr[]]
    # CIDR blocks for additional NSG ingress rules.
    # The VNET CIDRs used to provision the VM Cluster will be added by default.
    ${NsgCidr},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Single]
    # The number of OCPU cores to enable on the cloud VM cluster.
    # Only 1 decimal place is allowed for the fractional part.
    ${OcpuCount},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The TCP Single Client Access Name (SCAN) port.
    # The default port is 1521.
    ${ScanListenerPortTcp},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The TCPS Single Client Access Name (SCAN) port.
    # The default port is 2484.
    ${ScanListenerPortTcpSsl},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String[]]
    # The public key portion of one or more key pairs used for SSH access to the cloud VM cluster.
    ${SshPublicKey},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Client subnet
    ${SubnetId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Operating system version of the image.
    ${SystemVersion},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ITrackedResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The time zone of the cloud VM cluster.
    # For details, see [Exadata Infrastructure Time Zones](/Content/Database/References/timezones.htm).
    ${TimeZone},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # VNET for network connectivity
    ${VnetId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The OCID of the zone the cloud VM cluster is associated with.
    ${ZoneId},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.Oracle.private\New-AzOracleCloudVMCluster_CreateExpanded';
            CreateViaJsonFilePath = 'Az.Oracle.private\New-AzOracleCloudVMCluster_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.Oracle.private\New-AzOracleCloudVMCluster_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create a ExadbVmCluster
.Description
Create a ExadbVmCluster
.Example
$subscriptionId = "00000000-0000-0000-0000-000000000000"
$resourceGroup = "PowerShellTestRg"

$vnetName = "PSTestVnet"
$vnetId = "/subscriptions/$($subscriptionId)/resourceGroups/$($resourceGroup)/providers/Microsoft.Network/virtualNetworks/$($vnetName)"

$subnetName = "delegated"
$subnetId = "/subscriptions/$($subscriptionId)/resourceGroups/$($resourceGroup)/providers/Microsoft.Network/virtualNetworks/$($vnetName)/subnets/$($subnetName)"
    
$sshPublicKey = "ssh-rsa xxx"

$resourceGroup = "PowerShellTestRg"
$exascaleStorageVaultName = "OFake_PowerShellTestExaScaleStorage"
$exascaleDbStorageVault = Get-AzOracleExascaleDbStorageVault -Name $exascaleStorageVaultName -ResourceGroupName $resourceGroup
$exascaleDbStorageVaultId = $exascaleDbStorageVault.Id

$exadbVmClusterName = "OFake_PowerShellTestExadbVmCluster"
New-AzOracleExadbVMCluster -Name $exadbVmClusterName -ResourceGroupName $resourceGroup -Location "eastus" -DisplayName $exadbVmClusterName -HostName "host" -totalEcpuCount 8 -exascaleDbStorageVaultId $exascaleDbStorageVaultId -SshPublicKey $sshPublicKey -VnetId $vnetId -SubnetId $subnetId -LicenseModel "LicenseIncluded" -shape "ExaDbXS" -enabledEcpuCount 8 -TimeZone "UTC" -nodeCount 1 

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExadbVMCluster
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

NSGCIDR <INsgCidr[]>: CIDR blocks for additional NSG ingress rules. The VNET CIDRs used to provision the VM Cluster will be added by default.
  Source <String>: Conceptually, this is the range of IP addresses that a packet coming into the instance can come from.
  [DestinationPortRangeMax <Int32?>]: The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
  [DestinationPortRangeMin <Int32?>]: The minimum port number, which must not be greater than the maximum port number.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/new-azoracleexadbvmcluster
#>
function New-AzOracleExadbVMCluster {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExadbVMCluster])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('ExadbVMClusterName')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the ExadbVmCluster
    ${Name},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The geo-location where the resource lives
    ${Location},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Client OCI backup subnet CIDR, default is 192.168.252.0/22
    ${BackupSubnetCidr},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The cluster name for Exadata VM cluster on Exascale Infrastructure.
    # The cluster name must begin with an alphabetic character, and may contain hyphens (-).
    # Underscores (_) are not permitted.
    # The cluster name can be no longer than 11 characters and is not case sensitive.
    ${ClusterName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS.
    ${DataCollectionOptionIsDiagnosticsEventsEnabled},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS.
    ${DataCollectionOptionIsHealthMonitoringEnabled},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS.
    ${DataCollectionOptionIsIncidentLogsEnabled},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Display Name
    ${DisplayName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # A domain name used for the Exadata VM cluster on Exascale Infrastructure
    ${Domain},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The number of ECPUs to enable for an Exadata VM cluster on Exascale Infrastructure.
    ${EnabledEcpuCount},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The Azure Resource ID of the Exadata Database Storage Vault.
    ${ExascaleDbStorageVaultId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Grid Setup will be done using this Grid Image OCID.
    # Can be obtained using giMinorVersions API
    ${GridImageOcid},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The hostname for the Exadata VM cluster on Exascale Infrastructure.
    ${Hostname},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("LicenseIncluded", "BringYourOwnLicense")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The Oracle license model that applies to the Exadata VM cluster on Exascale Infrastructure.
    # The default is LICENSE_INCLUDED.
    ${LicenseModel},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The number of nodes in the Exadata VM cluster on Exascale Infrastructure.
    ${NodeCount},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.INsgCidr[]]
    # CIDR blocks for additional NSG ingress rules.
    # The VNET CIDRs used to provision the VM Cluster will be added by default.
    ${NsgCidr},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The OCID of the zone the Exadata VM cluster on Exascale Infrastructure is associated with.
    ${PrivateZoneOcid},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The TCP Single Client Access Name (SCAN) port.
    # The default port is 1521.
    ${ScanListenerPortTcp},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The TCPS Single Client Access Name (SCAN) port.
    # The default port is 2484.
    ${ScanListenerPortTcpSsl},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The shape of the Exadata VM cluster on Exascale Infrastructure resource
    ${Shape},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String[]]
    # The public key portion of one or more key pairs used for SSH access to the Exadata VM cluster on Exascale Infrastructure.
    ${SshPublicKey},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Client subnet
    ${SubnetId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Operating system version of the image.
    ${SystemVersion},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ITrackedResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The time zone of the Exadata VM cluster on Exascale Infrastructure.
    # For details, see [Exadata Infrastructure Time Zones](/Content/Database/References/timezones.htm).
    ${TimeZone},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The number of Total ECPUs for an Exadata VM cluster on Exascale Infrastructure.
    ${TotalEcpuCount},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # Total Capacity
    ${VMFileSystemStorageTotalSizeInGb},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # VNET for network connectivity
    ${VnetId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String[]]
    # The availability zones.
    ${Zone},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.Oracle.private\New-AzOracleExadbVMCluster_CreateExpanded';
            CreateViaJsonFilePath = 'Az.Oracle.private\New-AzOracleExadbVMCluster_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.Oracle.private\New-AzOracleExadbVMCluster_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create a ExascaleDbStorageVault
.Description
Create a ExascaleDbStorageVault
.Example
$subscriptionId = "00000000-0000-0000-0000-000000000000"
$resourceGroup = "PowerShellTestRg"

$exaScaleDbStorageVaultName = "OFake_PowerShellTestExaScaleDbStorage"
New-AzOracleExascaleDbStorageVault -Name $exaScaleDbStorageVaultName -ResourceGroupName $resourceGroup -Location "eastus" -DisplayName $exaScaleDbStorageVaultName -description "description" -additionalFlashCacheInPercent 100 -TimeZone "UTC"  

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExascaleDbStorageVault
.Link
https://learn.microsoft.com/powershell/module/az.oracle/new-azoracleexascaledbstoragevault
#>
function New-AzOracleExascaleDbStorageVault {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExascaleDbStorageVault])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('ExascaleDbStorageVaultName')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the ExascaleDbStorageVault
    ${Name},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The geo-location where the resource lives
    ${Location},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The size of additional Flash Cache in percentage of High Capacity database storage.
    ${AdditionalFlashCacheInPercent},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Exadata Database Storage Vault description.
    ${Description},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The user-friendly name for the Exadata Database Storage Vault.
    # The name does not need to be unique.
    ${DisplayName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # Total Capacity
    ${HighCapacityDatabaseStorageInputTotalSizeInGb},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ITrackedResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The time zone that you want to use for the Exadata Database Storage Vault
    ${TimeZone},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String[]]
    # The availability zones.
    ${Zone},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            CreateExpanded = 'Az.Oracle.private\New-AzOracleExascaleDbStorageVault_CreateExpanded';
            CreateViaJsonFilePath = 'Az.Oracle.private\New-AzOracleExascaleDbStorageVault_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.Oracle.private\New-AzOracleExascaleDbStorageVault_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Delete a AutonomousDatabaseBackup
.Description
Delete a AutonomousDatabaseBackup
.Example
Remove-AzOracleAutonomousDatabaseBackup -Adbbackupid "testBackupId" -Autonomousdatabasename "OFakePowerShellTestAdbs" -ResourceGroupName "PowerShellTestRg"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

AUTONOMOUSDATABASEINPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/remove-azoracleautonomousdatabasebackup
#>
function Remove-AzOracleAutonomousDatabaseBackup {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Parameter(ParameterSetName='DeleteViaIdentityAutonomousDatabase', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # AutonomousDatabaseBackup id
    ${Adbbackupid},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The database name.
    ${Autonomousdatabasename},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='DeleteViaIdentityAutonomousDatabase', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${AutonomousDatabaseInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.Oracle.private\Remove-AzOracleAutonomousDatabaseBackup_Delete';
            DeleteViaIdentity = 'Az.Oracle.private\Remove-AzOracleAutonomousDatabaseBackup_DeleteViaIdentity';
            DeleteViaIdentityAutonomousDatabase = 'Az.Oracle.private\Remove-AzOracleAutonomousDatabaseBackup_DeleteViaIdentityAutonomousDatabase';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Delete a AutonomousDatabase
.Description
Delete a AutonomousDatabase
.Example
Remove-AzOracleAutonomousDatabase -NoWait -Name "OFakePowerShellTestAdbs" -ResourceGroupName "PowerShellTestRg"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/remove-azoracleautonomousdatabase
#>
function Remove-AzOracleAutonomousDatabase {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Alias('Autonomousdatabasename')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The database name.
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.Oracle.private\Remove-AzOracleAutonomousDatabase_Delete';
            DeleteViaIdentity = 'Az.Oracle.private\Remove-AzOracleAutonomousDatabase_DeleteViaIdentity';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Delete a CloudExadataInfrastructure
.Description
Delete a CloudExadataInfrastructure
.Example
Remove-AzOracleCloudExadataInfrastructure -NoWait -Name "OFake_PowerShellTestExaInfra" -ResourceGroupName "PowerShellTestRg"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/remove-azoraclecloudexadatainfrastructure
#>
function Remove-AzOracleCloudExadataInfrastructure {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Alias('Cloudexadatainfrastructurename')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # CloudExadataInfrastructure name
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.Oracle.private\Remove-AzOracleCloudExadataInfrastructure_Delete';
            DeleteViaIdentity = 'Az.Oracle.private\Remove-AzOracleCloudExadataInfrastructure_DeleteViaIdentity';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Remove VMs from the VM Cluster
.Description
Remove VMs from the VM Cluster
.Example
$resourceGroup = "PowerShellTestRg"

$dbServerList = Get-AzOracleDbServer -Cloudexadatainfrastructurename "OFake_PowerShellTestExaInfra" -ResourceGroupName $resourceGroup
$dbServerOcid1 = $dbServerList[0].Ocid
$dbServersToRemove = @($dbServerOcid1)

Remove-AzOracleCloudVMClusterVM -Cloudvmclustername "OFake_PowerShellTestVmCluster" -ResourceGroupName "PowerShellTestRg" -DbServer $dbServersToRemove

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAddRemoveDbNode
.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudVMCluster
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IAddRemoveDbNode>: Add/Remove (Virtual Machine) DbNode model
  DbServer <List<String>>: Db servers ocids

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/remove-azoraclecloudvmclustervm
#>
function Remove-AzOracleCloudVMClusterVM {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudVMCluster])]
[CmdletBinding(DefaultParameterSetName='RemoveExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Remove', Mandatory)]
    [Parameter(ParameterSetName='RemoveExpanded', Mandatory)]
    [Parameter(ParameterSetName='RemoveViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='RemoveViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # CloudVmCluster name
    ${Cloudvmclustername},

    [Parameter(ParameterSetName='Remove', Mandatory)]
    [Parameter(ParameterSetName='RemoveExpanded', Mandatory)]
    [Parameter(ParameterSetName='RemoveViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='RemoveViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Remove')]
    [Parameter(ParameterSetName='RemoveExpanded')]
    [Parameter(ParameterSetName='RemoveViaJsonFilePath')]
    [Parameter(ParameterSetName='RemoveViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='RemoveViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='RemoveViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='Remove', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='RemoveViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAddRemoveDbNode]
    # Add/Remove (Virtual Machine) DbNode model
    ${Body},

    [Parameter(ParameterSetName='RemoveExpanded', Mandatory)]
    [Parameter(ParameterSetName='RemoveViaIdentityExpanded', Mandatory)]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String[]]
    # Db servers ocids
    ${DbServer},

    [Parameter(ParameterSetName='RemoveViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Remove operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='RemoveViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Remove operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Remove = 'Az.Oracle.private\Remove-AzOracleCloudVMClusterVM_Remove';
            RemoveExpanded = 'Az.Oracle.private\Remove-AzOracleCloudVMClusterVM_RemoveExpanded';
            RemoveViaIdentity = 'Az.Oracle.private\Remove-AzOracleCloudVMClusterVM_RemoveViaIdentity';
            RemoveViaIdentityExpanded = 'Az.Oracle.private\Remove-AzOracleCloudVMClusterVM_RemoveViaIdentityExpanded';
            RemoveViaJsonFilePath = 'Az.Oracle.private\Remove-AzOracleCloudVMClusterVM_RemoveViaJsonFilePath';
            RemoveViaJsonString = 'Az.Oracle.private\Remove-AzOracleCloudVMClusterVM_RemoveViaJsonString';
        }
        if (('Remove', 'RemoveExpanded', 'RemoveViaJsonFilePath', 'RemoveViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Delete a CloudVmCluster
.Description
Delete a CloudVmCluster
.Example
Remove-AzOracleCloudVMCluster -NoWait -Name "OFake_PowerShellTestVmCluster" -ResourceGroupName "PowerShellTestRg"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/remove-azoraclecloudvmcluster
#>
function Remove-AzOracleCloudVMCluster {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Alias('Cloudvmclustername')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # CloudVmCluster name
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.Oracle.private\Remove-AzOracleCloudVMCluster_Delete';
            DeleteViaIdentity = 'Az.Oracle.private\Remove-AzOracleCloudVMCluster_DeleteViaIdentity';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Remove VMs from the VM Cluster
.Description
Remove VMs from the VM Cluster
.Example
$resourceGroup = "PowerShellTestRg"

$dbNodeList = Get-AzOracleExascaleDbNode -Exadbvmclustername "OFake_PowerShellTestVmCluster" -ResourceGroupName $resourceGroup
$dbNodeOcid1 = $dbNodeList[0].Ocid
$dbNodeToRemove = @($dbNodeOcid1)

Remove-AzOracleExadbVMClusterVM -Exadbvmclustername "OFake_PowerShellTestVmCluster" -ResourceGroupName $resourceGroup -DbNode $dbNodeToRemove

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IRemoveVirtualMachineFromExadbVMClusterDetails
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExadbVMCluster
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IRemoveVirtualMachineFromExadbVMClusterDetails>: Details of removing Virtual Machines from the Exadata VM cluster on Exascale Infrastructure. Applies to Exadata Database Service on Exascale Infrastructure only.
  DbNode <List<IDbNodeDetails>>: The list of ExaCS DB nodes for the Exadata VM cluster on Exascale Infrastructure to be removed.
    DbNodeId <String>: Exascale DbNode Azure Resource ID

DBNODE <IDbNodeDetails[]>: The list of ExaCS DB nodes for the Exadata VM cluster on Exascale Infrastructure to be removed.
  DbNodeId <String>: Exascale DbNode Azure Resource ID

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/remove-azoracleexadbvmclustervm
#>
function Remove-AzOracleExadbVMClusterVM {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExadbVMCluster])]
[CmdletBinding(DefaultParameterSetName='RemoveViaIdentity', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Remove', Mandatory)]
    [Parameter(ParameterSetName='RemoveExpanded', Mandatory)]
    [Parameter(ParameterSetName='RemoveViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='RemoveViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the ExadbVmCluster
    ${ExadbVMClusterName},

    [Parameter(ParameterSetName='Remove', Mandatory)]
    [Parameter(ParameterSetName='RemoveExpanded', Mandatory)]
    [Parameter(ParameterSetName='RemoveViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='RemoveViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Remove')]
    [Parameter(ParameterSetName='RemoveExpanded')]
    [Parameter(ParameterSetName='RemoveViaJsonFilePath')]
    [Parameter(ParameterSetName='RemoveViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='RemoveViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='RemoveViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='Remove', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='RemoveViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IRemoveVirtualMachineFromExadbVMClusterDetails]
    # Details of removing Virtual Machines from the Exadata VM cluster on Exascale Infrastructure.
    # Applies to Exadata Database Service on Exascale Infrastructure only.
    ${Body},

    [Parameter(ParameterSetName='RemoveExpanded', Mandatory)]
    [Parameter(ParameterSetName='RemoveViaIdentityExpanded', Mandatory)]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDbNodeDetails[]]
    # The list of ExaCS DB nodes for the Exadata VM cluster on Exascale Infrastructure to be removed.
    ${DbNode},

    [Parameter(ParameterSetName='RemoveViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Remove operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='RemoveViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Remove operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Remove = 'Az.Oracle.private\Remove-AzOracleExadbVMClusterVM_Remove';
            RemoveExpanded = 'Az.Oracle.private\Remove-AzOracleExadbVMClusterVM_RemoveExpanded';
            RemoveViaIdentity = 'Az.Oracle.private\Remove-AzOracleExadbVMClusterVM_RemoveViaIdentity';
            RemoveViaIdentityExpanded = 'Az.Oracle.private\Remove-AzOracleExadbVMClusterVM_RemoveViaIdentityExpanded';
            RemoveViaJsonFilePath = 'Az.Oracle.private\Remove-AzOracleExadbVMClusterVM_RemoveViaJsonFilePath';
            RemoveViaJsonString = 'Az.Oracle.private\Remove-AzOracleExadbVMClusterVM_RemoveViaJsonString';
        }
        if (('Remove', 'RemoveExpanded', 'RemoveViaJsonFilePath', 'RemoveViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Delete a ExadbVmCluster
.Description
Delete a ExadbVmCluster
.Example
Remove-AzOracleExadbVMCluster -NoWait -Name "OFake_PowerShellTestVmCluster" -ResourceGroupName "PowerShellTestRg"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/remove-azoracleexadbvmcluster
#>
function Remove-AzOracleExadbVMCluster {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Alias('ExadbVMClusterName')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the ExadbVmCluster
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.Oracle.private\Remove-AzOracleExadbVMCluster_Delete';
            DeleteViaIdentity = 'Az.Oracle.private\Remove-AzOracleExadbVMCluster_DeleteViaIdentity';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Delete a ExascaleDbStorageVault
.Description
Delete a ExascaleDbStorageVault
.Example
Remove-AzOracleExascaleDbStorageVault -NoWait -Name "OFake_PowerShellTestExascaleDbStorageVault" -ResourceGroupName "PowerShellTestRg"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/remove-azoracleexascaledbstoragevault
#>
function Remove-AzOracleExascaleDbStorageVault {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Alias('ExascaleDbStorageVaultName')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the ExascaleDbStorageVault
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Delete')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='DeleteViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Delete = 'Az.Oracle.private\Remove-AzOracleExascaleDbStorageVault_Delete';
            DeleteViaIdentity = 'Az.Oracle.private\Remove-AzOracleExascaleDbStorageVault_DeleteViaIdentity';
        }
        if (('Delete') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Perform ChangeDisasterRecoveryConfiguration action on Autonomous Database
.Description
Perform ChangeDisasterRecoveryConfiguration action on Autonomous Database
.Example
$subscriptionId = "00000000-0000-0000-0000-000000000000"
$resourceGroup = "PowerShellTestRg"
$autonomousdatabasename = "databasedb1"

Rename-AzOracleAutonomousDatabaseDisasterRecoveryConfiguration -autonomousdatabasename $autonomousdatabasename -ResourceGroupName $resourceGroup -DisasterRecoveryType "Adg"

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDisasterRecoveryConfigurationDetails
.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabase
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IDisasterRecoveryConfigurationDetails>: Configurations of a Disaster Recovery Details
  [DisasterRecoveryType <String>]: Indicates the disaster recovery (DR) type of the Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
  [IsReplicateAutomaticBackup <Boolean?>]: If true, 7 days worth of backups are replicated across regions for Cross-Region ADB or Backup-Based DR between Primary and Standby. If false, the backups taken on the Primary are not replicated to the Standby database.
  [IsSnapshotStandby <Boolean?>]: Indicates if user wants to convert to a snapshot standby. For example, true would set a standby database to snapshot standby database. False would set a snapshot standby database back to regular standby database.
  [TimeSnapshotStandbyEnabledTill <DateTime?>]: Time and date stored as an RFC 3339 formatted timestamp string. For example, 2022-01-01T12:00:00.000Z would set a limit for the snapshot standby to be converted back to a cross-region standby database.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/rename-azoracleautonomousdatabasedisasterrecoveryconfiguration
#>
function Rename-AzOracleAutonomousDatabaseDisasterRecoveryConfiguration {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabase])]
[CmdletBinding(DefaultParameterSetName='ChangeExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Change', Mandatory)]
    [Parameter(ParameterSetName='ChangeExpanded', Mandatory)]
    [Parameter(ParameterSetName='ChangeViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='ChangeViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The database name.
    ${Autonomousdatabasename},

    [Parameter(ParameterSetName='Change', Mandatory)]
    [Parameter(ParameterSetName='ChangeExpanded', Mandatory)]
    [Parameter(ParameterSetName='ChangeViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='ChangeViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Change')]
    [Parameter(ParameterSetName='ChangeExpanded')]
    [Parameter(ParameterSetName='ChangeViaJsonFilePath')]
    [Parameter(ParameterSetName='ChangeViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='ChangeViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ChangeViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='Change', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='ChangeViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDisasterRecoveryConfigurationDetails]
    # Configurations of a Disaster Recovery Details
    ${Body},

    [Parameter(ParameterSetName='ChangeExpanded')]
    [Parameter(ParameterSetName='ChangeViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("Adg", "BackupBased")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Indicates the disaster recovery (DR) type of the Autonomous Database Serverless instance.
    # Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or switchover.
    # Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
    ${DisasterRecoveryType},

    [Parameter(ParameterSetName='ChangeExpanded')]
    [Parameter(ParameterSetName='ChangeViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If true, 7 days worth of backups are replicated across regions for Cross-Region ADB or Backup-Based DR between Primary and Standby.
    # If false, the backups taken on the Primary are not replicated to the Standby database.
    ${IsReplicateAutomaticBackup},

    [Parameter(ParameterSetName='ChangeExpanded')]
    [Parameter(ParameterSetName='ChangeViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Indicates if user wants to convert to a snapshot standby.
    # For example, true would set a standby database to snapshot standby database.
    # False would set a snapshot standby database back to regular standby database.
    ${IsSnapshotStandby},

    [Parameter(ParameterSetName='ChangeExpanded')]
    [Parameter(ParameterSetName='ChangeViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.DateTime]
    # Time and date stored as an RFC 3339 formatted timestamp string.
    # For example, 2022-01-01T12:00:00.000Z would set a limit for the snapshot standby to be converted back to a cross-region standby database.
    ${TimeSnapshotStandbyEnabledTill},

    [Parameter(ParameterSetName='ChangeViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Change operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='ChangeViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Change operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Change = 'Az.Oracle.private\Rename-AzOracleAutonomousDatabaseDisasterRecoveryConfiguration_Change';
            ChangeExpanded = 'Az.Oracle.private\Rename-AzOracleAutonomousDatabaseDisasterRecoveryConfiguration_ChangeExpanded';
            ChangeViaIdentity = 'Az.Oracle.private\Rename-AzOracleAutonomousDatabaseDisasterRecoveryConfiguration_ChangeViaIdentity';
            ChangeViaIdentityExpanded = 'Az.Oracle.private\Rename-AzOracleAutonomousDatabaseDisasterRecoveryConfiguration_ChangeViaIdentityExpanded';
            ChangeViaJsonFilePath = 'Az.Oracle.private\Rename-AzOracleAutonomousDatabaseDisasterRecoveryConfiguration_ChangeViaJsonFilePath';
            ChangeViaJsonString = 'Az.Oracle.private\Rename-AzOracleAutonomousDatabaseDisasterRecoveryConfiguration_ChangeViaJsonString';
        }
        if (('Change', 'ChangeExpanded', 'ChangeViaJsonFilePath', 'ChangeViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Restores an Autonomous Database based on the provided request parameters.
.Description
Restores an Autonomous Database based on the provided request parameters.
.Example
$timeStamp = Get-Date
Restore-AzOracleAutonomousDatabase -Name "OFakePowerShellTestAdbs" -ResourceGroupName "PowerShellTestRg" -Timestamp $timeStamp

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IRestoreAutonomousDatabaseDetails
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabase
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IRestoreAutonomousDatabaseDetails>: Details to restore an Oracle Autonomous Database.
  Timestamp <DateTime>: The time to restore the database to.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/restore-azoracleautonomousdatabase
#>
function Restore-AzOracleAutonomousDatabase {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabase])]
[CmdletBinding(DefaultParameterSetName='RestoreExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Restore', Mandatory)]
    [Parameter(ParameterSetName='RestoreExpanded', Mandatory)]
    [Parameter(ParameterSetName='RestoreViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='RestoreViaJsonString', Mandatory)]
    [Alias('Autonomousdatabasename')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The database name.
    ${Name},

    [Parameter(ParameterSetName='Restore', Mandatory)]
    [Parameter(ParameterSetName='RestoreExpanded', Mandatory)]
    [Parameter(ParameterSetName='RestoreViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='RestoreViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='Restore')]
    [Parameter(ParameterSetName='RestoreExpanded')]
    [Parameter(ParameterSetName='RestoreViaJsonFilePath')]
    [Parameter(ParameterSetName='RestoreViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='RestoreViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='Restore', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='RestoreViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IRestoreAutonomousDatabaseDetails]
    # Details to restore an Oracle Autonomous Database.
    ${Body},

    [Parameter(ParameterSetName='RestoreExpanded', Mandatory)]
    [Parameter(ParameterSetName='RestoreViaIdentityExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.DateTime]
    # The time to restore the database to.
    ${Timestamp},

    [Parameter(ParameterSetName='RestoreViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Restore operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='RestoreViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Restore operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            Restore = 'Az.Oracle.private\Restore-AzOracleAutonomousDatabase_Restore';
            RestoreExpanded = 'Az.Oracle.private\Restore-AzOracleAutonomousDatabase_RestoreExpanded';
            RestoreViaIdentity = 'Az.Oracle.private\Restore-AzOracleAutonomousDatabase_RestoreViaIdentity';
            RestoreViaIdentityExpanded = 'Az.Oracle.private\Restore-AzOracleAutonomousDatabase_RestoreViaIdentityExpanded';
            RestoreViaJsonFilePath = 'Az.Oracle.private\Restore-AzOracleAutonomousDatabase_RestoreViaJsonFilePath';
            RestoreViaJsonString = 'Az.Oracle.private\Restore-AzOracleAutonomousDatabase_RestoreViaJsonString';
        }
        if (('Restore', 'RestoreExpanded', 'RestoreViaJsonFilePath', 'RestoreViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Update a AutonomousDatabase
.Description
Update a AutonomousDatabase
.Example
$tagHashTable = @{'tagName'="tagValue"}
Update-AzOracleAutonomousDatabase -Name "OFakePowerShellTestAdbs" -ResourceGroupName "PowerShellTestRg" -Tag $tagHashTable

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabase
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CUSTOMERCONTACT <ICustomerContact[]>: Customer Contacts.
  Email <String>: The email address used by Oracle to send notifications regarding databases and infrastructure.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/update-azoracleautonomousdatabase
#>
function Update-AzOracleAutonomousDatabase {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabase])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Alias('Autonomousdatabasename')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The database name.
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath')]
    [Parameter(ParameterSetName='UpdateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Security.SecureString]
    # Admin password.
    ${AdminPassword},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("Early", "Regular")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The maintenance schedule type of the Autonomous Database Serverless.
    ${AutonomousMaintenanceScheduleType},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # Retention period, in days, for long-term backups
    ${BackupRetentionPeriodInDay},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Single]
    # The compute amount (CPUs) available to the database.
    ${ComputeCount},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The number of CPU cores to be made available to the database.
    ${CpuCoreCount},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICustomerContact[]]
    # Customer Contacts.
    ${CustomerContact},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The size, in gigabytes, of the data volume that will be created and attached to the database.
    ${DataStorageSizeInGb},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The quantity of data in the database, in terabytes.
    ${DataStorageSizeInTb},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("StandardEdition", "EnterpriseEdition")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The Oracle Database Edition that applies to the Autonomous databases.
    ${DatabaseEdition},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Name of the day of the week.
    ${DayOfWeekName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The user-friendly name for the Autonomous Database.
    ${DisplayName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Indicates if auto scaling is enabled for the Autonomous Database CPU core count.
    ${IsAutoScalingEnabled},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Indicates if auto scaling is enabled for the Autonomous Database storage.
    ${IsAutoScalingForStorageEnabled},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Indicates whether the Autonomous Database has local or called in-region Data Guard enabled.
    ${IsLocalDataGuardEnabled},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Specifies if the Autonomous Database requires mTLS connections.
    ${IsMtlsConnectionRequired},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("LicenseIncluded", "BringYourOwnLicense")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The Oracle license model that applies to the Oracle Autonomous Database.
    # The default is LICENSE_INCLUDED.
    ${LicenseModel},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # Parameter that allows users to select an acceptable maximum data loss limit in seconds, up to which Automatic Failover will be triggered when necessary for a Local Autonomous Data Guard
    ${LocalAdgAutoFailoverMaxDataLossLimit},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Indicates if the long-term backup schedule should be deleted.
    # The default value is `FALSE`.
    ${LongTermBackupScheduleIsDisabled},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("OneTime", "Weekly", "Monthly", "Yearly")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The frequency of the long-term backup schedule
    ${LongTermBackupScheduleRepeatCadence},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # Retention period, in days, for backups.
    ${LongTermBackupScheduleRetentionPeriodInDay},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.DateTime]
    # The timestamp for the long-term backup schedule.
    # For a MONTHLY cadence, months having fewer days than the provided date will have the backup taken on the last day of that month.
    ${LongTermBackupScheduleTimeOfBackup},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("ReadOnly", "ReadWrite")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Indicates the Autonomous Database mode.
    ${OpenMode},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The Azure resource ID of the Disaster Recovery peer database, which is located in a different region from the current peer database.
    ${PeerDbId},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("Restricted", "Unrestricted")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The Autonomous Database permission level.
    ${PermissionLevel},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("Primary", "Standby", "DisabledStandby", "BackupCopy", "SnapshotStandby")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The Data Guard role of the Autonomous Container Database or Autonomous Database, if Autonomous Data Guard is enabled.
    ${Role},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # auto start time.
    # value must be of ISO-8601 format HH:mm
    ${ScheduledStartTime},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # auto stop time.
    # value must be of ISO-8601 format HH:mm
    ${ScheduledStopTime},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IAutonomousDatabaseUpdateTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String[]]
    # The client IP access control list (ACL).
    # This is an array of CIDR notations and/or IP addresses.
    # Values should be separate strings, separated by commas.
    # Example: ['1.1.1.1','1.1.1.0/24','1.1.2.25']
    ${WhitelistedIP},

    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Update operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Update operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.Oracle.private\Update-AzOracleAutonomousDatabase_UpdateExpanded';
            UpdateViaIdentityExpanded = 'Az.Oracle.private\Update-AzOracleAutonomousDatabase_UpdateViaIdentityExpanded';
            UpdateViaJsonFilePath = 'Az.Oracle.private\Update-AzOracleAutonomousDatabase_UpdateViaJsonFilePath';
            UpdateViaJsonString = 'Az.Oracle.private\Update-AzOracleAutonomousDatabase_UpdateViaJsonString';
        }
        if (('UpdateExpanded', 'UpdateViaJsonFilePath', 'UpdateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Update a CloudExadataInfrastructure
.Description
Update a CloudExadataInfrastructure
.Example
$tagHashTable = @{'tagName'="tagValue"}
Update-AzOracleCloudExadataInfrastructure -Name "OFake_PowerShellTestExaInfra" -ResourceGroupName "PowerShellTestRg" -Tag $tagHashTable

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudExadataInfrastructure
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

CUSTOMERCONTACT <ICustomerContact[]>: The list of customer email addresses that receive information from Oracle about the specified OCI Database service resource. Oracle uses these email addresses to send notifications about planned and unplanned software maintenance updates, information about system hardware, and other information needed by administrators. Up to 10 email addresses can be added to the customer contacts for a cloud Exadata infrastructure instance. 
  Email <String>: The email address used by Oracle to send notifications regarding databases and infrastructure.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.

MAINTENANCEWINDOWDAYSOFWEEK <IDayOfWeek[]>: Days during the week when maintenance should be performed.
  Name <String>: Name of the day of the week.

MAINTENANCEWINDOWMONTH <IMonth[]>: Months during the year when maintenance should be performed.
  Name <String>: Name of the month of the year.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/update-azoraclecloudexadatainfrastructure
#>
function Update-AzOracleCloudExadataInfrastructure {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudExadataInfrastructure])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Alias('Cloudexadatainfrastructurename')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # CloudExadataInfrastructure name
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath')]
    [Parameter(ParameterSetName='UpdateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The number of compute servers for the cloud Exadata infrastructure.
    ${ComputeCount},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICustomerContact[]]
    # The list of customer email addresses that receive information from Oracle about the specified OCI Database service resource.
    # Oracle uses these email addresses to send notifications about planned and unplanned software maintenance updates, information about system hardware, and other information needed by administrators.
    # Up to 10 email addresses can be added to the customer contacts for a cloud Exadata infrastructure instance.
    ${CustomerContact},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The name for the Exadata infrastructure.
    ${DisplayName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # Determines the amount of time the system will wait before the start of each database server patching operation.
    # Custom action timeout is in minutes and valid value is between 15 to 120 (inclusive).
    ${MaintenanceWindowCustomActionTimeoutInMin},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IDayOfWeek[]]
    # Days during the week when maintenance should be performed.
    ${MaintenanceWindowDaysOfWeek},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32[]]
    # The window of hours during the day when maintenance should be performed.
    # The window is a 4 hour slot.
    # Valid values are - 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
    ${MaintenanceWindowHoursOfDay},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # If true, enables the configuration of a custom action timeout (waiting period) between database server patching operations.
    ${MaintenanceWindowIsCustomActionTimeoutEnabled},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # is Monthly Patching Enabled
    ${MaintenanceWindowIsMonthlyPatchingEnabled},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # Lead time window allows user to set a lead time to prepare for a down time.
    # The lead time is in weeks and valid value is between 1 to 4.
    ${MaintenanceWindowLeadTimeInWeek},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IMonth[]]
    # Months during the year when maintenance should be performed.
    ${MaintenanceWindowMonth},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("Rolling", "NonRolling")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Cloud Exadata infrastructure node patching method.
    ${MaintenanceWindowPatchingMode},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("NoPreference", "CustomPreference")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The maintenance window scheduling preference.
    ${MaintenanceWindowPreference},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32[]]
    # Weeks during the month when maintenance should be performed.
    # Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days.
    # Weeks start and end based on calendar dates, not days of the week.
    # For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2.
    # Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days.
    # Note that this parameter works in conjunction with the daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
    ${MaintenanceWindowWeeksOfMonth},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The number of storage servers for the cloud Exadata infrastructure.
    ${StorageCount},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudExadataInfrastructureUpdateTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String[]]
    # CloudExadataInfrastructure zones
    ${Zone},

    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Update operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Update operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.Oracle.private\Update-AzOracleCloudExadataInfrastructure_UpdateExpanded';
            UpdateViaIdentityExpanded = 'Az.Oracle.private\Update-AzOracleCloudExadataInfrastructure_UpdateViaIdentityExpanded';
            UpdateViaJsonFilePath = 'Az.Oracle.private\Update-AzOracleCloudExadataInfrastructure_UpdateViaJsonFilePath';
            UpdateViaJsonString = 'Az.Oracle.private\Update-AzOracleCloudExadataInfrastructure_UpdateViaJsonString';
        }
        if (('UpdateExpanded', 'UpdateViaJsonFilePath', 'UpdateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Update a CloudVmCluster
.Description
Update a CloudVmCluster
.Example
$tagHashTable = @{'tagName'="tagValue"}
Update-AzOracleCloudVMCluster -Name "OFake_PowerShellTestVmCluster" -ResourceGroupName "PowerShellTestRg" -Tag $tagHashTable

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudVMCluster
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

FILESYSTEMCONFIGURATIONDETAIL <IFileSystemConfigurationDetails[]>: Array of mount path and size.
  [FileSystemSizeGb <Int32?>]: Size of the VM
  [MountPoint <String>]: Mount path

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/update-azoraclecloudvmcluster
#>
function Update-AzOracleCloudVMCluster {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudVMCluster])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Alias('Cloudvmclustername')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # CloudVmCluster name
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath')]
    [Parameter(ParameterSetName='UpdateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String[]]
    # The list of compute servers to be added to the cloud VM cluster.
    ${ComputeNode},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The number of CPU cores enabled on the cloud VM cluster.
    ${CpuCoreCount},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Indicates whether diagnostic collection is enabled for the VM cluster/Cloud VM cluster/VMBM DBCS.
    ${DataCollectionOptionIsDiagnosticsEventsEnabled},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Indicates whether health monitoring is enabled for the VM cluster / Cloud VM cluster / VMBM DBCS.
    ${DataCollectionOptionIsHealthMonitoringEnabled},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Management.Automation.SwitchParameter]
    # Indicates whether incident logs and trace collection are enabled for the VM cluster / Cloud VM cluster / VMBM DBCS.
    ${DataCollectionOptionIsIncidentLogsEnabled},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Double]
    # The data disk group size to be allocated in TBs.
    ${DataStorageSizeInTb},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The local node storage to be allocated in GBs.
    ${DbNodeStorageSizeInGb},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Display Name
    ${DisplayName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IFileSystemConfigurationDetails[]]
    # Array of mount path and size.
    ${FileSystemConfigurationDetail},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.PSArgumentCompleterAttribute("LicenseIncluded", "BringYourOwnLicense")]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The Oracle license model that applies to the cloud VM cluster.
    # The default is LICENSE_INCLUDED.
    ${LicenseModel},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The memory to be allocated in GBs.
    ${MemorySizeInGb},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Single]
    # The number of OCPU cores to enable on the cloud VM cluster.
    # Only 1 decimal place is allowed for the fractional part.
    ${OcpuCount},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String[]]
    # The public key portion of one or more key pairs used for SSH access to the cloud VM cluster.
    ${SshPublicKey},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The data disk group size to be allocated in GBs per VM.
    ${StorageSizeInGb},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.ICloudVMClusterUpdateTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Update operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Update operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.Oracle.private\Update-AzOracleCloudVMCluster_UpdateExpanded';
            UpdateViaIdentityExpanded = 'Az.Oracle.private\Update-AzOracleCloudVMCluster_UpdateViaIdentityExpanded';
            UpdateViaJsonFilePath = 'Az.Oracle.private\Update-AzOracleCloudVMCluster_UpdateViaJsonFilePath';
            UpdateViaJsonString = 'Az.Oracle.private\Update-AzOracleCloudVMCluster_UpdateViaJsonString';
        }
        if (('UpdateExpanded', 'UpdateViaJsonFilePath', 'UpdateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Update a ExadbVmCluster
.Description
Update a ExadbVmCluster
.Example
$tagHashTable = @{'tagName'="tagValue"}
Update-AzOracleExadbVMCluster -Name "OFake_PowerShellTestVmCluster" -ResourceGroupName "PowerShellTestRg" -Tag $tagHashTable

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExadbVMCluster
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/update-azoracleexadbvmcluster
#>
function Update-AzOracleExadbVMCluster {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExadbVMCluster])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Alias('ExadbVMClusterName')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the ExadbVmCluster
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath')]
    [Parameter(ParameterSetName='UpdateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The number of nodes in the Exadata VM cluster on Exascale Infrastructure.
    ${NodeCount},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExadbVMClusterUpdateTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String[]]
    # The availability zones.
    ${Zone},

    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Update operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Update operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.Oracle.private\Update-AzOracleExadbVMCluster_UpdateExpanded';
            UpdateViaIdentityExpanded = 'Az.Oracle.private\Update-AzOracleExadbVMCluster_UpdateViaIdentityExpanded';
            UpdateViaJsonFilePath = 'Az.Oracle.private\Update-AzOracleExadbVMCluster_UpdateViaJsonFilePath';
            UpdateViaJsonString = 'Az.Oracle.private\Update-AzOracleExadbVMCluster_UpdateViaJsonString';
        }
        if (('UpdateExpanded', 'UpdateViaJsonFilePath', 'UpdateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Update a ExascaleDbStorageVault
.Description
Update a ExascaleDbStorageVault
.Example
$tagHashTable = @{'tagName'="tagValue"}
Update-AzOracleExadbVMCluster -Name "OFake_PowerShellTestVmCluster" -ResourceGroupName "PowerShellTestRg" -Tag $tagHashTable

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExascaleDbStorageVault
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IOracleIdentity>: Identity Parameter
  [Adbbackupid <String>]: AutonomousDatabaseBackup id
  [Adbscharsetname <String>]: AutonomousDatabaseCharacterSet name
  [Adbsncharsetname <String>]: AutonomousDatabaseNationalCharacterSets name
  [Autonomousdatabasename <String>]: The database name.
  [Autonomousdbversionsname <String>]: AutonomousDbVersion name
  [Cloudexadatainfrastructurename <String>]: CloudExadataInfrastructure name
  [Cloudvmclustername <String>]: CloudVmCluster name
  [Dbnodeocid <String>]: DbNode OCID.
  [Dbserverocid <String>]: DbServer OCID.
  [Dbsystemshapename <String>]: DbSystemShape name
  [Dnsprivateviewocid <String>]: DnsPrivateView OCID
  [Dnsprivatezonename <String>]: DnsPrivateZone name
  [ExadbVMClusterName <String>]: The name of the ExadbVmCluster
  [ExascaleDbNodeName <String>]: The name of the ExascaleDbNode
  [ExascaleDbStorageVaultName <String>]: The name of the ExascaleDbStorageVault
  [FlexComponentName <String>]: The name of the FlexComponent
  [GiMinorVersionName <String>]: The name of the GiMinorVersion
  [Giversionname <String>]: GiVersion name
  [Id <String>]: Resource identity path
  [Location <String>]: The name of the Azure region.
  [ResourceGroupName <String>]: The name of the resource group. The name is case insensitive.
  [SubscriptionId <String>]: The ID of the target subscription. The value must be an UUID.
  [Systemversionname <String>]: SystemVersion name
  [Virtualnetworkaddressname <String>]: Virtual IP address hostname.
.Link
https://learn.microsoft.com/powershell/module/az.oracle/update-azoracleexascaledbstoragevault
#>
function Update-AzOracleExascaleDbStorageVault {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExascaleDbStorageVault])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Alias('ExascaleDbStorageVaultName')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the ExascaleDbStorageVault
    ${Name},

    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [System.String]
    # The name of the resource group.
    # The name is case insensitive.
    ${ResourceGroupName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath')]
    [Parameter(ParameterSetName='UpdateViaJsonString')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The ID of the target subscription.
    # The value must be an UUID.
    ${SubscriptionId},

    [Parameter(ParameterSetName='UpdateViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IOracleIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.IExascaleDbStorageVaultTagsUpdateTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Update operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Json string supplied to the Update operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $context = Get-AzContext
        if (-not $context -and -not $testPlayback) {
            Write-Error "No Azure login detected. Please run 'Connect-AzAccount' to log in."
            exit
        }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            UpdateExpanded = 'Az.Oracle.private\Update-AzOracleExascaleDbStorageVault_UpdateExpanded';
            UpdateViaIdentityExpanded = 'Az.Oracle.private\Update-AzOracleExascaleDbStorageVault_UpdateViaIdentityExpanded';
            UpdateViaJsonFilePath = 'Az.Oracle.private\Update-AzOracleExascaleDbStorageVault_UpdateViaJsonFilePath';
            UpdateViaJsonString = 'Az.Oracle.private\Update-AzOracleExascaleDbStorageVault_UpdateViaJsonString';
        }
        if (('UpdateExpanded', 'UpdateViaJsonFilePath', 'UpdateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for CustomerContact.
.Description
Create an in-memory object for CustomerContact.
.Example
New-AzOracleCustomerContactObject -Email "example@oracle.com"

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.CustomerContact
.Link
https://learn.microsoft.com/powershell/module/Az.Oracle/new-azoraclecustomercontactobject
#>
function New-AzOracleCustomerContactObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.CustomerContact])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # The email address used by Oracle to send notifications regarding databases and infrastructure.
    ${Email}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.Oracle.custom\New-AzOracleCustomerContactObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}

<#
.Synopsis
Create an in-memory object for NsgCidr.
.Description
Create an in-memory object for NsgCidr.
.Example
New-AzOracleNsgCidrObject -Source "source" -DestinationPortRangeMax 0 -DestinationPortRangeMin 1

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.NsgCidr
.Link
https://learn.microsoft.com/powershell/module/Az.Oracle/new-azoraclensgcidrobject
#>
function New-AzOracleNsgCidrObject {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.Oracle.Models.NsgCidr])]
[CmdletBinding(PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.String]
    # Conceptually, this is the range of IP addresses that a packet coming into the instance can come from.
    ${Source},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The maximum port number, which must not be less than the minimum port number.
    # To specify a single port number, set both the min and max to the same value.
    ${DestinationPortRangeMax},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Category('Body')]
    [System.Int32]
    # The minimum port number, which must not be greater than the maximum port number.
    ${DestinationPortRangeMin}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        if ($null -eq [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion) {
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PowerShellVersion = $PSVersionTable.PSVersion.ToString()
        }         
        $preTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        if ($preTelemetryId -eq '') {
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId =(New-Guid).ToString()
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Create', $MyInvocation, $parameterSet, $PSCmdlet)
        } else {
            $internalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
            if ($internalCalledCmdlets -eq '') {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $MyInvocation.MyCommand.Name
            } else {
                [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets += ',' + $MyInvocation.MyCommand.Name
            }
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = 'internal'
        }

        $mapping = @{
            __AllParameterSets = 'Az.Oracle.custom\New-AzOracleNsgCidrObject';
        }
        $cmdInfo = Get-Command -Name $mapping[$parameterSet]
        [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessCustomAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
        if ($null -ne $MyInvocation.MyCommand -and [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets -notcontains $MyInvocation.MyCommand.Name -and [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ContainsPreviewAttribute($cmdInfo, $MyInvocation)){
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.Runtime.MessageAttributeHelper]::ProcessPreviewMessageAttributesAtRuntime($cmdInfo, $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Utilities.Common.AzurePSCmdlet]::PromptedPreviewMessageCmdlets.Enqueue($MyInvocation.MyCommand.Name)
        }
        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }

    finally {
        $backupTelemetryId = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId
        $backupInternalCalledCmdlets = [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
    }

}
end {
    try {
        $steppablePipeline.End()

        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $backupTelemetryId
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::InternalCalledCmdlets = $backupInternalCalledCmdlets
        if ($preTelemetryId -eq '') {
            [Microsoft.Azure.PowerShell.Cmdlets.Oracle.module]::Instance.Telemetry.Invoke('Send', $MyInvocation, $parameterSet, $PSCmdlet)
            [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        }
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::TelemetryId = $preTelemetryId

    } catch {
        [Microsoft.WindowsAzure.Commands.Common.MetricHelper]::ClearTelemetryContext()
        throw
    }
} 
}
