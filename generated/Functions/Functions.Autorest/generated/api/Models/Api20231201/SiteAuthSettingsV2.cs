// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Extensions;

    /// <summary>
    /// Configuration settings for the Azure App Service Authentication / Authorization V2 feature.
    /// </summary>
    public partial class SiteAuthSettingsV2 :
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2,
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Internal,
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.IValidates
    {
        /// <summary>
        /// Backing field for Inherited model <see cref= "Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResource"
        /// />
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResource __proxyOnlyResource = new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ProxyOnlyResource();

        /// <summary>
        /// The name of the app setting containing the SAS URL of the blob storage containing the tokens.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string AzureBlobStorageSasUrlSettingName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).AzureBlobStorageSasUrlSettingName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).AzureBlobStorageSasUrlSettingName = value ?? null; }

        /// <summary>The convention used when determining the session cookie's expiration.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.CookieExpirationConvention? CookieExpirationConvention { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).CookieExpirationConvention; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).CookieExpirationConvention = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.CookieExpirationConvention)""); }

        /// <summary>The time after the request is made when the session cookie should expire.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string CookieExpirationTimeToExpiration { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).CookieExpirationTimeToExpiration; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).CookieExpirationTimeToExpiration = value ?? null; }

        /// <summary>The directory in which the tokens will be stored.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string FileSystemDirectory { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).FileSystemDirectory; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).FileSystemDirectory = value ?? null; }

        /// <summary>The convention used to determine the url of the request made.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ForwardProxyConvention? ForwardProxyConvention { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).ForwardProxyConvention; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).ForwardProxyConvention = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ForwardProxyConvention)""); }

        /// <summary>The name of the header containing the host of the request.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string ForwardProxyCustomHostHeaderName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).ForwardProxyCustomHostHeaderName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).ForwardProxyCustomHostHeaderName = value ?? null; }

        /// <summary>The name of the header containing the scheme of the request.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string ForwardProxyCustomProtoHeaderName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).ForwardProxyCustomProtoHeaderName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).ForwardProxyCustomProtoHeaderName = value ?? null; }

        /// <summary>
        /// The paths for which unauthenticated flow would not be redirected to the login page.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string[] GlobalValidationExcludedPath { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).GlobalValidationExcludedPath; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).GlobalValidationExcludedPath = value ?? null /* arrayOf */; }

        /// <summary>
        /// The default authentication provider to use when multiple providers are configured.
        /// This setting is only needed if multiple providers are configured and the unauthenticated client
        /// action is set to "RedirectToLoginPage".
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string GlobalValidationRedirectToProvider { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).GlobalValidationRedirectToProvider; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).GlobalValidationRedirectToProvider = value ?? null; }

        /// <summary>
        /// <code>true</code> if the authentication flow is required any request is made; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? GlobalValidationRequireAuthentication { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).GlobalValidationRequireAuthentication; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).GlobalValidationRequireAuthentication = value ?? default(bool); }

        /// <summary>The action to take when an unauthenticated client attempts to access the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.UnauthenticatedClientActionV2? GlobalValidationUnauthenticatedClientAction { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).GlobalValidationUnauthenticatedClientAction; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).GlobalValidationUnauthenticatedClientAction = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.UnauthenticatedClientActionV2)""); }

        /// <summary>
        /// <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise,
        /// <code>true</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? HttpSettingRequireHttps { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).HttpSettingRequireHttps; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).HttpSettingRequireHttps = value ?? default(bool); }

        /// <summary>Resource Id.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inherited)]
        public string Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResourceInternal)__proxyOnlyResource).Id; }

        /// <summary>
        /// The configuration settings of each of the identity providers used to configure App Service Authentication/Authorization.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IIdentityProviders IdentityProvider { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).IdentityProvider; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).IdentityProvider = value ?? null /* model class */; }

        /// <summary>Kind of resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inherited)]
        public string Kind { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResourceInternal)__proxyOnlyResource).Kind; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResourceInternal)__proxyOnlyResource).Kind = value ?? null; }

        /// <summary>
        /// External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part
        /// of the URL is ignored.
        /// This is an advanced setting typically only needed by Windows Store application backends.
        /// Note that URLs within the current domain are always implicitly allowed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string[] LoginAllowedExternalRedirectUrl { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).LoginAllowedExternalRedirectUrl; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).LoginAllowedExternalRedirectUrl = value ?? null /* arrayOf */; }

        /// <summary>
        /// <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? LoginPreserveUrlFragmentsForLogin { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).LoginPreserveUrlFragmentsForLogin; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).LoginPreserveUrlFragmentsForLogin = value ?? default(bool); }

        /// <summary>Internal Acessors for Id</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResourceInternal.Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResourceInternal)__proxyOnlyResource).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResourceInternal)__proxyOnlyResource).Id = value; }

        /// <summary>Internal Acessors for Name</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResourceInternal.Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResourceInternal)__proxyOnlyResource).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResourceInternal)__proxyOnlyResource).Name = value; }

        /// <summary>Internal Acessors for Type</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResourceInternal.Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResourceInternal)__proxyOnlyResource).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResourceInternal)__proxyOnlyResource).Type = value; }

        /// <summary>Internal Acessors for GlobalValidation</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IGlobalValidation Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Internal.GlobalValidation { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).GlobalValidation; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).GlobalValidation = value; }

        /// <summary>Internal Acessors for HttpSetting</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHttpSettings Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Internal.HttpSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).HttpSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).HttpSetting = value; }

        /// <summary>Internal Acessors for HttpSettingForwardProxy</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IForwardProxy Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Internal.HttpSettingForwardProxy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).HttpSettingForwardProxy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).HttpSettingForwardProxy = value; }

        /// <summary>Internal Acessors for HttpSettingRoute</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHttpSettingsRoutes Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Internal.HttpSettingRoute { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).HttpSettingRoute; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).HttpSettingRoute = value; }

        /// <summary>Internal Acessors for Login</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ILogin Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Internal.Login { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).Login; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).Login = value; }

        /// <summary>Internal Acessors for LoginCookieExpiration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICookieExpiration Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Internal.LoginCookieExpiration { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).LoginCookieExpiration; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).LoginCookieExpiration = value; }

        /// <summary>Internal Acessors for LoginNonce</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.INonce Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Internal.LoginNonce { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).LoginNonce; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).LoginNonce = value; }

        /// <summary>Internal Acessors for LoginRoute</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ILoginRoutes Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Internal.LoginRoute { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).LoginRoute; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).LoginRoute = value; }

        /// <summary>Internal Acessors for LoginTokenStore</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ITokenStore Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Internal.LoginTokenStore { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).LoginTokenStore; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).LoginTokenStore = value; }

        /// <summary>Internal Acessors for Platform</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IAuthPlatform Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Internal.Platform { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).Platform; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).Platform = value; }

        /// <summary>Internal Acessors for Property</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Properties Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Internal.Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.SiteAuthSettingsV2Properties()); set { {_property = value;} } }

        /// <summary>Internal Acessors for TokenStoreAzureBlobStorage</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IBlobStorageTokenStore Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Internal.TokenStoreAzureBlobStorage { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).TokenStoreAzureBlobStorage; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).TokenStoreAzureBlobStorage = value; }

        /// <summary>Internal Acessors for TokenStoreFileSystem</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFileSystemTokenStore Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Internal.TokenStoreFileSystem { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).TokenStoreFileSystem; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).TokenStoreFileSystem = value; }

        /// <summary>Resource Name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inherited)]
        public string Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResourceInternal)__proxyOnlyResource).Name; }

        /// <summary>The time after the request is made when the nonce should expire.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string NonceExpirationInterval { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).NonceExpirationInterval; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).NonceExpirationInterval = value ?? null; }

        /// <summary>
        /// <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? NonceValidateNonce { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).NonceValidateNonce; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).NonceValidateNonce = value ?? default(bool); }

        /// <summary>
        /// The path of the config file containing auth settings if they come from a file.
        /// If the path is relative, base will the site's root directory.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string PlatformConfigFilePath { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).PlatformConfigFilePath; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).PlatformConfigFilePath = value ?? null; }

        /// <summary>
        /// <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? PlatformEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).PlatformEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).PlatformEnabled = value ?? default(bool); }

        /// <summary>
        /// The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
        /// The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string PlatformRuntimeVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).PlatformRuntimeVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).PlatformRuntimeVersion = value ?? null; }

        /// <summary>Backing field for <see cref="Property" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Properties _property;

        /// <summary>SiteAuthSettingsV2 resource specific properties</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Properties Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.SiteAuthSettingsV2Properties()); set => this._property = value; }

        /// <summary>The prefix that should precede all the authentication/authorization paths.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string RouteApiPrefix { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).RouteApiPrefix; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).RouteApiPrefix = value ?? null; }

        /// <summary>The endpoint at which a logout request should be made.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string RouteLogoutEndpoint { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).RouteLogoutEndpoint; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).RouteLogoutEndpoint = value ?? null; }

        /// <summary>
        /// <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise,
        /// <code>false</code>.
        /// The default is <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? TokenStoreEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).TokenStoreEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).TokenStoreEnabled = value ?? default(bool); }

        /// <summary>
        /// The number of hours after session token expiration that a session token can be used to
        /// call the token refresh API. The default is 72 hours.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public double? TokenStoreTokenRefreshExtensionHour { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).TokenStoreTokenRefreshExtensionHour; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2PropertiesInternal)Property).TokenStoreTokenRefreshExtensionHour = value ?? default(double); }

        /// <summary>Resource type.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inherited)]
        public string Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResourceInternal)__proxyOnlyResource).Type; }

        /// <summary>Creates an new <see cref="SiteAuthSettingsV2" /> instance.</summary>
        public SiteAuthSettingsV2()
        {

        }

        /// <summary>Validates that this object meets the validation criteria.</summary>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.IEventListener" /> instance that will receive validation
        /// events.</param>
        /// <returns>
        /// A <see cref = "global::System.Threading.Tasks.Task" /> that will be complete when validation is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task Validate(Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.IEventListener eventListener)
        {
            await eventListener.AssertNotNull(nameof(__proxyOnlyResource), __proxyOnlyResource);
            await eventListener.AssertObjectIsValid(nameof(__proxyOnlyResource), __proxyOnlyResource);
        }
    }
    /// Configuration settings for the Azure App Service Authentication / Authorization V2 feature.
    public partial interface ISiteAuthSettingsV2 :
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.IJsonSerializable,
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResource
    {
        /// <summary>
        /// The name of the app setting containing the SAS URL of the blob storage containing the tokens.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the app setting containing the SAS URL of the blob storage containing the tokens.",
        SerializedName = @"sasUrlSettingName",
        PossibleTypes = new [] { typeof(string) })]
        string AzureBlobStorageSasUrlSettingName { get; set; }
        /// <summary>The convention used when determining the session cookie's expiration.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The convention used when determining the session cookie's expiration.",
        SerializedName = @"convention",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.CookieExpirationConvention) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.CookieExpirationConvention? CookieExpirationConvention { get; set; }
        /// <summary>The time after the request is made when the session cookie should expire.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The time after the request is made when the session cookie should expire.",
        SerializedName = @"timeToExpiration",
        PossibleTypes = new [] { typeof(string) })]
        string CookieExpirationTimeToExpiration { get; set; }
        /// <summary>The directory in which the tokens will be stored.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The directory in which the tokens will be stored.",
        SerializedName = @"directory",
        PossibleTypes = new [] { typeof(string) })]
        string FileSystemDirectory { get; set; }
        /// <summary>The convention used to determine the url of the request made.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The convention used to determine the url of the request made.",
        SerializedName = @"convention",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ForwardProxyConvention) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ForwardProxyConvention? ForwardProxyConvention { get; set; }
        /// <summary>The name of the header containing the host of the request.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the header containing the host of the request.",
        SerializedName = @"customHostHeaderName",
        PossibleTypes = new [] { typeof(string) })]
        string ForwardProxyCustomHostHeaderName { get; set; }
        /// <summary>The name of the header containing the scheme of the request.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the header containing the scheme of the request.",
        SerializedName = @"customProtoHeaderName",
        PossibleTypes = new [] { typeof(string) })]
        string ForwardProxyCustomProtoHeaderName { get; set; }
        /// <summary>
        /// The paths for which unauthenticated flow would not be redirected to the login page.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The paths for which unauthenticated flow would not be redirected to the login page.",
        SerializedName = @"excludedPaths",
        PossibleTypes = new [] { typeof(string) })]
        string[] GlobalValidationExcludedPath { get; set; }
        /// <summary>
        /// The default authentication provider to use when multiple providers are configured.
        /// This setting is only needed if multiple providers are configured and the unauthenticated client
        /// action is set to "RedirectToLoginPage".
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default authentication provider to use when multiple providers are configured.
        This setting is only needed if multiple providers are configured and the unauthenticated client
        action is set to ""RedirectToLoginPage"".",
        SerializedName = @"redirectToProvider",
        PossibleTypes = new [] { typeof(string) })]
        string GlobalValidationRedirectToProvider { get; set; }
        /// <summary>
        /// <code>true</code> if the authentication flow is required any request is made; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> if the authentication flow is required any request is made; otherwise, <code>false</code>.",
        SerializedName = @"requireAuthentication",
        PossibleTypes = new [] { typeof(bool) })]
        bool? GlobalValidationRequireAuthentication { get; set; }
        /// <summary>The action to take when an unauthenticated client attempts to access the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The action to take when an unauthenticated client attempts to access the app.",
        SerializedName = @"unauthenticatedClientAction",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.UnauthenticatedClientActionV2) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.UnauthenticatedClientActionV2? GlobalValidationUnauthenticatedClientAction { get; set; }
        /// <summary>
        /// <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise,
        /// <code>true</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise, <code>true</code>.",
        SerializedName = @"requireHttps",
        PossibleTypes = new [] { typeof(bool) })]
        bool? HttpSettingRequireHttps { get; set; }
        /// <summary>
        /// The configuration settings of each of the identity providers used to configure App Service Authentication/Authorization.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The configuration settings of each of the identity providers used to configure App Service Authentication/Authorization.",
        SerializedName = @"identityProviders",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IIdentityProviders) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IIdentityProviders IdentityProvider { get; set; }
        /// <summary>
        /// External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part
        /// of the URL is ignored.
        /// This is an advanced setting typically only needed by Windows Store application backends.
        /// Note that URLs within the current domain are always implicitly allowed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part of the URL is ignored.
        This is an advanced setting typically only needed by Windows Store application backends.
        Note that URLs within the current domain are always implicitly allowed.",
        SerializedName = @"allowedExternalRedirectUrls",
        PossibleTypes = new [] { typeof(string) })]
        string[] LoginAllowedExternalRedirectUrl { get; set; }
        /// <summary>
        /// <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.",
        SerializedName = @"preserveUrlFragmentsForLogins",
        PossibleTypes = new [] { typeof(bool) })]
        bool? LoginPreserveUrlFragmentsForLogin { get; set; }
        /// <summary>The time after the request is made when the nonce should expire.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The time after the request is made when the nonce should expire.",
        SerializedName = @"nonceExpirationInterval",
        PossibleTypes = new [] { typeof(string) })]
        string NonceExpirationInterval { get; set; }
        /// <summary>
        /// <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.",
        SerializedName = @"validateNonce",
        PossibleTypes = new [] { typeof(bool) })]
        bool? NonceValidateNonce { get; set; }
        /// <summary>
        /// The path of the config file containing auth settings if they come from a file.
        /// If the path is relative, base will the site's root directory.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The path of the config file containing auth settings if they come from a file.
        If the path is relative, base will the site's root directory.",
        SerializedName = @"configFilePath",
        PossibleTypes = new [] { typeof(string) })]
        string PlatformConfigFilePath { get; set; }
        /// <summary>
        /// <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? PlatformEnabled { get; set; }
        /// <summary>
        /// The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
        /// The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
        The setting in this value can control the behavior of certain features in the Authentication / Authorization module.",
        SerializedName = @"runtimeVersion",
        PossibleTypes = new [] { typeof(string) })]
        string PlatformRuntimeVersion { get; set; }
        /// <summary>The prefix that should precede all the authentication/authorization paths.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The prefix that should precede all the authentication/authorization paths.",
        SerializedName = @"apiPrefix",
        PossibleTypes = new [] { typeof(string) })]
        string RouteApiPrefix { get; set; }
        /// <summary>The endpoint at which a logout request should be made.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The endpoint at which a logout request should be made.",
        SerializedName = @"logoutEndpoint",
        PossibleTypes = new [] { typeof(string) })]
        string RouteLogoutEndpoint { get; set; }
        /// <summary>
        /// <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise,
        /// <code>false</code>.
        /// The default is <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise, <code>false</code>.
         The default is <code>false</code>.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? TokenStoreEnabled { get; set; }
        /// <summary>
        /// The number of hours after session token expiration that a session token can be used to
        /// call the token refresh API. The default is 72 hours.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The number of hours after session token expiration that a session token can be used to
        call the token refresh API. The default is 72 hours.",
        SerializedName = @"tokenRefreshExtensionHours",
        PossibleTypes = new [] { typeof(double) })]
        double? TokenStoreTokenRefreshExtensionHour { get; set; }

    }
    /// Configuration settings for the Azure App Service Authentication / Authorization V2 feature.
    internal partial interface ISiteAuthSettingsV2Internal :
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IProxyOnlyResourceInternal
    {
        /// <summary>
        /// The name of the app setting containing the SAS URL of the blob storage containing the tokens.
        /// </summary>
        string AzureBlobStorageSasUrlSettingName { get; set; }
        /// <summary>The convention used when determining the session cookie's expiration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.CookieExpirationConvention? CookieExpirationConvention { get; set; }
        /// <summary>The time after the request is made when the session cookie should expire.</summary>
        string CookieExpirationTimeToExpiration { get; set; }
        /// <summary>The directory in which the tokens will be stored.</summary>
        string FileSystemDirectory { get; set; }
        /// <summary>The convention used to determine the url of the request made.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ForwardProxyConvention? ForwardProxyConvention { get; set; }
        /// <summary>The name of the header containing the host of the request.</summary>
        string ForwardProxyCustomHostHeaderName { get; set; }
        /// <summary>The name of the header containing the scheme of the request.</summary>
        string ForwardProxyCustomProtoHeaderName { get; set; }
        /// <summary>
        /// The configuration settings that determines the validation flow of users using App Service Authentication/Authorization.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IGlobalValidation GlobalValidation { get; set; }
        /// <summary>
        /// The paths for which unauthenticated flow would not be redirected to the login page.
        /// </summary>
        string[] GlobalValidationExcludedPath { get; set; }
        /// <summary>
        /// The default authentication provider to use when multiple providers are configured.
        /// This setting is only needed if multiple providers are configured and the unauthenticated client
        /// action is set to "RedirectToLoginPage".
        /// </summary>
        string GlobalValidationRedirectToProvider { get; set; }
        /// <summary>
        /// <code>true</code> if the authentication flow is required any request is made; otherwise, <code>false</code>.
        /// </summary>
        bool? GlobalValidationRequireAuthentication { get; set; }
        /// <summary>The action to take when an unauthenticated client attempts to access the app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.UnauthenticatedClientActionV2? GlobalValidationUnauthenticatedClientAction { get; set; }
        /// <summary>
        /// The configuration settings of the HTTP requests for authentication and authorization requests made against App Service
        /// Authentication/Authorization.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHttpSettings HttpSetting { get; set; }
        /// <summary>The configuration settings of a forward proxy used to make the requests.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IForwardProxy HttpSettingForwardProxy { get; set; }
        /// <summary>
        /// <code>false</code> if the authentication/authorization responses not having the HTTPS scheme are permissible; otherwise,
        /// <code>true</code>.
        /// </summary>
        bool? HttpSettingRequireHttps { get; set; }
        /// <summary>The configuration settings of the paths HTTP requests.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHttpSettingsRoutes HttpSettingRoute { get; set; }
        /// <summary>
        /// The configuration settings of each of the identity providers used to configure App Service Authentication/Authorization.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IIdentityProviders IdentityProvider { get; set; }
        /// <summary>
        /// The configuration settings of the login flow of users using App Service Authentication/Authorization.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ILogin Login { get; set; }
        /// <summary>
        /// External URLs that can be redirected to as part of logging in or logging out of the app. Note that the query string part
        /// of the URL is ignored.
        /// This is an advanced setting typically only needed by Windows Store application backends.
        /// Note that URLs within the current domain are always implicitly allowed.
        /// </summary>
        string[] LoginAllowedExternalRedirectUrl { get; set; }
        /// <summary>The configuration settings of the session cookie's expiration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICookieExpiration LoginCookieExpiration { get; set; }
        /// <summary>The configuration settings of the nonce used in the login flow.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.INonce LoginNonce { get; set; }
        /// <summary>
        /// <code>true</code> if the fragments from the request are preserved after the login request is made; otherwise, <code>false</code>.
        /// </summary>
        bool? LoginPreserveUrlFragmentsForLogin { get; set; }
        /// <summary>The routes that specify the endpoints used for login and logout requests.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ILoginRoutes LoginRoute { get; set; }
        /// <summary>The configuration settings of the token store.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ITokenStore LoginTokenStore { get; set; }
        /// <summary>The time after the request is made when the nonce should expire.</summary>
        string NonceExpirationInterval { get; set; }
        /// <summary>
        /// <code>false</code> if the nonce should not be validated while completing the login flow; otherwise, <code>true</code>.
        /// </summary>
        bool? NonceValidateNonce { get; set; }
        /// <summary>
        /// The configuration settings of the platform of App Service Authentication/Authorization.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IAuthPlatform Platform { get; set; }
        /// <summary>
        /// The path of the config file containing auth settings if they come from a file.
        /// If the path is relative, base will the site's root directory.
        /// </summary>
        string PlatformConfigFilePath { get; set; }
        /// <summary>
        /// <code>true</code> if the Authentication / Authorization feature is enabled for the current app; otherwise, <code>false</code>.
        /// </summary>
        bool? PlatformEnabled { get; set; }
        /// <summary>
        /// The RuntimeVersion of the Authentication / Authorization feature in use for the current app.
        /// The setting in this value can control the behavior of certain features in the Authentication / Authorization module.
        /// </summary>
        string PlatformRuntimeVersion { get; set; }
        /// <summary>SiteAuthSettingsV2 resource specific properties</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteAuthSettingsV2Properties Property { get; set; }
        /// <summary>The prefix that should precede all the authentication/authorization paths.</summary>
        string RouteApiPrefix { get; set; }
        /// <summary>The endpoint at which a logout request should be made.</summary>
        string RouteLogoutEndpoint { get; set; }
        /// <summary>
        /// The configuration settings of the storage of the tokens if blob storage is used.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IBlobStorageTokenStore TokenStoreAzureBlobStorage { get; set; }
        /// <summary>
        /// <code>true</code> to durably store platform-specific security tokens that are obtained during login flows; otherwise,
        /// <code>false</code>.
        /// The default is <code>false</code>.
        /// </summary>
        bool? TokenStoreEnabled { get; set; }
        /// <summary>
        /// The configuration settings of the storage of the tokens if a file system is used.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFileSystemTokenStore TokenStoreFileSystem { get; set; }
        /// <summary>
        /// The number of hours after session token expiration that a session token can be used to
        /// call the token refresh API. The default is 72 hours.
        /// </summary>
        double? TokenStoreTokenRefreshExtensionHour { get; set; }

    }
}