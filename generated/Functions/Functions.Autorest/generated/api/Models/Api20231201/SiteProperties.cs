// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Extensions;

    /// <summary>Site resource specific properties</summary>
    public partial class SiteProperties :
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteProperties,
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal
    {

        /// <summary>
        /// Use this property for StorageAccountConnectionString. Set the name of the app setting that has the storage account connection
        /// string. Do not set a value for this property when using other authentication type.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string AuthenticationStorageAccountConnectionStringName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).AuthenticationStorageAccountConnectionStringName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).AuthenticationStorageAccountConnectionStringName = value ?? null; }

        /// <summary>
        /// Property to select authentication type to access the selected storage account. Available options: SystemAssignedIdentity,
        /// UserAssignedIdentity, StorageAccountConnectionString.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.AuthenticationType? AuthenticationType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).AuthenticationType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).AuthenticationType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.AuthenticationType)""); }

        /// <summary>
        /// Use this property for UserAssignedIdentity. Set the resource ID of the identity. Do not set a value for this property
        /// when using other authentication type.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string AuthenticationUserAssignedIdentityResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).AuthenticationUserAssignedIdentityResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).AuthenticationUserAssignedIdentityResourceId = value ?? null; }

        /// <summary>Backing field for <see cref="AvailabilityState" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.SiteAvailabilityState? _availabilityState;

        /// <summary>Management information availability state for the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.SiteAvailabilityState? AvailabilityState { get => this._availabilityState; }

        /// <summary>Backing field for <see cref="ClientAffinityEnabled" /> property.</summary>
        private bool? _clientAffinityEnabled;

        /// <summary>
        /// <code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity cookies, which route
        /// client requests in the same session to the same instance. Default is <code>true</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public bool? ClientAffinityEnabled { get => this._clientAffinityEnabled; set => this._clientAffinityEnabled = value; }

        /// <summary>Backing field for <see cref="ClientCertEnabled" /> property.</summary>
        private bool? _clientCertEnabled;

        /// <summary>
        /// <code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise, <code>false</code>.
        /// Default is <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public bool? ClientCertEnabled { get => this._clientCertEnabled; set => this._clientCertEnabled = value; }

        /// <summary>Backing field for <see cref="ClientCertExclusionPath" /> property.</summary>
        private string _clientCertExclusionPath;

        /// <summary>client certificate authentication comma-separated exclusion paths</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string ClientCertExclusionPath { get => this._clientCertExclusionPath; set => this._clientCertExclusionPath = value; }

        /// <summary>Backing field for <see cref="ClientCertMode" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ClientCertMode? _clientCertMode;

        /// <summary>
        /// This composes with ClientCertEnabled setting.
        /// - ClientCertEnabled: false means ClientCert is ignored.
        /// - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
        /// - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ClientCertMode? ClientCertMode { get => this._clientCertMode; set => this._clientCertMode = value; }

        /// <summary>Backing field for <see cref="CloningInfo" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfo _cloningInfo;

        /// <summary>If specified during app creation, the app is cloned from a source app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfo CloningInfo { get => (this._cloningInfo = this._cloningInfo ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.CloningInfo()); set => this._cloningInfo = value; }

        /// <summary>
        /// Application setting overrides for cloned app. If specified, these settings override the settings cloned
        /// from source app. Otherwise, application settings from source app are retained.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoAppSettingsOverrides CloningInfoAppSettingsOverride { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).AppSettingsOverride; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).AppSettingsOverride = value ?? null /* model class */; }

        /// <summary>
        /// <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? CloningInfoCloneCustomHostName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).CloneCustomHostName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).CloneCustomHostName = value ?? default(bool); }

        /// <summary>
        /// <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? CloningInfoCloneSourceControl { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).CloneSourceControl; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).CloneSourceControl = value ?? default(bool); }

        /// <summary><code>true</code> to configure load balancing for source and destination app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? CloningInfoConfigureLoadBalancing { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).ConfigureLoadBalancing; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).ConfigureLoadBalancing = value ?? default(bool); }

        /// <summary>
        /// Correlation ID of cloning operation. This ID ties multiple cloning operations
        /// together to use the same snapshot.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string CloningInfoCorrelationId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).CorrelationId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).CorrelationId = value ?? null; }

        /// <summary>App Service Environment.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string CloningInfoHostingEnvironment { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).HostingEnvironment; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).HostingEnvironment = value ?? null; }

        /// <summary><code>true</code> to overwrite destination app; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? CloningInfoOverwrite { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).Overwrite; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).Overwrite = value ?? default(bool); }

        /// <summary>
        /// ARM resource ID of the source app. App resource ID is of the form
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots
        /// and
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for
        /// other slots.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string CloningInfoSourceWebAppId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).SourceWebAppId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).SourceWebAppId = value ?? null; }

        /// <summary>Location of source app ex: West US or North Europe</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string CloningInfoSourceWebAppLocation { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).SourceWebAppLocation; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).SourceWebAppLocation = value ?? null; }

        /// <summary>
        /// ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource ID is of the form
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string CloningInfoTrafficManagerProfileId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).TrafficManagerProfileId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).TrafficManagerProfileId = value ?? null; }

        /// <summary>
        /// Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile does not already exist.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string CloningInfoTrafficManagerProfileName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).TrafficManagerProfileName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoInternal)CloningInfo).TrafficManagerProfileName = value ?? null; }

        /// <summary>Backing field for <see cref="ContainerSize" /> property.</summary>
        private int? _containerSize;

        /// <summary>Size of the function container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public int? ContainerSize { get => this._containerSize; set => this._containerSize = value; }

        /// <summary>Backing field for <see cref="CustomDomainVerificationId" /> property.</summary>
        private string _customDomainVerificationId;

        /// <summary>
        /// Unique identifier that verifies the custom domains assigned to the app. Customer will add this id to a txt record for
        /// verification.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string CustomDomainVerificationId { get => this._customDomainVerificationId; set => this._customDomainVerificationId = value; }

        /// <summary>Backing field for <see cref="DailyMemoryTimeQuota" /> property.</summary>
        private int? _dailyMemoryTimeQuota;

        /// <summary>Maximum allowed daily memory-time quota (applicable on dynamic apps only).</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public int? DailyMemoryTimeQuota { get => this._dailyMemoryTimeQuota; set => this._dailyMemoryTimeQuota = value; }

        /// <summary>Backing field for <see cref="DaprConfig" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfig _daprConfig;

        /// <summary>Dapr configuration of the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfig DaprConfig { get => (this._daprConfig = this._daprConfig ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.DaprConfig()); set => this._daprConfig = value; }

        /// <summary>Dapr application identifier</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string DaprConfigAppId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfigInternal)DaprConfig).AppId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfigInternal)DaprConfig).AppId = value ?? null; }

        /// <summary>Tells Dapr which port your application is listening on</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public int? DaprConfigAppPort { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfigInternal)DaprConfig).AppPort; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfigInternal)DaprConfig).AppPort = value ?? default(int); }

        /// <summary>Enables API logging for the Dapr sidecar</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? DaprConfigEnableApiLogging { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfigInternal)DaprConfig).EnableApiLogging; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfigInternal)DaprConfig).EnableApiLogging = value ?? default(bool); }

        /// <summary>Boolean indicating if the Dapr side car is enabled</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? DaprConfigEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfigInternal)DaprConfig).Enabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfigInternal)DaprConfig).Enabled = value ?? default(bool); }

        /// <summary>
        /// Increasing max size of request body http servers parameter in MB to handle uploading of big files. Default is 4 MB.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public int? DaprConfigHttpMaxRequestSize { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfigInternal)DaprConfig).HttpMaxRequestSize; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfigInternal)DaprConfig).HttpMaxRequestSize = value ?? default(int); }

        /// <summary>
        /// Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public int? DaprConfigHttpReadBufferSize { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfigInternal)DaprConfig).HttpReadBufferSize; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfigInternal)DaprConfig).HttpReadBufferSize = value ?? default(int); }

        /// <summary>
        /// Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.DaprLogLevel? DaprConfigLogLevel { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfigInternal)DaprConfig).LogLevel; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfigInternal)DaprConfig).LogLevel = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.DaprLogLevel)""); }

        /// <summary>Backing field for <see cref="DefaultHostName" /> property.</summary>
        private string _defaultHostName;

        /// <summary>Default hostname of the app. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string DefaultHostName { get => this._defaultHostName; }

        /// <summary>Backing field for <see cref="DnsConfiguration" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfig _dnsConfiguration;

        /// <summary>Property to configure various DNS related settings for a site.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfig DnsConfiguration { get => (this._dnsConfiguration = this._dnsConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.SiteDnsConfig()); set => this._dnsConfiguration = value; }

        /// <summary>
        /// Alternate DNS server to be used by apps. This property replicates the WEBSITE_DNS_ALT_SERVER app setting.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string DnsConfigurationDnsAltServer { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfigInternal)DnsConfiguration).DnsAltServer; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfigInternal)DnsConfiguration).DnsAltServer = value ?? null; }

        /// <summary>
        /// Indicates that sites using Virtual network custom DNS servers are still sorting the list of DNS servers. Read-Only.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public bool? DnsConfigurationDnsLegacySortOrder { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfigInternal)DnsConfiguration).DnsLegacySortOrder; }

        /// <summary>
        /// Custom time for DNS to be cached in seconds. Allowed range: 0-60. Default is 30 seconds. 0 means caching disabled.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public int? DnsConfigurationDnsMaxCacheTimeout { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfigInternal)DnsConfiguration).DnsMaxCacheTimeout; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfigInternal)DnsConfiguration).DnsMaxCacheTimeout = value ?? default(int); }

        /// <summary>Total number of retries for dns lookup. Allowed range: 1-5. Default is 3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public int? DnsConfigurationDnsRetryAttemptCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfigInternal)DnsConfiguration).DnsRetryAttemptCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfigInternal)DnsConfiguration).DnsRetryAttemptCount = value ?? default(int); }

        /// <summary>Timeout for a single dns lookup in seconds. Allowed range: 1-30. Default is 3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public int? DnsConfigurationDnsRetryAttemptTimeout { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfigInternal)DnsConfiguration).DnsRetryAttemptTimeout; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfigInternal)DnsConfiguration).DnsRetryAttemptTimeout = value ?? default(int); }

        /// <summary>
        /// List of custom DNS servers to be used by an app for lookups. Maximum 5 dns servers can be set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string[] DnsConfigurationDnsServer { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfigInternal)DnsConfiguration).DnsServer; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfigInternal)DnsConfiguration).DnsServer = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="Enabled" /> property.</summary>
        private bool? _enabled;

        /// <summary>
        /// <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables the app (takes
        /// the app offline).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public bool? Enabled { get => this._enabled; set => this._enabled = value; }

        /// <summary>Backing field for <see cref="EnabledHostName" /> property.</summary>
        private string[] _enabledHostName;

        /// <summary>
        /// Enabled hostnames for the app.Hostnames need to be assigned (see HostNames) AND enabled. Otherwise,
        /// the app is not served on those hostnames.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string[] EnabledHostName { get => this._enabledHostName; }

        /// <summary>Backing field for <see cref="FunctionAppConfig" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfig _functionAppConfig;

        /// <summary>Configuration specific of the Azure Function app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfig FunctionAppConfig { get => (this._functionAppConfig = this._functionAppConfig ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.FunctionAppConfig()); set => this._functionAppConfig = value; }

        /// <summary>Backing field for <see cref="HostName" /> property.</summary>
        private string[] _hostName;

        /// <summary>Hostnames associated with the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string[] HostName { get => this._hostName; }

        /// <summary>Backing field for <see cref="HostNameSslState" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostNameSslState[] _hostNameSslState;

        /// <summary>Hostname SSL states are used to manage the SSL bindings for app's hostnames.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostNameSslState[] HostNameSslState { get => this._hostNameSslState; set => this._hostNameSslState = value; }

        /// <summary>Backing field for <see cref="HostNamesDisabled" /> property.</summary>
        private bool? _hostNamesDisabled;

        /// <summary>
        /// <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
        /// If <code>true</code>, the app is only accessible via API management process.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public bool? HostNamesDisabled { get => this._hostNamesDisabled; set => this._hostNamesDisabled = value; }

        /// <summary>Backing field for <see cref="HostingEnvironmentProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostingEnvironmentProfile _hostingEnvironmentProfile;

        /// <summary>App Service Environment to use for the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostingEnvironmentProfile HostingEnvironmentProfile { get => (this._hostingEnvironmentProfile = this._hostingEnvironmentProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.HostingEnvironmentProfile()); set => this._hostingEnvironmentProfile = value; }

        /// <summary>Resource ID of the App Service Environment.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string HostingEnvironmentProfileId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostingEnvironmentProfileInternal)HostingEnvironmentProfile).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostingEnvironmentProfileInternal)HostingEnvironmentProfile).Id = value ?? null; }

        /// <summary>Name of the App Service Environment.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string HostingEnvironmentProfileName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostingEnvironmentProfileInternal)HostingEnvironmentProfile).Name; }

        /// <summary>Resource type of the App Service Environment.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string HostingEnvironmentProfileType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostingEnvironmentProfileInternal)HostingEnvironmentProfile).Type; }

        /// <summary>The maximum number of concurrent HTTP trigger invocations per instance.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public float? HttpPerInstanceConcurrency { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).HttpPerInstanceConcurrency; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).HttpPerInstanceConcurrency = value ?? default(float); }

        /// <summary>Backing field for <see cref="HttpsOnly" /> property.</summary>
        private bool? _httpsOnly;

        /// <summary>
        /// HttpsOnly: configures a web site to accept only https requests. Issues redirect for
        /// http requests
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public bool? HttpsOnly { get => this._httpsOnly; set => this._httpsOnly = value; }

        /// <summary>Backing field for <see cref="HyperV" /> property.</summary>
        private bool? _hyperV;

        /// <summary>Hyper-V sandbox.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public bool? HyperV { get => this._hyperV; set => this._hyperV = value; }

        /// <summary>Backing field for <see cref="InProgressOperationId" /> property.</summary>
        private string _inProgressOperationId;

        /// <summary>Specifies an operation id if this site has a pending operation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string InProgressOperationId { get => this._inProgressOperationId; }

        /// <summary>Backing field for <see cref="IsDefaultContainer" /> property.</summary>
        private bool? _isDefaultContainer;

        /// <summary>
        /// <code>true</code> if the app is a default container; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public bool? IsDefaultContainer { get => this._isDefaultContainer; }

        /// <summary>Backing field for <see cref="IsXenon" /> property.</summary>
        private bool? _isXenon;

        /// <summary>Obsolete: Hyper-V sandbox.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public bool? IsXenon { get => this._isXenon; set => this._isXenon = value; }

        /// <summary>Backing field for <see cref="KeyVaultReferenceIdentity" /> property.</summary>
        private string _keyVaultReferenceIdentity;

        /// <summary>Identity to use for Key Vault Reference authentication.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string KeyVaultReferenceIdentity { get => this._keyVaultReferenceIdentity; set => this._keyVaultReferenceIdentity = value; }

        /// <summary>Backing field for <see cref="LastModifiedTimeUtc" /> property.</summary>
        private global::System.DateTime? _lastModifiedTimeUtc;

        /// <summary>Last time the app was modified, in UTC. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public global::System.DateTime? LastModifiedTimeUtc { get => this._lastModifiedTimeUtc; }

        /// <summary>Backing field for <see cref="ManagedEnvironmentId" /> property.</summary>
        private string _managedEnvironmentId;

        /// <summary>
        /// Azure Resource Manager ID of the customer's selected Managed Environment on which to host this app. This must be of the
        /// form /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.App/managedEnvironments/{managedEnvironmentName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string ManagedEnvironmentId { get => this._managedEnvironmentId; set => this._managedEnvironmentId = value; }

        /// <summary>Backing field for <see cref="MaxNumberOfWorker" /> property.</summary>
        private int? _maxNumberOfWorker;

        /// <summary>
        /// Maximum number of workers.
        /// This only applies to Functions container.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public int? MaxNumberOfWorker { get => this._maxNumberOfWorker; }

        /// <summary>Internal Acessors for AvailabilityState</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.SiteAvailabilityState? Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.AvailabilityState { get => this._availabilityState; set { {_availabilityState = value;} } }

        /// <summary>Internal Acessors for CloningInfo</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfo Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.CloningInfo { get => (this._cloningInfo = this._cloningInfo ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.CloningInfo()); set { {_cloningInfo = value;} } }

        /// <summary>Internal Acessors for DaprConfig</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfig Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.DaprConfig { get => (this._daprConfig = this._daprConfig ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.DaprConfig()); set { {_daprConfig = value;} } }

        /// <summary>Internal Acessors for DefaultHostName</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.DefaultHostName { get => this._defaultHostName; set { {_defaultHostName = value;} } }

        /// <summary>Internal Acessors for DeploymentStorage</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsDeploymentStorage Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.DeploymentStorage { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).DeploymentStorage; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).DeploymentStorage = value; }

        /// <summary>Internal Acessors for DnsConfiguration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfig Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.DnsConfiguration { get => (this._dnsConfiguration = this._dnsConfiguration ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.SiteDnsConfig()); set { {_dnsConfiguration = value;} } }

        /// <summary>Internal Acessors for DnsConfigurationDnsLegacySortOrder</summary>
        bool? Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.DnsConfigurationDnsLegacySortOrder { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfigInternal)DnsConfiguration).DnsLegacySortOrder; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfigInternal)DnsConfiguration).DnsLegacySortOrder = value; }

        /// <summary>Internal Acessors for EnabledHostName</summary>
        string[] Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.EnabledHostName { get => this._enabledHostName; set { {_enabledHostName = value;} } }

        /// <summary>Internal Acessors for FunctionAppConfig</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfig Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.FunctionAppConfig { get => (this._functionAppConfig = this._functionAppConfig ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.FunctionAppConfig()); set { {_functionAppConfig = value;} } }

        /// <summary>Internal Acessors for FunctionAppConfigDeployment</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsDeployment Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.FunctionAppConfigDeployment { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).Deployment; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).Deployment = value; }

        /// <summary>Internal Acessors for FunctionAppConfigRuntime</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsRuntime Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.FunctionAppConfigRuntime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).Runtime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).Runtime = value; }

        /// <summary>Internal Acessors for FunctionAppConfigScaleAndConcurrency</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsScaleAndConcurrency Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.FunctionAppConfigScaleAndConcurrency { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).ScaleAndConcurrency; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).ScaleAndConcurrency = value; }

        /// <summary>Internal Acessors for HostName</summary>
        string[] Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.HostName { get => this._hostName; set { {_hostName = value;} } }

        /// <summary>Internal Acessors for HostingEnvironmentProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostingEnvironmentProfile Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.HostingEnvironmentProfile { get => (this._hostingEnvironmentProfile = this._hostingEnvironmentProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.HostingEnvironmentProfile()); set { {_hostingEnvironmentProfile = value;} } }

        /// <summary>Internal Acessors for HostingEnvironmentProfileName</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.HostingEnvironmentProfileName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostingEnvironmentProfileInternal)HostingEnvironmentProfile).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostingEnvironmentProfileInternal)HostingEnvironmentProfile).Name = value; }

        /// <summary>Internal Acessors for HostingEnvironmentProfileType</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.HostingEnvironmentProfileType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostingEnvironmentProfileInternal)HostingEnvironmentProfile).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostingEnvironmentProfileInternal)HostingEnvironmentProfile).Type = value; }

        /// <summary>Internal Acessors for InProgressOperationId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.InProgressOperationId { get => this._inProgressOperationId; set { {_inProgressOperationId = value;} } }

        /// <summary>Internal Acessors for IsDefaultContainer</summary>
        bool? Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.IsDefaultContainer { get => this._isDefaultContainer; set { {_isDefaultContainer = value;} } }

        /// <summary>Internal Acessors for LastModifiedTimeUtc</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.LastModifiedTimeUtc { get => this._lastModifiedTimeUtc; set { {_lastModifiedTimeUtc = value;} } }

        /// <summary>Internal Acessors for MaxNumberOfWorker</summary>
        int? Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.MaxNumberOfWorker { get => this._maxNumberOfWorker; set { {_maxNumberOfWorker = value;} } }

        /// <summary>Internal Acessors for OutboundIPAddress</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.OutboundIPAddress { get => this._outboundIPAddress; set { {_outboundIPAddress = value;} } }

        /// <summary>Internal Acessors for PossibleOutboundIPAddress</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.PossibleOutboundIPAddress { get => this._possibleOutboundIPAddress; set { {_possibleOutboundIPAddress = value;} } }

        /// <summary>Internal Acessors for RepositorySiteName</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.RepositorySiteName { get => this._repositorySiteName; set { {_repositorySiteName = value;} } }

        /// <summary>Internal Acessors for ResourceConfig</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceConfig Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.ResourceConfig { get => (this._resourceConfig = this._resourceConfig ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ResourceConfig()); set { {_resourceConfig = value;} } }

        /// <summary>Internal Acessors for ResourceGroup</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.ResourceGroup { get => this._resourceGroup; set { {_resourceGroup = value;} } }

        /// <summary>Internal Acessors for ScaleAndConcurrencyTrigger</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsScaleAndConcurrencyTriggers Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.ScaleAndConcurrencyTrigger { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).ScaleAndConcurrencyTrigger; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).ScaleAndConcurrencyTrigger = value; }

        /// <summary>Internal Acessors for SlotSwapStatus</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISlotSwapStatus Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.SlotSwapStatus { get => (this._slotSwapStatus = this._slotSwapStatus ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.SlotSwapStatus()); set { {_slotSwapStatus = value;} } }

        /// <summary>Internal Acessors for SlotSwapStatusDestinationSlotName</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.SlotSwapStatusDestinationSlotName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISlotSwapStatusInternal)SlotSwapStatus).DestinationSlotName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISlotSwapStatusInternal)SlotSwapStatus).DestinationSlotName = value; }

        /// <summary>Internal Acessors for SlotSwapStatusSourceSlotName</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.SlotSwapStatusSourceSlotName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISlotSwapStatusInternal)SlotSwapStatus).SourceSlotName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISlotSwapStatusInternal)SlotSwapStatus).SourceSlotName = value; }

        /// <summary>Internal Acessors for SlotSwapStatusTimestampUtc</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.SlotSwapStatusTimestampUtc { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISlotSwapStatusInternal)SlotSwapStatus).TimestampUtc; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISlotSwapStatusInternal)SlotSwapStatus).TimestampUtc = value; }

        /// <summary>Internal Acessors for State</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.State { get => this._state; set { {_state = value;} } }

        /// <summary>Internal Acessors for StorageAuthentication</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsDeploymentStorageAuthentication Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.StorageAuthentication { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).StorageAuthentication; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).StorageAuthentication = value; }

        /// <summary>Internal Acessors for SuspendedTill</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.SuspendedTill { get => this._suspendedTill; set { {_suspendedTill = value;} } }

        /// <summary>Internal Acessors for TargetSwapSlot</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.TargetSwapSlot { get => this._targetSwapSlot; set { {_targetSwapSlot = value;} } }

        /// <summary>Internal Acessors for TrafficManagerHostName</summary>
        string[] Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.TrafficManagerHostName { get => this._trafficManagerHostName; set { {_trafficManagerHostName = value;} } }

        /// <summary>Internal Acessors for TriggerHttp</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsScaleAndConcurrencyTriggersHttp Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.TriggerHttp { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).TriggerHttp; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).TriggerHttp = value; }

        /// <summary>Internal Acessors for UsageState</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.UsageState? Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISitePropertiesInternal.UsageState { get => this._usageState; set { {_usageState = value;} } }

        /// <summary>Backing field for <see cref="OutboundIPAddress" /> property.</summary>
        private string _outboundIPAddress;

        /// <summary>
        /// List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from tenants that
        /// site can be hosted with current settings. Read-only.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string OutboundIPAddress { get => this._outboundIPAddress; }

        /// <summary>Backing field for <see cref="PossibleOutboundIPAddress" /> property.</summary>
        private string _possibleOutboundIPAddress;

        /// <summary>
        /// List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from all tenants
        /// except dataComponent. Read-only.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string PossibleOutboundIPAddress { get => this._possibleOutboundIPAddress; }

        /// <summary>Backing field for <see cref="PublicNetworkAccess" /> property.</summary>
        private string _publicNetworkAccess;

        /// <summary>
        /// Property to allow or block all public traffic. Allowed Values: 'Enabled', 'Disabled' or an empty string.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string PublicNetworkAccess { get => this._publicNetworkAccess; set => this._publicNetworkAccess = value; }

        /// <summary>Backing field for <see cref="RedundancyMode" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RedundancyMode? _redundancyMode;

        /// <summary>Site redundancy mode</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RedundancyMode? RedundancyMode { get => this._redundancyMode; set => this._redundancyMode = value; }

        /// <summary>Backing field for <see cref="RepositorySiteName" /> property.</summary>
        private string _repositorySiteName;

        /// <summary>Name of the repository site.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string RepositorySiteName { get => this._repositorySiteName; }

        /// <summary>Backing field for <see cref="Reserved" /> property.</summary>
        private bool? _reserved;

        /// <summary><code>true</code> if reserved; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public bool? Reserved { get => this._reserved; set => this._reserved = value; }

        /// <summary>Backing field for <see cref="ResourceConfig" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceConfig _resourceConfig;

        /// <summary>Function app resource requirements.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceConfig ResourceConfig { get => (this._resourceConfig = this._resourceConfig ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ResourceConfig()); set => this._resourceConfig = value; }

        /// <summary>Required CPU in cores, e.g. 0.5</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public double? ResourceConfigCpu { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceConfigInternal)ResourceConfig).Cpu; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceConfigInternal)ResourceConfig).Cpu = value ?? default(double); }

        /// <summary>Required memory, e.g. "1Gi"</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string ResourceConfigMemory { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceConfigInternal)ResourceConfig).Memory; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceConfigInternal)ResourceConfig).Memory = value ?? null; }

        /// <summary>Backing field for <see cref="ResourceGroup" /> property.</summary>
        private string _resourceGroup;

        /// <summary>Name of the resource group the app belongs to. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string ResourceGroup { get => this._resourceGroup; }

        /// <summary>
        /// Function app runtime name. Available options: dotnet-isolated, node, java, powershell, python, custom
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RuntimeName? RuntimeName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).RuntimeName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).RuntimeName = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RuntimeName)""); }

        /// <summary>Function app runtime version. Example: 8 (for dotnet-isolated)</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string RuntimeVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).RuntimeVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).RuntimeVersion = value ?? null; }

        /// <summary>'Always Ready' configuration for the function app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsAlwaysReadyConfig[] ScaleAndConcurrencyAlwaysReady { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).ScaleAndConcurrencyAlwaysReady; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).ScaleAndConcurrencyAlwaysReady = value ?? null /* arrayOf */; }

        /// <summary>
        /// Set the amount of memory allocated to each instance of the function app in MB. CPU and network bandwidth are allocated
        /// proportionally.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public float? ScaleAndConcurrencyInstanceMemoryMb { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).ScaleAndConcurrencyInstanceMemoryMb; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).ScaleAndConcurrencyInstanceMemoryMb = value ?? default(float); }

        /// <summary>The maximum number of instances for the function app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public float? ScaleAndConcurrencyMaximumInstanceCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).ScaleAndConcurrencyMaximumInstanceCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).ScaleAndConcurrencyMaximumInstanceCount = value ?? default(float); }

        /// <summary>Backing field for <see cref="ScmSiteAlsoStopped" /> property.</summary>
        private bool? _scmSiteAlsoStopped;

        /// <summary>
        /// <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The default is <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public bool? ScmSiteAlsoStopped { get => this._scmSiteAlsoStopped; set => this._scmSiteAlsoStopped = value; }

        /// <summary>Backing field for <see cref="ServerFarmId" /> property.</summary>
        private string _serverFarmId;

        /// <summary>
        /// Resource ID of the associated App Service plan, formatted as: "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string ServerFarmId { get => this._serverFarmId; set => this._serverFarmId = value; }

        /// <summary>Backing field for <see cref="SiteConfig" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteConfig _siteConfig;

        /// <summary>Configuration of the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteConfig SiteConfig { get => (this._siteConfig = this._siteConfig ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.SiteConfig()); set => this._siteConfig = value; }

        /// <summary>Backing field for <see cref="SlotSwapStatus" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISlotSwapStatus _slotSwapStatus;

        /// <summary>Status of the last deployment slot swap operation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISlotSwapStatus SlotSwapStatus { get => (this._slotSwapStatus = this._slotSwapStatus ?? new Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.SlotSwapStatus()); }

        /// <summary>The destination slot of the last swap operation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string SlotSwapStatusDestinationSlotName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISlotSwapStatusInternal)SlotSwapStatus).DestinationSlotName; }

        /// <summary>The source slot of the last swap operation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string SlotSwapStatusSourceSlotName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISlotSwapStatusInternal)SlotSwapStatus).SourceSlotName; }

        /// <summary>The time the last successful slot swap completed.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public global::System.DateTime? SlotSwapStatusTimestampUtc { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISlotSwapStatusInternal)SlotSwapStatus).TimestampUtc; }

        /// <summary>Backing field for <see cref="State" /> property.</summary>
        private string _state;

        /// <summary>Current state of the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string State { get => this._state; }

        /// <summary>Backing field for <see cref="StorageAccountRequired" /> property.</summary>
        private bool? _storageAccountRequired;

        /// <summary>Checks if Customer provided storage account is required</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public bool? StorageAccountRequired { get => this._storageAccountRequired; set => this._storageAccountRequired = value; }

        /// <summary>Property to select Azure Storage type. Available options: blobContainer.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.FunctionsDeploymentStorageType? StorageType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).StorageType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).StorageType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.FunctionsDeploymentStorageType)""); }

        /// <summary>
        /// Property to set the URL for the selected Azure Storage type. Example: For blobContainer, the value could be https://<storageAccountName>.blob.core.windows.net/<containerName>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Inlined)]
        public string StorageValue { get => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).StorageValue; set => ((Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfigInternal)FunctionAppConfig).StorageValue = value ?? null; }

        /// <summary>Backing field for <see cref="SuspendedTill" /> property.</summary>
        private global::System.DateTime? _suspendedTill;

        /// <summary>App suspended till in case memory-time quota is exceeded.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public global::System.DateTime? SuspendedTill { get => this._suspendedTill; }

        /// <summary>Backing field for <see cref="TargetSwapSlot" /> property.</summary>
        private string _targetSwapSlot;

        /// <summary>Specifies which deployment slot this app will swap into. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string TargetSwapSlot { get => this._targetSwapSlot; }

        /// <summary>Backing field for <see cref="TrafficManagerHostName" /> property.</summary>
        private string[] _trafficManagerHostName;

        /// <summary>Azure Traffic Manager hostnames associated with the app. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string[] TrafficManagerHostName { get => this._trafficManagerHostName; }

        /// <summary>Backing field for <see cref="UsageState" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.UsageState? _usageState;

        /// <summary>State indicating whether the app has exceeded its quota usage. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.UsageState? UsageState { get => this._usageState; }

        /// <summary>Backing field for <see cref="VirtualNetworkSubnetId" /> property.</summary>
        private string _virtualNetworkSubnetId;

        /// <summary>
        /// Azure Resource Manager ID of the Virtual network and subnet to be joined by Regional VNET Integration.
        /// This must be of the form /subscriptions/{subscriptionName}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string VirtualNetworkSubnetId { get => this._virtualNetworkSubnetId; set => this._virtualNetworkSubnetId = value; }

        /// <summary>Backing field for <see cref="VnetBackupRestoreEnabled" /> property.</summary>
        private bool? _vnetBackupRestoreEnabled;

        /// <summary>To enable Backup and Restore operations over virtual network</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public bool? VnetBackupRestoreEnabled { get => this._vnetBackupRestoreEnabled; set => this._vnetBackupRestoreEnabled = value; }

        /// <summary>Backing field for <see cref="VnetContentShareEnabled" /> property.</summary>
        private bool? _vnetContentShareEnabled;

        /// <summary>To enable accessing content over virtual network</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public bool? VnetContentShareEnabled { get => this._vnetContentShareEnabled; set => this._vnetContentShareEnabled = value; }

        /// <summary>Backing field for <see cref="VnetImagePullEnabled" /> property.</summary>
        private bool? _vnetImagePullEnabled;

        /// <summary>To enable pulling image over Virtual Network</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public bool? VnetImagePullEnabled { get => this._vnetImagePullEnabled; set => this._vnetImagePullEnabled = value; }

        /// <summary>Backing field for <see cref="VnetRouteAllEnabled" /> property.</summary>
        private bool? _vnetRouteAllEnabled;

        /// <summary>
        /// Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined
        /// Routes applied.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public bool? VnetRouteAllEnabled { get => this._vnetRouteAllEnabled; set => this._vnetRouteAllEnabled = value; }

        /// <summary>Backing field for <see cref="WorkloadProfileName" /> property.</summary>
        private string _workloadProfileName;

        /// <summary>Workload profile name for function app to execute on.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Origin(Microsoft.Azure.PowerShell.Cmdlets.Functions.PropertyOrigin.Owned)]
        public string WorkloadProfileName { get => this._workloadProfileName; set => this._workloadProfileName = value; }

        /// <summary>Creates an new <see cref="SiteProperties" /> instance.</summary>
        public SiteProperties()
        {

        }
    }
    /// Site resource specific properties
    public partial interface ISiteProperties :
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.IJsonSerializable
    {
        /// <summary>
        /// Use this property for StorageAccountConnectionString. Set the name of the app setting that has the storage account connection
        /// string. Do not set a value for this property when using other authentication type.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Use this property for StorageAccountConnectionString. Set the name of the app setting that has the storage account connection string. Do not set a value for this property when using other authentication type.",
        SerializedName = @"storageAccountConnectionStringName",
        PossibleTypes = new [] { typeof(string) })]
        string AuthenticationStorageAccountConnectionStringName { get; set; }
        /// <summary>
        /// Property to select authentication type to access the selected storage account. Available options: SystemAssignedIdentity,
        /// UserAssignedIdentity, StorageAccountConnectionString.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Property to select authentication type to access the selected storage account. Available options: SystemAssignedIdentity, UserAssignedIdentity, StorageAccountConnectionString.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.AuthenticationType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.AuthenticationType? AuthenticationType { get; set; }
        /// <summary>
        /// Use this property for UserAssignedIdentity. Set the resource ID of the identity. Do not set a value for this property
        /// when using other authentication type.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Use this property for UserAssignedIdentity. Set the resource ID of the identity. Do not set a value for this property when using other authentication type.",
        SerializedName = @"userAssignedIdentityResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string AuthenticationUserAssignedIdentityResourceId { get; set; }
        /// <summary>Management information availability state for the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Management information availability state for the app.",
        SerializedName = @"availabilityState",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.SiteAvailabilityState) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.SiteAvailabilityState? AvailabilityState { get;  }
        /// <summary>
        /// <code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity cookies, which route
        /// client requests in the same session to the same instance. Default is <code>true</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity cookies, which route client requests in the same session to the same instance. Default is <code>true</code>.",
        SerializedName = @"clientAffinityEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ClientAffinityEnabled { get; set; }
        /// <summary>
        /// <code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise, <code>false</code>.
        /// Default is <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise, <code>false</code>. Default is <code>false</code>.",
        SerializedName = @"clientCertEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ClientCertEnabled { get; set; }
        /// <summary>client certificate authentication comma-separated exclusion paths</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"client certificate authentication comma-separated exclusion paths",
        SerializedName = @"clientCertExclusionPaths",
        PossibleTypes = new [] { typeof(string) })]
        string ClientCertExclusionPath { get; set; }
        /// <summary>
        /// This composes with ClientCertEnabled setting.
        /// - ClientCertEnabled: false means ClientCert is ignored.
        /// - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
        /// - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This composes with ClientCertEnabled setting.
        - ClientCertEnabled: false means ClientCert is ignored.
        - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
        - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.",
        SerializedName = @"clientCertMode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ClientCertMode) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ClientCertMode? ClientCertMode { get; set; }
        /// <summary>
        /// Application setting overrides for cloned app. If specified, these settings override the settings cloned
        /// from source app. Otherwise, application settings from source app are retained.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Application setting overrides for cloned app. If specified, these settings override the settings cloned
        from source app. Otherwise, application settings from source app are retained.",
        SerializedName = @"appSettingsOverrides",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoAppSettingsOverrides) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoAppSettingsOverrides CloningInfoAppSettingsOverride { get; set; }
        /// <summary>
        /// <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.",
        SerializedName = @"cloneCustomHostNames",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CloningInfoCloneCustomHostName { get; set; }
        /// <summary>
        /// <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to clone source control from source app; otherwise, <code>false</code>.",
        SerializedName = @"cloneSourceControl",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CloningInfoCloneSourceControl { get; set; }
        /// <summary><code>true</code> to configure load balancing for source and destination app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to configure load balancing for source and destination app.",
        SerializedName = @"configureLoadBalancing",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CloningInfoConfigureLoadBalancing { get; set; }
        /// <summary>
        /// Correlation ID of cloning operation. This ID ties multiple cloning operations
        /// together to use the same snapshot.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Correlation ID of cloning operation. This ID ties multiple cloning operations
        together to use the same snapshot.",
        SerializedName = @"correlationId",
        PossibleTypes = new [] { typeof(string) })]
        string CloningInfoCorrelationId { get; set; }
        /// <summary>App Service Environment.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"App Service Environment.",
        SerializedName = @"hostingEnvironment",
        PossibleTypes = new [] { typeof(string) })]
        string CloningInfoHostingEnvironment { get; set; }
        /// <summary><code>true</code> to overwrite destination app; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to overwrite destination app; otherwise, <code>false</code>.",
        SerializedName = @"overwrite",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CloningInfoOverwrite { get; set; }
        /// <summary>
        /// ARM resource ID of the source app. App resource ID is of the form
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots
        /// and
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for
        /// other slots.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"ARM resource ID of the source app. App resource ID is of the form
        /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots and
        /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for other slots.",
        SerializedName = @"sourceWebAppId",
        PossibleTypes = new [] { typeof(string) })]
        string CloningInfoSourceWebAppId { get; set; }
        /// <summary>Location of source app ex: West US or North Europe</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Location of source app ex: West US or North Europe",
        SerializedName = @"sourceWebAppLocation",
        PossibleTypes = new [] { typeof(string) })]
        string CloningInfoSourceWebAppLocation { get; set; }
        /// <summary>
        /// ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource ID is of the form
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource ID is of the form
        /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.",
        SerializedName = @"trafficManagerProfileId",
        PossibleTypes = new [] { typeof(string) })]
        string CloningInfoTrafficManagerProfileId { get; set; }
        /// <summary>
        /// Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile does not already exist.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile does not already exist.",
        SerializedName = @"trafficManagerProfileName",
        PossibleTypes = new [] { typeof(string) })]
        string CloningInfoTrafficManagerProfileName { get; set; }
        /// <summary>Size of the function container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Size of the function container.",
        SerializedName = @"containerSize",
        PossibleTypes = new [] { typeof(int) })]
        int? ContainerSize { get; set; }
        /// <summary>
        /// Unique identifier that verifies the custom domains assigned to the app. Customer will add this id to a txt record for
        /// verification.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Unique identifier that verifies the custom domains assigned to the app. Customer will add this id to a txt record for verification.",
        SerializedName = @"customDomainVerificationId",
        PossibleTypes = new [] { typeof(string) })]
        string CustomDomainVerificationId { get; set; }
        /// <summary>Maximum allowed daily memory-time quota (applicable on dynamic apps only).</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Maximum allowed daily memory-time quota (applicable on dynamic apps only).",
        SerializedName = @"dailyMemoryTimeQuota",
        PossibleTypes = new [] { typeof(int) })]
        int? DailyMemoryTimeQuota { get; set; }
        /// <summary>Dapr application identifier</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Dapr application identifier",
        SerializedName = @"appId",
        PossibleTypes = new [] { typeof(string) })]
        string DaprConfigAppId { get; set; }
        /// <summary>Tells Dapr which port your application is listening on</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Tells Dapr which port your application is listening on",
        SerializedName = @"appPort",
        PossibleTypes = new [] { typeof(int) })]
        int? DaprConfigAppPort { get; set; }
        /// <summary>Enables API logging for the Dapr sidecar</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enables API logging for the Dapr sidecar",
        SerializedName = @"enableApiLogging",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DaprConfigEnableApiLogging { get; set; }
        /// <summary>Boolean indicating if the Dapr side car is enabled</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Boolean indicating if the Dapr side car is enabled",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DaprConfigEnabled { get; set; }
        /// <summary>
        /// Increasing max size of request body http servers parameter in MB to handle uploading of big files. Default is 4 MB.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Increasing max size of request body http servers parameter in MB to handle uploading of big files. Default is 4 MB.",
        SerializedName = @"httpMaxRequestSize",
        PossibleTypes = new [] { typeof(int) })]
        int? DaprConfigHttpMaxRequestSize { get; set; }
        /// <summary>
        /// Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.",
        SerializedName = @"httpReadBufferSize",
        PossibleTypes = new [] { typeof(int) })]
        int? DaprConfigHttpReadBufferSize { get; set; }
        /// <summary>
        /// Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.",
        SerializedName = @"logLevel",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.DaprLogLevel) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.DaprLogLevel? DaprConfigLogLevel { get; set; }
        /// <summary>Default hostname of the app. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Default hostname of the app. Read-only.",
        SerializedName = @"defaultHostName",
        PossibleTypes = new [] { typeof(string) })]
        string DefaultHostName { get;  }
        /// <summary>
        /// Alternate DNS server to be used by apps. This property replicates the WEBSITE_DNS_ALT_SERVER app setting.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Alternate DNS server to be used by apps. This property replicates the WEBSITE_DNS_ALT_SERVER app setting.",
        SerializedName = @"dnsAltServer",
        PossibleTypes = new [] { typeof(string) })]
        string DnsConfigurationDnsAltServer { get; set; }
        /// <summary>
        /// Indicates that sites using Virtual network custom DNS servers are still sorting the list of DNS servers. Read-Only.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Indicates that sites using Virtual network custom DNS servers are still sorting the list of DNS servers. Read-Only.",
        SerializedName = @"dnsLegacySortOrder",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DnsConfigurationDnsLegacySortOrder { get;  }
        /// <summary>
        /// Custom time for DNS to be cached in seconds. Allowed range: 0-60. Default is 30 seconds. 0 means caching disabled.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Custom time for DNS to be cached in seconds. Allowed range: 0-60. Default is 30 seconds. 0 means caching disabled.",
        SerializedName = @"dnsMaxCacheTimeout",
        PossibleTypes = new [] { typeof(int) })]
        int? DnsConfigurationDnsMaxCacheTimeout { get; set; }
        /// <summary>Total number of retries for dns lookup. Allowed range: 1-5. Default is 3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Total number of retries for dns lookup. Allowed range: 1-5. Default is 3.",
        SerializedName = @"dnsRetryAttemptCount",
        PossibleTypes = new [] { typeof(int) })]
        int? DnsConfigurationDnsRetryAttemptCount { get; set; }
        /// <summary>Timeout for a single dns lookup in seconds. Allowed range: 1-30. Default is 3.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Timeout for a single dns lookup in seconds. Allowed range: 1-30. Default is 3.",
        SerializedName = @"dnsRetryAttemptTimeout",
        PossibleTypes = new [] { typeof(int) })]
        int? DnsConfigurationDnsRetryAttemptTimeout { get; set; }
        /// <summary>
        /// List of custom DNS servers to be used by an app for lookups. Maximum 5 dns servers can be set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"List of custom DNS servers to be used by an app for lookups. Maximum 5 dns servers can be set.",
        SerializedName = @"dnsServers",
        PossibleTypes = new [] { typeof(string) })]
        string[] DnsConfigurationDnsServer { get; set; }
        /// <summary>
        /// <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables the app (takes
        /// the app offline).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables the app (takes the app offline).",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? Enabled { get; set; }
        /// <summary>
        /// Enabled hostnames for the app.Hostnames need to be assigned (see HostNames) AND enabled. Otherwise,
        /// the app is not served on those hostnames.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Enabled hostnames for the app.Hostnames need to be assigned (see HostNames) AND enabled. Otherwise,
        the app is not served on those hostnames.",
        SerializedName = @"enabledHostNames",
        PossibleTypes = new [] { typeof(string) })]
        string[] EnabledHostName { get;  }
        /// <summary>Hostnames associated with the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Hostnames associated with the app.",
        SerializedName = @"hostNames",
        PossibleTypes = new [] { typeof(string) })]
        string[] HostName { get;  }
        /// <summary>Hostname SSL states are used to manage the SSL bindings for app's hostnames.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Hostname SSL states are used to manage the SSL bindings for app's hostnames.",
        SerializedName = @"hostNameSslStates",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostNameSslState) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostNameSslState[] HostNameSslState { get; set; }
        /// <summary>
        /// <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
        /// If <code>true</code>, the app is only accessible via API management process.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
         If <code>true</code>, the app is only accessible via API management process.",
        SerializedName = @"hostNamesDisabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? HostNamesDisabled { get; set; }
        /// <summary>Resource ID of the App Service Environment.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource ID of the App Service Environment.",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(string) })]
        string HostingEnvironmentProfileId { get; set; }
        /// <summary>Name of the App Service Environment.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Name of the App Service Environment.",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string HostingEnvironmentProfileName { get;  }
        /// <summary>Resource type of the App Service Environment.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Resource type of the App Service Environment.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(string) })]
        string HostingEnvironmentProfileType { get;  }
        /// <summary>The maximum number of concurrent HTTP trigger invocations per instance.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The maximum number of concurrent HTTP trigger invocations per instance.",
        SerializedName = @"perInstanceConcurrency",
        PossibleTypes = new [] { typeof(float) })]
        float? HttpPerInstanceConcurrency { get; set; }
        /// <summary>
        /// HttpsOnly: configures a web site to accept only https requests. Issues redirect for
        /// http requests
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"HttpsOnly: configures a web site to accept only https requests. Issues redirect for
        http requests",
        SerializedName = @"httpsOnly",
        PossibleTypes = new [] { typeof(bool) })]
        bool? HttpsOnly { get; set; }
        /// <summary>Hyper-V sandbox.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Hyper-V sandbox.",
        SerializedName = @"hyperV",
        PossibleTypes = new [] { typeof(bool) })]
        bool? HyperV { get; set; }
        /// <summary>Specifies an operation id if this site has a pending operation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Specifies an operation id if this site has a pending operation.",
        SerializedName = @"inProgressOperationId",
        PossibleTypes = new [] { typeof(string) })]
        string InProgressOperationId { get;  }
        /// <summary>
        /// <code>true</code> if the app is a default container; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"<code>true</code> if the app is a default container; otherwise, <code>false</code>.",
        SerializedName = @"isDefaultContainer",
        PossibleTypes = new [] { typeof(bool) })]
        bool? IsDefaultContainer { get;  }
        /// <summary>Obsolete: Hyper-V sandbox.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Obsolete: Hyper-V sandbox.",
        SerializedName = @"isXenon",
        PossibleTypes = new [] { typeof(bool) })]
        bool? IsXenon { get; set; }
        /// <summary>Identity to use for Key Vault Reference authentication.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Identity to use for Key Vault Reference authentication.",
        SerializedName = @"keyVaultReferenceIdentity",
        PossibleTypes = new [] { typeof(string) })]
        string KeyVaultReferenceIdentity { get; set; }
        /// <summary>Last time the app was modified, in UTC. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Last time the app was modified, in UTC. Read-only.",
        SerializedName = @"lastModifiedTimeUtc",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? LastModifiedTimeUtc { get;  }
        /// <summary>
        /// Azure Resource Manager ID of the customer's selected Managed Environment on which to host this app. This must be of the
        /// form /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.App/managedEnvironments/{managedEnvironmentName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Azure Resource Manager ID of the customer's selected Managed Environment on which to host this app. This must be of the form /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.App/managedEnvironments/{managedEnvironmentName}",
        SerializedName = @"managedEnvironmentId",
        PossibleTypes = new [] { typeof(string) })]
        string ManagedEnvironmentId { get; set; }
        /// <summary>
        /// Maximum number of workers.
        /// This only applies to Functions container.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Maximum number of workers.
        This only applies to Functions container.",
        SerializedName = @"maxNumberOfWorkers",
        PossibleTypes = new [] { typeof(int) })]
        int? MaxNumberOfWorker { get;  }
        /// <summary>
        /// List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from tenants that
        /// site can be hosted with current settings. Read-only.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from tenants that site can be hosted with current settings. Read-only.",
        SerializedName = @"outboundIpAddresses",
        PossibleTypes = new [] { typeof(string) })]
        string OutboundIPAddress { get;  }
        /// <summary>
        /// List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from all tenants
        /// except dataComponent. Read-only.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from all tenants except dataComponent. Read-only.",
        SerializedName = @"possibleOutboundIpAddresses",
        PossibleTypes = new [] { typeof(string) })]
        string PossibleOutboundIPAddress { get;  }
        /// <summary>
        /// Property to allow or block all public traffic. Allowed Values: 'Enabled', 'Disabled' or an empty string.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Property to allow or block all public traffic. Allowed Values: 'Enabled', 'Disabled' or an empty string.",
        SerializedName = @"publicNetworkAccess",
        PossibleTypes = new [] { typeof(string) })]
        string PublicNetworkAccess { get; set; }
        /// <summary>Site redundancy mode</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Site redundancy mode",
        SerializedName = @"redundancyMode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RedundancyMode) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RedundancyMode? RedundancyMode { get; set; }
        /// <summary>Name of the repository site.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Name of the repository site.",
        SerializedName = @"repositorySiteName",
        PossibleTypes = new [] { typeof(string) })]
        string RepositorySiteName { get;  }
        /// <summary><code>true</code> if reserved; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> if reserved; otherwise, <code>false</code>.",
        SerializedName = @"reserved",
        PossibleTypes = new [] { typeof(bool) })]
        bool? Reserved { get; set; }
        /// <summary>Required CPU in cores, e.g. 0.5</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Required CPU in cores, e.g. 0.5",
        SerializedName = @"cpu",
        PossibleTypes = new [] { typeof(double) })]
        double? ResourceConfigCpu { get; set; }
        /// <summary>Required memory, e.g. "1Gi"</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Required memory, e.g. ""1Gi""",
        SerializedName = @"memory",
        PossibleTypes = new [] { typeof(string) })]
        string ResourceConfigMemory { get; set; }
        /// <summary>Name of the resource group the app belongs to. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Name of the resource group the app belongs to. Read-only.",
        SerializedName = @"resourceGroup",
        PossibleTypes = new [] { typeof(string) })]
        string ResourceGroup { get;  }
        /// <summary>
        /// Function app runtime name. Available options: dotnet-isolated, node, java, powershell, python, custom
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Function app runtime name. Available options: dotnet-isolated, node, java, powershell, python, custom",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RuntimeName) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RuntimeName? RuntimeName { get; set; }
        /// <summary>Function app runtime version. Example: 8 (for dotnet-isolated)</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Function app runtime version. Example: 8 (for dotnet-isolated)",
        SerializedName = @"version",
        PossibleTypes = new [] { typeof(string) })]
        string RuntimeVersion { get; set; }
        /// <summary>'Always Ready' configuration for the function app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"'Always Ready' configuration for the function app.",
        SerializedName = @"alwaysReady",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsAlwaysReadyConfig) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsAlwaysReadyConfig[] ScaleAndConcurrencyAlwaysReady { get; set; }
        /// <summary>
        /// Set the amount of memory allocated to each instance of the function app in MB. CPU and network bandwidth are allocated
        /// proportionally.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Set the amount of memory allocated to each instance of the function app in MB. CPU and network bandwidth are allocated proportionally.",
        SerializedName = @"instanceMemoryMB",
        PossibleTypes = new [] { typeof(float) })]
        float? ScaleAndConcurrencyInstanceMemoryMb { get; set; }
        /// <summary>The maximum number of instances for the function app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The maximum number of instances for the function app.",
        SerializedName = @"maximumInstanceCount",
        PossibleTypes = new [] { typeof(float) })]
        float? ScaleAndConcurrencyMaximumInstanceCount { get; set; }
        /// <summary>
        /// <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The default is <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The default is <code>false</code>.",
        SerializedName = @"scmSiteAlsoStopped",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ScmSiteAlsoStopped { get; set; }
        /// <summary>
        /// Resource ID of the associated App Service plan, formatted as: "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource ID of the associated App Service plan, formatted as: ""/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}"".",
        SerializedName = @"serverFarmId",
        PossibleTypes = new [] { typeof(string) })]
        string ServerFarmId { get; set; }
        /// <summary>Configuration of the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Configuration of the app.",
        SerializedName = @"siteConfig",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteConfig) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteConfig SiteConfig { get; set; }
        /// <summary>The destination slot of the last swap operation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The destination slot of the last swap operation.",
        SerializedName = @"destinationSlotName",
        PossibleTypes = new [] { typeof(string) })]
        string SlotSwapStatusDestinationSlotName { get;  }
        /// <summary>The source slot of the last swap operation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The source slot of the last swap operation.",
        SerializedName = @"sourceSlotName",
        PossibleTypes = new [] { typeof(string) })]
        string SlotSwapStatusSourceSlotName { get;  }
        /// <summary>The time the last successful slot swap completed.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"The time the last successful slot swap completed.",
        SerializedName = @"timestampUtc",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? SlotSwapStatusTimestampUtc { get;  }
        /// <summary>Current state of the app.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Current state of the app.",
        SerializedName = @"state",
        PossibleTypes = new [] { typeof(string) })]
        string State { get;  }
        /// <summary>Checks if Customer provided storage account is required</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Checks if Customer provided storage account is required",
        SerializedName = @"storageAccountRequired",
        PossibleTypes = new [] { typeof(bool) })]
        bool? StorageAccountRequired { get; set; }
        /// <summary>Property to select Azure Storage type. Available options: blobContainer.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Property to select Azure Storage type. Available options: blobContainer.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.FunctionsDeploymentStorageType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.FunctionsDeploymentStorageType? StorageType { get; set; }
        /// <summary>
        /// Property to set the URL for the selected Azure Storage type. Example: For blobContainer, the value could be https://<storageAccountName>.blob.core.windows.net/<containerName>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Property to set the URL for the selected Azure Storage type. Example: For blobContainer, the value could be https://<storageAccountName>.blob.core.windows.net/<containerName>.",
        SerializedName = @"value",
        PossibleTypes = new [] { typeof(string) })]
        string StorageValue { get; set; }
        /// <summary>App suspended till in case memory-time quota is exceeded.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"App suspended till in case memory-time quota is exceeded.",
        SerializedName = @"suspendedTill",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? SuspendedTill { get;  }
        /// <summary>Specifies which deployment slot this app will swap into. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Specifies which deployment slot this app will swap into. Read-only.",
        SerializedName = @"targetSwapSlot",
        PossibleTypes = new [] { typeof(string) })]
        string TargetSwapSlot { get;  }
        /// <summary>Azure Traffic Manager hostnames associated with the app. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Azure Traffic Manager hostnames associated with the app. Read-only.",
        SerializedName = @"trafficManagerHostNames",
        PossibleTypes = new [] { typeof(string) })]
        string[] TrafficManagerHostName { get;  }
        /// <summary>State indicating whether the app has exceeded its quota usage. Read-only.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"State indicating whether the app has exceeded its quota usage. Read-only.",
        SerializedName = @"usageState",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.UsageState) })]
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.UsageState? UsageState { get;  }
        /// <summary>
        /// Azure Resource Manager ID of the Virtual network and subnet to be joined by Regional VNET Integration.
        /// This must be of the form /subscriptions/{subscriptionName}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Azure Resource Manager ID of the Virtual network and subnet to be joined by Regional VNET Integration.
        This must be of the form /subscriptions/{subscriptionName}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}",
        SerializedName = @"virtualNetworkSubnetId",
        PossibleTypes = new [] { typeof(string) })]
        string VirtualNetworkSubnetId { get; set; }
        /// <summary>To enable Backup and Restore operations over virtual network</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To enable Backup and Restore operations over virtual network",
        SerializedName = @"vnetBackupRestoreEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? VnetBackupRestoreEnabled { get; set; }
        /// <summary>To enable accessing content over virtual network</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To enable accessing content over virtual network",
        SerializedName = @"vnetContentShareEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? VnetContentShareEnabled { get; set; }
        /// <summary>To enable pulling image over Virtual Network</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To enable pulling image over Virtual Network",
        SerializedName = @"vnetImagePullEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? VnetImagePullEnabled { get; set; }
        /// <summary>
        /// Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined
        /// Routes applied.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied.",
        SerializedName = @"vnetRouteAllEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? VnetRouteAllEnabled { get; set; }
        /// <summary>Workload profile name for function app to execute on.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Functions.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Workload profile name for function app to execute on.",
        SerializedName = @"workloadProfileName",
        PossibleTypes = new [] { typeof(string) })]
        string WorkloadProfileName { get; set; }

    }
    /// Site resource specific properties
    internal partial interface ISitePropertiesInternal

    {
        /// <summary>
        /// Use this property for StorageAccountConnectionString. Set the name of the app setting that has the storage account connection
        /// string. Do not set a value for this property when using other authentication type.
        /// </summary>
        string AuthenticationStorageAccountConnectionStringName { get; set; }
        /// <summary>
        /// Property to select authentication type to access the selected storage account. Available options: SystemAssignedIdentity,
        /// UserAssignedIdentity, StorageAccountConnectionString.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.AuthenticationType? AuthenticationType { get; set; }
        /// <summary>
        /// Use this property for UserAssignedIdentity. Set the resource ID of the identity. Do not set a value for this property
        /// when using other authentication type.
        /// </summary>
        string AuthenticationUserAssignedIdentityResourceId { get; set; }
        /// <summary>Management information availability state for the app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.SiteAvailabilityState? AvailabilityState { get; set; }
        /// <summary>
        /// <code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity cookies, which route
        /// client requests in the same session to the same instance. Default is <code>true</code>.
        /// </summary>
        bool? ClientAffinityEnabled { get; set; }
        /// <summary>
        /// <code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise, <code>false</code>.
        /// Default is <code>false</code>.
        /// </summary>
        bool? ClientCertEnabled { get; set; }
        /// <summary>client certificate authentication comma-separated exclusion paths</summary>
        string ClientCertExclusionPath { get; set; }
        /// <summary>
        /// This composes with ClientCertEnabled setting.
        /// - ClientCertEnabled: false means ClientCert is ignored.
        /// - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
        /// - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.ClientCertMode? ClientCertMode { get; set; }
        /// <summary>If specified during app creation, the app is cloned from a source app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfo CloningInfo { get; set; }
        /// <summary>
        /// Application setting overrides for cloned app. If specified, these settings override the settings cloned
        /// from source app. Otherwise, application settings from source app are retained.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ICloningInfoAppSettingsOverrides CloningInfoAppSettingsOverride { get; set; }
        /// <summary>
        /// <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
        /// </summary>
        bool? CloningInfoCloneCustomHostName { get; set; }
        /// <summary>
        /// <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
        /// </summary>
        bool? CloningInfoCloneSourceControl { get; set; }
        /// <summary><code>true</code> to configure load balancing for source and destination app.</summary>
        bool? CloningInfoConfigureLoadBalancing { get; set; }
        /// <summary>
        /// Correlation ID of cloning operation. This ID ties multiple cloning operations
        /// together to use the same snapshot.
        /// </summary>
        string CloningInfoCorrelationId { get; set; }
        /// <summary>App Service Environment.</summary>
        string CloningInfoHostingEnvironment { get; set; }
        /// <summary><code>true</code> to overwrite destination app; otherwise, <code>false</code>.</summary>
        bool? CloningInfoOverwrite { get; set; }
        /// <summary>
        /// ARM resource ID of the source app. App resource ID is of the form
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots
        /// and
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for
        /// other slots.
        /// </summary>
        string CloningInfoSourceWebAppId { get; set; }
        /// <summary>Location of source app ex: West US or North Europe</summary>
        string CloningInfoSourceWebAppLocation { get; set; }
        /// <summary>
        /// ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource ID is of the form
        /// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
        /// </summary>
        string CloningInfoTrafficManagerProfileId { get; set; }
        /// <summary>
        /// Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile does not already exist.
        /// </summary>
        string CloningInfoTrafficManagerProfileName { get; set; }
        /// <summary>Size of the function container.</summary>
        int? ContainerSize { get; set; }
        /// <summary>
        /// Unique identifier that verifies the custom domains assigned to the app. Customer will add this id to a txt record for
        /// verification.
        /// </summary>
        string CustomDomainVerificationId { get; set; }
        /// <summary>Maximum allowed daily memory-time quota (applicable on dynamic apps only).</summary>
        int? DailyMemoryTimeQuota { get; set; }
        /// <summary>Dapr configuration of the app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IDaprConfig DaprConfig { get; set; }
        /// <summary>Dapr application identifier</summary>
        string DaprConfigAppId { get; set; }
        /// <summary>Tells Dapr which port your application is listening on</summary>
        int? DaprConfigAppPort { get; set; }
        /// <summary>Enables API logging for the Dapr sidecar</summary>
        bool? DaprConfigEnableApiLogging { get; set; }
        /// <summary>Boolean indicating if the Dapr side car is enabled</summary>
        bool? DaprConfigEnabled { get; set; }
        /// <summary>
        /// Increasing max size of request body http servers parameter in MB to handle uploading of big files. Default is 4 MB.
        /// </summary>
        int? DaprConfigHttpMaxRequestSize { get; set; }
        /// <summary>
        /// Dapr max size of http header read buffer in KB to handle when sending multi-KB headers. Default is 65KB.
        /// </summary>
        int? DaprConfigHttpReadBufferSize { get; set; }
        /// <summary>
        /// Sets the log level for the Dapr sidecar. Allowed values are debug, info, warn, error. Default is info.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.DaprLogLevel? DaprConfigLogLevel { get; set; }
        /// <summary>Default hostname of the app. Read-only.</summary>
        string DefaultHostName { get; set; }
        /// <summary>Storage for deployed package used by the function app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsDeploymentStorage DeploymentStorage { get; set; }
        /// <summary>Property to configure various DNS related settings for a site.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteDnsConfig DnsConfiguration { get; set; }
        /// <summary>
        /// Alternate DNS server to be used by apps. This property replicates the WEBSITE_DNS_ALT_SERVER app setting.
        /// </summary>
        string DnsConfigurationDnsAltServer { get; set; }
        /// <summary>
        /// Indicates that sites using Virtual network custom DNS servers are still sorting the list of DNS servers. Read-Only.
        /// </summary>
        bool? DnsConfigurationDnsLegacySortOrder { get; set; }
        /// <summary>
        /// Custom time for DNS to be cached in seconds. Allowed range: 0-60. Default is 30 seconds. 0 means caching disabled.
        /// </summary>
        int? DnsConfigurationDnsMaxCacheTimeout { get; set; }
        /// <summary>Total number of retries for dns lookup. Allowed range: 1-5. Default is 3.</summary>
        int? DnsConfigurationDnsRetryAttemptCount { get; set; }
        /// <summary>Timeout for a single dns lookup in seconds. Allowed range: 1-30. Default is 3.</summary>
        int? DnsConfigurationDnsRetryAttemptTimeout { get; set; }
        /// <summary>
        /// List of custom DNS servers to be used by an app for lookups. Maximum 5 dns servers can be set.
        /// </summary>
        string[] DnsConfigurationDnsServer { get; set; }
        /// <summary>
        /// <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables the app (takes
        /// the app offline).
        /// </summary>
        bool? Enabled { get; set; }
        /// <summary>
        /// Enabled hostnames for the app.Hostnames need to be assigned (see HostNames) AND enabled. Otherwise,
        /// the app is not served on those hostnames.
        /// </summary>
        string[] EnabledHostName { get; set; }
        /// <summary>Configuration specific of the Azure Function app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionAppConfig FunctionAppConfig { get; set; }
        /// <summary>Function app deployment configuration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsDeployment FunctionAppConfigDeployment { get; set; }
        /// <summary>Function app runtime settings.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsRuntime FunctionAppConfigRuntime { get; set; }
        /// <summary>Function app scale and concurrency settings.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsScaleAndConcurrency FunctionAppConfigScaleAndConcurrency { get; set; }
        /// <summary>Hostnames associated with the app.</summary>
        string[] HostName { get; set; }
        /// <summary>Hostname SSL states are used to manage the SSL bindings for app's hostnames.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostNameSslState[] HostNameSslState { get; set; }
        /// <summary>
        /// <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
        /// If <code>true</code>, the app is only accessible via API management process.
        /// </summary>
        bool? HostNamesDisabled { get; set; }
        /// <summary>App Service Environment to use for the app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IHostingEnvironmentProfile HostingEnvironmentProfile { get; set; }
        /// <summary>Resource ID of the App Service Environment.</summary>
        string HostingEnvironmentProfileId { get; set; }
        /// <summary>Name of the App Service Environment.</summary>
        string HostingEnvironmentProfileName { get; set; }
        /// <summary>Resource type of the App Service Environment.</summary>
        string HostingEnvironmentProfileType { get; set; }
        /// <summary>The maximum number of concurrent HTTP trigger invocations per instance.</summary>
        float? HttpPerInstanceConcurrency { get; set; }
        /// <summary>
        /// HttpsOnly: configures a web site to accept only https requests. Issues redirect for
        /// http requests
        /// </summary>
        bool? HttpsOnly { get; set; }
        /// <summary>Hyper-V sandbox.</summary>
        bool? HyperV { get; set; }
        /// <summary>Specifies an operation id if this site has a pending operation.</summary>
        string InProgressOperationId { get; set; }
        /// <summary>
        /// <code>true</code> if the app is a default container; otherwise, <code>false</code>.
        /// </summary>
        bool? IsDefaultContainer { get; set; }
        /// <summary>Obsolete: Hyper-V sandbox.</summary>
        bool? IsXenon { get; set; }
        /// <summary>Identity to use for Key Vault Reference authentication.</summary>
        string KeyVaultReferenceIdentity { get; set; }
        /// <summary>Last time the app was modified, in UTC. Read-only.</summary>
        global::System.DateTime? LastModifiedTimeUtc { get; set; }
        /// <summary>
        /// Azure Resource Manager ID of the customer's selected Managed Environment on which to host this app. This must be of the
        /// form /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.App/managedEnvironments/{managedEnvironmentName}
        /// </summary>
        string ManagedEnvironmentId { get; set; }
        /// <summary>
        /// Maximum number of workers.
        /// This only applies to Functions container.
        /// </summary>
        int? MaxNumberOfWorker { get; set; }
        /// <summary>
        /// List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from tenants that
        /// site can be hosted with current settings. Read-only.
        /// </summary>
        string OutboundIPAddress { get; set; }
        /// <summary>
        /// List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from all tenants
        /// except dataComponent. Read-only.
        /// </summary>
        string PossibleOutboundIPAddress { get; set; }
        /// <summary>
        /// Property to allow or block all public traffic. Allowed Values: 'Enabled', 'Disabled' or an empty string.
        /// </summary>
        string PublicNetworkAccess { get; set; }
        /// <summary>Site redundancy mode</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RedundancyMode? RedundancyMode { get; set; }
        /// <summary>Name of the repository site.</summary>
        string RepositorySiteName { get; set; }
        /// <summary><code>true</code> if reserved; otherwise, <code>false</code>.</summary>
        bool? Reserved { get; set; }
        /// <summary>Function app resource requirements.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IResourceConfig ResourceConfig { get; set; }
        /// <summary>Required CPU in cores, e.g. 0.5</summary>
        double? ResourceConfigCpu { get; set; }
        /// <summary>Required memory, e.g. "1Gi"</summary>
        string ResourceConfigMemory { get; set; }
        /// <summary>Name of the resource group the app belongs to. Read-only.</summary>
        string ResourceGroup { get; set; }
        /// <summary>
        /// Function app runtime name. Available options: dotnet-isolated, node, java, powershell, python, custom
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.RuntimeName? RuntimeName { get; set; }
        /// <summary>Function app runtime version. Example: 8 (for dotnet-isolated)</summary>
        string RuntimeVersion { get; set; }
        /// <summary>'Always Ready' configuration for the function app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsAlwaysReadyConfig[] ScaleAndConcurrencyAlwaysReady { get; set; }
        /// <summary>
        /// Set the amount of memory allocated to each instance of the function app in MB. CPU and network bandwidth are allocated
        /// proportionally.
        /// </summary>
        float? ScaleAndConcurrencyInstanceMemoryMb { get; set; }
        /// <summary>The maximum number of instances for the function app.</summary>
        float? ScaleAndConcurrencyMaximumInstanceCount { get; set; }
        /// <summary>Scale and concurrency settings for the function app triggers.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsScaleAndConcurrencyTriggers ScaleAndConcurrencyTrigger { get; set; }
        /// <summary>
        /// <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The default is <code>false</code>.
        /// </summary>
        bool? ScmSiteAlsoStopped { get; set; }
        /// <summary>
        /// Resource ID of the associated App Service plan, formatted as: "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
        /// </summary>
        string ServerFarmId { get; set; }
        /// <summary>Configuration of the app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISiteConfig SiteConfig { get; set; }
        /// <summary>Status of the last deployment slot swap operation.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.ISlotSwapStatus SlotSwapStatus { get; set; }
        /// <summary>The destination slot of the last swap operation.</summary>
        string SlotSwapStatusDestinationSlotName { get; set; }
        /// <summary>The source slot of the last swap operation.</summary>
        string SlotSwapStatusSourceSlotName { get; set; }
        /// <summary>The time the last successful slot swap completed.</summary>
        global::System.DateTime? SlotSwapStatusTimestampUtc { get; set; }
        /// <summary>Current state of the app.</summary>
        string State { get; set; }
        /// <summary>Checks if Customer provided storage account is required</summary>
        bool? StorageAccountRequired { get; set; }
        /// <summary>Authentication method to access the storage account for deployment.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsDeploymentStorageAuthentication StorageAuthentication { get; set; }
        /// <summary>Property to select Azure Storage type. Available options: blobContainer.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.FunctionsDeploymentStorageType? StorageType { get; set; }
        /// <summary>
        /// Property to set the URL for the selected Azure Storage type. Example: For blobContainer, the value could be https://<storageAccountName>.blob.core.windows.net/<containerName>.
        /// </summary>
        string StorageValue { get; set; }
        /// <summary>App suspended till in case memory-time quota is exceeded.</summary>
        global::System.DateTime? SuspendedTill { get; set; }
        /// <summary>Specifies which deployment slot this app will swap into. Read-only.</summary>
        string TargetSwapSlot { get; set; }
        /// <summary>Azure Traffic Manager hostnames associated with the app. Read-only.</summary>
        string[] TrafficManagerHostName { get; set; }
        /// <summary>Scale and concurrency settings for the HTTP trigger.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Models.Api20231201.IFunctionsScaleAndConcurrencyTriggersHttp TriggerHttp { get; set; }
        /// <summary>State indicating whether the app has exceeded its quota usage. Read-only.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Functions.Support.UsageState? UsageState { get; set; }
        /// <summary>
        /// Azure Resource Manager ID of the Virtual network and subnet to be joined by Regional VNET Integration.
        /// This must be of the form /subscriptions/{subscriptionName}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}
        /// </summary>
        string VirtualNetworkSubnetId { get; set; }
        /// <summary>To enable Backup and Restore operations over virtual network</summary>
        bool? VnetBackupRestoreEnabled { get; set; }
        /// <summary>To enable accessing content over virtual network</summary>
        bool? VnetContentShareEnabled { get; set; }
        /// <summary>To enable pulling image over Virtual Network</summary>
        bool? VnetImagePullEnabled { get; set; }
        /// <summary>
        /// Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined
        /// Routes applied.
        /// </summary>
        bool? VnetRouteAllEnabled { get; set; }
        /// <summary>Workload profile name for function app to execute on.</summary>
        string WorkloadProfileName { get; set; }

    }
}