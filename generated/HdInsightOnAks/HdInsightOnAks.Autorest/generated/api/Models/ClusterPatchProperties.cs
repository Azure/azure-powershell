// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models
{
    using static Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Extensions;

    /// <summary>Cluster resource patch data.</summary>
    public partial class ClusterPatchProperties :
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchProperties,
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal
    {

        /// <summary>True if stderror is enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? ApplicationLogStdErrorEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).ApplicationLogStdErrorEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).ApplicationLogStdErrorEnabled = value ?? default(bool); }

        /// <summary>True if stdout is enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? ApplicationLogStdOutEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).ApplicationLogStdOutEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).ApplicationLogStdOutEnabled = value ?? default(bool); }

        /// <summary>AAD group Ids authorized for data plane access.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> AuthorizationProfileGroupId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AuthorizationProfileGroupId; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AuthorizationProfileGroupId = value ?? null /* arrayOf */; }

        /// <summary>AAD user Ids authorized for data plane access.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> AuthorizationProfileUserId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AuthorizationProfileUserId; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AuthorizationProfileUserId = value ?? null /* arrayOf */; }

        /// <summary>
        /// User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string AutoscaleProfileAutoscaleType { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AutoscaleProfileAutoscaleType; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AutoscaleProfileAutoscaleType = value ?? null; }

        /// <summary>This indicates whether auto scale is enabled on HDInsight on AKS cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? AutoscaleProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AutoscaleProfileEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AutoscaleProfileEnabled = value ?? default(bool); }

        /// <summary>
        /// This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes
        /// place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING
        /// node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? AutoscaleProfileGracefulDecommissionTimeout { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AutoscaleProfileGracefulDecommissionTimeout; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AutoscaleProfileGracefulDecommissionTimeout = value ?? default(int); }

        /// <summary>hive catalog options.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IHiveCatalogOption> CatalogOptionHive { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).CatalogOptionHive; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).CatalogOptionHive = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="ClusterProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfile _clusterProfile;

        /// <summary>Cluster resource patch properties.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfile ClusterProfile { get => (this._clusterProfile = this._clusterProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.UpdatableClusterProfile()); set => this._clusterProfile = value; }

        /// <summary>The script action profile list.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScriptActionProfile> ClusterProfileScriptActionProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).ScriptActionProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).ScriptActionProfile = value ?? null /* arrayOf */; }

        /// <summary>The service configs profiles.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterServiceConfigsProfile> ClusterProfileServiceConfigsProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).ServiceConfigsProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).ServiceConfigsProfile = value ?? null /* arrayOf */; }

        /// <summary>The flag that if enable debug or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? CoordinatorDebugEnable { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).CoordinatorDebugEnable; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).CoordinatorDebugEnable = value ?? default(bool); }

        /// <summary>The debug port.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? CoordinatorDebugPort { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).CoordinatorDebugPort; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).CoordinatorDebugPort = value ?? default(int); }

        /// <summary>The flag that if suspend debug or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? CoordinatorDebugSuspend { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).CoordinatorDebugSuspend; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).CoordinatorDebugSuspend = value ?? default(bool); }

        /// <summary>
        /// The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node.
        /// Default: true.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? CoordinatorHighAvailabilityEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).CoordinatorHighAvailabilityEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).CoordinatorHighAvailabilityEnabled = value ?? default(bool); }

        /// <summary>The database URL</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string DatabaseHost { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).DatabaseHost; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).DatabaseHost = value ?? null; }

        /// <summary>The database name</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string DatabaseName { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).DatabaseName; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).DatabaseName = value ?? null; }

        /// <summary>Reference for the database password</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string DatabasePasswordSecretRef { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).DatabasePasswordSecretRef; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).DatabasePasswordSecretRef = value ?? null; }

        /// <summary>The name of the database user</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string DatabaseUsername { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).DatabaseUsername; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).DatabaseUsername = value ?? null; }

        /// <summary>
        /// This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between
        /// a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers
        /// it. The default value is 300 seconds.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? LoadBasedConfigCooldownPeriod { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LoadBasedConfigCooldownPeriod; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LoadBasedConfigCooldownPeriod = value ?? default(int); }

        /// <summary>
        /// User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? LoadBasedConfigMaxNode { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LoadBasedConfigMaxNode; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LoadBasedConfigMaxNode = value ?? default(int); }

        /// <summary>
        /// User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? LoadBasedConfigMinNode { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LoadBasedConfigMinNode; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LoadBasedConfigMinNode = value ?? default(int); }

        /// <summary>
        /// User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering
        /// a scaling operation.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? LoadBasedConfigPollInterval { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LoadBasedConfigPollInterval; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LoadBasedConfigPollInterval = value ?? default(int); }

        /// <summary>The scaling rules.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScalingRule> LoadBasedConfigScalingRule { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LoadBasedConfigScalingRule; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LoadBasedConfigScalingRule = value ?? null /* arrayOf */; }

        /// <summary>True if log analytics is enabled for the cluster, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? LogAnalyticProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LogAnalyticProfileEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LogAnalyticProfileEnabled = value ?? default(bool); }

        /// <summary>True if metrics are enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? LogAnalyticProfileMetricsEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LogAnalyticProfileMetricsEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LogAnalyticProfileMetricsEnabled = value ?? default(bool); }

        /// <summary>Internal Acessors for AutoscaleProfileLoadBasedConfig</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ILoadBasedConfig Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.AutoscaleProfileLoadBasedConfig { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AutoscaleProfileLoadBasedConfig; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AutoscaleProfileLoadBasedConfig = value; }

        /// <summary>Internal Acessors for AutoscaleProfileScheduleBasedConfig</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScheduleBasedConfig Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.AutoscaleProfileScheduleBasedConfig { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AutoscaleProfileScheduleBasedConfig; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AutoscaleProfileScheduleBasedConfig = value; }

        /// <summary>Internal Acessors for ClusterProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.ClusterProfile { get => (this._clusterProfile = this._clusterProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.UpdatableClusterProfile()); set { {_clusterProfile = value;} } }

        /// <summary>Internal Acessors for ClusterProfileAuthorizationProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IAuthorizationProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.ClusterProfileAuthorizationProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AuthorizationProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AuthorizationProfile = value; }

        /// <summary>Internal Acessors for ClusterProfileAutoscaleProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IAutoscaleProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.ClusterProfileAutoscaleProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AutoscaleProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).AutoscaleProfile = value; }

        /// <summary>Internal Acessors for ClusterProfileLogAnalyticsProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterLogAnalyticsProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.ClusterProfileLogAnalyticsProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LogAnalyticsProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LogAnalyticsProfile = value; }

        /// <summary>Internal Acessors for ClusterProfilePrometheusProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPrometheusProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.ClusterProfilePrometheusProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).PrometheusProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).PrometheusProfile = value; }

        /// <summary>Internal Acessors for ClusterProfileRangerPluginProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterRangerPluginProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.ClusterProfileRangerPluginProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerPluginProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerPluginProfile = value; }

        /// <summary>Internal Acessors for ClusterProfileRangerProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.ClusterProfileRangerProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerProfile = value; }

        /// <summary>Internal Acessors for ClusterProfileSecretsProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISecretsProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.ClusterProfileSecretsProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).SecretsProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).SecretsProfile = value; }

        /// <summary>Internal Acessors for ClusterProfileSshProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISshProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.ClusterProfileSshProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).SshProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).SshProfile = value; }

        /// <summary>Internal Acessors for ClusterProfileTrinoProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoProfile Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.ClusterProfileTrinoProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).TrinoProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).TrinoProfile = value; }

        /// <summary>Internal Acessors for CoordinatorDebug</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoDebugConfig Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.CoordinatorDebug { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).CoordinatorDebug; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).CoordinatorDebug = value; }

        /// <summary>Internal Acessors for LogAnalyticProfileApplicationLog</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterLogAnalyticsApplicationLogs Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.LogAnalyticProfileApplicationLog { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LogAnalyticProfileApplicationLog; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).LogAnalyticProfileApplicationLog = value; }

        /// <summary>Internal Acessors for RangerAdminDatabase</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerAdminSpecDatabase Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.RangerAdminDatabase { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerAdminDatabase; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerAdminDatabase = value; }

        /// <summary>Internal Acessors for RangerProfileRangerAdmin</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerAdminSpec Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.RangerProfileRangerAdmin { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerProfileRangerAdmin; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerProfileRangerAdmin = value; }

        /// <summary>Internal Acessors for RangerProfileRangerAudit</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerAuditSpec Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.RangerProfileRangerAudit { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerProfileRangerAudit; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerProfileRangerAudit = value; }

        /// <summary>Internal Acessors for RangerProfileRangerUsersync</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerUsersyncSpec Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.RangerProfileRangerUsersync { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerProfileRangerUsersync; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerProfileRangerUsersync = value; }

        /// <summary>Internal Acessors for SshProfilePodPrefix</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.SshProfilePodPrefix { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).SshProfilePodPrefix; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).SshProfilePodPrefix = value; }

        /// <summary>Internal Acessors for TrinoProfileCatalogOption</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ICatalogOptions Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.TrinoProfileCatalogOption { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).TrinoProfileCatalogOption; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).TrinoProfileCatalogOption = value; }

        /// <summary>Internal Acessors for TrinoProfileCoordinator</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoCoordinator Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.TrinoProfileCoordinator { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).TrinoProfileCoordinator; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).TrinoProfileCoordinator = value; }

        /// <summary>Internal Acessors for TrinoProfileUserPluginsSpec</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoUserPlugins Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.TrinoProfileUserPluginsSpec { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).TrinoProfileUserPluginsSpec; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).TrinoProfileUserPluginsSpec = value; }

        /// <summary>Internal Acessors for TrinoProfileUserTelemetrySpec</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoUserTelemetry Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.TrinoProfileUserTelemetrySpec { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).TrinoProfileUserTelemetrySpec; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).TrinoProfileUserTelemetrySpec = value; }

        /// <summary>Internal Acessors for TrinoProfileWorker</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoWorker Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.TrinoProfileWorker { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).TrinoProfileWorker; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).TrinoProfileWorker = value; }

        /// <summary>Internal Acessors for UserTelemetrySpecStorage</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoTelemetryConfig Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.UserTelemetrySpecStorage { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).UserTelemetrySpecStorage; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).UserTelemetrySpecStorage = value; }

        /// <summary>Internal Acessors for WorkerDebug</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoDebugConfig Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPatchPropertiesInternal.WorkerDebug { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).WorkerDebug; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).WorkerDebug = value; }

        /// <summary>Enable Prometheus for cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? PrometheuProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).PrometheuProfileEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).PrometheuProfileEnabled = value ?? default(bool); }

        /// <summary>
        /// List of usernames that should be marked as ranger admins. These usernames should match the user principal name (UPN) of
        /// the respective AAD users.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> RangerAdmin { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerAdmin; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerAdmin = value ?? null /* arrayOf */; }

        /// <summary>
        /// Azure storage location of the blobs. MSI should have read/write access to this Storage account.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string RangerAuditStorageAccount { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerAuditStorageAccount; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerAuditStorageAccount = value ?? null; }

        /// <summary>Enable Ranger for cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? RangerPluginProfileEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerPluginProfileEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerPluginProfileEnabled = value ?? default(bool); }

        /// <summary>Denotes whether usersync service should be enabled</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? RangerUsersyncEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerUsersyncEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerUsersyncEnabled = value ?? default(bool); }

        /// <summary>
        /// List of groups that should be synced. These group names should match the object id of the respective AAD groups.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> RangerUsersyncGroup { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerUsersyncGroup; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerUsersyncGroup = value ?? null /* arrayOf */; }

        /// <summary>
        /// User & groups can be synced automatically or via a static list that's refreshed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string RangerUsersyncMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerUsersyncMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerUsersyncMode = value ?? null; }

        /// <summary>
        /// List of user names that should be synced. These usernames should match the User principal name of the respective AAD users.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> RangerUsersyncUser { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerUsersyncUser; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerUsersyncUser = value ?? null /* arrayOf */; }

        /// <summary>Azure storage location of a mapping file that lists user & group associations.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string RangerUsersyncUserMappingLocation { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerUsersyncUserMappingLocation; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).RangerUsersyncUserMappingLocation = value ?? null; }

        /// <summary>
        /// Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are
        /// default when an specified scaling operation is executed (scale up/scale down)
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? ScheduleBasedConfigDefaultCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).ScheduleBasedConfigDefaultCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).ScheduleBasedConfigDefaultCount = value ?? default(int); }

        /// <summary>
        /// This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules
        /// within the schedule across days and times (start/end).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISchedule> ScheduleBasedConfigSchedule { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).ScheduleBasedConfigSchedule; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).ScheduleBasedConfigSchedule = value ?? null /* arrayOf */; }

        /// <summary>
        /// User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string ScheduleBasedConfigTimeZone { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).ScheduleBasedConfigTimeZone; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).ScheduleBasedConfigTimeZone = value ?? null; }

        /// <summary>
        /// Name of the user Key Vault where all the cluster specific user secrets are stored.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string SecretProfileKeyVaultResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).SecretProfileKeyVaultResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).SecretProfileKeyVaultResourceId = value ?? null; }

        /// <summary>Properties of Key Vault secret.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISecretReference> SecretProfileSecret { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).SecretProfileSecret; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).SecretProfileSecret = value ?? null /* arrayOf */; }

        /// <summary>Number of ssh pods per cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? SshProfileCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).SshProfileCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).SshProfileCount = value ?? default(int); }

        /// <summary>
        /// Prefix of the pod names. Pod number will be appended to the prefix. The ingress URLs for the pods will be available at
        /// <clusterFqdn>/<sshBasePath>/<prefix>-<number>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string SshProfilePodPrefix { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).SshProfilePodPrefix; }

        /// <summary>The virtual machine SKU.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string SshProfileVMSize { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).SshProfileVMSize; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).SshProfileVMSize = value ?? null; }

        /// <summary>
        /// Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string StorageHivecatalogName { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).StorageHivecatalogName; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).StorageHivecatalogName = value ?? null; }

        /// <summary>
        /// Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under
        /// schema trinologs.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string StorageHivecatalogSchema { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).StorageHivecatalogSchema; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).StorageHivecatalogSchema = value ?? null; }

        /// <summary>
        /// Retention period for query log table partitions, this doesn't have any affect on actual data.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? StoragePartitionRetentionInDay { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).StoragePartitionRetentionInDay; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).StoragePartitionRetentionInDay = value ?? default(int); }

        /// <summary>Azure storage location of the blobs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public string StoragePath { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).StoragePath; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).StoragePath = value ?? null; }

        /// <summary>Trino user plugins.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoUserPlugin> UserPluginSpecPlugin { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).UserPluginSpecPlugin; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).UserPluginSpecPlugin = value ?? null /* arrayOf */; }

        /// <summary>The flag that if enable debug or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? WorkerDebugEnable { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).WorkerDebugEnable; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).WorkerDebugEnable = value ?? default(bool); }

        /// <summary>The debug port.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public int? WorkerDebugPort { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).WorkerDebugPort; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).WorkerDebugPort = value ?? default(int); }

        /// <summary>The flag that if suspend debug or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Origin(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PropertyOrigin.Inlined)]
        public bool? WorkerDebugSuspend { get => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).WorkerDebugSuspend; set => ((Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfileInternal)ClusterProfile).WorkerDebugSuspend = value ?? default(bool); }

        /// <summary>Creates an new <see cref="ClusterPatchProperties" /> instance.</summary>
        public ClusterPatchProperties()
        {

        }
    }
    /// Cluster resource patch data.
    public partial interface IClusterPatchProperties :
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.IJsonSerializable
    {
        /// <summary>True if stderror is enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if stderror is enabled, otherwise false.",
        SerializedName = @"stdErrorEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ApplicationLogStdErrorEnabled { get; set; }
        /// <summary>True if stdout is enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if stdout is enabled, otherwise false.",
        SerializedName = @"stdOutEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ApplicationLogStdOutEnabled { get; set; }
        /// <summary>AAD group Ids authorized for data plane access.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"AAD group Ids authorized for data plane access.",
        SerializedName = @"groupIds",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> AuthorizationProfileGroupId { get; set; }
        /// <summary>AAD user Ids authorized for data plane access.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"AAD user Ids authorized for data plane access.",
        SerializedName = @"userIds",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> AuthorizationProfileUserId { get; set; }
        /// <summary>
        /// User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.",
        SerializedName = @"autoscaleType",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("ScheduleBased", "LoadBased")]
        string AutoscaleProfileAutoscaleType { get; set; }
        /// <summary>This indicates whether auto scale is enabled on HDInsight on AKS cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This indicates whether auto scale is enabled on HDInsight on AKS cluster.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AutoscaleProfileEnabled { get; set; }
        /// <summary>
        /// This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes
        /// place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING
        /// node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.",
        SerializedName = @"gracefulDecommissionTimeout",
        PossibleTypes = new [] { typeof(int) })]
        int? AutoscaleProfileGracefulDecommissionTimeout { get; set; }
        /// <summary>hive catalog options.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"hive catalog options.",
        SerializedName = @"hive",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IHiveCatalogOption) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IHiveCatalogOption> CatalogOptionHive { get; set; }
        /// <summary>The script action profile list.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The script action profile list.",
        SerializedName = @"scriptActionProfiles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScriptActionProfile) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScriptActionProfile> ClusterProfileScriptActionProfile { get; set; }
        /// <summary>The service configs profiles.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The service configs profiles.",
        SerializedName = @"serviceConfigsProfiles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterServiceConfigsProfile) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterServiceConfigsProfile> ClusterProfileServiceConfigsProfile { get; set; }
        /// <summary>The flag that if enable debug or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The flag that if enable debug or not.",
        SerializedName = @"enable",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CoordinatorDebugEnable { get; set; }
        /// <summary>The debug port.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The debug port.",
        SerializedName = @"port",
        PossibleTypes = new [] { typeof(int) })]
        int? CoordinatorDebugPort { get; set; }
        /// <summary>The flag that if suspend debug or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The flag that if suspend debug or not.",
        SerializedName = @"suspend",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CoordinatorDebugSuspend { get; set; }
        /// <summary>
        /// The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node.
        /// Default: true.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node. Default: true.",
        SerializedName = @"highAvailabilityEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CoordinatorHighAvailabilityEnabled { get; set; }
        /// <summary>The database URL</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The database URL",
        SerializedName = @"host",
        PossibleTypes = new [] { typeof(string) })]
        string DatabaseHost { get; set; }
        /// <summary>The database name</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The database name",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string DatabaseName { get; set; }
        /// <summary>Reference for the database password</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Reference for the database password",
        SerializedName = @"passwordSecretRef",
        PossibleTypes = new [] { typeof(string) })]
        string DatabasePasswordSecretRef { get; set; }
        /// <summary>The name of the database user</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The name of the database user",
        SerializedName = @"username",
        PossibleTypes = new [] { typeof(string) })]
        string DatabaseUsername { get; set; }
        /// <summary>
        /// This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between
        /// a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers
        /// it. The default value is 300 seconds.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers it. The default value is 300 seconds.",
        SerializedName = @"cooldownPeriod",
        PossibleTypes = new [] { typeof(int) })]
        int? LoadBasedConfigCooldownPeriod { get; set; }
        /// <summary>
        /// User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.",
        SerializedName = @"maxNodes",
        PossibleTypes = new [] { typeof(int) })]
        int? LoadBasedConfigMaxNode { get; set; }
        /// <summary>
        /// User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up and scale down between minimum and maximum number of nodes.",
        SerializedName = @"minNodes",
        PossibleTypes = new [] { typeof(int) })]
        int? LoadBasedConfigMinNode { get; set; }
        /// <summary>
        /// User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering
        /// a scaling operation.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering a scaling operation.",
        SerializedName = @"pollInterval",
        PossibleTypes = new [] { typeof(int) })]
        int? LoadBasedConfigPollInterval { get; set; }
        /// <summary>The scaling rules.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The scaling rules.",
        SerializedName = @"scalingRules",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScalingRule) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScalingRule> LoadBasedConfigScalingRule { get; set; }
        /// <summary>True if log analytics is enabled for the cluster, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if log analytics is enabled for the cluster, otherwise false.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? LogAnalyticProfileEnabled { get; set; }
        /// <summary>True if metrics are enabled, otherwise false.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"True if metrics are enabled, otherwise false.",
        SerializedName = @"metricsEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? LogAnalyticProfileMetricsEnabled { get; set; }
        /// <summary>Enable Prometheus for cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Enable Prometheus for cluster or not.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? PrometheuProfileEnabled { get; set; }
        /// <summary>
        /// List of usernames that should be marked as ranger admins. These usernames should match the user principal name (UPN) of
        /// the respective AAD users.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"List of usernames that should be marked as ranger admins. These usernames should match the user principal name (UPN) of the respective AAD users.",
        SerializedName = @"admins",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> RangerAdmin { get; set; }
        /// <summary>
        /// Azure storage location of the blobs. MSI should have read/write access to this Storage account.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Azure storage location of the blobs. MSI should have read/write access to this Storage account.",
        SerializedName = @"storageAccount",
        PossibleTypes = new [] { typeof(string) })]
        string RangerAuditStorageAccount { get; set; }
        /// <summary>Enable Ranger for cluster or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Enable Ranger for cluster or not.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? RangerPluginProfileEnabled { get; set; }
        /// <summary>Denotes whether usersync service should be enabled</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Denotes whether usersync service should be enabled",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? RangerUsersyncEnabled { get; set; }
        /// <summary>
        /// List of groups that should be synced. These group names should match the object id of the respective AAD groups.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"List of groups that should be synced. These group names should match the object id of the respective AAD groups.",
        SerializedName = @"groups",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> RangerUsersyncGroup { get; set; }
        /// <summary>
        /// User & groups can be synced automatically or via a static list that's refreshed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User & groups can be synced automatically or via a static list that's refreshed.",
        SerializedName = @"mode",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("static", "automatic")]
        string RangerUsersyncMode { get; set; }
        /// <summary>
        /// List of user names that should be synced. These usernames should match the User principal name of the respective AAD users.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"List of user names that should be synced. These usernames should match the User principal name of the respective AAD users.",
        SerializedName = @"users",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> RangerUsersyncUser { get; set; }
        /// <summary>Azure storage location of a mapping file that lists user & group associations.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Azure storage location of a mapping file that lists user & group associations.",
        SerializedName = @"userMappingLocation",
        PossibleTypes = new [] { typeof(string) })]
        string RangerUsersyncUserMappingLocation { get; set; }
        /// <summary>
        /// Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are
        /// default when an specified scaling operation is executed (scale up/scale down)
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are default when an specified scaling operation is executed (scale up/scale down)",
        SerializedName = @"defaultCount",
        PossibleTypes = new [] { typeof(int) })]
        int? ScheduleBasedConfigDefaultCount { get; set; }
        /// <summary>
        /// This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules
        /// within the schedule across days and times (start/end).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules within the schedule across days and times (start/end).",
        SerializedName = @"schedules",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISchedule) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISchedule> ScheduleBasedConfigSchedule { get; set; }
        /// <summary>
        /// User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.",
        SerializedName = @"timeZone",
        PossibleTypes = new [] { typeof(string) })]
        string ScheduleBasedConfigTimeZone { get; set; }
        /// <summary>
        /// Name of the user Key Vault where all the cluster specific user secrets are stored.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Name of the user Key Vault where all the cluster specific user secrets are stored.",
        SerializedName = @"keyVaultResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string SecretProfileKeyVaultResourceId { get; set; }
        /// <summary>Properties of Key Vault secret.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Properties of Key Vault secret.",
        SerializedName = @"secrets",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISecretReference) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISecretReference> SecretProfileSecret { get; set; }
        /// <summary>Number of ssh pods per cluster.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Number of ssh pods per cluster.",
        SerializedName = @"count",
        PossibleTypes = new [] { typeof(int) })]
        int? SshProfileCount { get; set; }
        /// <summary>
        /// Prefix of the pod names. Pod number will be appended to the prefix. The ingress URLs for the pods will be available at
        /// <clusterFqdn>/<sshBasePath>/<prefix>-<number>
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Prefix of the pod names. Pod number will be appended to the prefix. The ingress URLs for the pods will be available at <clusterFqdn>/<sshBasePath>/<prefix>-<number>",
        SerializedName = @"podPrefix",
        PossibleTypes = new [] { typeof(string) })]
        string SshProfilePodPrefix { get;  }
        /// <summary>The virtual machine SKU.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The virtual machine SKU.",
        SerializedName = @"vmSize",
        PossibleTypes = new [] { typeof(string) })]
        string SshProfileVMSize { get; set; }
        /// <summary>
        /// Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.",
        SerializedName = @"hivecatalogName",
        PossibleTypes = new [] { typeof(string) })]
        string StorageHivecatalogName { get; set; }
        /// <summary>
        /// Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under
        /// schema trinologs.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under schema trinologs.",
        SerializedName = @"hivecatalogSchema",
        PossibleTypes = new [] { typeof(string) })]
        string StorageHivecatalogSchema { get; set; }
        /// <summary>
        /// Retention period for query log table partitions, this doesn't have any affect on actual data.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Retention period for query log table partitions, this doesn't have any affect on actual data.",
        SerializedName = @"partitionRetentionInDays",
        PossibleTypes = new [] { typeof(int) })]
        int? StoragePartitionRetentionInDay { get; set; }
        /// <summary>Azure storage location of the blobs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Azure storage location of the blobs.",
        SerializedName = @"path",
        PossibleTypes = new [] { typeof(string) })]
        string StoragePath { get; set; }
        /// <summary>Trino user plugins.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Trino user plugins.",
        SerializedName = @"plugins",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoUserPlugin) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoUserPlugin> UserPluginSpecPlugin { get; set; }
        /// <summary>The flag that if enable debug or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The flag that if enable debug or not.",
        SerializedName = @"enable",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WorkerDebugEnable { get; set; }
        /// <summary>The debug port.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The debug port.",
        SerializedName = @"port",
        PossibleTypes = new [] { typeof(int) })]
        int? WorkerDebugPort { get; set; }
        /// <summary>The flag that if suspend debug or not.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The flag that if suspend debug or not.",
        SerializedName = @"suspend",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WorkerDebugSuspend { get; set; }

    }
    /// Cluster resource patch data.
    internal partial interface IClusterPatchPropertiesInternal

    {
        /// <summary>True if stderror is enabled, otherwise false.</summary>
        bool? ApplicationLogStdErrorEnabled { get; set; }
        /// <summary>True if stdout is enabled, otherwise false.</summary>
        bool? ApplicationLogStdOutEnabled { get; set; }
        /// <summary>AAD group Ids authorized for data plane access.</summary>
        System.Collections.Generic.List<string> AuthorizationProfileGroupId { get; set; }
        /// <summary>AAD user Ids authorized for data plane access.</summary>
        System.Collections.Generic.List<string> AuthorizationProfileUserId { get; set; }
        /// <summary>
        /// User to specify which type of Autoscale to be implemented - Scheduled Based or Load Based.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("ScheduleBased", "LoadBased")]
        string AutoscaleProfileAutoscaleType { get; set; }
        /// <summary>This indicates whether auto scale is enabled on HDInsight on AKS cluster.</summary>
        bool? AutoscaleProfileEnabled { get; set; }
        /// <summary>
        /// This property is for graceful decommission timeout; It has a default setting of 3600 seconds before forced shutdown takes
        /// place. This is the maximal time to wait for running containers and applications to complete before transition a DECOMMISSIONING
        /// node into DECOMMISSIONED. The default value is 3600 seconds. Negative value (like -1) is handled as infinite timeout.
        /// </summary>
        int? AutoscaleProfileGracefulDecommissionTimeout { get; set; }
        /// <summary>Profiles of load based Autoscale.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ILoadBasedConfig AutoscaleProfileLoadBasedConfig { get; set; }
        /// <summary>Profiles of schedule based Autoscale.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScheduleBasedConfig AutoscaleProfileScheduleBasedConfig { get; set; }
        /// <summary>hive catalog options.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IHiveCatalogOption> CatalogOptionHive { get; set; }
        /// <summary>Cluster resource patch properties.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IUpdatableClusterProfile ClusterProfile { get; set; }
        /// <summary>
        /// Authorization profile with details of AAD user Ids and group Ids authorized for data plane access.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IAuthorizationProfile ClusterProfileAuthorizationProfile { get; set; }
        /// <summary>
        /// This is the Autoscale profile for the cluster. This will allow customer to create cluster enabled with Autoscale.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IAutoscaleProfile ClusterProfileAutoscaleProfile { get; set; }
        /// <summary>Cluster log analytics profile to enable or disable OMS agent for cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterLogAnalyticsProfile ClusterProfileLogAnalyticsProfile { get; set; }
        /// <summary>Cluster Prometheus profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterPrometheusProfile ClusterProfilePrometheusProfile { get; set; }
        /// <summary>Cluster Ranger plugin profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterRangerPluginProfile ClusterProfileRangerPluginProfile { get; set; }
        /// <summary>The ranger cluster profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerProfile ClusterProfileRangerProfile { get; set; }
        /// <summary>The script action profile list.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScriptActionProfile> ClusterProfileScriptActionProfile { get; set; }
        /// <summary>The cluster secret profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISecretsProfile ClusterProfileSecretsProfile { get; set; }
        /// <summary>The service configs profiles.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterServiceConfigsProfile> ClusterProfileServiceConfigsProfile { get; set; }
        /// <summary>Ssh profile for the cluster.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISshProfile ClusterProfileSshProfile { get; set; }
        /// <summary>Trino Cluster profile.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoProfile ClusterProfileTrinoProfile { get; set; }
        /// <summary>Trino debug configuration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoDebugConfig CoordinatorDebug { get; set; }
        /// <summary>The flag that if enable debug or not.</summary>
        bool? CoordinatorDebugEnable { get; set; }
        /// <summary>The debug port.</summary>
        int? CoordinatorDebugPort { get; set; }
        /// <summary>The flag that if suspend debug or not.</summary>
        bool? CoordinatorDebugSuspend { get; set; }
        /// <summary>
        /// The flag that if enable coordinator HA, uses multiple coordinator replicas with auto failover, one per each head node.
        /// Default: true.
        /// </summary>
        bool? CoordinatorHighAvailabilityEnabled { get; set; }
        /// <summary>The database URL</summary>
        string DatabaseHost { get; set; }
        /// <summary>The database name</summary>
        string DatabaseName { get; set; }
        /// <summary>Reference for the database password</summary>
        string DatabasePasswordSecretRef { get; set; }
        /// <summary>The name of the database user</summary>
        string DatabaseUsername { get; set; }
        /// <summary>
        /// This is a cool down period, this is a time period in seconds, which determines the amount of time that must elapse between
        /// a scaling activity started by a rule and the start of the next scaling activity, regardless of the rule that triggers
        /// it. The default value is 300 seconds.
        /// </summary>
        int? LoadBasedConfigCooldownPeriod { get; set; }
        /// <summary>
        /// User needs to set the maximum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        int? LoadBasedConfigMaxNode { get; set; }
        /// <summary>
        /// User needs to set the minimum number of nodes for load based scaling, the load based scaling will use this to scale up
        /// and scale down between minimum and maximum number of nodes.
        /// </summary>
        int? LoadBasedConfigMinNode { get; set; }
        /// <summary>
        /// User can specify the poll interval, this is the time period (in seconds) after which scaling metrics are polled for triggering
        /// a scaling operation.
        /// </summary>
        int? LoadBasedConfigPollInterval { get; set; }
        /// <summary>The scaling rules.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IScalingRule> LoadBasedConfigScalingRule { get; set; }
        /// <summary>Collection of logs to be enabled or disabled for log analytics.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IClusterLogAnalyticsApplicationLogs LogAnalyticProfileApplicationLog { get; set; }
        /// <summary>True if log analytics is enabled for the cluster, otherwise false.</summary>
        bool? LogAnalyticProfileEnabled { get; set; }
        /// <summary>True if metrics are enabled, otherwise false.</summary>
        bool? LogAnalyticProfileMetricsEnabled { get; set; }
        /// <summary>Enable Prometheus for cluster or not.</summary>
        bool? PrometheuProfileEnabled { get; set; }
        /// <summary>
        /// List of usernames that should be marked as ranger admins. These usernames should match the user principal name (UPN) of
        /// the respective AAD users.
        /// </summary>
        System.Collections.Generic.List<string> RangerAdmin { get; set; }

        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerAdminSpecDatabase RangerAdminDatabase { get; set; }
        /// <summary>
        /// Azure storage location of the blobs. MSI should have read/write access to this Storage account.
        /// </summary>
        string RangerAuditStorageAccount { get; set; }
        /// <summary>Enable Ranger for cluster or not.</summary>
        bool? RangerPluginProfileEnabled { get; set; }
        /// <summary>Specification for the Ranger Admin service.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerAdminSpec RangerProfileRangerAdmin { get; set; }
        /// <summary>Properties required to describe audit log storage.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerAuditSpec RangerProfileRangerAudit { get; set; }
        /// <summary>Specification for the Ranger Usersync service</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.IRangerUsersyncSpec RangerProfileRangerUsersync { get; set; }
        /// <summary>Denotes whether usersync service should be enabled</summary>
        bool? RangerUsersyncEnabled { get; set; }
        /// <summary>
        /// List of groups that should be synced. These group names should match the object id of the respective AAD groups.
        /// </summary>
        System.Collections.Generic.List<string> RangerUsersyncGroup { get; set; }
        /// <summary>
        /// User & groups can be synced automatically or via a static list that's refreshed.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.PSArgumentCompleterAttribute("static", "automatic")]
        string RangerUsersyncMode { get; set; }
        /// <summary>
        /// List of user names that should be synced. These usernames should match the User principal name of the respective AAD users.
        /// </summary>
        System.Collections.Generic.List<string> RangerUsersyncUser { get; set; }
        /// <summary>Azure storage location of a mapping file that lists user & group associations.</summary>
        string RangerUsersyncUserMappingLocation { get; set; }
        /// <summary>
        /// Setting default node count of current schedule configuration. Default node count specifies the number of nodes which are
        /// default when an specified scaling operation is executed (scale up/scale down)
        /// </summary>
        int? ScheduleBasedConfigDefaultCount { get; set; }
        /// <summary>
        /// This specifies the schedules where scheduled based Autoscale to be enabled, the user has a choice to set multiple rules
        /// within the schedule across days and times (start/end).
        /// </summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISchedule> ScheduleBasedConfigSchedule { get; set; }
        /// <summary>
        /// User has to specify the timezone on which the schedule has to be set for schedule based autoscale configuration.
        /// </summary>
        string ScheduleBasedConfigTimeZone { get; set; }
        /// <summary>
        /// Name of the user Key Vault where all the cluster specific user secrets are stored.
        /// </summary>
        string SecretProfileKeyVaultResourceId { get; set; }
        /// <summary>Properties of Key Vault secret.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ISecretReference> SecretProfileSecret { get; set; }
        /// <summary>Number of ssh pods per cluster.</summary>
        int? SshProfileCount { get; set; }
        /// <summary>
        /// Prefix of the pod names. Pod number will be appended to the prefix. The ingress URLs for the pods will be available at
        /// <clusterFqdn>/<sshBasePath>/<prefix>-<number>
        /// </summary>
        string SshProfilePodPrefix { get; set; }
        /// <summary>The virtual machine SKU.</summary>
        string SshProfileVMSize { get; set; }
        /// <summary>
        /// Hive Catalog name used to mount external tables on the logs written by trino, if not specified there tables are not created.
        /// </summary>
        string StorageHivecatalogName { get; set; }
        /// <summary>
        /// Schema of the above catalog to use, to mount query logs as external tables, if not specified tables will be mounted under
        /// schema trinologs.
        /// </summary>
        string StorageHivecatalogSchema { get; set; }
        /// <summary>
        /// Retention period for query log table partitions, this doesn't have any affect on actual data.
        /// </summary>
        int? StoragePartitionRetentionInDay { get; set; }
        /// <summary>Azure storage location of the blobs.</summary>
        string StoragePath { get; set; }
        /// <summary>Trino cluster catalog options.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ICatalogOptions TrinoProfileCatalogOption { get; set; }
        /// <summary>Trino Coordinator.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoCoordinator TrinoProfileCoordinator { get; set; }
        /// <summary>Trino user plugins spec</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoUserPlugins TrinoProfileUserPluginsSpec { get; set; }
        /// <summary>User telemetry</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoUserTelemetry TrinoProfileUserTelemetrySpec { get; set; }
        /// <summary>Trino worker.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoWorker TrinoProfileWorker { get; set; }
        /// <summary>Trino user plugins.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoUserPlugin> UserPluginSpecPlugin { get; set; }
        /// <summary>Trino user telemetry definition.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoTelemetryConfig UserTelemetrySpecStorage { get; set; }
        /// <summary>Trino debug configuration.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.HdInsightOnAks.Models.ITrinoDebugConfig WorkerDebug { get; set; }
        /// <summary>The flag that if enable debug or not.</summary>
        bool? WorkerDebugEnable { get; set; }
        /// <summary>The debug port.</summary>
        int? WorkerDebugPort { get; set; }
        /// <summary>The flag that if suspend debug or not.</summary>
        bool? WorkerDebugSuspend { get; set; }

    }
}