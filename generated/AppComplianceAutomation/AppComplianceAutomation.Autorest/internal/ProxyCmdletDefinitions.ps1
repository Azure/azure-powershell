
# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Code generated by Microsoft (R) AutoRest Code Generator.Changes may cause incorrect behavior and will be lost if the code
# is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Get the evidence metadata
.Description
Get the evidence metadata
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IEvidenceResource
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/get-azappcomplianceautomationevidence
#>
function Get-AzAppComplianceAutomationEvidence {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IEvidenceResource])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${ReportName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Alias('EvidenceName')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # The evidence name.
    ${Name},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # The filter to apply on the operation.
    ${Filter},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # The offerGuid which mapping to the reports.
    ${OfferGuid},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # OData order by query option.
    ${Orderby},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # The tenant id of the report creator.
    ${ReportCreatorTenantId},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # OData Select statement.
    # Limits the properties on each entry to just those requested, e.g.
    # ?$select=reportName,id.
    ${Select},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # Skip over when retrieving results.
    ${SkipToken},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.Int32]
    # Number of elements to return when retrieving results.
    ${Top},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Get = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationEvidence_Get';
            List = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationEvidence_List';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
List the operations for the provider
.Description
List the operations for the provider
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IOperation
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/get-azappcomplianceautomationoperation
#>
function Get-AzAppComplianceAutomationOperation {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IOperation])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            List = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationOperation_List';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Get the count of reports.
.Description
Get the count of reports.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IGetCollectionCountRequest
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IGetCollectionCountResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IGetCollectionCountRequest>: Get collection count's request object.
  [Type <String>]: The resource type.
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/get-azappcomplianceautomationprovideractioncollectioncount
#>
function Get-AzAppComplianceAutomationProviderActionCollectionCount {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IGetCollectionCountResponse])]
[CmdletBinding(DefaultParameterSetName='GetExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Get', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IGetCollectionCountRequest]
    # Get collection count's request object.
    ${Body},

    [Parameter(ParameterSetName='GetExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # The resource type.
    ${Type},

    [Parameter(ParameterSetName='GetViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Get operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='GetViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Json string supplied to the Get operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Get = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationProviderActionCollectionCount_Get';
            GetExpanded = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationProviderActionCollectionCount_GetExpanded';
            GetViaJsonFilePath = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationProviderActionCollectionCount_GetViaJsonFilePath';
            GetViaJsonString = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationProviderActionCollectionCount_GetViaJsonString';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Get the resource overview status.
.Description
Get the resource overview status.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IGetOverviewStatusRequest
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IGetOverviewStatusResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IGetOverviewStatusRequest>: Get overview status request object.
  [Type <String>]: The resource type.
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/get-azappcomplianceautomationprovideractionoverviewstatus
#>
function Get-AzAppComplianceAutomationProviderActionOverviewStatus {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IGetOverviewStatusResponse])]
[CmdletBinding(DefaultParameterSetName='GetExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Get', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IGetOverviewStatusRequest]
    # Get overview status request object.
    ${Body},

    [Parameter(ParameterSetName='GetExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # The resource type.
    ${Type},

    [Parameter(ParameterSetName='GetViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Get operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='GetViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Json string supplied to the Get operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Get = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationProviderActionOverviewStatus_Get';
            GetExpanded = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationProviderActionOverviewStatus_GetExpanded';
            GetViaJsonFilePath = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationProviderActionOverviewStatus_GetViaJsonFilePath';
            GetViaJsonString = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationProviderActionOverviewStatus_GetViaJsonString';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
List the storage accounts which are in use by related reports
.Description
List the storage accounts which are in use by related reports
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IListInUseStorageAccountsRequest
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IListInUseStorageAccountsResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IListInUseStorageAccountsRequest>: Parameters for listing in use storage accounts operation. If subscription list is null, it will check the user's all subscriptions.
  [SubscriptionId <List<String>>]: List of subscription ids to be query. If the list is null or empty, the API will query all the subscriptions of the user.
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/get-azappcomplianceautomationprovideraction
#>
function Get-AzAppComplianceAutomationProviderAction {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IListInUseStorageAccountsResponse])]
[CmdletBinding(DefaultParameterSetName='ListExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='List', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IListInUseStorageAccountsRequest]
    # Parameters for listing in use storage accounts operation.
    # If subscription list is null, it will check the user's all subscriptions.
    ${Body},

    [Parameter(ParameterSetName='ListExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # List of subscription ids to be query.
    # If the list is null or empty, the API will query all the subscriptions of the user.
    ${SubscriptionId},

    [Parameter(ParameterSetName='ListViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Path of Json file supplied to the List operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='ListViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Json string supplied to the List operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            List = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationProviderAction_List';
            ListExpanded = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationProviderAction_ListExpanded';
            ListViaJsonFilePath = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationProviderAction_ListViaJsonFilePath';
            ListViaJsonString = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationProviderAction_ListViaJsonString';
        }
        if (('ListExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $testPlayback = $false
            $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Fix the AppComplianceAutomation report error.
e.g: App Compliance Automation Tool service unregistered, automation removed.
.Description
Fix the AppComplianceAutomation report error.
e.g: App Compliance Automation Tool service unregistered, automation removed.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IScopingQuestions
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/get-azappcomplianceautomationreportscopingquestion
#>
function Get-AzAppComplianceAutomationReportScopingQuestion {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IScopingQuestions])]
[CmdletBinding(DefaultParameterSetName='Get', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${ReportName},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Get = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationReportScopingQuestion_Get';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Get the AppComplianceAutomation report and its properties.
.Description
Get the AppComplianceAutomation report and its properties.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IReportResource
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/get-azappcomplianceautomationreport
#>
function Get-AzAppComplianceAutomationReport {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IReportResource])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(ParameterSetName='Get', Mandatory)]
    [Alias('ReportName')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${Name},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # The filter to apply on the operation.
    ${Filter},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # The offerGuid which mapping to the reports.
    ${OfferGuid},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # OData order by query option.
    ${Orderby},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # The tenant id of the report creator.
    ${ReportCreatorTenantId},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # OData Select statement.
    # Limits the properties on each entry to just those requested, e.g.
    # ?$select=reportName,id.
    ${Select},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # Skip over when retrieving results.
    ${SkipToken},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.Int32]
    # Number of elements to return when retrieving results.
    ${Top},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Header')]
    [System.String]
    # .
    ${XmsAadUserToken},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Get = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationReport_Get';
            List = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationReport_List';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Get the AppComplianceAutomation scoping configuration of the specific report.
.Description
Get the AppComplianceAutomation scoping configuration of the specific report.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IScopingConfigurationResource
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/get-azappcomplianceautomationscopingconfiguration
#>
function Get-AzAppComplianceAutomationScopingConfiguration {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IScopingConfigurationResource])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${ReportName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Alias('ScopingConfigurationName')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # The scoping configuration of the specific report.
    ${Name},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Get = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationScopingConfiguration_Get';
            List = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationScopingConfiguration_List';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Get the AppComplianceAutomation snapshot and its properties.
.Description
Get the AppComplianceAutomation snapshot and its properties.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.ISnapshotResource
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/get-azappcomplianceautomationsnapshot
#>
function Get-AzAppComplianceAutomationSnapshot {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.ISnapshotResource])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${ReportName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Alias('SnapshotName')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Snapshot Name.
    ${Name},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # The filter to apply on the operation.
    ${Filter},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # The offerGuid which mapping to the reports.
    ${OfferGuid},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # OData order by query option.
    ${Orderby},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # The tenant id of the report creator.
    ${ReportCreatorTenantId},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # OData Select statement.
    # Limits the properties on each entry to just those requested, e.g.
    # ?$select=reportName,id.
    ${Select},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # Skip over when retrieving results.
    ${SkipToken},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.Int32]
    # Number of elements to return when retrieving results.
    ${Top},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Header')]
    [System.String]
    # .
    ${XmsAadUserToken},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Get = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationSnapshot_Get';
            List = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationSnapshot_List';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Get the AppComplianceAutomation webhook and its properties.
.Description
Get the AppComplianceAutomation webhook and its properties.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IWebhookResource
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/get-azappcomplianceautomationwebhook
#>
function Get-AzAppComplianceAutomationWebhook {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IWebhookResource])]
[CmdletBinding(DefaultParameterSetName='List', PositionalBinding=$false)]
param(
    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${ReportName},

    [Parameter(ParameterSetName='Get', Mandatory)]
    [Alias('WebhookName')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Webhook Name.
    ${Name},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # The filter to apply on the operation.
    ${Filter},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # The offerGuid which mapping to the reports.
    ${OfferGuid},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # OData order by query option.
    ${Orderby},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # The tenant id of the report creator.
    ${ReportCreatorTenantId},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # OData Select statement.
    # Limits the properties on each entry to just those requested, e.g.
    # ?$select=reportName,id.
    ${Select},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # Skip over when retrieving results.
    ${SkipToken},

    [Parameter(ParameterSetName='List')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.Int32]
    # Number of elements to return when retrieving results.
    ${Top},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Header')]
    [System.String]
    # .
    ${XmsAadUserToken},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Get = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationWebhook_Get';
            List = 'Az.AppComplianceAutomation.private\Get-AzAppComplianceAutomationWebhook_List';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Download evidence file.
.Description
Download evidence file.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity
.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IEvidenceFileDownloadRequest
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IEvidenceFileDownloadResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IEvidenceFileDownloadRequest>: Evidence file's download request.
  [OfferGuid <String>]: The offerGuid which mapping to the reports.
  [ReportCreatorTenantId <String>]: Tenant id.

INPUTOBJECT <IAppComplianceAutomationIdentity>: Identity Parameter
  [EvidenceName <String>]: The evidence name.
  [Id <String>]: Resource identity path
  [ReportName <String>]: Report Name.
  [ScopingConfigurationName <String>]: The scoping configuration of the specific report.
  [SnapshotName <String>]: Snapshot Name.
  [WebhookName <String>]: Webhook Name.

REPORTINPUTOBJECT <IAppComplianceAutomationIdentity>: Identity Parameter
  [EvidenceName <String>]: The evidence name.
  [Id <String>]: Resource identity path
  [ReportName <String>]: Report Name.
  [ScopingConfigurationName <String>]: The scoping configuration of the specific report.
  [SnapshotName <String>]: Snapshot Name.
  [WebhookName <String>]: Webhook Name.
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/invoke-azappcomplianceautomationdownloadevidence
#>
function Invoke-AzAppComplianceAutomationDownloadEvidence {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IEvidenceFileDownloadResponse])]
[CmdletBinding(DefaultParameterSetName='DownloadExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Download', Mandatory)]
    [Parameter(ParameterSetName='DownloadExpanded', Mandatory)]
    [Parameter(ParameterSetName='DownloadViaIdentityReport', Mandatory)]
    [Parameter(ParameterSetName='DownloadViaIdentityReportExpanded', Mandatory)]
    [Parameter(ParameterSetName='DownloadViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='DownloadViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # The evidence name.
    ${EvidenceName},

    [Parameter(ParameterSetName='Download', Mandatory)]
    [Parameter(ParameterSetName='DownloadExpanded', Mandatory)]
    [Parameter(ParameterSetName='DownloadViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='DownloadViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${ReportName},

    [Parameter(ParameterSetName='DownloadViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='DownloadViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='DownloadViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='DownloadViaIdentityReportExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity]
    # Identity Parameter
    ${ReportInputObject},

    [Parameter(ParameterSetName='Download', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='DownloadViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='DownloadViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IEvidenceFileDownloadRequest]
    # Evidence file's download request.
    ${Body},

    [Parameter(ParameterSetName='DownloadExpanded')]
    [Parameter(ParameterSetName='DownloadViaIdentityExpanded')]
    [Parameter(ParameterSetName='DownloadViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # The offerGuid which mapping to the reports.
    ${OfferGuid},

    [Parameter(ParameterSetName='DownloadExpanded')]
    [Parameter(ParameterSetName='DownloadViaIdentityExpanded')]
    [Parameter(ParameterSetName='DownloadViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Tenant id.
    ${ReportCreatorTenantId},

    [Parameter(ParameterSetName='DownloadViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Download operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='DownloadViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Json string supplied to the Download operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Download = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationDownloadEvidence_Download';
            DownloadExpanded = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationDownloadEvidence_DownloadExpanded';
            DownloadViaIdentity = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationDownloadEvidence_DownloadViaIdentity';
            DownloadViaIdentityExpanded = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationDownloadEvidence_DownloadViaIdentityExpanded';
            DownloadViaIdentityReport = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationDownloadEvidence_DownloadViaIdentityReport';
            DownloadViaIdentityReportExpanded = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationDownloadEvidence_DownloadViaIdentityReportExpanded';
            DownloadViaJsonFilePath = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationDownloadEvidence_DownloadViaJsonFilePath';
            DownloadViaJsonString = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationDownloadEvidence_DownloadViaJsonString';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Download compliance needs from snapshot, like: Compliance Report, Resource List.
.Description
Download compliance needs from snapshot, like: Compliance Report, Resource List.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity
.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.ISnapshotDownloadRequest
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IDownloadResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ISnapshotDownloadRequest>: Snapshot's download request.
  DownloadType <String>: Indicates the download type.
  [OfferGuid <String>]: The offerGuid which mapping to the reports.
  [ReportCreatorTenantId <String>]: Tenant id.

INPUTOBJECT <IAppComplianceAutomationIdentity>: Identity Parameter
  [EvidenceName <String>]: The evidence name.
  [Id <String>]: Resource identity path
  [ReportName <String>]: Report Name.
  [ScopingConfigurationName <String>]: The scoping configuration of the specific report.
  [SnapshotName <String>]: Snapshot Name.
  [WebhookName <String>]: Webhook Name.

REPORTINPUTOBJECT <IAppComplianceAutomationIdentity>: Identity Parameter
  [EvidenceName <String>]: The evidence name.
  [Id <String>]: Resource identity path
  [ReportName <String>]: Report Name.
  [ScopingConfigurationName <String>]: The scoping configuration of the specific report.
  [SnapshotName <String>]: Snapshot Name.
  [WebhookName <String>]: Webhook Name.
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/invoke-azappcomplianceautomationdownloadsnapshot
#>
function Invoke-AzAppComplianceAutomationDownloadSnapshot {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IDownloadResponse])]
[CmdletBinding(DefaultParameterSetName='DownloadExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Download', Mandatory)]
    [Parameter(ParameterSetName='DownloadExpanded', Mandatory)]
    [Parameter(ParameterSetName='DownloadViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='DownloadViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${ReportName},

    [Parameter(ParameterSetName='Download', Mandatory)]
    [Parameter(ParameterSetName='DownloadExpanded', Mandatory)]
    [Parameter(ParameterSetName='DownloadViaIdentityReport', Mandatory)]
    [Parameter(ParameterSetName='DownloadViaIdentityReportExpanded', Mandatory)]
    [Parameter(ParameterSetName='DownloadViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='DownloadViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Snapshot Name.
    ${SnapshotName},

    [Parameter(ParameterSetName='DownloadViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='DownloadViaIdentityExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter(ParameterSetName='DownloadViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='DownloadViaIdentityReportExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity]
    # Identity Parameter
    ${ReportInputObject},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Header')]
    [System.String]
    # .
    ${XmsAadUserToken},

    [Parameter(ParameterSetName='Download', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='DownloadViaIdentity', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='DownloadViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.ISnapshotDownloadRequest]
    # Snapshot's download request.
    ${Body},

    [Parameter(ParameterSetName='DownloadExpanded', Mandatory)]
    [Parameter(ParameterSetName='DownloadViaIdentityExpanded', Mandatory)]
    [Parameter(ParameterSetName='DownloadViaIdentityReportExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.PSArgumentCompleterAttribute("ComplianceReport", "CompliancePdfReport", "ComplianceDetailedPdfReport", "ResourceList")]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Indicates the download type.
    ${DownloadType},

    [Parameter(ParameterSetName='DownloadExpanded')]
    [Parameter(ParameterSetName='DownloadViaIdentityExpanded')]
    [Parameter(ParameterSetName='DownloadViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # The offerGuid which mapping to the reports.
    ${OfferGuid},

    [Parameter(ParameterSetName='DownloadExpanded')]
    [Parameter(ParameterSetName='DownloadViaIdentityExpanded')]
    [Parameter(ParameterSetName='DownloadViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Tenant id.
    ${ReportCreatorTenantId},

    [Parameter(ParameterSetName='DownloadViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Download operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='DownloadViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Json string supplied to the Download operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Download = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationDownloadSnapshot_Download';
            DownloadExpanded = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationDownloadSnapshot_DownloadExpanded';
            DownloadViaIdentity = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationDownloadSnapshot_DownloadViaIdentity';
            DownloadViaIdentityExpanded = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationDownloadSnapshot_DownloadViaIdentityExpanded';
            DownloadViaIdentityReport = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationDownloadSnapshot_DownloadViaIdentityReport';
            DownloadViaIdentityReportExpanded = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationDownloadSnapshot_DownloadViaIdentityReportExpanded';
            DownloadViaJsonFilePath = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationDownloadSnapshot_DownloadViaJsonFilePath';
            DownloadViaJsonString = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationDownloadSnapshot_DownloadViaJsonString';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Fix the AppComplianceAutomation report error.
e.g: App Compliance Automation Tool service unregistered, automation removed.
.Description
Fix the AppComplianceAutomation report error.
e.g: App Compliance Automation Tool service unregistered, automation removed.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IReportFixResult
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

INPUTOBJECT <IAppComplianceAutomationIdentity>: Identity Parameter
  [EvidenceName <String>]: The evidence name.
  [Id <String>]: Resource identity path
  [ReportName <String>]: Report Name.
  [ScopingConfigurationName <String>]: The scoping configuration of the specific report.
  [SnapshotName <String>]: Snapshot Name.
  [WebhookName <String>]: Webhook Name.
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/invoke-azappcomplianceautomationfixreport
#>
function Invoke-AzAppComplianceAutomationFixReport {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IReportFixResult])]
[CmdletBinding(DefaultParameterSetName='Fix', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(ParameterSetName='Fix', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${ReportName},

    [Parameter(ParameterSetName='FixViaIdentity', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity]
    # Identity Parameter
    ${InputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Fix = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationFixReport_Fix';
            FixViaIdentity = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationFixReport_FixViaIdentity';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Onboard given subscriptions to Microsoft.AppComplianceAutomation provider.
.Description
Onboard given subscriptions to Microsoft.AppComplianceAutomation provider.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IOnboardRequest
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IOnboardResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <IOnboardRequest>: Parameters for onboard operation
  SubscriptionId <List<String>>: List of subscription ids to be onboarded
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/invoke-azappcomplianceautomationonboardprovideraction
#>
function Invoke-AzAppComplianceAutomationOnboardProviderAction {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IOnboardResponse])]
[CmdletBinding(DefaultParameterSetName='OnboardExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Header')]
    [System.String]
    # .
    ${XmsAadUserToken},

    [Parameter(ParameterSetName='Onboard', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IOnboardRequest]
    # Parameters for onboard operation
    ${Body},

    [Parameter(ParameterSetName='OnboardExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String[]]
    # List of subscription ids to be onboarded
    ${SubscriptionId},

    [Parameter(ParameterSetName='OnboardViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Onboard operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='OnboardViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Json string supplied to the Onboard operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Onboard = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationOnboardProviderAction_Onboard';
            OnboardExpanded = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationOnboardProviderAction_OnboardExpanded';
            OnboardViaJsonFilePath = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationOnboardProviderAction_OnboardViaJsonFilePath';
            OnboardViaJsonString = 'Az.AppComplianceAutomation.private\Invoke-AzAppComplianceAutomationOnboardProviderAction_OnboardViaJsonString';
        }
        if (('OnboardExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            $testPlayback = $false
            $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Create an evidence a specified report
.Description
Create an evidence a specified report
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity
.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IEvidenceResource
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IEvidenceResource
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

PROPERTY <IEvidenceResource>: A class represent an AppComplianceAutomation evidence resource.
  FilePath <String>: The path of the file in storage.
  [ControlId <String>]: Control id.
  [EvidenceType <String>]: Evidence type.
  [ExtraData <String>]: Extra data considered as evidence.
  [ResponsibilityId <String>]: Responsibility id.

REPORTINPUTOBJECT <IAppComplianceAutomationIdentity>: Identity Parameter
  [EvidenceName <String>]: The evidence name.
  [Id <String>]: Resource identity path
  [ReportName <String>]: Report Name.
  [ScopingConfigurationName <String>]: The scoping configuration of the specific report.
  [SnapshotName <String>]: Snapshot Name.
  [WebhookName <String>]: Webhook Name.
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/new-azappcomplianceautomationevidence
#>
function New-AzAppComplianceAutomationEvidence {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IEvidenceResource])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('EvidenceName')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # The evidence name.
    ${Name},

    [Parameter(ParameterSetName='Create', Mandatory)]
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${ReportName},

    [Parameter(ParameterSetName='CreateViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='CreateViaIdentityReportExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity]
    # Identity Parameter
    ${ReportInputObject},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # The offerGuid which mapping to the reports.
    ${OfferGuid},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # The tenant id of the report creator.
    ${ReportCreatorTenantId},

    [Parameter(ParameterSetName='Create', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='CreateViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IEvidenceResource]
    # A class represent an AppComplianceAutomation evidence resource.
    ${Property},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaIdentityReportExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # The path of the file in storage.
    ${FilePath},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Control id.
    ${ControlId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.PSArgumentCompleterAttribute("File", "AutoCollectedEvidence", "Data")]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Evidence type.
    ${EvidenceType},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Extra data considered as evidence.
    ${ExtraData},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Responsibility id.
    ${ResponsibilityId},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Create = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationEvidence_Create';
            CreateExpanded = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationEvidence_CreateExpanded';
            CreateViaIdentityReport = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationEvidence_CreateViaIdentityReport';
            CreateViaIdentityReportExpanded = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationEvidence_CreateViaIdentityReportExpanded';
            CreateViaJsonFilePath = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationEvidence_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationEvidence_CreateViaJsonString';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Create a new AppComplianceAutomation report or update an exiting AppComplianceAutomation report.
.Description
Create a new AppComplianceAutomation report or update an exiting AppComplianceAutomation report.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IReportResource
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IReportResource
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

PROPERTY <IReportResource>: A class represent an AppComplianceAutomation report resource.
  Resource <List<IResourceMetadata>>: List of resource data.
    ResourceId <String>: Resource Id - e.g. "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg1/providers/Microsoft.Compute/virtualMachines/vm1".
    [AccountId <String>]: Account Id. For example - the AWS account id.
    [ResourceKind <String>]: Resource kind.
    [ResourceOrigin <String>]: Resource Origin.
    [ResourceType <String>]: Resource type. e.g. "Microsoft.Compute/virtualMachines"
  TimeZone <String>: Report collection trigger time's time zone, the available list can be obtained by executing "Get-TimeZone -ListAvailable" in PowerShell.         An example of valid timezone id is "Pacific Standard Time".
  TriggerTime <DateTime>: Report collection trigger time.
  [OfferGuid <String>]: A list of comma-separated offerGuids indicates a series of offerGuids that map to the report. For example, "00000000-0000-0000-0000-000000000001,00000000-0000-0000-0000-000000000002" and "00000000-0000-0000-0000-000000000003".
  [StorageInfoAccountName <String>]: 'bring your own storage' account name
  [StorageInfoLocation <String>]: The region of 'bring your own storage' account
  [StorageInfoResourceGroup <String>]: The resourceGroup which 'bring your own storage' account belongs to
  [StorageInfoSubscriptionId <String>]: The subscription id which 'bring your own storage' account belongs to

RESOURCE <IResourceMetadata[]>: List of resource data.
  ResourceId <String>: Resource Id - e.g. "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg1/providers/Microsoft.Compute/virtualMachines/vm1".
  [AccountId <String>]: Account Id. For example - the AWS account id.
  [ResourceKind <String>]: Resource kind.
  [ResourceOrigin <String>]: Resource Origin.
  [ResourceType <String>]: Resource type. e.g. "Microsoft.Compute/virtualMachines"
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/new-azappcomplianceautomationreport
#>
function New-AzAppComplianceAutomationReport {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IReportResource])]
[CmdletBinding(DefaultParameterSetName='Create', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('ReportName')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${Name},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Header')]
    [System.String]
    # .
    ${XmsAadUserToken},

    [Parameter(ParameterSetName='Create', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IReportResource]
    # A class represent an AppComplianceAutomation report resource.
    ${Property},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IResourceMetadata[]]
    # List of resource data.
    ${Resource},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Report collection trigger time's time zone, the available list can be obtained by executing "Get-TimeZone -ListAvailable" in PowerShell.An example of valid timezone id is "Pacific Standard Time".
    ${TimeZone},

    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.DateTime]
    # Report collection trigger time.
    ${TriggerTime},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # A list of comma-separated offerGuids indicates a series of offerGuids that map to the report.
    # For example, "00000000-0000-0000-0000-000000000001,00000000-0000-0000-0000-000000000002" and "00000000-0000-0000-0000-000000000003".
    ${OfferGuid},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # 'bring your own storage' account name
    ${StorageInfoAccountName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # The region of 'bring your own storage' account
    ${StorageInfoLocation},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # The resourceGroup which 'bring your own storage' account belongs to
    ${StorageInfoResourceGroup},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # The subscription id which 'bring your own storage' account belongs to
    ${StorageInfoSubscriptionId},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Create = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationReport_Create';
            CreateExpanded = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationReport_CreateExpanded';
            CreateViaJsonFilePath = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationReport_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationReport_CreateViaJsonString';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Get the AppComplianceAutomation scoping configuration of the specific report.
.Description
Get the AppComplianceAutomation scoping configuration of the specific report.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity
.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IScopingConfigurationResource
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IScopingConfigurationResource
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ANSWER <IScopingAnswer[]>: List of scoping question answers.
  Answer <List<String>>: Question answer value list.
  QuestionId <String>: Question id.

PROPERTY <IScopingConfigurationResource>: A class represent an AppComplianceAutomation scoping configuration resource.
  [Answer <List<IScopingAnswer>>]: List of scoping question answers.
    Answer <List<String>>: Question answer value list.
    QuestionId <String>: Question id.

REPORTINPUTOBJECT <IAppComplianceAutomationIdentity>: Identity Parameter
  [EvidenceName <String>]: The evidence name.
  [Id <String>]: Resource identity path
  [ReportName <String>]: Report Name.
  [ScopingConfigurationName <String>]: The scoping configuration of the specific report.
  [SnapshotName <String>]: Snapshot Name.
  [WebhookName <String>]: Webhook Name.
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/new-azappcomplianceautomationscopingconfiguration
#>
function New-AzAppComplianceAutomationScopingConfiguration {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IScopingConfigurationResource])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('ScopingConfigurationName')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # The scoping configuration of the specific report.
    ${Name},

    [Parameter(ParameterSetName='Create', Mandatory)]
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${ReportName},

    [Parameter(ParameterSetName='CreateViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='CreateViaIdentityReportExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity]
    # Identity Parameter
    ${ReportInputObject},

    [Parameter(ParameterSetName='Create', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='CreateViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IScopingConfigurationResource]
    # A class represent an AppComplianceAutomation scoping configuration resource.
    ${Property},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityReportExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IScopingAnswer[]]
    # List of scoping question answers.
    ${Answer},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Create = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationScopingConfiguration_Create';
            CreateExpanded = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationScopingConfiguration_CreateExpanded';
            CreateViaIdentityReport = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationScopingConfiguration_CreateViaIdentityReport';
            CreateViaIdentityReportExpanded = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationScopingConfiguration_CreateViaIdentityReportExpanded';
            CreateViaJsonFilePath = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationScopingConfiguration_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationScopingConfiguration_CreateViaJsonString';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Create a new AppComplianceAutomation webhook or update an exiting AppComplianceAutomation webhook.
.Description
Create a new AppComplianceAutomation webhook or update an exiting AppComplianceAutomation webhook.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity
.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IWebhookResource
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IWebhookResource
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

PROPERTY <IWebhookResource>: A class represent an AppComplianceAutomation webhook resource.
  [ContentType <String>]: content type
  [EnableSslVerification <String>]: whether to enable ssl verification
  [Event <List<String>>]: under which event notification should be sent.
  [PayloadUrl <String>]: webhook payload url
  [SendAllEvent <String>]: whether to send notification under any event.
  [Status <String>]: Webhook status.
  [UpdateWebhookKey <String>]: whether to update webhookKey.
  [WebhookKey <String>]: webhook secret token. If not set, this field value is null; otherwise, please set a string value.

REPORTINPUTOBJECT <IAppComplianceAutomationIdentity>: Identity Parameter
  [EvidenceName <String>]: The evidence name.
  [Id <String>]: Resource identity path
  [ReportName <String>]: Report Name.
  [ScopingConfigurationName <String>]: The scoping configuration of the specific report.
  [SnapshotName <String>]: Snapshot Name.
  [WebhookName <String>]: Webhook Name.
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/new-azappcomplianceautomationwebhook
#>
function New-AzAppComplianceAutomationWebhook {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IWebhookResource])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('WebhookName')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Webhook Name.
    ${Name},

    [Parameter(ParameterSetName='Create', Mandatory)]
    [Parameter(ParameterSetName='CreateExpanded', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${ReportName},

    [Parameter(ParameterSetName='CreateViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='CreateViaIdentityReportExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity]
    # Identity Parameter
    ${ReportInputObject},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Header')]
    [System.String]
    # .
    ${XmsAadUserToken},

    [Parameter(ParameterSetName='Create', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='CreateViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IWebhookResource]
    # A class represent an AppComplianceAutomation webhook resource.
    ${Property},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.PSArgumentCompleterAttribute("application/json")]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # content type
    ${ContentType},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.PSArgumentCompleterAttribute("true", "false")]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # whether to enable ssl verification
    ${EnableSslVerification},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityReportExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.PSArgumentCompleterAttribute("generate_snapshot_success", "generate_snapshot_failed", "assessment_failure", "report_configuration_changes", "report_deletion")]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String[]]
    # under which event notification should be sent.
    ${Event},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # webhook payload url
    ${PayloadUrl},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.PSArgumentCompleterAttribute("true", "false")]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # whether to send notification under any event.
    ${SendAllEvent},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.PSArgumentCompleterAttribute("Enabled", "Disabled")]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Webhook status.
    ${Status},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.PSArgumentCompleterAttribute("true", "false")]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # whether to update webhookKey.
    ${UpdateWebhookKey},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Parameter(ParameterSetName='CreateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # webhook secret token.
    # If not set, this field value is null; otherwise, please set a string value.
    ${WebhookKey},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Create = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationWebhook_Create';
            CreateExpanded = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationWebhook_CreateExpanded';
            CreateViaIdentityReport = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationWebhook_CreateViaIdentityReport';
            CreateViaIdentityReportExpanded = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationWebhook_CreateViaIdentityReportExpanded';
            CreateViaJsonFilePath = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationWebhook_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.AppComplianceAutomation.private\New-AzAppComplianceAutomationWebhook_CreateViaJsonString';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Delete an existent evidence from a specified report
.Description
Delete an existent evidence from a specified report
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

REPORTINPUTOBJECT <IAppComplianceAutomationIdentity>: Identity Parameter
  [EvidenceName <String>]: The evidence name.
  [Id <String>]: Resource identity path
  [ReportName <String>]: Report Name.
  [ScopingConfigurationName <String>]: The scoping configuration of the specific report.
  [SnapshotName <String>]: Snapshot Name.
  [WebhookName <String>]: Webhook Name.
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/remove-azappcomplianceautomationevidence
#>
function Remove-AzAppComplianceAutomationEvidence {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('EvidenceName')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # The evidence name.
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${ReportName},

    [Parameter(ParameterSetName='DeleteViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity]
    # Identity Parameter
    ${ReportInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Delete = 'Az.AppComplianceAutomation.private\Remove-AzAppComplianceAutomationEvidence_Delete';
            DeleteViaIdentityReport = 'Az.AppComplianceAutomation.private\Remove-AzAppComplianceAutomationEvidence_DeleteViaIdentityReport';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Delete an AppComplianceAutomation report.
.Description
Delete an AppComplianceAutomation report.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Outputs
System.Boolean
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/remove-azappcomplianceautomationreport
#>
function Remove-AzAppComplianceAutomationReport {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('ReportName')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${Name},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Header')]
    [System.String]
    # .
    ${XmsAadUserToken},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Delete = 'Az.AppComplianceAutomation.private\Remove-AzAppComplianceAutomationReport_Delete';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Clean the AppComplianceAutomation scoping configuration of the specific report.
.Description
Clean the AppComplianceAutomation scoping configuration of the specific report.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

REPORTINPUTOBJECT <IAppComplianceAutomationIdentity>: Identity Parameter
  [EvidenceName <String>]: The evidence name.
  [Id <String>]: Resource identity path
  [ReportName <String>]: Report Name.
  [ScopingConfigurationName <String>]: The scoping configuration of the specific report.
  [SnapshotName <String>]: Snapshot Name.
  [WebhookName <String>]: Webhook Name.
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/remove-azappcomplianceautomationscopingconfiguration
#>
function Remove-AzAppComplianceAutomationScopingConfiguration {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('ScopingConfigurationName')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # The scoping configuration of the specific report.
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${ReportName},

    [Parameter(ParameterSetName='DeleteViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity]
    # Identity Parameter
    ${ReportInputObject},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Delete = 'Az.AppComplianceAutomation.private\Remove-AzAppComplianceAutomationScopingConfiguration_Delete';
            DeleteViaIdentityReport = 'Az.AppComplianceAutomation.private\Remove-AzAppComplianceAutomationScopingConfiguration_DeleteViaIdentityReport';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Delete an AppComplianceAutomation webhook.
.Description
Delete an AppComplianceAutomation webhook.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity
.Outputs
System.Boolean
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

REPORTINPUTOBJECT <IAppComplianceAutomationIdentity>: Identity Parameter
  [EvidenceName <String>]: The evidence name.
  [Id <String>]: Resource identity path
  [ReportName <String>]: Report Name.
  [ScopingConfigurationName <String>]: The scoping configuration of the specific report.
  [SnapshotName <String>]: Snapshot Name.
  [WebhookName <String>]: Webhook Name.
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/remove-azappcomplianceautomationwebhook
#>
function Remove-AzAppComplianceAutomationWebhook {
[OutputType([System.Boolean])]
[CmdletBinding(DefaultParameterSetName='Delete', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('WebhookName')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Webhook Name.
    ${Name},

    [Parameter(ParameterSetName='Delete', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${ReportName},

    [Parameter(ParameterSetName='DeleteViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity]
    # Identity Parameter
    ${ReportInputObject},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Header')]
    [System.String]
    # .
    ${XmsAadUserToken},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Returns true when the command succeeds
    ${PassThru},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Delete = 'Az.AppComplianceAutomation.private\Remove-AzAppComplianceAutomationWebhook_Delete';
            DeleteViaIdentityReport = 'Az.AppComplianceAutomation.private\Remove-AzAppComplianceAutomationWebhook_DeleteViaIdentityReport';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Trigger quick evaluation for the given subscriptions.
.Description
Trigger quick evaluation for the given subscriptions.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.ITriggerEvaluationRequest
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.ITriggerEvaluationResponse
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BODY <ITriggerEvaluationRequest>: Trigger evaluation request.
  ResourceId <List<String>>: List of resource ids to be evaluated
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/start-azappcomplianceautomationprovideractionevaluation
#>
function Start-AzAppComplianceAutomationProviderActionEvaluation {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.ITriggerEvaluationResponse])]
[CmdletBinding(DefaultParameterSetName='TriggerExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Header')]
    [System.String]
    # .
    ${XmsAadUserToken},

    [Parameter(ParameterSetName='Trigger', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.ITriggerEvaluationRequest]
    # Trigger evaluation request.
    ${Body},

    [Parameter(ParameterSetName='TriggerExpanded', Mandatory)]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String[]]
    # List of resource ids to be evaluated
    ${ResourceId},

    [Parameter(ParameterSetName='TriggerViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Trigger operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='TriggerViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Json string supplied to the Trigger operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Trigger = 'Az.AppComplianceAutomation.private\Start-AzAppComplianceAutomationProviderActionEvaluation_Trigger';
            TriggerExpanded = 'Az.AppComplianceAutomation.private\Start-AzAppComplianceAutomationProviderActionEvaluation_TriggerExpanded';
            TriggerViaJsonFilePath = 'Az.AppComplianceAutomation.private\Start-AzAppComplianceAutomationProviderActionEvaluation_TriggerViaJsonFilePath';
            TriggerViaJsonString = 'Az.AppComplianceAutomation.private\Start-AzAppComplianceAutomationProviderActionEvaluation_TriggerViaJsonString';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Update an evidence a specified report
.Description
Update an evidence a specified report
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity
.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IEvidenceResource
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IEvidenceResource
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

PROPERTY <IEvidenceResource>: A class represent an AppComplianceAutomation evidence resource.
  FilePath <String>: The path of the file in storage.
  [ControlId <String>]: Control id.
  [EvidenceType <String>]: Evidence type.
  [ExtraData <String>]: Extra data considered as evidence.
  [ResponsibilityId <String>]: Responsibility id.

REPORTINPUTOBJECT <IAppComplianceAutomationIdentity>: Identity Parameter
  [EvidenceName <String>]: The evidence name.
  [Id <String>]: Resource identity path
  [ReportName <String>]: Report Name.
  [ScopingConfigurationName <String>]: The scoping configuration of the specific report.
  [SnapshotName <String>]: Snapshot Name.
  [WebhookName <String>]: Webhook Name.
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/update-azappcomplianceautomationevidence
#>
function Update-AzAppComplianceAutomationEvidence {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IEvidenceResource])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('EvidenceName')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # The evidence name.
    ${Name},

    [Parameter(ParameterSetName='Update', Mandatory)]
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${ReportName},

    [Parameter(ParameterSetName='UpdateViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='UpdateViaIdentityReportExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity]
    # Identity Parameter
    ${ReportInputObject},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # The offerGuid which mapping to the reports.
    ${OfferGuid},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Query')]
    [System.String]
    # The tenant id of the report creator.
    ${ReportCreatorTenantId},

    [Parameter(ParameterSetName='Update', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='UpdateViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IEvidenceResource]
    # A class represent an AppComplianceAutomation evidence resource.
    ${Property},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Control id.
    ${ControlId},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.PSArgumentCompleterAttribute("File", "AutoCollectedEvidence", "Data")]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Evidence type.
    ${EvidenceType},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Extra data considered as evidence.
    ${ExtraData},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # The path of the file in storage.
    ${FilePath},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Responsibility id.
    ${ResponsibilityId},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Update = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationEvidence_Update';
            UpdateExpanded = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationEvidence_UpdateExpanded';
            UpdateViaIdentityReport = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationEvidence_UpdateViaIdentityReport';
            UpdateViaIdentityReportExpanded = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationEvidence_UpdateViaIdentityReportExpanded';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Update an exiting AppComplianceAutomation report.
.Description
Update an exiting AppComplianceAutomation report.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IReportResourcePatch
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IReportResource
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

PROPERTY <IReportResourcePatch>: A class represent a AppComplianceAutomation report resource update properties.
  [OfferGuid <String>]: A list of comma-separated offerGuids indicates a series of offerGuids that map to the report. For example, "00000000-0000-0000-0000-000000000001,00000000-0000-0000-0000-000000000002" and "00000000-0000-0000-0000-000000000003".
  [Resource <List<IResourceMetadata>>]: List of resource data.
    ResourceId <String>: Resource Id - e.g. "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg1/providers/Microsoft.Compute/virtualMachines/vm1".
    [AccountId <String>]: Account Id. For example - the AWS account id.
    [ResourceKind <String>]: Resource kind.
    [ResourceOrigin <String>]: Resource Origin.
    [ResourceType <String>]: Resource type. e.g. "Microsoft.Compute/virtualMachines"
  [StorageInfoAccountName <String>]: 'bring your own storage' account name
  [StorageInfoLocation <String>]: The region of 'bring your own storage' account
  [StorageInfoResourceGroup <String>]: The resourceGroup which 'bring your own storage' account belongs to
  [StorageInfoSubscriptionId <String>]: The subscription id which 'bring your own storage' account belongs to
  [TimeZone <String>]: Report collection trigger time's time zone, the available list can be obtained by executing "Get-TimeZone -ListAvailable" in PowerShell.         An example of valid timezone id is "Pacific Standard Time".
  [TriggerTime <DateTime?>]: Report collection trigger time.

RESOURCE <IResourceMetadata[]>: List of resource data.
  ResourceId <String>: Resource Id - e.g. "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rg1/providers/Microsoft.Compute/virtualMachines/vm1".
  [AccountId <String>]: Account Id. For example - the AWS account id.
  [ResourceKind <String>]: Resource kind.
  [ResourceOrigin <String>]: Resource Origin.
  [ResourceType <String>]: Resource type. e.g. "Microsoft.Compute/virtualMachines"
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/update-azappcomplianceautomationreport
#>
function Update-AzAppComplianceAutomationReport {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IReportResource])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('ReportName')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${Name},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Header')]
    [System.String]
    # .
    ${XmsAadUserToken},

    [Parameter(ParameterSetName='Update', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IReportResourcePatch]
    # A class represent a AppComplianceAutomation report resource update properties.
    ${Property},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # A list of comma-separated offerGuids indicates a series of offerGuids that map to the report.
    # For example, "00000000-0000-0000-0000-000000000001,00000000-0000-0000-0000-000000000002" and "00000000-0000-0000-0000-000000000003".
    ${OfferGuid},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IResourceMetadata[]]
    # List of resource data.
    ${Resource},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # 'bring your own storage' account name
    ${StorageInfoAccountName},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # The region of 'bring your own storage' account
    ${StorageInfoLocation},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # The resourceGroup which 'bring your own storage' account belongs to
    ${StorageInfoResourceGroup},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # The subscription id which 'bring your own storage' account belongs to
    ${StorageInfoSubscriptionId},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Report collection trigger time's time zone, the available list can be obtained by executing "Get-TimeZone -ListAvailable" in PowerShell.An example of valid timezone id is "Pacific Standard Time".
    ${TimeZone},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.DateTime]
    # Report collection trigger time.
    ${TriggerTime},

    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Update operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Json string supplied to the Update operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Update = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationReport_Update';
            UpdateExpanded = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationReport_UpdateExpanded';
            UpdateViaJsonFilePath = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationReport_UpdateViaJsonFilePath';
            UpdateViaJsonString = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationReport_UpdateViaJsonString';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Get the AppComplianceAutomation scoping configuration of the specific report.
.Description
Get the AppComplianceAutomation scoping configuration of the specific report.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity
.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IScopingConfigurationResource
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IScopingConfigurationResource
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

ANSWER <IScopingAnswer[]>: List of scoping question answers.
  Answer <List<String>>: Question answer value list.
  QuestionId <String>: Question id.

PROPERTY <IScopingConfigurationResource>: A class represent an AppComplianceAutomation scoping configuration resource.
  [Answer <List<IScopingAnswer>>]: List of scoping question answers.
    Answer <List<String>>: Question answer value list.
    QuestionId <String>: Question id.

REPORTINPUTOBJECT <IAppComplianceAutomationIdentity>: Identity Parameter
  [EvidenceName <String>]: The evidence name.
  [Id <String>]: Resource identity path
  [ReportName <String>]: Report Name.
  [ScopingConfigurationName <String>]: The scoping configuration of the specific report.
  [SnapshotName <String>]: Snapshot Name.
  [WebhookName <String>]: Webhook Name.
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/update-azappcomplianceautomationscopingconfiguration
#>
function Update-AzAppComplianceAutomationScopingConfiguration {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IScopingConfigurationResource])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('ScopingConfigurationName')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # The scoping configuration of the specific report.
    ${Name},

    [Parameter(ParameterSetName='Update', Mandatory)]
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${ReportName},

    [Parameter(ParameterSetName='UpdateViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='UpdateViaIdentityReportExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity]
    # Identity Parameter
    ${ReportInputObject},

    [Parameter(ParameterSetName='Update', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='UpdateViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IScopingConfigurationResource]
    # A class represent an AppComplianceAutomation scoping configuration resource.
    ${Property},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityReportExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IScopingAnswer[]]
    # List of scoping question answers.
    ${Answer},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Update = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationScopingConfiguration_Update';
            UpdateExpanded = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationScopingConfiguration_UpdateExpanded';
            UpdateViaIdentityReport = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationScopingConfiguration_UpdateViaIdentityReport';
            UpdateViaIdentityReportExpanded = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationScopingConfiguration_UpdateViaIdentityReportExpanded';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}

<#
.Synopsis
Update an exiting AppComplianceAutomation webhook.
.Description
Update an exiting AppComplianceAutomation webhook.
.Example
{{ Add code here }}
.Example
{{ Add code here }}

.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity
.Inputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IWebhookResourcePatch
.Outputs
Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IWebhookResource
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

PROPERTY <IWebhookResourcePatch>: A class represent a AppComplianceAutomation webhook resource update properties.
  [ContentType <String>]: content type
  [EnableSslVerification <String>]: whether to enable ssl verification
  [Event <List<String>>]: under which event notification should be sent.
  [PayloadUrl <String>]: webhook payload url
  [SendAllEvent <String>]: whether to send notification under any event.
  [Status <String>]: Webhook status.
  [UpdateWebhookKey <String>]: whether to update webhookKey.
  [WebhookKey <String>]: webhook secret token. If not set, this field value is null; otherwise, please set a string value.

REPORTINPUTOBJECT <IAppComplianceAutomationIdentity>: Identity Parameter
  [EvidenceName <String>]: The evidence name.
  [Id <String>]: Resource identity path
  [ReportName <String>]: Report Name.
  [ScopingConfigurationName <String>]: The scoping configuration of the specific report.
  [SnapshotName <String>]: Snapshot Name.
  [WebhookName <String>]: Webhook Name.
.Link
https://learn.microsoft.com/powershell/module/az.appcomplianceautomation/update-azappcomplianceautomationwebhook
#>
function Update-AzAppComplianceAutomationWebhook {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IWebhookResource])]
[CmdletBinding(DefaultParameterSetName='UpdateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('WebhookName')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Webhook Name.
    ${Name},

    [Parameter(ParameterSetName='Update', Mandatory)]
    [Parameter(ParameterSetName='UpdateExpanded', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [System.String]
    # Report Name.
    ${ReportName},

    [Parameter(ParameterSetName='UpdateViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='UpdateViaIdentityReportExpanded', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IAppComplianceAutomationIdentity]
    # Identity Parameter
    ${ReportInputObject},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Header')]
    [System.String]
    # .
    ${XmsAadUserToken},

    [Parameter(ParameterSetName='Update', Mandatory, ValueFromPipeline)]
    [Parameter(ParameterSetName='UpdateViaIdentityReport', Mandatory, ValueFromPipeline)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Models.IWebhookResourcePatch]
    # A class represent a AppComplianceAutomation webhook resource update properties.
    ${Property},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.PSArgumentCompleterAttribute("application/json")]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # content type
    ${ContentType},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.PSArgumentCompleterAttribute("true", "false")]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # whether to enable ssl verification
    ${EnableSslVerification},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityReportExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.PSArgumentCompleterAttribute("generate_snapshot_success", "generate_snapshot_failed", "assessment_failure", "report_configuration_changes", "report_deletion")]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String[]]
    # under which event notification should be sent.
    ${Event},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # webhook payload url
    ${PayloadUrl},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.PSArgumentCompleterAttribute("true", "false")]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # whether to send notification under any event.
    ${SendAllEvent},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.PSArgumentCompleterAttribute("Enabled", "Disabled")]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Webhook status.
    ${Status},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.PSArgumentCompleterAttribute("true", "false")]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # whether to update webhookKey.
    ${UpdateWebhookKey},

    [Parameter(ParameterSetName='UpdateExpanded')]
    [Parameter(ParameterSetName='UpdateViaIdentityReportExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # webhook secret token.
    # If not set, this field value is null; otherwise, please set a string value.
    ${WebhookKey},

    [Parameter(ParameterSetName='UpdateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Update operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='UpdateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Body')]
    [System.String]
    # Json string supplied to the Update operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.AppComplianceAutomation.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName

        $mapping = @{
            Update = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationWebhook_Update';
            UpdateExpanded = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationWebhook_UpdateExpanded';
            UpdateViaIdentityReport = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationWebhook_UpdateViaIdentityReport';
            UpdateViaIdentityReportExpanded = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationWebhook_UpdateViaIdentityReportExpanded';
            UpdateViaJsonFilePath = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationWebhook_UpdateViaJsonFilePath';
            UpdateViaJsonString = 'Az.AppComplianceAutomation.private\Update-AzAppComplianceAutomationWebhook_UpdateViaJsonString';
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}
