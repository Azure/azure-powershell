// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Storage.Models
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Extensions;

    /// <summary>The blob container properties be listed out.</summary>
    public partial class ListContainerItem :
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItem,
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal,
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IValidates
    {
        /// <summary>
        /// Backing field for Inherited model <see cref= "Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IAzureEntityResource"
        /// />
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IAzureEntityResource __azureEntityResource = new Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.AzureEntityResource();

        /// <summary>
        /// This property can only be changed for unlocked time-based retention policies. When enabled, new blocks can be written
        /// to an append blob while maintaining immutability protection and compliance. Only new blocks can be added and any existing
        /// blocks cannot be modified or deleted. This property cannot be changed with ExtendImmutabilityPolicy API.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public bool? AllowProtectedAppendWrite { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).AllowProtectedAppendWrite; }

        /// <summary>
        /// This property can only be changed for unlocked time-based retention policies. When enabled, new blocks can be written
        /// to both 'Append and Bock Blobs' while maintaining immutability protection and compliance. Only new blocks can be added
        /// and any existing blocks cannot be modified or deleted. This property cannot be changed with ExtendImmutabilityPolicy API.
        /// The 'allowProtectedAppendWrites' and 'allowProtectedAppendWritesAll' properties are mutually exclusive.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public bool? AllowProtectedAppendWritesAll { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).AllowProtectedAppendWritesAll; }

        /// <summary>Default the container to use specified encryption scope for all writes.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public string DefaultEncryptionScope { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).DefaultEncryptionScope; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).DefaultEncryptionScope = value ?? null; }

        /// <summary>Indicates whether the blob container was deleted.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public bool? Deleted { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).Deleted; }

        /// <summary>Blob container deletion time.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public global::System.DateTime? DeletedTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).DeletedTime; }

        /// <summary>Block override of encryption scope from the container default.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public bool? DenyEncryptionScopeOverride { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).DenyEncryptionScopeOverride; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).DenyEncryptionScopeOverride = value ?? default(bool); }

        /// <summary>Enable NFSv3 all squash on blob container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public bool? EnableNfsV3AllSquash { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).EnableNfsV3AllSquash; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).EnableNfsV3AllSquash = value ?? default(bool); }

        /// <summary>Enable NFSv3 root squash on blob container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public bool? EnableNfsV3RootSquash { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).EnableNfsV3RootSquash; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).EnableNfsV3RootSquash = value ?? default(bool); }

        /// <summary>Resource Etag.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inherited)]
        public string Etag { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IAzureEntityResourceInternal)__azureEntityResource).Etag; }

        /// <summary>
        /// The hasImmutabilityPolicy public property is set to true by SRP if ImmutabilityPolicy has been created for this container.
        /// The hasImmutabilityPolicy public property is set to false by SRP if ImmutabilityPolicy has not been created for this container.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public bool? HasImmutabilityPolicy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).HasImmutabilityPolicy; }

        /// <summary>
        /// The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public
        /// property is set to false by SRP if all existing legal hold tags are cleared out. There can be a maximum of 1000 blob containers
        /// with hasLegalHold=true for a given account.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public bool? HasLegalHold { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).HasLegalHold; }

        /// <summary>
        /// Fully qualified resource ID for the resource. E.g. "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inherited)]
        public string Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).Id; }

        /// <summary>
        /// The immutability period for the blobs in the container since the policy creation, in days.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public int? ImmutabilityPeriodSinceCreationInDay { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutabilityPeriodSinceCreationInDay; }

        /// <summary>ImmutabilityPolicy Etag.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public string ImmutabilityPolicyEtag { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutabilityPolicyEtag; }

        /// <summary>The ImmutabilityPolicy update history of the blob container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IUpdateHistoryProperty> ImmutabilityPolicyUpdateHistory { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutabilityPolicyUpdateHistory; }

        /// <summary>
        /// This is an immutable property, when set to true it enables object level immutability at the container level.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public bool? ImmutableStorageWithVersioningEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutableStorageWithVersioningEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutableStorageWithVersioningEnabled = value ?? default(bool); }

        /// <summary>
        /// This property denotes the container level immutability to object level immutability migration state.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public string ImmutableStorageWithVersioningMigrationState { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutableStorageWithVersioningMigrationState; }

        /// <summary>Returns the date and time the object level immutability was enabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public global::System.DateTime? ImmutableStorageWithVersioningTimeStamp { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutableStorageWithVersioningTimeStamp; }

        /// <summary>Returns the date and time the container was last modified.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public global::System.DateTime? LastModifiedTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LastModifiedTime; }

        /// <summary>
        /// Specifies whether the lease on a container is of infinite or fixed duration, only when the container is leased.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public string LeaseDuration { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LeaseDuration; }

        /// <summary>Lease state of the container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public string LeaseState { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LeaseState; }

        /// <summary>The lease status of the container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public string LeaseStatus { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LeaseStatus; }

        /// <summary>
        /// The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public
        /// property is set to false by SRP if all existing legal hold tags are cleared out. There can be a maximum of 1000 blob containers
        /// with hasLegalHold=true for a given account.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public bool? LegalHoldHasLegalHold { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LegalHoldHasLegalHold; }

        /// <summary>The list of LegalHold tags of a blob container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.ITagProperty> LegalHoldTag { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LegalHoldTag; }

        /// <summary>A name-value pair to associate with the container as metadata.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesMetadata Metadata { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).Metadata; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).Metadata = value ?? null /* model class */; }

        /// <summary>Internal Acessors for Etag</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IAzureEntityResourceInternal.Etag { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IAzureEntityResourceInternal)__azureEntityResource).Etag; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IAzureEntityResourceInternal)__azureEntityResource).Etag = value ?? null; }

        /// <summary>Internal Acessors for AllowProtectedAppendWrite</summary>
        bool? Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.AllowProtectedAppendWrite { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).AllowProtectedAppendWrite; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).AllowProtectedAppendWrite = value ?? default(bool); }

        /// <summary>Internal Acessors for AllowProtectedAppendWritesAll</summary>
        bool? Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.AllowProtectedAppendWritesAll { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).AllowProtectedAppendWritesAll; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).AllowProtectedAppendWritesAll = value ?? default(bool); }

        /// <summary>Internal Acessors for Deleted</summary>
        bool? Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.Deleted { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).Deleted; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).Deleted = value ?? default(bool); }

        /// <summary>Internal Acessors for DeletedTime</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.DeletedTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).DeletedTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).DeletedTime = value ?? default(global::System.DateTime); }

        /// <summary>Internal Acessors for HasImmutabilityPolicy</summary>
        bool? Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.HasImmutabilityPolicy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).HasImmutabilityPolicy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).HasImmutabilityPolicy = value ?? default(bool); }

        /// <summary>Internal Acessors for HasLegalHold</summary>
        bool? Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.HasLegalHold { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).HasLegalHold; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).HasLegalHold = value ?? default(bool); }

        /// <summary>Internal Acessors for ImmutabilityPeriodSinceCreationInDay</summary>
        int? Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.ImmutabilityPeriodSinceCreationInDay { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutabilityPeriodSinceCreationInDay; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutabilityPeriodSinceCreationInDay = value ?? default(int); }

        /// <summary>Internal Acessors for ImmutabilityPolicy</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IImmutabilityPolicyProperties Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.ImmutabilityPolicy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutabilityPolicy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutabilityPolicy = value ?? null /* model class */; }

        /// <summary>Internal Acessors for ImmutabilityPolicyEtag</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.ImmutabilityPolicyEtag { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutabilityPolicyEtag; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutabilityPolicyEtag = value ?? null; }

        /// <summary>Internal Acessors for ImmutabilityPolicyProperty</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IImmutabilityPolicyProperty Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.ImmutabilityPolicyProperty { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutabilityPolicyProperty; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutabilityPolicyProperty = value ?? null /* model class */; }

        /// <summary>Internal Acessors for ImmutabilityPolicyUpdateHistory</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IUpdateHistoryProperty> Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.ImmutabilityPolicyUpdateHistory { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutabilityPolicyUpdateHistory; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutabilityPolicyUpdateHistory = value ?? null /* arrayOf */; }

        /// <summary>Internal Acessors for ImmutableStorageWithVersioning</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IImmutableStorageWithVersioning Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.ImmutableStorageWithVersioning { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutableStorageWithVersioning; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutableStorageWithVersioning = value ?? null /* model class */; }

        /// <summary>Internal Acessors for ImmutableStorageWithVersioningMigrationState</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.ImmutableStorageWithVersioningMigrationState { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutableStorageWithVersioningMigrationState; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutableStorageWithVersioningMigrationState = value ?? null; }

        /// <summary>Internal Acessors for ImmutableStorageWithVersioningTimeStamp</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.ImmutableStorageWithVersioningTimeStamp { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutableStorageWithVersioningTimeStamp; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ImmutableStorageWithVersioningTimeStamp = value ?? default(global::System.DateTime); }

        /// <summary>Internal Acessors for LastModifiedTime</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.LastModifiedTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LastModifiedTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LastModifiedTime = value ?? default(global::System.DateTime); }

        /// <summary>Internal Acessors for LeaseDuration</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.LeaseDuration { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LeaseDuration; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LeaseDuration = value ?? null; }

        /// <summary>Internal Acessors for LeaseState</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.LeaseState { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LeaseState; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LeaseState = value ?? null; }

        /// <summary>Internal Acessors for LeaseStatus</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.LeaseStatus { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LeaseStatus; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LeaseStatus = value ?? null; }

        /// <summary>Internal Acessors for LegalHold</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.ILegalHoldProperties Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.LegalHold { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LegalHold; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LegalHold = value ?? null /* model class */; }

        /// <summary>Internal Acessors for LegalHoldHasLegalHold</summary>
        bool? Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.LegalHoldHasLegalHold { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LegalHoldHasLegalHold; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LegalHoldHasLegalHold = value ?? default(bool); }

        /// <summary>Internal Acessors for LegalHoldProtectedAppendWritesHistory</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IProtectedAppendWritesHistory Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.LegalHoldProtectedAppendWritesHistory { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LegalHoldProtectedAppendWritesHistory; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LegalHoldProtectedAppendWritesHistory = value ?? null /* model class */; }

        /// <summary>Internal Acessors for LegalHoldTag</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.ITagProperty> Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.LegalHoldTag { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LegalHoldTag; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).LegalHoldTag = value ?? null /* arrayOf */; }

        /// <summary>Internal Acessors for Property</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerProperties Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.ContainerProperties()); set { {_property = value;} } }

        /// <summary>Internal Acessors for ProtectedAppendWriteHistoryAllowProtectedAppendWritesAll</summary>
        bool? Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.ProtectedAppendWriteHistoryAllowProtectedAppendWritesAll { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ProtectedAppendWriteHistoryAllowProtectedAppendWritesAll; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ProtectedAppendWriteHistoryAllowProtectedAppendWritesAll = value ?? default(bool); }

        /// <summary>Internal Acessors for ProtectedAppendWriteHistoryTimestamp</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.ProtectedAppendWriteHistoryTimestamp { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ProtectedAppendWriteHistoryTimestamp; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ProtectedAppendWriteHistoryTimestamp = value ?? default(global::System.DateTime); }

        /// <summary>Internal Acessors for RemainingRetentionDay</summary>
        int? Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.RemainingRetentionDay { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).RemainingRetentionDay; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).RemainingRetentionDay = value ?? default(int); }

        /// <summary>Internal Acessors for State</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.State { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).State; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).State = value ?? null; }

        /// <summary>Internal Acessors for Version</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IListContainerItemInternal.Version { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).Version; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).Version = value ?? null; }

        /// <summary>Internal Acessors for Id</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal.Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).Id = value ?? null; }

        /// <summary>Internal Acessors for Name</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal.Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).Name = value ?? null; }

        /// <summary>Internal Acessors for SystemData</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.ISystemData Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal.SystemData { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemData; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemData = value ?? null /* model class */; }

        /// <summary>Internal Acessors for SystemDataCreatedAt</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal.SystemDataCreatedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataCreatedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataCreatedAt = value ?? default(global::System.DateTime); }

        /// <summary>Internal Acessors for SystemDataCreatedBy</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal.SystemDataCreatedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataCreatedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataCreatedBy = value ?? null; }

        /// <summary>Internal Acessors for SystemDataCreatedByType</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal.SystemDataCreatedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataCreatedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataCreatedByType = value ?? null; }

        /// <summary>Internal Acessors for SystemDataLastModifiedAt</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal.SystemDataLastModifiedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataLastModifiedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataLastModifiedAt = value ?? default(global::System.DateTime); }

        /// <summary>Internal Acessors for SystemDataLastModifiedBy</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal.SystemDataLastModifiedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataLastModifiedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataLastModifiedBy = value ?? null; }

        /// <summary>Internal Acessors for SystemDataLastModifiedByType</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal.SystemDataLastModifiedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataLastModifiedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataLastModifiedByType = value ?? null; }

        /// <summary>Internal Acessors for Type</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal.Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).Type = value ?? null; }

        /// <summary>The name of the resource</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inherited)]
        public string Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).Name; }

        /// <summary>Backing field for <see cref="Property" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerProperties _property;

        /// <summary>The blob container properties be listed out.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerProperties Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.ContainerProperties()); set => this._property = value; }

        /// <summary>
        /// When enabled, new blocks can be written to both 'Append and Bock Blobs' while maintaining legal hold protection and compliance.
        /// Only new blocks can be added and any existing blocks cannot be modified or deleted.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public bool? ProtectedAppendWriteHistoryAllowProtectedAppendWritesAll { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ProtectedAppendWriteHistoryAllowProtectedAppendWritesAll; }

        /// <summary>Returns the date and time the tag was added.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public global::System.DateTime? ProtectedAppendWriteHistoryTimestamp { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).ProtectedAppendWriteHistoryTimestamp; }

        /// <summary>
        /// Specifies whether data in the container may be accessed publicly and the level of access.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public string PublicAccess { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).PublicAccess; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).PublicAccess = value ?? null; }

        /// <summary>Remaining retention days for soft deleted blob container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public int? RemainingRetentionDay { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).RemainingRetentionDay; }

        /// <summary>
        /// The ImmutabilityPolicy state of a blob container, possible values include: Locked and Unlocked.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public string State { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).State; }

        /// <summary>
        /// Azure Resource Manager metadata containing createdBy and modifiedBy information.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inherited)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.ISystemData SystemData { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemData; set => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemData = value ?? null /* model class */; }

        /// <summary>The timestamp of resource creation (UTC).</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inherited)]
        public global::System.DateTime? SystemDataCreatedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataCreatedAt; }

        /// <summary>The identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inherited)]
        public string SystemDataCreatedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataCreatedBy; }

        /// <summary>The type of identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inherited)]
        public string SystemDataCreatedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataCreatedByType; }

        /// <summary>The timestamp of resource last modification (UTC)</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inherited)]
        public global::System.DateTime? SystemDataLastModifiedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataLastModifiedAt; }

        /// <summary>The identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inherited)]
        public string SystemDataLastModifiedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataLastModifiedBy; }

        /// <summary>The type of identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inherited)]
        public string SystemDataLastModifiedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).SystemDataLastModifiedByType; }

        /// <summary>
        /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inherited)]
        public string Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IResourceInternal)__azureEntityResource).Type; }

        /// <summary>The version of the deleted blob container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Origin(Microsoft.Azure.PowerShell.Cmdlets.Storage.PropertyOrigin.Inlined)]
        public string Version { get => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesInternal)Property).Version; }

        /// <summary>Creates an new <see cref="ListContainerItem" /> instance.</summary>
        public ListContainerItem()
        {

        }

        /// <summary>Validates that this object meets the validation criteria.</summary>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener" /> instance that will receive validation
        /// events.</param>
        /// <returns>
        /// A <see cref = "global::System.Threading.Tasks.Task" /> that will be complete when validation is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task Validate(Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener eventListener)
        {
            await eventListener.AssertNotNull(nameof(__azureEntityResource), __azureEntityResource);
            await eventListener.AssertObjectIsValid(nameof(__azureEntityResource), __azureEntityResource);
        }
    }
    /// The blob container properties be listed out.
    public partial interface IListContainerItem :
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IJsonSerializable,
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IAzureEntityResource
    {
        /// <summary>
        /// This property can only be changed for unlocked time-based retention policies. When enabled, new blocks can be written
        /// to an append blob while maintaining immutability protection and compliance. Only new blocks can be added and any existing
        /// blocks cannot be modified or deleted. This property cannot be changed with ExtendImmutabilityPolicy API.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"This property can only be changed for unlocked time-based retention policies. When enabled, new blocks can be written to an append blob while maintaining immutability protection and compliance. Only new blocks can be added and any existing blocks cannot be modified or deleted. This property cannot be changed with ExtendImmutabilityPolicy API.",
        SerializedName = @"allowProtectedAppendWrites",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AllowProtectedAppendWrite { get;  }
        /// <summary>
        /// This property can only be changed for unlocked time-based retention policies. When enabled, new blocks can be written
        /// to both 'Append and Bock Blobs' while maintaining immutability protection and compliance. Only new blocks can be added
        /// and any existing blocks cannot be modified or deleted. This property cannot be changed with ExtendImmutabilityPolicy API.
        /// The 'allowProtectedAppendWrites' and 'allowProtectedAppendWritesAll' properties are mutually exclusive.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"This property can only be changed for unlocked time-based retention policies. When enabled, new blocks can be written to both 'Append and Bock Blobs' while maintaining immutability protection and compliance. Only new blocks can be added and any existing blocks cannot be modified or deleted. This property cannot be changed with ExtendImmutabilityPolicy API. The 'allowProtectedAppendWrites' and 'allowProtectedAppendWritesAll' properties are mutually exclusive.",
        SerializedName = @"allowProtectedAppendWritesAll",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AllowProtectedAppendWritesAll { get;  }
        /// <summary>Default the container to use specified encryption scope for all writes.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Default the container to use specified encryption scope for all writes.",
        SerializedName = @"defaultEncryptionScope",
        PossibleTypes = new [] { typeof(string) })]
        string DefaultEncryptionScope { get; set; }
        /// <summary>Indicates whether the blob container was deleted.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Indicates whether the blob container was deleted.",
        SerializedName = @"deleted",
        PossibleTypes = new [] { typeof(bool) })]
        bool? Deleted { get;  }
        /// <summary>Blob container deletion time.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Blob container deletion time.",
        SerializedName = @"deletedTime",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? DeletedTime { get;  }
        /// <summary>Block override of encryption scope from the container default.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Block override of encryption scope from the container default.",
        SerializedName = @"denyEncryptionScopeOverride",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DenyEncryptionScopeOverride { get; set; }
        /// <summary>Enable NFSv3 all squash on blob container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Enable NFSv3 all squash on blob container.",
        SerializedName = @"enableNfsV3AllSquash",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnableNfsV3AllSquash { get; set; }
        /// <summary>Enable NFSv3 root squash on blob container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Enable NFSv3 root squash on blob container.",
        SerializedName = @"enableNfsV3RootSquash",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnableNfsV3RootSquash { get; set; }
        /// <summary>
        /// The hasImmutabilityPolicy public property is set to true by SRP if ImmutabilityPolicy has been created for this container.
        /// The hasImmutabilityPolicy public property is set to false by SRP if ImmutabilityPolicy has not been created for this container.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The hasImmutabilityPolicy public property is set to true by SRP if ImmutabilityPolicy has been created for this container. The hasImmutabilityPolicy public property is set to false by SRP if ImmutabilityPolicy has not been created for this container.",
        SerializedName = @"hasImmutabilityPolicy",
        PossibleTypes = new [] { typeof(bool) })]
        bool? HasImmutabilityPolicy { get;  }
        /// <summary>
        /// The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public
        /// property is set to false by SRP if all existing legal hold tags are cleared out. There can be a maximum of 1000 blob containers
        /// with hasLegalHold=true for a given account.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public property is set to false by SRP if all existing legal hold tags are cleared out. There can be a maximum of 1000 blob containers with hasLegalHold=true for a given account.",
        SerializedName = @"hasLegalHold",
        PossibleTypes = new [] { typeof(bool) })]
        bool? HasLegalHold { get;  }
        /// <summary>
        /// The immutability period for the blobs in the container since the policy creation, in days.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The immutability period for the blobs in the container since the policy creation, in days.",
        SerializedName = @"immutabilityPeriodSinceCreationInDays",
        PossibleTypes = new [] { typeof(int) })]
        int? ImmutabilityPeriodSinceCreationInDay { get;  }
        /// <summary>ImmutabilityPolicy Etag.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"ImmutabilityPolicy Etag.",
        SerializedName = @"etag",
        PossibleTypes = new [] { typeof(string) })]
        string ImmutabilityPolicyEtag { get;  }
        /// <summary>The ImmutabilityPolicy update history of the blob container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The ImmutabilityPolicy update history of the blob container.",
        SerializedName = @"updateHistory",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IUpdateHistoryProperty) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IUpdateHistoryProperty> ImmutabilityPolicyUpdateHistory { get;  }
        /// <summary>
        /// This is an immutable property, when set to true it enables object level immutability at the container level.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This is an immutable property, when set to true it enables object level immutability at the container level.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ImmutableStorageWithVersioningEnabled { get; set; }
        /// <summary>
        /// This property denotes the container level immutability to object level immutability migration state.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"This property denotes the container level immutability to object level immutability migration state.",
        SerializedName = @"migrationState",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.PSArgumentCompleterAttribute("InProgress", "Completed")]
        string ImmutableStorageWithVersioningMigrationState { get;  }
        /// <summary>Returns the date and time the object level immutability was enabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Returns the date and time the object level immutability was enabled.",
        SerializedName = @"timeStamp",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? ImmutableStorageWithVersioningTimeStamp { get;  }
        /// <summary>Returns the date and time the container was last modified.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Returns the date and time the container was last modified.",
        SerializedName = @"lastModifiedTime",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? LastModifiedTime { get;  }
        /// <summary>
        /// Specifies whether the lease on a container is of infinite or fixed duration, only when the container is leased.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Specifies whether the lease on a container is of infinite or fixed duration, only when the container is leased.",
        SerializedName = @"leaseDuration",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.PSArgumentCompleterAttribute("Infinite", "Fixed")]
        string LeaseDuration { get;  }
        /// <summary>Lease state of the container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Lease state of the container.",
        SerializedName = @"leaseState",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.PSArgumentCompleterAttribute("Available", "Leased", "Expired", "Breaking", "Broken")]
        string LeaseState { get;  }
        /// <summary>The lease status of the container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The lease status of the container.",
        SerializedName = @"leaseStatus",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.PSArgumentCompleterAttribute("Locked", "Unlocked")]
        string LeaseStatus { get;  }
        /// <summary>
        /// The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public
        /// property is set to false by SRP if all existing legal hold tags are cleared out. There can be a maximum of 1000 blob containers
        /// with hasLegalHold=true for a given account.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public property is set to false by SRP if all existing legal hold tags are cleared out. There can be a maximum of 1000 blob containers with hasLegalHold=true for a given account.",
        SerializedName = @"hasLegalHold",
        PossibleTypes = new [] { typeof(bool) })]
        bool? LegalHoldHasLegalHold { get;  }
        /// <summary>The list of LegalHold tags of a blob container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The list of LegalHold tags of a blob container.",
        SerializedName = @"tags",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.ITagProperty) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.ITagProperty> LegalHoldTag { get;  }
        /// <summary>A name-value pair to associate with the container as metadata.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"A name-value pair to associate with the container as metadata.",
        SerializedName = @"metadata",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesMetadata) })]
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesMetadata Metadata { get; set; }
        /// <summary>
        /// When enabled, new blocks can be written to both 'Append and Bock Blobs' while maintaining legal hold protection and compliance.
        /// Only new blocks can be added and any existing blocks cannot be modified or deleted.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"When enabled, new blocks can be written to both 'Append and Bock Blobs' while maintaining legal hold protection and compliance. Only new blocks can be added and any existing blocks cannot be modified or deleted.",
        SerializedName = @"allowProtectedAppendWritesAll",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ProtectedAppendWriteHistoryAllowProtectedAppendWritesAll { get;  }
        /// <summary>Returns the date and time the tag was added.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Returns the date and time the tag was added.",
        SerializedName = @"timestamp",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? ProtectedAppendWriteHistoryTimestamp { get;  }
        /// <summary>
        /// Specifies whether data in the container may be accessed publicly and the level of access.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies whether data in the container may be accessed publicly and the level of access.",
        SerializedName = @"publicAccess",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.PSArgumentCompleterAttribute("Container", "Blob", "None")]
        string PublicAccess { get; set; }
        /// <summary>Remaining retention days for soft deleted blob container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Remaining retention days for soft deleted blob container.",
        SerializedName = @"remainingRetentionDays",
        PossibleTypes = new [] { typeof(int) })]
        int? RemainingRetentionDay { get;  }
        /// <summary>
        /// The ImmutabilityPolicy state of a blob container, possible values include: Locked and Unlocked.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The ImmutabilityPolicy state of a blob container, possible values include: Locked and Unlocked.",
        SerializedName = @"state",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.PSArgumentCompleterAttribute("Locked", "Unlocked")]
        string State { get;  }
        /// <summary>The version of the deleted blob container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"The version of the deleted blob container.",
        SerializedName = @"version",
        PossibleTypes = new [] { typeof(string) })]
        string Version { get;  }

    }
    /// The blob container properties be listed out.
    internal partial interface IListContainerItemInternal :
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IAzureEntityResourceInternal
    {
        /// <summary>
        /// This property can only be changed for unlocked time-based retention policies. When enabled, new blocks can be written
        /// to an append blob while maintaining immutability protection and compliance. Only new blocks can be added and any existing
        /// blocks cannot be modified or deleted. This property cannot be changed with ExtendImmutabilityPolicy API.
        /// </summary>
        bool? AllowProtectedAppendWrite { get; set; }
        /// <summary>
        /// This property can only be changed for unlocked time-based retention policies. When enabled, new blocks can be written
        /// to both 'Append and Bock Blobs' while maintaining immutability protection and compliance. Only new blocks can be added
        /// and any existing blocks cannot be modified or deleted. This property cannot be changed with ExtendImmutabilityPolicy API.
        /// The 'allowProtectedAppendWrites' and 'allowProtectedAppendWritesAll' properties are mutually exclusive.
        /// </summary>
        bool? AllowProtectedAppendWritesAll { get; set; }
        /// <summary>Default the container to use specified encryption scope for all writes.</summary>
        string DefaultEncryptionScope { get; set; }
        /// <summary>Indicates whether the blob container was deleted.</summary>
        bool? Deleted { get; set; }
        /// <summary>Blob container deletion time.</summary>
        global::System.DateTime? DeletedTime { get; set; }
        /// <summary>Block override of encryption scope from the container default.</summary>
        bool? DenyEncryptionScopeOverride { get; set; }
        /// <summary>Enable NFSv3 all squash on blob container.</summary>
        bool? EnableNfsV3AllSquash { get; set; }
        /// <summary>Enable NFSv3 root squash on blob container.</summary>
        bool? EnableNfsV3RootSquash { get; set; }
        /// <summary>
        /// The hasImmutabilityPolicy public property is set to true by SRP if ImmutabilityPolicy has been created for this container.
        /// The hasImmutabilityPolicy public property is set to false by SRP if ImmutabilityPolicy has not been created for this container.
        /// </summary>
        bool? HasImmutabilityPolicy { get; set; }
        /// <summary>
        /// The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public
        /// property is set to false by SRP if all existing legal hold tags are cleared out. There can be a maximum of 1000 blob containers
        /// with hasLegalHold=true for a given account.
        /// </summary>
        bool? HasLegalHold { get; set; }
        /// <summary>
        /// The immutability period for the blobs in the container since the policy creation, in days.
        /// </summary>
        int? ImmutabilityPeriodSinceCreationInDay { get; set; }
        /// <summary>The ImmutabilityPolicy property of the container.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IImmutabilityPolicyProperties ImmutabilityPolicy { get; set; }
        /// <summary>ImmutabilityPolicy Etag.</summary>
        string ImmutabilityPolicyEtag { get; set; }
        /// <summary>The properties of an ImmutabilityPolicy of a blob container.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IImmutabilityPolicyProperty ImmutabilityPolicyProperty { get; set; }
        /// <summary>The ImmutabilityPolicy update history of the blob container.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IUpdateHistoryProperty> ImmutabilityPolicyUpdateHistory { get; set; }
        /// <summary>
        /// The object level immutability property of the container. The property is immutable and can only be set to true at the
        /// container creation time. Existing containers must undergo a migration process.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IImmutableStorageWithVersioning ImmutableStorageWithVersioning { get; set; }
        /// <summary>
        /// This is an immutable property, when set to true it enables object level immutability at the container level.
        /// </summary>
        bool? ImmutableStorageWithVersioningEnabled { get; set; }
        /// <summary>
        /// This property denotes the container level immutability to object level immutability migration state.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.PSArgumentCompleterAttribute("InProgress", "Completed")]
        string ImmutableStorageWithVersioningMigrationState { get; set; }
        /// <summary>Returns the date and time the object level immutability was enabled.</summary>
        global::System.DateTime? ImmutableStorageWithVersioningTimeStamp { get; set; }
        /// <summary>Returns the date and time the container was last modified.</summary>
        global::System.DateTime? LastModifiedTime { get; set; }
        /// <summary>
        /// Specifies whether the lease on a container is of infinite or fixed duration, only when the container is leased.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.PSArgumentCompleterAttribute("Infinite", "Fixed")]
        string LeaseDuration { get; set; }
        /// <summary>Lease state of the container.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.PSArgumentCompleterAttribute("Available", "Leased", "Expired", "Breaking", "Broken")]
        string LeaseState { get; set; }
        /// <summary>The lease status of the container.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.PSArgumentCompleterAttribute("Locked", "Unlocked")]
        string LeaseStatus { get; set; }
        /// <summary>The LegalHold property of the container.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.ILegalHoldProperties LegalHold { get; set; }
        /// <summary>
        /// The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public
        /// property is set to false by SRP if all existing legal hold tags are cleared out. There can be a maximum of 1000 blob containers
        /// with hasLegalHold=true for a given account.
        /// </summary>
        bool? LegalHoldHasLegalHold { get; set; }
        /// <summary>Protected append blob writes history.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IProtectedAppendWritesHistory LegalHoldProtectedAppendWritesHistory { get; set; }
        /// <summary>The list of LegalHold tags of a blob container.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.ITagProperty> LegalHoldTag { get; set; }
        /// <summary>A name-value pair to associate with the container as metadata.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerPropertiesMetadata Metadata { get; set; }
        /// <summary>The blob container properties be listed out.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.IContainerProperties Property { get; set; }
        /// <summary>
        /// When enabled, new blocks can be written to both 'Append and Bock Blobs' while maintaining legal hold protection and compliance.
        /// Only new blocks can be added and any existing blocks cannot be modified or deleted.
        /// </summary>
        bool? ProtectedAppendWriteHistoryAllowProtectedAppendWritesAll { get; set; }
        /// <summary>Returns the date and time the tag was added.</summary>
        global::System.DateTime? ProtectedAppendWriteHistoryTimestamp { get; set; }
        /// <summary>
        /// Specifies whether data in the container may be accessed publicly and the level of access.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.PSArgumentCompleterAttribute("Container", "Blob", "None")]
        string PublicAccess { get; set; }
        /// <summary>Remaining retention days for soft deleted blob container.</summary>
        int? RemainingRetentionDay { get; set; }
        /// <summary>
        /// The ImmutabilityPolicy state of a blob container, possible values include: Locked and Unlocked.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.PSArgumentCompleterAttribute("Locked", "Unlocked")]
        string State { get; set; }
        /// <summary>The version of the deleted blob container.</summary>
        string Version { get; set; }

    }
}