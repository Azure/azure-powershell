// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Extensions;

    /// <summary>Web app configuration ARM resource.</summary>
    public partial class SiteConfigResource :
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResource,
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal,
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.IValidates
    {
        /// <summary>
        /// Backing field for Inherited model <see cref= "Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResource"
        /// />
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResource __proxyOnlyResource = new Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.ProxyOnlyResource();

        /// <summary>Flag to use Managed Identity Creds for ACR pull</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? AcrUseManagedIdentityCred { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AcrUseManagedIdentityCred; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AcrUseManagedIdentityCred = value ?? default(bool); }

        /// <summary>If using user managed identity, the user managed identity ClientId</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string AcrUserManagedIdentityId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AcrUserManagedIdentityId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AcrUserManagedIdentityId = value ?? null; }

        /// <summary>
        /// Minimum time the process must execute
        /// before taking the action
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string ActionMinProcessExecutionTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ActionMinProcessExecutionTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ActionMinProcessExecutionTime = value ?? null; }

        /// <summary>Predefined action to be taken.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.AutoHealActionType? ActionType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ActionType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ActionType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.AutoHealActionType)""); }

        /// <summary><code>true</code> if Always On is enabled; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? AlwaysOn { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AlwaysOn; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AlwaysOn = value ?? default(bool); }

        /// <summary>The URL of the API definition.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string ApiDefinitionUrl { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ApiDefinitionUrl; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ApiDefinitionUrl = value ?? null; }

        /// <summary>APIM-Api Identifier.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string ApiManagementConfigId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ApiManagementConfigId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ApiManagementConfigId = value ?? null; }

        /// <summary>App command line to launch.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string AppCommandLine { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AppCommandLine; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AppCommandLine = value ?? null; }

        /// <summary>Application settings.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.INameValuePair[] AppSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AppSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AppSetting = value ?? null /* arrayOf */; }

        /// <summary><code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? AutoHealEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AutoHealEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AutoHealEnabled = value ?? default(bool); }

        /// <summary>Auto-swap slot name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string AutoSwapSlotName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AutoSwapSlotName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AutoSwapSlotName = value ?? null; }

        /// <summary>List of Azure Storage Accounts.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigAzureStorageAccounts AzureStorageAccount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AzureStorageAccount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AzureStorageAccount = value ?? null /* model class */; }

        /// <summary>Connection strings.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IConnStringInfo[] ConnectionString { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ConnectionString; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ConnectionString = value ?? null /* arrayOf */; }

        /// <summary>
        /// Gets or sets the list of origins that should be allowed to make cross-origin
        /// calls (for example: http://example.com:12345). Use "*" to allow all.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string[] CorAllowedOrigin { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).CorAllowedOrigin; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).CorAllowedOrigin = value ?? null /* arrayOf */; }

        /// <summary>
        /// Gets or sets whether CORS requests with credentials are allowed. See
        /// https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
        /// for more details.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? CorSupportCredentials { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).CorSupportCredentials; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).CorSupportCredentials = value ?? default(bool); }

        /// <summary>Executable to be run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string CustomActionExe { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).CustomActionExe; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).CustomActionExe = value ?? null; }

        /// <summary>Parameters for the executable.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string CustomActionParameter { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).CustomActionParameter; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).CustomActionParameter = value ?? null; }

        /// <summary>Default documents.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string[] DefaultDocument { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).DefaultDocument; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).DefaultDocument = value ?? null /* arrayOf */; }

        /// <summary>
        /// <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? DetailedErrorLoggingEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).DetailedErrorLoggingEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).DetailedErrorLoggingEnabled = value ?? default(bool); }

        /// <summary>Document root.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string DocumentRoot { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).DocumentRoot; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).DocumentRoot = value ?? null; }

        /// <summary>
        /// Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in the push registration
        /// endpoint.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string DynamicTagsJson { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).DynamicTagsJson; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).DynamicTagsJson = value ?? null; }

        /// <summary>List of ramp-up rules.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IRampUpRule[] ExperimentRampUpRule { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ExperimentRampUpRule; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ExperimentRampUpRule = value ?? null /* arrayOf */; }

        /// <summary>State of FTP / FTPS service</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.FtpsState? FtpsState { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).FtpsState; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).FtpsState = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.FtpsState)""); }

        /// <summary>
        /// Maximum number of workers that a site can scale out to.
        /// This setting only applies to the Consumption and Elastic Premium Plans
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public int? FunctionAppScaleLimit { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).FunctionAppScaleLimit; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).FunctionAppScaleLimit = value ?? default(int); }

        /// <summary>
        /// Gets or sets a value indicating whether functions runtime scale monitoring is enabled. When enabled,
        /// the ScaleController will not monitor event sources directly, but will instead call to the
        /// runtime to get scale status.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? FunctionsRuntimeScaleMonitoringEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).FunctionsRuntimeScaleMonitoringEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).FunctionsRuntimeScaleMonitoringEnabled = value ?? default(bool); }

        /// <summary>Handler mappings.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IHandlerMapping[] HandlerMapping { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).HandlerMapping; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).HandlerMapping = value ?? null /* arrayOf */; }

        /// <summary>Health check path</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string HealthCheckPath { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).HealthCheckPath; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).HealthCheckPath = value ?? null; }

        /// <summary>Http20Enabled: configures a web site to allow clients to connect over http2.0</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? Http20Enabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).Http20Enabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).Http20Enabled = value ?? default(bool); }

        /// <summary><code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? HttpLoggingEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).HttpLoggingEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).HttpLoggingEnabled = value ?? default(bool); }

        /// <summary>IP security restrictions for main.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IIPSecurityRestriction[] IPSecurityRestriction { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).IPSecurityRestriction; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).IPSecurityRestriction = value ?? null /* arrayOf */; }

        /// <summary>Resource Id.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inherited)]
        public string Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResourceInternal)__proxyOnlyResource).Id; }

        /// <summary>Gets or sets a flag indicating whether the Push endpoint is enabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? IsPushEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).IsPushEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).IsPushEnabled = value ?? default(bool); }

        /// <summary>Java container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string JavaContainer { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).JavaContainer; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).JavaContainer = value ?? null; }

        /// <summary>Java container version.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string JavaContainerVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).JavaContainerVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).JavaContainerVersion = value ?? null; }

        /// <summary>Java version.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string JavaVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).JavaVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).JavaVersion = value ?? null; }

        /// <summary>Identity to use for Key Vault Reference authentication.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string KeyVaultReferenceIdentity { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).KeyVaultReferenceIdentity; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).KeyVaultReferenceIdentity = value ?? null; }

        /// <summary>Kind of resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inherited)]
        public string Kind { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResourceInternal)__proxyOnlyResource).Kind; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResourceInternal)__proxyOnlyResource).Kind = value ?? null; }

        /// <summary>Maximum allowed disk size usage in MB.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public long? LimitMaxDiskSizeInMb { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).LimitMaxDiskSizeInMb; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).LimitMaxDiskSizeInMb = value ?? default(long); }

        /// <summary>Maximum allowed memory usage in MB.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public long? LimitMaxMemoryInMb { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).LimitMaxMemoryInMb; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).LimitMaxMemoryInMb = value ?? default(long); }

        /// <summary>Maximum allowed CPU usage percentage.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public double? LimitMaxPercentageCpu { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).LimitMaxPercentageCpu; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).LimitMaxPercentageCpu = value ?? default(double); }

        /// <summary>Linux App Framework and version</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string LinuxFxVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).LinuxFxVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).LinuxFxVersion = value ?? null; }

        /// <summary>Site load balancing.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.SiteLoadBalancing? LoadBalancing { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).LoadBalancing; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).LoadBalancing = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.SiteLoadBalancing)""); }

        /// <summary><code>true</code> to enable local MySQL; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? LocalMySqlEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).LocalMySqlEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).LocalMySqlEnabled = value ?? default(bool); }

        /// <summary>HTTP logs directory size limit.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public int? LogsDirectorySizeLimit { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).LogsDirectorySizeLimit; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).LogsDirectorySizeLimit = value ?? default(int); }

        /// <summary>Algorithm used for decryption.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string MachineKeyDecryption { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).MachineKeyDecryption; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).MachineKeyDecryption = value ?? null; }

        /// <summary>Decryption key.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string MachineKeyDecryptionKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).MachineKeyDecryptionKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).MachineKeyDecryptionKey = value ?? null; }

        /// <summary>MachineKey validation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string MachineKeyValidation { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).MachineKeyValidation; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).MachineKeyValidation = value ?? null; }

        /// <summary>Validation key.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string MachineKeyValidationKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).MachineKeyValidationKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).MachineKeyValidationKey = value ?? null; }

        /// <summary>Managed pipeline mode.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.ManagedPipelineMode? ManagedPipelineMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ManagedPipelineMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ManagedPipelineMode = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.ManagedPipelineMode)""); }

        /// <summary>Managed Service Identity Id</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public int? ManagedServiceIdentityId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ManagedServiceIdentityId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ManagedServiceIdentityId = value ?? default(int); }

        /// <summary>Internal Acessors for Id</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResourceInternal.Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResourceInternal)__proxyOnlyResource).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResourceInternal)__proxyOnlyResource).Id = value; }

        /// <summary>Internal Acessors for Name</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResourceInternal.Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResourceInternal)__proxyOnlyResource).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResourceInternal)__proxyOnlyResource).Name = value; }

        /// <summary>Internal Acessors for Type</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResourceInternal.Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResourceInternal)__proxyOnlyResource).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResourceInternal)__proxyOnlyResource).Type = value; }

        /// <summary>Internal Acessors for ActionCustomAction</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IAutoHealCustomAction Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.ActionCustomAction { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ActionCustomAction; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ActionCustomAction = value; }

        /// <summary>Internal Acessors for ApiDefinition</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IApiDefinitionInfo Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.ApiDefinition { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ApiDefinition; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ApiDefinition = value; }

        /// <summary>Internal Acessors for ApiManagementConfig</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IApiManagementConfig Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.ApiManagementConfig { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ApiManagementConfig; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ApiManagementConfig = value; }

        /// <summary>Internal Acessors for AutoHealRule</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IAutoHealRules Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.AutoHealRule { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AutoHealRule; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AutoHealRule = value; }

        /// <summary>Internal Acessors for AutoHealRuleAction</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IAutoHealActions Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.AutoHealRuleAction { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AutoHealRuleAction; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AutoHealRuleAction = value; }

        /// <summary>Internal Acessors for AutoHealRuleTrigger</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IAutoHealTriggers Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.AutoHealRuleTrigger { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AutoHealRuleTrigger; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).AutoHealRuleTrigger = value; }

        /// <summary>Internal Acessors for Cor</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ICorsSettings Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.Cor { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).Cor; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).Cor = value; }

        /// <summary>Internal Acessors for Experiment</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IExperiments Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.Experiment { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).Experiment; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).Experiment = value; }

        /// <summary>Internal Acessors for Limit</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteLimits Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.Limit { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).Limit; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).Limit = value; }

        /// <summary>Internal Acessors for MachineKey</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteMachineKey Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.MachineKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).MachineKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).MachineKey = value; }

        /// <summary>Internal Acessors for Property</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfig Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.SiteConfig()); set { {_property = value;} } }

        /// <summary>Internal Acessors for Push</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IPushSettings Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.Push { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).Push; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).Push = value; }

        /// <summary>Internal Acessors for PushId</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.PushId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PushId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PushId = value; }

        /// <summary>Internal Acessors for PushName</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.PushName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PushName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PushName = value; }

        /// <summary>Internal Acessors for PushProperty</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IPushSettingsProperties Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.PushProperty { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PushProperty; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PushProperty = value; }

        /// <summary>Internal Acessors for PushType</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.PushType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PushType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PushType = value; }

        /// <summary>Internal Acessors for TriggerRequest</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IRequestsBasedTrigger Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.TriggerRequest { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TriggerRequest; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TriggerRequest = value; }

        /// <summary>Internal Acessors for TriggerSlowRequest</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISlowRequestsBasedTrigger Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigResourceInternal.TriggerSlowRequest { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TriggerSlowRequest; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TriggerSlowRequest = value; }

        /// <summary>MinTlsVersion: configures the minimum version of TLS required for SSL requests</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.SupportedTlsVersions? MinTlsVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).MinTlsVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).MinTlsVersion = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.SupportedTlsVersions)""); }

        /// <summary>
        /// Number of minimum instance count for a site
        /// This setting only applies to the Elastic Plans
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public int? MinimumElasticInstanceCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).MinimumElasticInstanceCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).MinimumElasticInstanceCount = value ?? default(int); }

        /// <summary>Resource Name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inherited)]
        public string Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResourceInternal)__proxyOnlyResource).Name; }

        /// <summary>.NET Framework version.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string NetFrameworkVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).NetFrameworkVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).NetFrameworkVersion = value ?? null; }

        /// <summary>Version of Node.js.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string NodeVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).NodeVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).NodeVersion = value ?? null; }

        /// <summary>Number of workers.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public int? NumberOfWorker { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).NumberOfWorker; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).NumberOfWorker = value ?? default(int); }

        /// <summary>Version of PHP.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string PhpVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PhpVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PhpVersion = value ?? null; }

        /// <summary>Version of PowerShell.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string PowerShellVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PowerShellVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PowerShellVersion = value ?? null; }

        /// <summary>
        /// Number of preWarmed instances.
        /// This setting only applies to the Consumption and Elastic Plans
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public int? PreWarmedInstanceCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PreWarmedInstanceCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PreWarmedInstanceCount = value ?? default(int); }

        /// <summary>Backing field for <see cref="Property" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfig _property;

        /// <summary>Core resource properties</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfig Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.SiteConfig()); set => this._property = value; }

        /// <summary>Property to allow or block all public traffic.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string PublicNetworkAccess { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PublicNetworkAccess; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PublicNetworkAccess = value ?? null; }

        /// <summary>Publishing user name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string PublishingUsername { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PublishingUsername; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PublishingUsername = value ?? null; }

        /// <summary>Resource Id.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string PushId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PushId; }

        /// <summary>Kind of resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string PushKind { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PushKind; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PushKind = value ?? null; }

        /// <summary>Resource Name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string PushName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PushName; }

        /// <summary>Resource type.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string PushType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PushType; }

        /// <summary>Version of Python.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string PythonVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PythonVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).PythonVersion = value ?? null; }

        /// <summary>
        /// <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? RemoteDebuggingEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).RemoteDebuggingEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).RemoteDebuggingEnabled = value ?? default(bool); }

        /// <summary>Remote debugging version.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string RemoteDebuggingVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).RemoteDebuggingVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).RemoteDebuggingVersion = value ?? null; }

        /// <summary>Request Count.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public int? RequestCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).RequestCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).RequestCount = value ?? default(int); }

        /// <summary>Time interval.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string RequestTimeInterval { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).RequestTimeInterval; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).RequestTimeInterval = value ?? null; }

        /// <summary><code>true</code> if request tracing is enabled; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? RequestTracingEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).RequestTracingEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).RequestTracingEnabled = value ?? default(bool); }

        /// <summary>Request tracing expiration time.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public global::System.DateTime? RequestTracingExpirationTime { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).RequestTracingExpirationTime; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).RequestTracingExpirationTime = value ?? default(global::System.DateTime); }

        /// <summary>IP security restrictions for scm.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IIPSecurityRestriction[] ScmIPSecurityRestriction { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ScmIPSecurityRestriction; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ScmIPSecurityRestriction = value ?? null /* arrayOf */; }

        /// <summary>IP security restrictions for scm to use main.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? ScmIPSecurityRestrictionsUseMain { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ScmIPSecurityRestrictionsUseMain; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ScmIPSecurityRestrictionsUseMain = value ?? default(bool); }

        /// <summary>
        /// ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.SupportedTlsVersions? ScmMinTlsVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ScmMinTlsVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ScmMinTlsVersion = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.SupportedTlsVersions)""); }

        /// <summary>SCM type.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.ScmType? ScmType { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ScmType; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).ScmType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.ScmType)""); }

        /// <summary>Request Count.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public int? SlowRequestCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).SlowRequestCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).SlowRequestCount = value ?? default(int); }

        /// <summary>Request Path.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string SlowRequestPath { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).SlowRequestPath; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).SlowRequestPath = value ?? null; }

        /// <summary>Time interval.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string SlowRequestTimeInterval { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).SlowRequestTimeInterval; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).SlowRequestTimeInterval = value ?? null; }

        /// <summary>Time taken.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string SlowRequestTimeTaken { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).SlowRequestTimeTaken; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).SlowRequestTimeTaken = value ?? null; }

        /// <summary>
        /// Gets or sets a JSON string containing a list of tags that are whitelisted for use by the push registration endpoint.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string TagWhitelistJson { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TagWhitelistJson; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TagWhitelistJson = value ?? null; }

        /// <summary>
        /// Gets or sets a JSON string containing a list of tags that require user authentication to be used in the push registration
        /// endpoint.
        /// Tags can consist of alphanumeric characters and the following:
        /// '_', '@', '#', '.', ':', '-'.
        /// Validation should be performed at the PushRequestHandler.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string TagsRequiringAuth { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TagsRequiringAuth; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TagsRequiringAuth = value ?? null; }

        /// <summary>Tracing options.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string TracingOption { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TracingOption; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TracingOption = value ?? null; }

        /// <summary>A rule based on private bytes.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public int? TriggerPrivateBytesInKb { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TriggerPrivateBytesInKb; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TriggerPrivateBytesInKb = value ?? default(int); }

        /// <summary>A rule based on multiple Slow Requests Rule with path</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISlowRequestsBasedTrigger[] TriggerSlowRequestsWithPath { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TriggerSlowRequestsWithPath; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TriggerSlowRequestsWithPath = value ?? null /* arrayOf */; }

        /// <summary>A rule based on status codes.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IStatusCodesBasedTrigger[] TriggerStatusCode { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TriggerStatusCode; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TriggerStatusCode = value ?? null /* arrayOf */; }

        /// <summary>A rule based on status codes ranges.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IStatusCodesRangeBasedTrigger[] TriggerStatusCodesRange { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TriggerStatusCodesRange; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).TriggerStatusCodesRange = value ?? null /* arrayOf */; }

        /// <summary>Resource type.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inherited)]
        public string Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResourceInternal)__proxyOnlyResource).Type; }

        /// <summary><code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? Use32BitWorkerProcess { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).Use32BitWorkerProcess; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).Use32BitWorkerProcess = value ?? default(bool); }

        /// <summary>Virtual applications.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IVirtualApplication[] VirtualApplication { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).VirtualApplication; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).VirtualApplication = value ?? null /* arrayOf */; }

        /// <summary>Virtual Network name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string VnetName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).VnetName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).VnetName = value ?? null; }

        /// <summary>
        /// The number of private ports assigned to this app. These will be assigned dynamically on runtime.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public int? VnetPrivatePortsCount { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).VnetPrivatePortsCount; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).VnetPrivatePortsCount = value ?? default(int); }

        /// <summary>
        /// Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined
        /// Routes applied.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? VnetRouteAllEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).VnetRouteAllEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).VnetRouteAllEnabled = value ?? default(bool); }

        /// <summary><code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public bool? WebSocketsEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).WebSocketsEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).WebSocketsEnabled = value ?? default(bool); }

        /// <summary>
        /// Sets the time zone a site uses for generating timestamps. Compatible with Linux and Windows App Service. Setting the WEBSITE_TIME_ZONE
        /// app setting takes precedence over this config. For Linux, expects tz database values https://www.iana.org/time-zones (for
        /// a quick reference see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For Windows, expects one of the time
        /// zones listed under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string WebsiteTimeZone { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).WebsiteTimeZone; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).WebsiteTimeZone = value ?? null; }

        /// <summary>Xenon App Framework and version</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public string WindowsFxVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).WindowsFxVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).WindowsFxVersion = value ?? null; }

        /// <summary>Explicit Managed Service Identity Id</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Origin(Microsoft.Azure.PowerShell.Cmdlets.Websites.PropertyOrigin.Inlined)]
        public int? XManagedServiceIdentityId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).XManagedServiceIdentityId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigInternal)Property).XManagedServiceIdentityId = value ?? default(int); }

        /// <summary>Creates an new <see cref="SiteConfigResource" /> instance.</summary>
        public SiteConfigResource()
        {

        }

        /// <summary>Validates that this object meets the validation criteria.</summary>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.IEventListener" /> instance that will receive validation
        /// events.</param>
        /// <returns>
        /// A <see cref = "global::System.Threading.Tasks.Task" /> that will be complete when validation is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task Validate(Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.IEventListener eventListener)
        {
            await eventListener.AssertNotNull(nameof(__proxyOnlyResource), __proxyOnlyResource);
            await eventListener.AssertObjectIsValid(nameof(__proxyOnlyResource), __proxyOnlyResource);
        }
    }
    /// Web app configuration ARM resource.
    public partial interface ISiteConfigResource :
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.IJsonSerializable,
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResource
    {
        /// <summary>Flag to use Managed Identity Creds for ACR pull</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Flag to use Managed Identity Creds for ACR pull",
        SerializedName = @"acrUseManagedIdentityCreds",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AcrUseManagedIdentityCred { get; set; }
        /// <summary>If using user managed identity, the user managed identity ClientId</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If using user managed identity, the user managed identity ClientId",
        SerializedName = @"acrUserManagedIdentityID",
        PossibleTypes = new [] { typeof(string) })]
        string AcrUserManagedIdentityId { get; set; }
        /// <summary>
        /// Minimum time the process must execute
        /// before taking the action
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Minimum time the process must execute
        before taking the action",
        SerializedName = @"minProcessExecutionTime",
        PossibleTypes = new [] { typeof(string) })]
        string ActionMinProcessExecutionTime { get; set; }
        /// <summary>Predefined action to be taken.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Predefined action to be taken.",
        SerializedName = @"actionType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.AutoHealActionType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.AutoHealActionType? ActionType { get; set; }
        /// <summary><code>true</code> if Always On is enabled; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> if Always On is enabled; otherwise, <code>false</code>.",
        SerializedName = @"alwaysOn",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AlwaysOn { get; set; }
        /// <summary>The URL of the API definition.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The URL of the API definition.",
        SerializedName = @"url",
        PossibleTypes = new [] { typeof(string) })]
        string ApiDefinitionUrl { get; set; }
        /// <summary>APIM-Api Identifier.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"APIM-Api Identifier.",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(string) })]
        string ApiManagementConfigId { get; set; }
        /// <summary>App command line to launch.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"App command line to launch.",
        SerializedName = @"appCommandLine",
        PossibleTypes = new [] { typeof(string) })]
        string AppCommandLine { get; set; }
        /// <summary>Application settings.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Application settings.",
        SerializedName = @"appSettings",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.INameValuePair) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.INameValuePair[] AppSetting { get; set; }
        /// <summary><code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.",
        SerializedName = @"autoHealEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? AutoHealEnabled { get; set; }
        /// <summary>Auto-swap slot name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Auto-swap slot name.",
        SerializedName = @"autoSwapSlotName",
        PossibleTypes = new [] { typeof(string) })]
        string AutoSwapSlotName { get; set; }
        /// <summary>List of Azure Storage Accounts.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"List of Azure Storage Accounts.",
        SerializedName = @"azureStorageAccounts",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigAzureStorageAccounts) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigAzureStorageAccounts AzureStorageAccount { get; set; }
        /// <summary>Connection strings.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Connection strings.",
        SerializedName = @"connectionStrings",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IConnStringInfo) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IConnStringInfo[] ConnectionString { get; set; }
        /// <summary>
        /// Gets or sets the list of origins that should be allowed to make cross-origin
        /// calls (for example: http://example.com:12345). Use "*" to allow all.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets the list of origins that should be allowed to make cross-origin
        calls (for example: http://example.com:12345). Use ""*"" to allow all.",
        SerializedName = @"allowedOrigins",
        PossibleTypes = new [] { typeof(string) })]
        string[] CorAllowedOrigin { get; set; }
        /// <summary>
        /// Gets or sets whether CORS requests with credentials are allowed. See
        /// https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
        /// for more details.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets whether CORS requests with credentials are allowed. See
        https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
        for more details.",
        SerializedName = @"supportCredentials",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CorSupportCredentials { get; set; }
        /// <summary>Executable to be run.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Executable to be run.",
        SerializedName = @"exe",
        PossibleTypes = new [] { typeof(string) })]
        string CustomActionExe { get; set; }
        /// <summary>Parameters for the executable.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Parameters for the executable.",
        SerializedName = @"parameters",
        PossibleTypes = new [] { typeof(string) })]
        string CustomActionParameter { get; set; }
        /// <summary>Default documents.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Default documents.",
        SerializedName = @"defaultDocuments",
        PossibleTypes = new [] { typeof(string) })]
        string[] DefaultDocument { get; set; }
        /// <summary>
        /// <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.",
        SerializedName = @"detailedErrorLoggingEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? DetailedErrorLoggingEnabled { get; set; }
        /// <summary>Document root.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Document root.",
        SerializedName = @"documentRoot",
        PossibleTypes = new [] { typeof(string) })]
        string DocumentRoot { get; set; }
        /// <summary>
        /// Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in the push registration
        /// endpoint.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in the push registration endpoint.",
        SerializedName = @"dynamicTagsJson",
        PossibleTypes = new [] { typeof(string) })]
        string DynamicTagsJson { get; set; }
        /// <summary>List of ramp-up rules.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"List of ramp-up rules.",
        SerializedName = @"rampUpRules",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IRampUpRule) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IRampUpRule[] ExperimentRampUpRule { get; set; }
        /// <summary>State of FTP / FTPS service</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"State of FTP / FTPS service",
        SerializedName = @"ftpsState",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.FtpsState) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.FtpsState? FtpsState { get; set; }
        /// <summary>
        /// Maximum number of workers that a site can scale out to.
        /// This setting only applies to the Consumption and Elastic Premium Plans
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Maximum number of workers that a site can scale out to.
        This setting only applies to the Consumption and Elastic Premium Plans",
        SerializedName = @"functionAppScaleLimit",
        PossibleTypes = new [] { typeof(int) })]
        int? FunctionAppScaleLimit { get; set; }
        /// <summary>
        /// Gets or sets a value indicating whether functions runtime scale monitoring is enabled. When enabled,
        /// the ScaleController will not monitor event sources directly, but will instead call to the
        /// runtime to get scale status.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets a value indicating whether functions runtime scale monitoring is enabled. When enabled,
        the ScaleController will not monitor event sources directly, but will instead call to the
        runtime to get scale status.",
        SerializedName = @"functionsRuntimeScaleMonitoringEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? FunctionsRuntimeScaleMonitoringEnabled { get; set; }
        /// <summary>Handler mappings.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Handler mappings.",
        SerializedName = @"handlerMappings",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IHandlerMapping) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IHandlerMapping[] HandlerMapping { get; set; }
        /// <summary>Health check path</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Health check path",
        SerializedName = @"healthCheckPath",
        PossibleTypes = new [] { typeof(string) })]
        string HealthCheckPath { get; set; }
        /// <summary>Http20Enabled: configures a web site to allow clients to connect over http2.0</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Http20Enabled: configures a web site to allow clients to connect over http2.0",
        SerializedName = @"http20Enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? Http20Enabled { get; set; }
        /// <summary><code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.",
        SerializedName = @"httpLoggingEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? HttpLoggingEnabled { get; set; }
        /// <summary>IP security restrictions for main.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"IP security restrictions for main.",
        SerializedName = @"ipSecurityRestrictions",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IIPSecurityRestriction) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IIPSecurityRestriction[] IPSecurityRestriction { get; set; }
        /// <summary>Gets or sets a flag indicating whether the Push endpoint is enabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets a flag indicating whether the Push endpoint is enabled.",
        SerializedName = @"isPushEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? IsPushEnabled { get; set; }
        /// <summary>Java container.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Java container.",
        SerializedName = @"javaContainer",
        PossibleTypes = new [] { typeof(string) })]
        string JavaContainer { get; set; }
        /// <summary>Java container version.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Java container version.",
        SerializedName = @"javaContainerVersion",
        PossibleTypes = new [] { typeof(string) })]
        string JavaContainerVersion { get; set; }
        /// <summary>Java version.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Java version.",
        SerializedName = @"javaVersion",
        PossibleTypes = new [] { typeof(string) })]
        string JavaVersion { get; set; }
        /// <summary>Identity to use for Key Vault Reference authentication.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Identity to use for Key Vault Reference authentication.",
        SerializedName = @"keyVaultReferenceIdentity",
        PossibleTypes = new [] { typeof(string) })]
        string KeyVaultReferenceIdentity { get; set; }
        /// <summary>Maximum allowed disk size usage in MB.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Maximum allowed disk size usage in MB.",
        SerializedName = @"maxDiskSizeInMb",
        PossibleTypes = new [] { typeof(long) })]
        long? LimitMaxDiskSizeInMb { get; set; }
        /// <summary>Maximum allowed memory usage in MB.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Maximum allowed memory usage in MB.",
        SerializedName = @"maxMemoryInMb",
        PossibleTypes = new [] { typeof(long) })]
        long? LimitMaxMemoryInMb { get; set; }
        /// <summary>Maximum allowed CPU usage percentage.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Maximum allowed CPU usage percentage.",
        SerializedName = @"maxPercentageCpu",
        PossibleTypes = new [] { typeof(double) })]
        double? LimitMaxPercentageCpu { get; set; }
        /// <summary>Linux App Framework and version</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Linux App Framework and version",
        SerializedName = @"linuxFxVersion",
        PossibleTypes = new [] { typeof(string) })]
        string LinuxFxVersion { get; set; }
        /// <summary>Site load balancing.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Site load balancing.",
        SerializedName = @"loadBalancing",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.SiteLoadBalancing) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.SiteLoadBalancing? LoadBalancing { get; set; }
        /// <summary><code>true</code> to enable local MySQL; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to enable local MySQL; otherwise, <code>false</code>.",
        SerializedName = @"localMySqlEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? LocalMySqlEnabled { get; set; }
        /// <summary>HTTP logs directory size limit.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"HTTP logs directory size limit.",
        SerializedName = @"logsDirectorySizeLimit",
        PossibleTypes = new [] { typeof(int) })]
        int? LogsDirectorySizeLimit { get; set; }
        /// <summary>Algorithm used for decryption.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Algorithm used for decryption.",
        SerializedName = @"decryption",
        PossibleTypes = new [] { typeof(string) })]
        string MachineKeyDecryption { get; set; }
        /// <summary>Decryption key.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Decryption key.",
        SerializedName = @"decryptionKey",
        PossibleTypes = new [] { typeof(string) })]
        string MachineKeyDecryptionKey { get; set; }
        /// <summary>MachineKey validation.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"MachineKey validation.",
        SerializedName = @"validation",
        PossibleTypes = new [] { typeof(string) })]
        string MachineKeyValidation { get; set; }
        /// <summary>Validation key.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Validation key.",
        SerializedName = @"validationKey",
        PossibleTypes = new [] { typeof(string) })]
        string MachineKeyValidationKey { get; set; }
        /// <summary>Managed pipeline mode.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Managed pipeline mode.",
        SerializedName = @"managedPipelineMode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.ManagedPipelineMode) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.ManagedPipelineMode? ManagedPipelineMode { get; set; }
        /// <summary>Managed Service Identity Id</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Managed Service Identity Id",
        SerializedName = @"managedServiceIdentityId",
        PossibleTypes = new [] { typeof(int) })]
        int? ManagedServiceIdentityId { get; set; }
        /// <summary>MinTlsVersion: configures the minimum version of TLS required for SSL requests</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"MinTlsVersion: configures the minimum version of TLS required for SSL requests",
        SerializedName = @"minTlsVersion",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.SupportedTlsVersions) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.SupportedTlsVersions? MinTlsVersion { get; set; }
        /// <summary>
        /// Number of minimum instance count for a site
        /// This setting only applies to the Elastic Plans
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of minimum instance count for a site
        This setting only applies to the Elastic Plans",
        SerializedName = @"minimumElasticInstanceCount",
        PossibleTypes = new [] { typeof(int) })]
        int? MinimumElasticInstanceCount { get; set; }
        /// <summary>.NET Framework version.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @".NET Framework version.",
        SerializedName = @"netFrameworkVersion",
        PossibleTypes = new [] { typeof(string) })]
        string NetFrameworkVersion { get; set; }
        /// <summary>Version of Node.js.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Version of Node.js.",
        SerializedName = @"nodeVersion",
        PossibleTypes = new [] { typeof(string) })]
        string NodeVersion { get; set; }
        /// <summary>Number of workers.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of workers.",
        SerializedName = @"numberOfWorkers",
        PossibleTypes = new [] { typeof(int) })]
        int? NumberOfWorker { get; set; }
        /// <summary>Version of PHP.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Version of PHP.",
        SerializedName = @"phpVersion",
        PossibleTypes = new [] { typeof(string) })]
        string PhpVersion { get; set; }
        /// <summary>Version of PowerShell.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Version of PowerShell.",
        SerializedName = @"powerShellVersion",
        PossibleTypes = new [] { typeof(string) })]
        string PowerShellVersion { get; set; }
        /// <summary>
        /// Number of preWarmed instances.
        /// This setting only applies to the Consumption and Elastic Plans
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of preWarmed instances.
        This setting only applies to the Consumption and Elastic Plans",
        SerializedName = @"preWarmedInstanceCount",
        PossibleTypes = new [] { typeof(int) })]
        int? PreWarmedInstanceCount { get; set; }
        /// <summary>Property to allow or block all public traffic.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Property to allow or block all public traffic.",
        SerializedName = @"publicNetworkAccess",
        PossibleTypes = new [] { typeof(string) })]
        string PublicNetworkAccess { get; set; }
        /// <summary>Publishing user name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Publishing user name.",
        SerializedName = @"publishingUsername",
        PossibleTypes = new [] { typeof(string) })]
        string PublishingUsername { get; set; }
        /// <summary>Resource Id.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Resource Id.",
        SerializedName = @"ResourceGroupName",
        PossibleTypes = new [] { typeof(string) })]
        string PushId { get;  }
        /// <summary>Kind of resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Kind of resource.",
        SerializedName = @"kind",
        PossibleTypes = new [] { typeof(string) })]
        string PushKind { get; set; }
        /// <summary>Resource Name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Resource Name.",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string PushName { get;  }
        /// <summary>Resource type.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Resource type.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(string) })]
        string PushType { get;  }
        /// <summary>Version of Python.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Version of Python.",
        SerializedName = @"pythonVersion",
        PossibleTypes = new [] { typeof(string) })]
        string PythonVersion { get; set; }
        /// <summary>
        /// <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.",
        SerializedName = @"remoteDebuggingEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? RemoteDebuggingEnabled { get; set; }
        /// <summary>Remote debugging version.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Remote debugging version.",
        SerializedName = @"remoteDebuggingVersion",
        PossibleTypes = new [] { typeof(string) })]
        string RemoteDebuggingVersion { get; set; }
        /// <summary>Request Count.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Request Count.",
        SerializedName = @"count",
        PossibleTypes = new [] { typeof(int) })]
        int? RequestCount { get; set; }
        /// <summary>Time interval.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Time interval.",
        SerializedName = @"timeInterval",
        PossibleTypes = new [] { typeof(string) })]
        string RequestTimeInterval { get; set; }
        /// <summary><code>true</code> if request tracing is enabled; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> if request tracing is enabled; otherwise, <code>false</code>.",
        SerializedName = @"requestTracingEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? RequestTracingEnabled { get; set; }
        /// <summary>Request tracing expiration time.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Request tracing expiration time.",
        SerializedName = @"requestTracingExpirationTime",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? RequestTracingExpirationTime { get; set; }
        /// <summary>IP security restrictions for scm.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"IP security restrictions for scm.",
        SerializedName = @"scmIpSecurityRestrictions",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IIPSecurityRestriction) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IIPSecurityRestriction[] ScmIPSecurityRestriction { get; set; }
        /// <summary>IP security restrictions for scm to use main.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"IP security restrictions for scm to use main.",
        SerializedName = @"scmIpSecurityRestrictionsUseMain",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ScmIPSecurityRestrictionsUseMain { get; set; }
        /// <summary>
        /// ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site",
        SerializedName = @"scmMinTlsVersion",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.SupportedTlsVersions) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.SupportedTlsVersions? ScmMinTlsVersion { get; set; }
        /// <summary>SCM type.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"SCM type.",
        SerializedName = @"scmType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.ScmType) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.ScmType? ScmType { get; set; }
        /// <summary>Request Count.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Request Count.",
        SerializedName = @"count",
        PossibleTypes = new [] { typeof(int) })]
        int? SlowRequestCount { get; set; }
        /// <summary>Request Path.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Request Path.",
        SerializedName = @"path",
        PossibleTypes = new [] { typeof(string) })]
        string SlowRequestPath { get; set; }
        /// <summary>Time interval.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Time interval.",
        SerializedName = @"timeInterval",
        PossibleTypes = new [] { typeof(string) })]
        string SlowRequestTimeInterval { get; set; }
        /// <summary>Time taken.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Time taken.",
        SerializedName = @"timeTaken",
        PossibleTypes = new [] { typeof(string) })]
        string SlowRequestTimeTaken { get; set; }
        /// <summary>
        /// Gets or sets a JSON string containing a list of tags that are whitelisted for use by the push registration endpoint.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets a JSON string containing a list of tags that are whitelisted for use by the push registration endpoint.",
        SerializedName = @"tagWhitelistJson",
        PossibleTypes = new [] { typeof(string) })]
        string TagWhitelistJson { get; set; }
        /// <summary>
        /// Gets or sets a JSON string containing a list of tags that require user authentication to be used in the push registration
        /// endpoint.
        /// Tags can consist of alphanumeric characters and the following:
        /// '_', '@', '#', '.', ':', '-'.
        /// Validation should be performed at the PushRequestHandler.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets a JSON string containing a list of tags that require user authentication to be used in the push registration endpoint.
        Tags can consist of alphanumeric characters and the following:
        '_', '@', '#', '.', ':', '-'.
        Validation should be performed at the PushRequestHandler.",
        SerializedName = @"tagsRequiringAuth",
        PossibleTypes = new [] { typeof(string) })]
        string TagsRequiringAuth { get; set; }
        /// <summary>Tracing options.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Tracing options.",
        SerializedName = @"tracingOptions",
        PossibleTypes = new [] { typeof(string) })]
        string TracingOption { get; set; }
        /// <summary>A rule based on private bytes.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A rule based on private bytes.",
        SerializedName = @"privateBytesInKB",
        PossibleTypes = new [] { typeof(int) })]
        int? TriggerPrivateBytesInKb { get; set; }
        /// <summary>A rule based on multiple Slow Requests Rule with path</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A rule based on multiple Slow Requests Rule with path",
        SerializedName = @"slowRequestsWithPath",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISlowRequestsBasedTrigger) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISlowRequestsBasedTrigger[] TriggerSlowRequestsWithPath { get; set; }
        /// <summary>A rule based on status codes.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A rule based on status codes.",
        SerializedName = @"statusCodes",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IStatusCodesBasedTrigger) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IStatusCodesBasedTrigger[] TriggerStatusCode { get; set; }
        /// <summary>A rule based on status codes ranges.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A rule based on status codes ranges.",
        SerializedName = @"statusCodesRange",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IStatusCodesRangeBasedTrigger) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IStatusCodesRangeBasedTrigger[] TriggerStatusCodesRange { get; set; }
        /// <summary><code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.",
        SerializedName = @"use32BitWorkerProcess",
        PossibleTypes = new [] { typeof(bool) })]
        bool? Use32BitWorkerProcess { get; set; }
        /// <summary>Virtual applications.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Virtual applications.",
        SerializedName = @"virtualApplications",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IVirtualApplication) })]
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IVirtualApplication[] VirtualApplication { get; set; }
        /// <summary>Virtual Network name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Virtual Network name.",
        SerializedName = @"vnetName",
        PossibleTypes = new [] { typeof(string) })]
        string VnetName { get; set; }
        /// <summary>
        /// The number of private ports assigned to this app. These will be assigned dynamically on runtime.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The number of private ports assigned to this app. These will be assigned dynamically on runtime.",
        SerializedName = @"vnetPrivatePortsCount",
        PossibleTypes = new [] { typeof(int) })]
        int? VnetPrivatePortsCount { get; set; }
        /// <summary>
        /// Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined
        /// Routes applied.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined Routes applied.",
        SerializedName = @"vnetRouteAllEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? VnetRouteAllEnabled { get; set; }
        /// <summary><code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"<code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.",
        SerializedName = @"webSocketsEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WebSocketsEnabled { get; set; }
        /// <summary>
        /// Sets the time zone a site uses for generating timestamps. Compatible with Linux and Windows App Service. Setting the WEBSITE_TIME_ZONE
        /// app setting takes precedence over this config. For Linux, expects tz database values https://www.iana.org/time-zones (for
        /// a quick reference see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For Windows, expects one of the time
        /// zones listed under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Sets the time zone a site uses for generating timestamps. Compatible with Linux and Windows App Service. Setting the WEBSITE_TIME_ZONE app setting takes precedence over this config. For Linux, expects tz database values https://www.iana.org/time-zones (for a quick reference see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For Windows, expects one of the time zones listed under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones",
        SerializedName = @"websiteTimeZone",
        PossibleTypes = new [] { typeof(string) })]
        string WebsiteTimeZone { get; set; }
        /// <summary>Xenon App Framework and version</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Xenon App Framework and version",
        SerializedName = @"windowsFxVersion",
        PossibleTypes = new [] { typeof(string) })]
        string WindowsFxVersion { get; set; }
        /// <summary>Explicit Managed Service Identity Id</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Websites.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Explicit Managed Service Identity Id",
        SerializedName = @"xManagedServiceIdentityId",
        PossibleTypes = new [] { typeof(int) })]
        int? XManagedServiceIdentityId { get; set; }

    }
    /// Web app configuration ARM resource.
    internal partial interface ISiteConfigResourceInternal :
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20201201.IProxyOnlyResourceInternal
    {
        /// <summary>Flag to use Managed Identity Creds for ACR pull</summary>
        bool? AcrUseManagedIdentityCred { get; set; }
        /// <summary>If using user managed identity, the user managed identity ClientId</summary>
        string AcrUserManagedIdentityId { get; set; }
        /// <summary>Custom action to be taken.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IAutoHealCustomAction ActionCustomAction { get; set; }
        /// <summary>
        /// Minimum time the process must execute
        /// before taking the action
        /// </summary>
        string ActionMinProcessExecutionTime { get; set; }
        /// <summary>Predefined action to be taken.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.AutoHealActionType? ActionType { get; set; }
        /// <summary><code>true</code> if Always On is enabled; otherwise, <code>false</code>.</summary>
        bool? AlwaysOn { get; set; }
        /// <summary>Information about the formal API definition for the app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IApiDefinitionInfo ApiDefinition { get; set; }
        /// <summary>The URL of the API definition.</summary>
        string ApiDefinitionUrl { get; set; }
        /// <summary>Azure API management settings linked to the app.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IApiManagementConfig ApiManagementConfig { get; set; }
        /// <summary>APIM-Api Identifier.</summary>
        string ApiManagementConfigId { get; set; }
        /// <summary>App command line to launch.</summary>
        string AppCommandLine { get; set; }
        /// <summary>Application settings.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.INameValuePair[] AppSetting { get; set; }
        /// <summary><code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.</summary>
        bool? AutoHealEnabled { get; set; }
        /// <summary>Auto Heal rules.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IAutoHealRules AutoHealRule { get; set; }
        /// <summary>Actions to be executed when a rule is triggered.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IAutoHealActions AutoHealRuleAction { get; set; }
        /// <summary>Conditions that describe when to execute the auto-heal actions.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IAutoHealTriggers AutoHealRuleTrigger { get; set; }
        /// <summary>Auto-swap slot name.</summary>
        string AutoSwapSlotName { get; set; }
        /// <summary>List of Azure Storage Accounts.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfigAzureStorageAccounts AzureStorageAccount { get; set; }
        /// <summary>Connection strings.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IConnStringInfo[] ConnectionString { get; set; }
        /// <summary>Cross-Origin Resource Sharing (CORS) settings.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ICorsSettings Cor { get; set; }
        /// <summary>
        /// Gets or sets the list of origins that should be allowed to make cross-origin
        /// calls (for example: http://example.com:12345). Use "*" to allow all.
        /// </summary>
        string[] CorAllowedOrigin { get; set; }
        /// <summary>
        /// Gets or sets whether CORS requests with credentials are allowed. See
        /// https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
        /// for more details.
        /// </summary>
        bool? CorSupportCredentials { get; set; }
        /// <summary>Executable to be run.</summary>
        string CustomActionExe { get; set; }
        /// <summary>Parameters for the executable.</summary>
        string CustomActionParameter { get; set; }
        /// <summary>Default documents.</summary>
        string[] DefaultDocument { get; set; }
        /// <summary>
        /// <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
        /// </summary>
        bool? DetailedErrorLoggingEnabled { get; set; }
        /// <summary>Document root.</summary>
        string DocumentRoot { get; set; }
        /// <summary>
        /// Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in the push registration
        /// endpoint.
        /// </summary>
        string DynamicTagsJson { get; set; }
        /// <summary>This is work around for polymorphic types.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IExperiments Experiment { get; set; }
        /// <summary>List of ramp-up rules.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IRampUpRule[] ExperimentRampUpRule { get; set; }
        /// <summary>State of FTP / FTPS service</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.FtpsState? FtpsState { get; set; }
        /// <summary>
        /// Maximum number of workers that a site can scale out to.
        /// This setting only applies to the Consumption and Elastic Premium Plans
        /// </summary>
        int? FunctionAppScaleLimit { get; set; }
        /// <summary>
        /// Gets or sets a value indicating whether functions runtime scale monitoring is enabled. When enabled,
        /// the ScaleController will not monitor event sources directly, but will instead call to the
        /// runtime to get scale status.
        /// </summary>
        bool? FunctionsRuntimeScaleMonitoringEnabled { get; set; }
        /// <summary>Handler mappings.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IHandlerMapping[] HandlerMapping { get; set; }
        /// <summary>Health check path</summary>
        string HealthCheckPath { get; set; }
        /// <summary>Http20Enabled: configures a web site to allow clients to connect over http2.0</summary>
        bool? Http20Enabled { get; set; }
        /// <summary><code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.</summary>
        bool? HttpLoggingEnabled { get; set; }
        /// <summary>IP security restrictions for main.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IIPSecurityRestriction[] IPSecurityRestriction { get; set; }
        /// <summary>Gets or sets a flag indicating whether the Push endpoint is enabled.</summary>
        bool? IsPushEnabled { get; set; }
        /// <summary>Java container.</summary>
        string JavaContainer { get; set; }
        /// <summary>Java container version.</summary>
        string JavaContainerVersion { get; set; }
        /// <summary>Java version.</summary>
        string JavaVersion { get; set; }
        /// <summary>Identity to use for Key Vault Reference authentication.</summary>
        string KeyVaultReferenceIdentity { get; set; }
        /// <summary>Site limits.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteLimits Limit { get; set; }
        /// <summary>Maximum allowed disk size usage in MB.</summary>
        long? LimitMaxDiskSizeInMb { get; set; }
        /// <summary>Maximum allowed memory usage in MB.</summary>
        long? LimitMaxMemoryInMb { get; set; }
        /// <summary>Maximum allowed CPU usage percentage.</summary>
        double? LimitMaxPercentageCpu { get; set; }
        /// <summary>Linux App Framework and version</summary>
        string LinuxFxVersion { get; set; }
        /// <summary>Site load balancing.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.SiteLoadBalancing? LoadBalancing { get; set; }
        /// <summary><code>true</code> to enable local MySQL; otherwise, <code>false</code>.</summary>
        bool? LocalMySqlEnabled { get; set; }
        /// <summary>HTTP logs directory size limit.</summary>
        int? LogsDirectorySizeLimit { get; set; }
        /// <summary>Site MachineKey.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteMachineKey MachineKey { get; set; }
        /// <summary>Algorithm used for decryption.</summary>
        string MachineKeyDecryption { get; set; }
        /// <summary>Decryption key.</summary>
        string MachineKeyDecryptionKey { get; set; }
        /// <summary>MachineKey validation.</summary>
        string MachineKeyValidation { get; set; }
        /// <summary>Validation key.</summary>
        string MachineKeyValidationKey { get; set; }
        /// <summary>Managed pipeline mode.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.ManagedPipelineMode? ManagedPipelineMode { get; set; }
        /// <summary>Managed Service Identity Id</summary>
        int? ManagedServiceIdentityId { get; set; }
        /// <summary>MinTlsVersion: configures the minimum version of TLS required for SSL requests</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.SupportedTlsVersions? MinTlsVersion { get; set; }
        /// <summary>
        /// Number of minimum instance count for a site
        /// This setting only applies to the Elastic Plans
        /// </summary>
        int? MinimumElasticInstanceCount { get; set; }
        /// <summary>.NET Framework version.</summary>
        string NetFrameworkVersion { get; set; }
        /// <summary>Version of Node.js.</summary>
        string NodeVersion { get; set; }
        /// <summary>Number of workers.</summary>
        int? NumberOfWorker { get; set; }
        /// <summary>Version of PHP.</summary>
        string PhpVersion { get; set; }
        /// <summary>Version of PowerShell.</summary>
        string PowerShellVersion { get; set; }
        /// <summary>
        /// Number of preWarmed instances.
        /// This setting only applies to the Consumption and Elastic Plans
        /// </summary>
        int? PreWarmedInstanceCount { get; set; }
        /// <summary>Core resource properties</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISiteConfig Property { get; set; }
        /// <summary>Property to allow or block all public traffic.</summary>
        string PublicNetworkAccess { get; set; }
        /// <summary>Publishing user name.</summary>
        string PublishingUsername { get; set; }
        /// <summary>Push endpoint settings.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IPushSettings Push { get; set; }
        /// <summary>Resource Id.</summary>
        string PushId { get; set; }
        /// <summary>Kind of resource.</summary>
        string PushKind { get; set; }
        /// <summary>Resource Name.</summary>
        string PushName { get; set; }
        /// <summary>PushSettings resource specific properties</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IPushSettingsProperties PushProperty { get; set; }
        /// <summary>Resource type.</summary>
        string PushType { get; set; }
        /// <summary>Version of Python.</summary>
        string PythonVersion { get; set; }
        /// <summary>
        /// <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
        /// </summary>
        bool? RemoteDebuggingEnabled { get; set; }
        /// <summary>Remote debugging version.</summary>
        string RemoteDebuggingVersion { get; set; }
        /// <summary>Request Count.</summary>
        int? RequestCount { get; set; }
        /// <summary>Time interval.</summary>
        string RequestTimeInterval { get; set; }
        /// <summary><code>true</code> if request tracing is enabled; otherwise, <code>false</code>.</summary>
        bool? RequestTracingEnabled { get; set; }
        /// <summary>Request tracing expiration time.</summary>
        global::System.DateTime? RequestTracingExpirationTime { get; set; }
        /// <summary>IP security restrictions for scm.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IIPSecurityRestriction[] ScmIPSecurityRestriction { get; set; }
        /// <summary>IP security restrictions for scm to use main.</summary>
        bool? ScmIPSecurityRestrictionsUseMain { get; set; }
        /// <summary>
        /// ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.SupportedTlsVersions? ScmMinTlsVersion { get; set; }
        /// <summary>SCM type.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Support.ScmType? ScmType { get; set; }
        /// <summary>Request Count.</summary>
        int? SlowRequestCount { get; set; }
        /// <summary>Request Path.</summary>
        string SlowRequestPath { get; set; }
        /// <summary>Time interval.</summary>
        string SlowRequestTimeInterval { get; set; }
        /// <summary>Time taken.</summary>
        string SlowRequestTimeTaken { get; set; }
        /// <summary>
        /// Gets or sets a JSON string containing a list of tags that are whitelisted for use by the push registration endpoint.
        /// </summary>
        string TagWhitelistJson { get; set; }
        /// <summary>
        /// Gets or sets a JSON string containing a list of tags that require user authentication to be used in the push registration
        /// endpoint.
        /// Tags can consist of alphanumeric characters and the following:
        /// '_', '@', '#', '.', ':', '-'.
        /// Validation should be performed at the PushRequestHandler.
        /// </summary>
        string TagsRequiringAuth { get; set; }
        /// <summary>Tracing options.</summary>
        string TracingOption { get; set; }
        /// <summary>A rule based on private bytes.</summary>
        int? TriggerPrivateBytesInKb { get; set; }
        /// <summary>A rule based on total requests.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IRequestsBasedTrigger TriggerRequest { get; set; }
        /// <summary>A rule based on request execution time.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISlowRequestsBasedTrigger TriggerSlowRequest { get; set; }
        /// <summary>A rule based on multiple Slow Requests Rule with path</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.ISlowRequestsBasedTrigger[] TriggerSlowRequestsWithPath { get; set; }
        /// <summary>A rule based on status codes.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IStatusCodesBasedTrigger[] TriggerStatusCode { get; set; }
        /// <summary>A rule based on status codes ranges.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IStatusCodesRangeBasedTrigger[] TriggerStatusCodesRange { get; set; }
        /// <summary><code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.</summary>
        bool? Use32BitWorkerProcess { get; set; }
        /// <summary>Virtual applications.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Websites.Models.Api20210201.IVirtualApplication[] VirtualApplication { get; set; }
        /// <summary>Virtual Network name.</summary>
        string VnetName { get; set; }
        /// <summary>
        /// The number of private ports assigned to this app. These will be assigned dynamically on runtime.
        /// </summary>
        int? VnetPrivatePortsCount { get; set; }
        /// <summary>
        /// Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network Security Groups and User Defined
        /// Routes applied.
        /// </summary>
        bool? VnetRouteAllEnabled { get; set; }
        /// <summary><code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.</summary>
        bool? WebSocketsEnabled { get; set; }
        /// <summary>
        /// Sets the time zone a site uses for generating timestamps. Compatible with Linux and Windows App Service. Setting the WEBSITE_TIME_ZONE
        /// app setting takes precedence over this config. For Linux, expects tz database values https://www.iana.org/time-zones (for
        /// a quick reference see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For Windows, expects one of the time
        /// zones listed under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones
        /// </summary>
        string WebsiteTimeZone { get; set; }
        /// <summary>Xenon App Framework and version</summary>
        string WindowsFxVersion { get; set; }
        /// <summary>Explicit Managed Service Identity Id</summary>
        int? XManagedServiceIdentityId { get; set; }

    }
}