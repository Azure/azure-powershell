// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.8, generator: @autorest/powershell@4.0.749)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Sample.API.Cmdlets
{
    using static Sample.API.Runtime.Extensions;
    using Sample.API.Runtime.PowerShell;
    using Sample.API.Runtime.Cmdlets;
    using System;

    /// <summary>create and start a packet capture on the specified VM.</summary>
    /// <remarks>
    /// [OpenAPI] Create=>PUT:"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures/{packetCaptureName}"
    /// </remarks>
    [global::System.Management.Automation.Cmdlet(global::System.Management.Automation.VerbsCommon.New, @"PacketCapture_CreateExpanded", SupportsShouldProcess = true)]
    [global::System.Management.Automation.OutputType(typeof(bool))]
    [global::Sample.API.Description(@"create and start a packet capture on the specified VM.")]
    [global::Sample.API.Generated]
    [global::Sample.API.HttpPath(Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures/{packetCaptureName}", ApiVersion = "2025-03-01")]
    public partial class NewPacketCapture_CreateExpanded : global::System.Management.Automation.PSCmdlet,
        Sample.API.Runtime.IEventListener,
        Sample.API.Runtime.IContext
    {
        /// <summary>A copy of the Invocation Info (necessary to allow asJob to clone this cmdlet)</summary>
        private global::System.Management.Automation.InvocationInfo __invocationInfo;

        /// <summary>
        /// The <see cref="global::System.Threading.CancellationTokenSource" /> for this operation.
        /// </summary>
        private global::System.Threading.CancellationTokenSource _cancellationTokenSource = new global::System.Threading.CancellationTokenSource();

        /// <summary>A dictionary to carry over additional data for pipeline.</summary>
        private global::System.Collections.Generic.Dictionary<global::System.String,global::System.Object> _extensibleParameters = new System.Collections.Generic.Dictionary<string, object>();

        /// <summary>Parameters that define the create packet capture operation.</summary>
        private Sample.API.Models.IPacketCapture _parametersBody = new Sample.API.Models.PacketCapture();

        /// <summary>when specified, runs this cmdlet as a PowerShell job</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Run the command as a job")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter AsJob { get; set; }

        /// <summary>Wait for .NET debugger to attach</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Wait for .NET debugger to attach")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter Break { get; set; }

        /// <summary>Number of bytes captured per packet, the remaining bytes are truncated.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Number of bytes captured per packet, the remaining bytes are truncated.")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Body)]
        [Sample.API.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of bytes captured per packet, the remaining bytes are truncated.",
        SerializedName = @"bytesToCapturePerPacket",
        PossibleTypes = new [] { typeof(long) })]
        public long BytesToCapturePerPacket { get => _parametersBody.BytesToCapturePerPacket ?? default(long); set => _parametersBody.BytesToCapturePerPacket = value; }

        /// <summary>Accessor for cancellationTokenSource.</summary>
        public global::System.Threading.CancellationTokenSource CancellationTokenSource { get => _cancellationTokenSource ; set { _cancellationTokenSource = value; } }

        /// <summary>Number of file count. Default value of count is 10 and maximum number is 10000.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Number of file count. Default value of count is 10 and maximum number is 10000.")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Body)]
        [Sample.API.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of file count. Default value of count is 10 and maximum number is 10000.",
        SerializedName = @"fileCount",
        PossibleTypes = new [] { typeof(int) })]
        public int CaptureSettingFileCount { get => _parametersBody.CaptureSettingFileCount ?? default(int); set => _parametersBody.CaptureSettingFileCount = value; }

        /// <summary>
        /// Number of bytes captured per packet. Default value in bytes 104857600 (100MB) and maximum in bytes 4294967295 (4GB).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Number of bytes captured per packet. Default value in bytes 104857600 (100MB) and maximum in bytes 4294967295 (4GB).")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Body)]
        [Sample.API.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of bytes captured per packet. Default value in bytes 104857600 (100MB) and maximum in bytes 4294967295 (4GB).",
        SerializedName = @"fileSizeInBytes",
        PossibleTypes = new [] { typeof(long) })]
        public long CaptureSettingFileSizeInBytes { get => _parametersBody.CaptureSettingFileSizeInBytes ?? default(long); set => _parametersBody.CaptureSettingFileSizeInBytes = value; }

        /// <summary>
        /// Maximum duration of the capture session in seconds is 604800s (7 days) for a file. Default value in second 86400s (1 day).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Maximum duration of the capture session in seconds is 604800s (7 days) for a file. Default value in second 86400s (1 day).")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Body)]
        [Sample.API.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Maximum duration of the capture session in seconds is 604800s (7 days) for a file. Default value in second 86400s (1 day).",
        SerializedName = @"sessionTimeLimitInSeconds",
        PossibleTypes = new [] { typeof(int) })]
        public int CaptureSettingSessionTimeLimitInSeconds { get => _parametersBody.CaptureSettingSessionTimeLimitInSeconds ?? default(int); set => _parametersBody.CaptureSettingSessionTimeLimitInSeconds = value; }

        /// <summary>The reference to the client API class.</summary>
        public Sample.API.NetworkManagementClient Client => Sample.API.Module.Instance.ClientAPI;

        /// <summary>
        /// This continuous capture is a nullable boolean, which can hold 'null', 'true' or 'false' value. If we do not pass this
        /// parameter, it would be consider as 'null', default value is 'null'.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This continuous capture is a nullable boolean, which can hold 'null', 'true' or 'false' value. If we do not pass this parameter, it would be consider as 'null', default value is 'null'.")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Body)]
        [Sample.API.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This continuous capture is a nullable boolean, which can hold 'null', 'true' or 'false' value. If we do not pass this parameter, it would be consider as 'null', default value is 'null'.",
        SerializedName = @"continuousCapture",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter ContinuousCapture { get => _parametersBody.ContinuousCapture ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.ContinuousCapture = value; }

        /// <summary>Accessor for extensibleParameters.</summary>
        public global::System.Collections.Generic.IDictionary<global::System.String,global::System.Object> ExtensibleParameters { get => _extensibleParameters ; }

        /// <summary>A list of packet capture filters.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "A list of packet capture filters.")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Body)]
        [Sample.API.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A list of packet capture filters.",
        SerializedName = @"filters",
        PossibleTypes = new [] { typeof(Sample.API.Models.IPacketCaptureFilter) })]
        public Sample.API.Models.IPacketCaptureFilter[] Filters { get => _parametersBody.Filters?.ToArray() ?? null /* fixedArrayOf */; set => _parametersBody.Filters = (value != null ? new System.Collections.Generic.List<Sample.API.Models.IPacketCaptureFilter>(value) : null); }

        /// <summary>SendAsync Pipeline Steps to be appended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be appended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Runtime)]
        public Sample.API.Runtime.SendAsyncStep[] HttpPipelineAppend { get; set; }

        /// <summary>SendAsync Pipeline Steps to be prepended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be prepended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Runtime)]
        public Sample.API.Runtime.SendAsyncStep[] HttpPipelinePrepend { get; set; }

        /// <summary>Accessor for our copy of the InvocationInfo.</summary>
        public global::System.Management.Automation.InvocationInfo InvocationInformation { get => __invocationInfo = __invocationInfo ?? this.MyInvocation ; set { __invocationInfo = value; } }

        /// <summary>
        /// <see cref="Sample.API.Runtime.IEventListener" /> cancellation delegate. Stops the cmdlet when called.
        /// </summary>
        global::System.Action Sample.API.Runtime.IEventListener.Cancel => _cancellationTokenSource.Cancel;

        /// <summary><see cref="Sample.API.Runtime.IEventListener" /> cancellation token.</summary>
        global::System.Threading.CancellationToken Sample.API.Runtime.IEventListener.Token => _cancellationTokenSource.Token;

        /// <summary>Backing field for <see cref="NetworkWatcherName" /> property.</summary>
        private string _networkWatcherName;

        /// <summary>The name of the network watcher.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The name of the network watcher.")]
        [Sample.API.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The name of the network watcher.",
        SerializedName = @"networkWatcherName",
        PossibleTypes = new [] { typeof(string) })]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Path)]
        public string NetworkWatcherName { get => this._networkWatcherName; set => this._networkWatcherName = value; }

        /// <summary>
        /// when specified, will make the remote call, and return an AsyncOperationResponse, letting the remote operation continue
        /// asynchronously.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Run the command asynchronously")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter NoWait { get; set; }

        /// <summary>Backing field for <see cref="PacketCaptureName" /> property.</summary>
        private string _packetCaptureName;

        /// <summary>The name of the packet capture session.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The name of the packet capture session.")]
        [Sample.API.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The name of the packet capture session.",
        SerializedName = @"packetCaptureName",
        PossibleTypes = new [] { typeof(string) })]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Path)]
        public string PacketCaptureName { get => this._packetCaptureName; set => this._packetCaptureName = value; }

        /// <summary>
        /// The instance of the <see cref="Sample.API.Runtime.HttpPipeline" /> that the remote call will use.
        /// </summary>
        public Sample.API.Runtime.HttpPipeline Pipeline { get; set; }

        /// <summary>The URI for the proxy server to use</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "The URI for the proxy server to use")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Runtime)]
        public global::System.Uri Proxy { get; set; }

        /// <summary>Credentials for a proxy server to use for the remote call</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Credentials for a proxy server to use for the remote call")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Runtime)]
        public global::System.Management.Automation.PSCredential ProxyCredential { get; set; }

        /// <summary>Use the default credentials for the proxy</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Use the default credentials for the proxy")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter ProxyUseDefaultCredentials { get; set; }

        /// <summary>Backing field for <see cref="ResourceGroupName" /> property.</summary>
        private string _resourceGroupName;

        /// <summary>The name of the resource group.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The name of the resource group.")]
        [Sample.API.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The name of the resource group.",
        SerializedName = @"resourceGroupName",
        PossibleTypes = new [] { typeof(string) })]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Path)]
        public string ResourceGroupName { get => this._resourceGroupName; set => this._resourceGroupName = value; }

        /// <summary>
        /// List of AzureVMSS instances which has to be excluded from the AzureVMSS from running packet capture.
        /// </summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "List of AzureVMSS instances which has to be excluded from the AzureVMSS from running packet capture.")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Body)]
        [Sample.API.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"List of AzureVMSS instances which has to be excluded from the AzureVMSS from running packet capture.",
        SerializedName = @"exclude",
        PossibleTypes = new [] { typeof(string) })]
        public string[] ScopeExclude { get => _parametersBody.ScopeExclude?.ToArray() ?? null /* fixedArrayOf */; set => _parametersBody.ScopeExclude = (value != null ? new System.Collections.Generic.List<string>(value) : null); }

        /// <summary>List of AzureVMSS instances to run packet capture on.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "List of AzureVMSS instances to run packet capture on.")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Body)]
        [Sample.API.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"List of AzureVMSS instances to run packet capture on.",
        SerializedName = @"include",
        PossibleTypes = new [] { typeof(string) })]
        public string[] ScopeInclude { get => _parametersBody.ScopeInclude?.ToArray() ?? null /* fixedArrayOf */; set => _parametersBody.ScopeInclude = (value != null ? new System.Collections.Generic.List<string>(value) : null); }

        /// <summary>
        /// This path is invalid if 'Continuous Capture' is provided with 'true' or 'false'. A valid local path on the targeting VM.
        /// Must include the name of the capture file (*.cap). For linux virtual machine it must start with /var/captures. Required
        /// if no storage ID is provided, otherwise optional.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This path is invalid if 'Continuous Capture' is provided with 'true' or 'false'. A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For linux virtual machine it must start with /var/captures. Required if no storage ID is provided, otherwise optional.")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Body)]
        [Sample.API.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This path is invalid if 'Continuous Capture' is provided with 'true' or 'false'. A valid local path on the targeting VM. Must include the name of the capture file (*.cap). For linux virtual machine it must start with /var/captures. Required if no storage ID is provided, otherwise optional.",
        SerializedName = @"filePath",
        PossibleTypes = new [] { typeof(string) })]
        public string StorageLocationFilePath { get => _parametersBody.StorageLocationFilePath ?? null; set => _parametersBody.StorageLocationFilePath = value; }

        /// <summary>
        /// This path is valid if 'Continuous Capture' is provided with 'true' or 'false' and required if no storage ID is provided,
        /// otherwise optional. Must include the name of the capture file (*.cap). For linux virtual machine it must start with /var/captures.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This path is valid if 'Continuous Capture' is provided with 'true' or 'false' and required if no storage ID is provided, otherwise optional. Must include the name of the capture file (*.cap). For linux virtual machine it must start with /var/captures.")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Body)]
        [Sample.API.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This path is valid if 'Continuous Capture' is provided with 'true' or 'false' and required if no storage ID is provided, otherwise optional. Must include the name of the capture file (*.cap). For linux virtual machine it must start with /var/captures.",
        SerializedName = @"localPath",
        PossibleTypes = new [] { typeof(string) })]
        public string StorageLocationLocalPath { get => _parametersBody.StorageLocationLocalPath ?? null; set => _parametersBody.StorageLocationLocalPath = value; }

        /// <summary>
        /// The ID of the storage account to save the packet capture session. Required if no localPath or filePath is provided.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The ID of the storage account to save the packet capture session. Required if no localPath or filePath is provided.")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Body)]
        [Sample.API.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The ID of the storage account to save the packet capture session. Required if no localPath or filePath is provided.",
        SerializedName = @"storageId",
        PossibleTypes = new [] { typeof(string) })]
        public string StorageLocationStorageId { get => _parametersBody.StorageLocationStorageId ?? null; set => _parametersBody.StorageLocationStorageId = value; }

        /// <summary>
        /// The URI of the storage path to save the packet capture. Must be a well-formed URI describing the location to save the
        /// packet capture.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The URI of the storage path to save the packet capture. Must be a well-formed URI describing the location to save the packet capture.")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Body)]
        [Sample.API.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The URI of the storage path to save the packet capture. Must be a well-formed URI describing the location to save the packet capture.",
        SerializedName = @"storagePath",
        PossibleTypes = new [] { typeof(string) })]
        public string StorageLocationStoragePath { get => _parametersBody.StorageLocationStoragePath ?? null; set => _parametersBody.StorageLocationStoragePath = value; }

        /// <summary>Backing field for <see cref="SubscriptionId" /> property.</summary>
        private string _subscriptionId;

        /// <summary>
        /// The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part
        /// of the URI for every service call.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.")]
        [Sample.API.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The subscription credentials which uniquely identify the Microsoft Azure subscription. The subscription ID forms part of the URI for every service call.",
        SerializedName = @"subscriptionId",
        PossibleTypes = new [] { typeof(string) })]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Path)]
        public string SubscriptionId { get => this._subscriptionId; set => this._subscriptionId = value; }

        /// <summary>
        /// The ID of the targeted resource, only AzureVM and AzureVMSS as target type are currently supported.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The ID of the targeted resource, only AzureVM and AzureVMSS as target type are currently supported.")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Body)]
        [Sample.API.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The ID of the targeted resource, only AzureVM and AzureVMSS as target type are currently supported.",
        SerializedName = @"target",
        PossibleTypes = new [] { typeof(string) })]
        public string Target { get => _parametersBody.Target ?? null; set => _parametersBody.Target = value; }

        /// <summary>Target type of the resource provided.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Target type of the resource provided.")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Body)]
        [Sample.API.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Target type of the resource provided.",
        SerializedName = @"targetType",
        PossibleTypes = new [] { typeof(string) })]
        [global::Sample.API.PSArgumentCompleterAttribute("AzureVM", "AzureVMSS")]
        public string TargetType { get => _parametersBody.TargetType ?? null; set => _parametersBody.TargetType = value; }

        /// <summary>Maximum duration of the capture session in seconds.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Maximum duration of the capture session in seconds.")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Body)]
        [Sample.API.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Maximum duration of the capture session in seconds.",
        SerializedName = @"timeLimitInSeconds",
        PossibleTypes = new [] { typeof(int) })]
        public int TimeLimitInSeconds { get => _parametersBody.TimeLimitInSeconds ?? default(int); set => _parametersBody.TimeLimitInSeconds = value; }

        /// <summary>Maximum size of the capture output.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Maximum size of the capture output.")]
        [global::Sample.API.Category(global::Sample.API.ParameterCategory.Body)]
        [Sample.API.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Maximum size of the capture output.",
        SerializedName = @"totalBytesPerSession",
        PossibleTypes = new [] { typeof(long) })]
        public long TotalBytesPerSession { get => _parametersBody.TotalBytesPerSession ?? default(long); set => _parametersBody.TotalBytesPerSession = value; }

        /// <summary>
        /// <c>overrideOnDefault</c> will be called before the regular onDefault has been processed, allowing customization of what
        /// happens on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Sample.API.Models.IErrorResponse">Sample.API.Models.IErrorResponse</see>
        /// from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onDefault method should be processed, or if the method should
        /// return immediately (set to true to skip further processing )</param>

        partial void overrideOnDefault(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Sample.API.Models.IErrorResponse> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// (overrides the default BeginProcessing method in global::System.Management.Automation.PSCmdlet)
        /// </summary>
        protected override void BeginProcessing()
        {
            Module.Instance.SetProxyConfiguration(Proxy, ProxyCredential, ProxyUseDefaultCredentials);
            if (Break)
            {
                Sample.API.Runtime.AttachDebugger.Break();
            }
            ((Sample.API.Runtime.IEventListener)this).Signal(Sample.API.Runtime.Events.CmdletBeginProcessing).Wait(); if( ((Sample.API.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
        }

        /// <summary>Creates a duplicate instance of this cmdlet (via JSON serialization).</summary>
        /// <returns>a duplicate instance of NewPacketCapture_CreateExpanded</returns>
        public Sample.API.Cmdlets.NewPacketCapture_CreateExpanded Clone()
        {
            var clone = new NewPacketCapture_CreateExpanded();
            clone.InvocationInformation = this.InvocationInformation;
            clone.Proxy = this.Proxy;
            clone.Pipeline = this.Pipeline;
            clone.AsJob = this.AsJob;
            clone.Break = this.Break;
            clone.ProxyCredential = this.ProxyCredential;
            clone.ProxyUseDefaultCredentials = this.ProxyUseDefaultCredentials;
            clone.HttpPipelinePrepend = this.HttpPipelinePrepend;
            clone.HttpPipelineAppend = this.HttpPipelineAppend;
            clone._parametersBody = this._parametersBody;
            clone.SubscriptionId = this.SubscriptionId;
            clone.ResourceGroupName = this.ResourceGroupName;
            clone.NetworkWatcherName = this.NetworkWatcherName;
            clone.PacketCaptureName = this.PacketCaptureName;
            return clone;
        }

        /// <summary>Performs clean-up after the command execution</summary>
        protected override void EndProcessing()
        {
            ((Sample.API.Runtime.IEventListener)this).Signal(Sample.API.Runtime.Events.CmdletEndProcessing).Wait(); if( ((Sample.API.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
        }

        /// <summary>Handles/Dispatches events during the call to the REST service.</summary>
        /// <param name="id">The message id</param>
        /// <param name="token">The message cancellation token. When this call is cancelled, this should be <c>true</c></param>
        /// <param name="messageData">Detailed message data for the message event.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the message is completed.
        /// </returns>
         async global::System.Threading.Tasks.Task Sample.API.Runtime.IEventListener.Signal(string id, global::System.Threading.CancellationToken token, global::System.Func<Sample.API.Runtime.EventData> messageData)
        {
            using( NoSynchronizationContext )
            {
                if (token.IsCancellationRequested)
                {
                    return ;
                }

                switch ( id )
                {
                    case Sample.API.Runtime.Events.Verbose:
                    {
                        WriteVerbose($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Sample.API.Runtime.Events.Warning:
                    {
                        WriteWarning($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Sample.API.Runtime.Events.Information:
                    {
                        // When an operation supports asjob, Information messages must go thru verbose.
                        WriteVerbose($"INFORMATION: {(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Sample.API.Runtime.Events.Debug:
                    {
                        WriteDebug($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Sample.API.Runtime.Events.Error:
                    {
                        WriteError(new global::System.Management.Automation.ErrorRecord( new global::System.Exception(messageData().Message), string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null ) );
                        return ;
                    }
                    case Sample.API.Runtime.Events.Progress:
                    {
                        var data = messageData();
                        int progress = (int)data.Value;
                        string activityMessage, statusDescription;
                        global::System.Management.Automation.ProgressRecordType recordType;
                        if (progress < 100)
                        {
                            activityMessage = "In progress";
                            statusDescription = "Checking operation status";
                            recordType = System.Management.Automation.ProgressRecordType.Processing;
                        }
                        else
                        {
                            activityMessage = "Completed";
                            statusDescription = "Completed";
                            recordType = System.Management.Automation.ProgressRecordType.Completed;
                        }
                        WriteProgress(new global::System.Management.Automation.ProgressRecord(1, activityMessage, statusDescription)
                        {
                            PercentComplete = progress,
                        RecordType = recordType
                        });
                        return ;
                    }
                    case Sample.API.Runtime.Events.DelayBeforePolling:
                    {
                        var data = messageData();
                        if (true == MyInvocation?.BoundParameters?.ContainsKey("NoWait"))
                        {
                            if (data.ResponseMessage is System.Net.Http.HttpResponseMessage response)
                            {
                                var asyncOperation = response.GetFirstHeader(@"Azure-AsyncOperation");
                                var location = response.GetFirstHeader(@"Location");
                                var uri = global::System.String.IsNullOrEmpty(asyncOperation) ? global::System.String.IsNullOrEmpty(location) ? response.RequestMessage.RequestUri.AbsoluteUri : location : asyncOperation;
                                WriteObject(new Sample.API.Runtime.PowerShell.AsyncOperationResponse { Target = uri });
                                // do nothing more.
                                data.Cancel();
                                return;
                            }
                        }
                        else
                        {
                            if (data.ResponseMessage is System.Net.Http.HttpResponseMessage response)
                            {
                                int delay = (int)(response.Headers.RetryAfter?.Delta?.TotalSeconds ?? 30);
                                WriteDebug($"Delaying {delay} seconds before polling.");
                                for (var now = 0; now < delay; ++now)
                                {
                                    WriteProgress(new global::System.Management.Automation.ProgressRecord(1, "In progress", "Checking operation status")
                                    {
                                        PercentComplete = now * 100 / delay
                                    });
                                    await global::System.Threading.Tasks.Task.Delay(1000, token);
                                }
                            }
                        }
                        break;
                    }
                }
                await Sample.API.Module.Instance.Signal(id, token, messageData, (i, t, m) => ((Sample.API.Runtime.IEventListener)this).Signal(i, t, () => Sample.API.Runtime.EventDataConverter.ConvertFrom(m()) as Sample.API.Runtime.EventData), InvocationInformation, this.ParameterSetName, null );
                if (token.IsCancellationRequested)
                {
                    return ;
                }
                WriteDebug($"{id}: {(messageData().Message ?? global::System.String.Empty)}");
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NewPacketCapture_CreateExpanded" /> cmdlet class.
        /// </summary>
        public NewPacketCapture_CreateExpanded()
        {

        }

        /// <summary>Performs execution of the command.</summary>
        protected override void ProcessRecord()
        {
            ((Sample.API.Runtime.IEventListener)this).Signal(Sample.API.Runtime.Events.CmdletProcessRecordStart).Wait(); if( ((Sample.API.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
            try
            {
                // work
                if (ShouldProcess($"Call remote 'PacketCapturesCreate' operation"))
                {
                    if (true == MyInvocation?.BoundParameters?.ContainsKey("AsJob"))
                    {
                        var instance = this.Clone();
                        var job = new Sample.API.Runtime.PowerShell.AsyncJob(instance, this.MyInvocation.Line, this.MyInvocation.MyCommand.Name, this._cancellationTokenSource.Token, this._cancellationTokenSource.Cancel);
                        JobRepository.Add(job);
                        var task = instance.ProcessRecordAsync();
                        job.Monitor(task);
                        WriteObject(job);
                    }
                    else
                    {
                        using( var asyncCommandRuntime = new Sample.API.Runtime.PowerShell.AsyncCommandRuntime(this, ((Sample.API.Runtime.IEventListener)this).Token) )
                        {
                            asyncCommandRuntime.Wait( ProcessRecordAsync(),((Sample.API.Runtime.IEventListener)this).Token);
                        }
                    }
                }
            }
            catch (global::System.AggregateException aggregateException)
            {
                // unroll the inner exceptions to get the root cause
                foreach( var innerException in aggregateException.Flatten().InnerExceptions )
                {
                    ((Sample.API.Runtime.IEventListener)this).Signal(Sample.API.Runtime.Events.CmdletException, $"{innerException.GetType().Name} - {innerException.Message} : {innerException.StackTrace}").Wait(); if( ((Sample.API.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    // Write exception out to error channel.
                    WriteError( new global::System.Management.Automation.ErrorRecord(innerException,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
                }
            }
            catch (global::System.Exception exception) when ((exception as System.Management.Automation.PipelineStoppedException)== null || (exception as System.Management.Automation.PipelineStoppedException).InnerException != null)
            {
                ((Sample.API.Runtime.IEventListener)this).Signal(Sample.API.Runtime.Events.CmdletException, $"{exception.GetType().Name} - {exception.Message} : {exception.StackTrace}").Wait(); if( ((Sample.API.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                // Write exception out to error channel.
                WriteError( new global::System.Management.Automation.ErrorRecord(exception,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
            }
            finally
            {
                ((Sample.API.Runtime.IEventListener)this).Signal(Sample.API.Runtime.Events.CmdletProcessRecordEnd).Wait();
            }
        }

        /// <summary>Performs execution of the command, working asynchronously if required.</summary>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        protected async global::System.Threading.Tasks.Task ProcessRecordAsync()
        {
            using( NoSynchronizationContext )
            {
                await ((Sample.API.Runtime.IEventListener)this).Signal(Sample.API.Runtime.Events.CmdletProcessRecordAsyncStart); if( ((Sample.API.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                await ((Sample.API.Runtime.IEventListener)this).Signal(Sample.API.Runtime.Events.CmdletGetPipeline); if( ((Sample.API.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                Pipeline = Sample.API.Module.Instance.CreatePipeline(InvocationInformation, this.ParameterSetName, this.ExtensibleParameters);
                if (null != HttpPipelinePrepend)
                {
                    Pipeline.Prepend((this.CommandRuntime as Sample.API.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelinePrepend) ?? HttpPipelinePrepend);
                }
                if (null != HttpPipelineAppend)
                {
                    Pipeline.Append((this.CommandRuntime as Sample.API.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelineAppend) ?? HttpPipelineAppend);
                }
                // get the client instance
                try
                {
                    await ((Sample.API.Runtime.IEventListener)this).Signal(Sample.API.Runtime.Events.CmdletBeforeAPICall); if( ((Sample.API.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    await this.Client.PacketCapturesCreate(SubscriptionId, ResourceGroupName, NetworkWatcherName, PacketCaptureName, _parametersBody, onDefault, this, Pipeline, Sample.API.Runtime.SerializationMode.IncludeCreate);
                    await ((Sample.API.Runtime.IEventListener)this).Signal(Sample.API.Runtime.Events.CmdletAfterAPICall); if( ((Sample.API.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                }
                catch (Sample.API.Runtime.UndeclaredResponseException urexception)
                {
                    WriteError(new global::System.Management.Automation.ErrorRecord(urexception, urexception.StatusCode.ToString(), global::System.Management.Automation.ErrorCategory.InvalidOperation, new { SubscriptionId=SubscriptionId,ResourceGroupName=ResourceGroupName,NetworkWatcherName=NetworkWatcherName,PacketCaptureName=PacketCaptureName})
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(urexception.Message) { RecommendedAction = urexception.Action }
                    });
                }
                finally
                {
                    await ((Sample.API.Runtime.IEventListener)this).Signal(Sample.API.Runtime.Events.CmdletProcessRecordAsyncEnd);
                }
            }
        }

        /// <summary>Interrupts currently running code within the command.</summary>
        protected override void StopProcessing()
        {
            ((Sample.API.Runtime.IEventListener)this).Cancel();
            base.StopProcessing();
        }

        /// <summary>
        /// a delegate that is called when the remote service returns default (any response code not handled elsewhere).
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Sample.API.Models.IErrorResponse">Sample.API.Models.IErrorResponse</see>
        /// from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onDefault(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Sample.API.Models.IErrorResponse> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnDefault(responseMessage, response, ref _returnNow);
                // if overrideOnDefault has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // Error Response : default
                var code = (await response)?.Code;
                var message = (await response)?.Message;
                if ((null == code || null == message))
                {
                    // Unrecognized Response. Create an error record based on what we have.
                    var ex = new Sample.API.Runtime.RestException<Sample.API.Models.IErrorResponse>(responseMessage, await response);
                    WriteError( new global::System.Management.Automation.ErrorRecord(ex, ex.Code, global::System.Management.Automation.ErrorCategory.InvalidOperation, new {  })
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(ex.Message) { RecommendedAction = ex.Action }
                    });
                }
                else
                {
                    WriteError( new global::System.Management.Automation.ErrorRecord(new global::System.Exception($"[{code}] : {message}"), code?.ToString(), global::System.Management.Automation.ErrorCategory.InvalidOperation, new {  })
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(message) { RecommendedAction = global::System.String.Empty }
                    });
                }
            }
        }
    }
}