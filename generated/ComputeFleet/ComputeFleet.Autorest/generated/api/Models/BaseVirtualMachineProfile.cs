// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models
{
    using static Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Extensions;

    /// <summary>Describes the base virtual machine profile for fleet</summary>
    public partial class BaseVirtualMachineProfile :
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfile,
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal
    {

        /// <summary>Backing field for <see cref="ApplicationProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IApplicationProfile _applicationProfile;

        /// <summary>Specifies the gallery applications that should be made available to the VM/VMSS</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IApplicationProfile ApplicationProfile { get => (this._applicationProfile = this._applicationProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ApplicationProfile()); set => this._applicationProfile = value; }

        /// <summary>Specifies the gallery applications that should be made available to the VM/VMSS</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVMGalleryApplication> ApplicationProfileGalleryApplication { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IApplicationProfileInternal)ApplicationProfile).GalleryApplication; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IApplicationProfileInternal)ApplicationProfile).GalleryApplication = value ?? null /* arrayOf */; }

        /// <summary>Whether boot diagnostics should be enabled on the Virtual Machine.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? BootDiagnosticEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IDiagnosticsProfileInternal)DiagnosticsProfile).BootDiagnosticEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IDiagnosticsProfileInternal)DiagnosticsProfile).BootDiagnosticEnabled = value ?? default(bool); }

        /// <summary>
        /// Uri of the storage account to use for placing the console output and
        /// screenshot. If storageUri is not specified while enabling boot diagnostics,
        /// managed storage will be used.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string BootDiagnosticStorageUri { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IDiagnosticsProfileInternal)DiagnosticsProfile).BootDiagnosticStorageUri; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IDiagnosticsProfileInternal)DiagnosticsProfile).BootDiagnosticStorageUri = value ?? null; }

        /// <summary>Backing field for <see cref="CapacityReservation" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ICapacityReservationProfile _capacityReservation;

        /// <summary>
        /// Specifies the capacity reservation related details of a scale set. Minimum
        /// api-version: 2021-04-01.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ICapacityReservationProfile CapacityReservation { get => (this._capacityReservation = this._capacityReservation ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.CapacityReservationProfile()); set => this._capacityReservation = value; }

        /// <summary>Resource Id</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string CapacityReservationGroupId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ICapacityReservationProfileInternal)CapacityReservation).CapacityReservationGroupId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ICapacityReservationProfileInternal)CapacityReservation).CapacityReservationGroupId = value ?? null; }

        /// <summary>Backing field for <see cref="DiagnosticsProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IDiagnosticsProfile _diagnosticsProfile;

        /// <summary>Specifies the boot diagnostic settings state.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IDiagnosticsProfile DiagnosticsProfile { get => (this._diagnosticsProfile = this._diagnosticsProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.DiagnosticsProfile()); set => this._diagnosticsProfile = value; }

        /// <summary>Specifies the ephemeral disk settings for operating system disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string DiffDiskSettingOption { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).DiffDiskSettingOption; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).DiffDiskSettingOption = value ?? null; }

        /// <summary>
        /// Specifies the ephemeral disk placement for operating system disk. Possible
        /// values are: **CacheDisk,** **ResourceDisk.** The defaulting behavior is:
        /// **CacheDisk** if one is configured for the VM size otherwise **ResourceDisk**
        /// is used. Refer to the VM size documentation for Windows VM at
        /// https://docs.microsoft.com/azure/virtual-machines/windows/sizes and Linux VM at
        /// https://docs.microsoft.com/azure/virtual-machines/linux/sizes to check which VM
        /// sizes exposes a cache disk.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string DiffDiskSettingPlacement { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).DiffDiskSettingPlacement; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).DiffDiskSettingPlacement = value ?? null; }

        /// <summary>Specifies ARM Resource ID of one of the user identities associated with the VM.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string EncryptionIdentityUserAssignedIdentityResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).EncryptionIdentityUserAssignedIdentityResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).EncryptionIdentityUserAssignedIdentityResourceId = value ?? null; }

        /// <summary>Backing field for <see cref="ExtensionProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetExtensionProfile _extensionProfile;

        /// <summary>
        /// Specifies a collection of settings for extensions installed on virtual machines
        /// in the scale set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetExtensionProfile ExtensionProfile { get => (this._extensionProfile = this._extensionProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.VirtualMachineScaleSetExtensionProfile()); set => this._extensionProfile = value; }

        /// <summary>The virtual machine scale set child extension resources.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetExtension> ExtensionProfileExtension { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetExtensionProfileInternal)ExtensionProfile).Extension; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetExtensionProfileInternal)ExtensionProfile).Extension = value ?? null /* arrayOf */; }

        /// <summary>
        /// Specifies the time alloted for all extensions to start. The time duration
        /// should be between 15 minutes and 120 minutes (inclusive) and should be
        /// specified in ISO 8601 format. The default value is 90 minutes (PT1H30M).
        /// Minimum api-version: 2020-06-01.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string ExtensionProfileExtensionsTimeBudget { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetExtensionProfileInternal)ExtensionProfile).ExtensionsTimeBudget; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetExtensionProfileInternal)ExtensionProfile).ExtensionsTimeBudget = value ?? null; }

        /// <summary>Backing field for <see cref="HardwareProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetHardwareProfile _hardwareProfile;

        /// <summary>
        /// Specifies the hardware profile related details of a scale set. Minimum
        /// api-version: 2021-11-01.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetHardwareProfile HardwareProfile { get => (this._hardwareProfile = this._hardwareProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.VirtualMachineScaleSetHardwareProfile()); set => this._hardwareProfile = value; }

        /// <summary>
        /// The ARM resource id in the form of
        /// /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string HealthProbeId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetNetworkProfileInternal)NetworkProfile).HealthProbeId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetNetworkProfileInternal)NetworkProfile).HealthProbeId = value ?? null; }

        /// <summary>Resource Id</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).Id = value ?? null; }

        /// <summary>
        /// Specified the community gallery image unique id for vm deployment. This can be
        /// fetched from community gallery image GET call.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string ImageReferenceCommunityGalleryImageId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReferenceCommunityGalleryImageId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReferenceCommunityGalleryImageId = value ?? null; }

        /// <summary>
        /// Specifies in decimal numbers, the version of platform image or marketplace
        /// image used to create the virtual machine. This readonly field differs from 'version',
        /// only if the value specified in 'version' field is 'latest'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string ImageReferenceExactVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReferenceExactVersion; }

        /// <summary>Resource Id</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string ImageReferenceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReferenceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReferenceId = value ?? null; }

        /// <summary>
        /// Specifies the offer of the platform image or marketplace image used to create
        /// the virtual machine.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string ImageReferenceOffer { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReferenceOffer; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReferenceOffer = value ?? null; }

        /// <summary>The image publisher.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string ImageReferencePublisher { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReferencePublisher; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReferencePublisher = value ?? null; }

        /// <summary>
        /// Specified the shared gallery image unique id for vm deployment. This can be
        /// fetched from shared gallery image GET call.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string ImageReferenceSharedGalleryImageId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReferenceSharedGalleryImageId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReferenceSharedGalleryImageId = value ?? null; }

        /// <summary>The image SKU.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string ImageReferenceSku { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReferenceSku; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReferenceSku = value ?? null; }

        /// <summary>
        /// Specifies the version of the platform image or marketplace image used to create
        /// the virtual machine. The allowed formats are Major.Minor.Build or 'latest'.
        /// Major, Minor, and Build are decimal numbers. Specify 'latest' to use the latest
        /// version of an image available at deploy time. Even if you use 'latest', the VM
        /// image will not automatically update after deploy time even if a new version
        /// becomes available. Please do not use field 'version' for gallery image
        /// deployment, gallery image should always use 'id' field for deployment, to use 'latest'
        /// version of gallery image, just set
        /// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageName}'
        /// in the 'id' field without version input.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string ImageReferenceVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReferenceVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReferenceVersion = value ?? null; }

        /// <summary>Specifies the virtual hard disk's uri.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string ImageUri { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageUri; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageUri = value ?? null; }

        /// <summary>Backing field for <see cref="LicenseType" /> property.</summary>
        private string _licenseType;

        /// <summary>
        /// Specifies that the image or disk that is being used was licensed on-premises.
        /// <br><br> Possible values for Windows Server operating system are: <br><br>
        /// Windows_Client <br><br> Windows_Server <br><br> Possible values for Linux
        /// Server operating system are: <br><br> RHEL_BYOS (for RHEL) <br><br> SLES_BYOS
        /// (for SUSE) <br><br> For more information, see [Azure Hybrid Use Benefit for
        /// Windows
        /// Server](https://docs.microsoft.com/azure/virtual-machines/windows/hybrid-use-benefit-licensing)
        /// <br><br> [Azure Hybrid Use Benefit for Linux
        /// Server](https://docs.microsoft.com/azure/virtual-machines/linux/azure-hybrid-benefit-linux)
        /// <br><br> Minimum api-version: 2015-06-15
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Owned)]
        public string LicenseType { get => this._licenseType; set => this._licenseType = value; }

        /// <summary>Specifies whether password authentication should be disabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? LinuxConfigurationDisablePasswordAuthentication { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationDisablePasswordAuthentication; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationDisablePasswordAuthentication = value ?? default(bool); }

        /// <summary>
        /// Indicates whether VMAgent Platform Updates is enabled for the Linux virtual
        /// machine. Default value is false.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? LinuxConfigurationEnableVMAgentPlatformUpdate { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationEnableVMAgentPlatformUpdate; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationEnableVMAgentPlatformUpdate = value ?? default(bool); }

        /// <summary>
        /// Specifies the mode of VM Guest Patch Assessment for the IaaS virtual
        /// machine.<br /><br /> Possible values are:<br /><br /> **ImageDefault** - You
        /// control the timing of patch assessments on a virtual machine. <br /><br />
        /// **AutomaticByPlatform** - The platform will trigger periodic patch assessments.
        /// The property provisionVMAgent must be true.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string LinuxConfigurationPatchSettingsAssessmentMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationPatchSettingsAssessmentMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationPatchSettingsAssessmentMode = value ?? null; }

        /// <summary>Enables customer to schedule patching without accidental upgrades</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? LinuxConfigurationPatchSettingsAutomaticByPlatformSettingsBypassPlatformSafetyChecksOnUserSchedule { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationPatchSettingsAutomaticByPlatformSettingsBypassPlatformSafetyChecksOnUserSchedule; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationPatchSettingsAutomaticByPlatformSettingsBypassPlatformSafetyChecksOnUserSchedule = value ?? default(bool); }

        /// <summary>
        /// Specifies the reboot setting for all AutomaticByPlatform patch installation
        /// operations.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string LinuxConfigurationPatchSettingsAutomaticByPlatformSettingsRebootSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationPatchSettingsAutomaticByPlatformSettingsRebootSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationPatchSettingsAutomaticByPlatformSettingsRebootSetting = value ?? null; }

        /// <summary>
        /// Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual
        /// machines associated to virtual machine scale set with OrchestrationMode as
        /// Flexible.<br /><br /> Possible values are:<br /><br /> **ImageDefault** - The
        /// virtual machine's default patching configuration is used. <br /><br />
        /// **AutomaticByPlatform** - The virtual machine will be automatically updated by
        /// the platform. The property provisionVMAgent must be true
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string LinuxConfigurationPatchSettingsPatchMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationPatchSettingsPatchMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationPatchSettingsPatchMode = value ?? null; }

        /// <summary>
        /// Indicates whether virtual machine agent should be provisioned on the virtual
        /// machine. When this property is not specified in the request body, default
        /// behavior is to set it to true. This will ensure that VM Agent is installed on
        /// the VM so that extensions can be added to the VM later.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? LinuxConfigurationProvisionVMAgent { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationProvisionVMAgent; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationProvisionVMAgent = value ?? default(bool); }

        /// <summary>
        /// Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can
        /// only be used with data disks, it cannot be used with OS Disk.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string ManagedDiskStorageAccountType { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ManagedDiskStorageAccountType; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ManagedDiskStorageAccountType = value ?? null; }

        /// <summary>Internal Acessors for ApplicationProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IApplicationProfile Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.ApplicationProfile { get => (this._applicationProfile = this._applicationProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ApplicationProfile()); set { {_applicationProfile = value;} } }

        /// <summary>Internal Acessors for CapacityReservation</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ICapacityReservationProfile Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.CapacityReservation { get => (this._capacityReservation = this._capacityReservation ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.CapacityReservationProfile()); set { {_capacityReservation = value;} } }

        /// <summary>Internal Acessors for CapacityReservationGroup</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISubResource Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.CapacityReservationGroup { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ICapacityReservationProfileInternal)CapacityReservation).CapacityReservationGroup; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ICapacityReservationProfileInternal)CapacityReservation).CapacityReservationGroup = value; }

        /// <summary>Internal Acessors for DiagnosticProfileBootDiagnostic</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBootDiagnostics Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.DiagnosticProfileBootDiagnostic { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IDiagnosticsProfileInternal)DiagnosticsProfile).BootDiagnostic; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IDiagnosticsProfileInternal)DiagnosticsProfile).BootDiagnostic = value; }

        /// <summary>Internal Acessors for DiagnosticsProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IDiagnosticsProfile Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.DiagnosticsProfile { get => (this._diagnosticsProfile = this._diagnosticsProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.DiagnosticsProfile()); set { {_diagnosticsProfile = value;} } }

        /// <summary>Internal Acessors for ExtensionProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetExtensionProfile Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.ExtensionProfile { get => (this._extensionProfile = this._extensionProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.VirtualMachineScaleSetExtensionProfile()); set { {_extensionProfile = value;} } }

        /// <summary>Internal Acessors for HardwareProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetHardwareProfile Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.HardwareProfile { get => (this._hardwareProfile = this._hardwareProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.VirtualMachineScaleSetHardwareProfile()); set { {_hardwareProfile = value;} } }

        /// <summary>Internal Acessors for HardwareProfileVMSizeProperty</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVMSizeProperties Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.HardwareProfileVMSizeProperty { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetHardwareProfileInternal)HardwareProfile).VMSizeProperty; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetHardwareProfileInternal)HardwareProfile).VMSizeProperty = value; }

        /// <summary>Internal Acessors for ImageReferenceExactVersion</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.ImageReferenceExactVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReferenceExactVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReferenceExactVersion = value; }

        /// <summary>Internal Acessors for LinuxConfigurationPatchSetting</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ILinuxPatchSettings Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.LinuxConfigurationPatchSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationPatchSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationPatchSetting = value; }

        /// <summary>Internal Acessors for LinuxConfigurationPatchSettingsAutomaticByPlatformSetting</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ILinuxVMGuestPatchAutomaticByPlatformSettings Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.LinuxConfigurationPatchSettingsAutomaticByPlatformSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationPatchSettingsAutomaticByPlatformSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationPatchSettingsAutomaticByPlatformSetting = value; }

        /// <summary>Internal Acessors for LinuxConfigurationSsh</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISshConfiguration Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.LinuxConfigurationSsh { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationSsh; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfigurationSsh = value; }

        /// <summary>Internal Acessors for ManagedDiskEncryptionSet</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IDiskEncryptionSetParameters Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.ManagedDiskEncryptionSet { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ManagedDiskEncryptionSet; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ManagedDiskEncryptionSet = value; }

        /// <summary>Internal Acessors for ManagedDiskSecurityProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVMDiskSecurityProfile Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.ManagedDiskSecurityProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ManagedDiskSecurityProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ManagedDiskSecurityProfile = value; }

        /// <summary>Internal Acessors for NetworkProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetNetworkProfile Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.NetworkProfile { get => (this._networkProfile = this._networkProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.VirtualMachineScaleSetNetworkProfile()); set { {_networkProfile = value;} } }

        /// <summary>Internal Acessors for NetworkProfileHealthProbe</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IApiEntityReference Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.NetworkProfileHealthProbe { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetNetworkProfileInternal)NetworkProfile).HealthProbe; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetNetworkProfileInternal)NetworkProfile).HealthProbe = value; }

        /// <summary>Internal Acessors for OSDiskDiffDiskSetting</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IDiffDiskSettings Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.OSDiskDiffDiskSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskDiffDiskSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskDiffDiskSetting = value; }

        /// <summary>Internal Acessors for OSDiskImage</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualHardDisk Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.OSDiskImage { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskImage; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskImage = value; }

        /// <summary>Internal Acessors for OSDiskManagedDisk</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetManagedDiskParameters Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.OSDiskManagedDisk { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskManagedDisk; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskManagedDisk = value; }

        /// <summary>Internal Acessors for OSProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfile Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.OSProfile { get => (this._oSProfile = this._oSProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.VirtualMachineScaleSetOSProfile()); set { {_oSProfile = value;} } }

        /// <summary>Internal Acessors for OSProfileLinuxConfiguration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ILinuxConfiguration Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.OSProfileLinuxConfiguration { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfiguration; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).LinuxConfiguration = value; }

        /// <summary>Internal Acessors for OSProfileWindowsConfiguration</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IWindowsConfiguration Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.OSProfileWindowsConfiguration { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowsConfiguration; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowsConfiguration = value; }

        /// <summary>Internal Acessors for ScheduledEventProfileOSImageNotificationProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IOSImageNotificationProfile Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.ScheduledEventProfileOSImageNotificationProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IScheduledEventsProfileInternal)ScheduledEventsProfile).OSImageNotificationProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IScheduledEventsProfileInternal)ScheduledEventsProfile).OSImageNotificationProfile = value; }

        /// <summary>Internal Acessors for ScheduledEventProfileTerminateNotificationProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ITerminateNotificationProfile Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.ScheduledEventProfileTerminateNotificationProfile { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IScheduledEventsProfileInternal)ScheduledEventsProfile).TerminateNotificationProfile; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IScheduledEventsProfileInternal)ScheduledEventsProfile).TerminateNotificationProfile = value; }

        /// <summary>Internal Acessors for ScheduledEventsProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IScheduledEventsProfile Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.ScheduledEventsProfile { get => (this._scheduledEventsProfile = this._scheduledEventsProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ScheduledEventsProfile()); set { {_scheduledEventsProfile = value;} } }

        /// <summary>Internal Acessors for SecurityPostureReference</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityPostureReference Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.SecurityPostureReference { get => (this._securityPostureReference = this._securityPostureReference ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.SecurityPostureReference()); set { {_securityPostureReference = value;} } }

        /// <summary>Internal Acessors for SecurityProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfile Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.SecurityProfile { get => (this._securityProfile = this._securityProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.SecurityProfile()); set { {_securityProfile = value;} } }

        /// <summary>Internal Acessors for SecurityProfileDiskEncryptionSet</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IDiskEncryptionSetParameters Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.SecurityProfileDiskEncryptionSet { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).SecurityProfileDiskEncryptionSet; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).SecurityProfileDiskEncryptionSet = value; }

        /// <summary>Internal Acessors for SecurityProfileEncryptionIdentity</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IEncryptionIdentity Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.SecurityProfileEncryptionIdentity { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).EncryptionIdentity; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).EncryptionIdentity = value; }

        /// <summary>Internal Acessors for SecurityProfileProxyAgentSetting</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IProxyAgentSettings Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.SecurityProfileProxyAgentSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).ProxyAgentSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).ProxyAgentSetting = value; }

        /// <summary>Internal Acessors for SecurityProfileUefiSetting</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IUefiSettings Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.SecurityProfileUefiSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).UefiSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).UefiSetting = value; }

        /// <summary>Internal Acessors for ServiceArtifactReference</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IServiceArtifactReference Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.ServiceArtifactReference { get => (this._serviceArtifactReference = this._serviceArtifactReference ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ServiceArtifactReference()); set { {_serviceArtifactReference = value;} } }

        /// <summary>Internal Acessors for StorageProfile</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfile Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.StorageProfile { get => (this._storageProfile = this._storageProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.VirtualMachineScaleSetStorageProfile()); set { {_storageProfile = value;} } }

        /// <summary>Internal Acessors for StorageProfileImageReference</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IImageReference Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.StorageProfileImageReference { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReference; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).ImageReference = value; }

        /// <summary>Internal Acessors for StorageProfileOSDisk</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSDisk Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.StorageProfileOSDisk { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDisk; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDisk = value; }

        /// <summary>Internal Acessors for TimeCreated</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.TimeCreated { get => this._timeCreated; set { {_timeCreated = value;} } }

        /// <summary>Internal Acessors for WindowConfigurationPatchSetting</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IPatchSettings Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.WindowConfigurationPatchSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowConfigurationPatchSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowConfigurationPatchSetting = value; }

        /// <summary>Internal Acessors for WindowConfigurationWinRm</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IWinRmConfiguration Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.WindowConfigurationWinRm { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowConfigurationWinRm; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowConfigurationWinRm = value; }

        /// <summary>
        /// Internal Acessors for WindowsConfigurationPatchSettingsAutomaticByPlatformSetting
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IWindowsVMGuestPatchAutomaticByPlatformSettings Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBaseVirtualMachineProfileInternal.WindowsConfigurationPatchSettingsAutomaticByPlatformSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowsConfigurationPatchSettingsAutomaticByPlatformSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowsConfigurationPatchSettingsAutomaticByPlatformSetting = value; }

        /// <summary>Backing field for <see cref="NetworkProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetNetworkProfile _networkProfile;

        /// <summary>
        /// Specifies properties of the network interfaces of the virtual machines in the
        /// scale set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetNetworkProfile NetworkProfile { get => (this._networkProfile = this._networkProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.VirtualMachineScaleSetNetworkProfile()); set => this._networkProfile = value; }

        /// <summary>
        /// specifies the Microsoft.Network API version used when creating networking
        /// resources in the Network Interface Configurations for Virtual Machine Scale Set
        /// with orchestration mode 'Flexible'
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string NetworkProfileNetworkApiVersion { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetNetworkProfileInternal)NetworkProfile).NetworkApiVersion; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetNetworkProfileInternal)NetworkProfile).NetworkApiVersion = value ?? null; }

        /// <summary>The list of network configurations.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetNetworkConfiguration> NetworkProfileNetworkInterfaceConfiguration { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetNetworkProfileInternal)NetworkProfile).NetworkInterfaceConfiguration; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetNetworkProfileInternal)NetworkProfile).NetworkInterfaceConfiguration = value ?? null /* arrayOf */; }

        /// <summary>
        /// Specifies the caching requirements. Possible values are: **None,**
        /// **ReadOnly,** **ReadWrite.** The default values are: **None for Standard
        /// storage. ReadOnly for Premium storage.**
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string OSDiskCaching { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskCaching; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskCaching = value ?? null; }

        /// <summary>
        /// Specifies how the virtual machines in the scale set should be created. The only
        /// allowed value is: **FromImage.** This value is used when you are using an image
        /// to create the virtual machine. If you are using a platform image, you also use
        /// the imageReference element described above. If you are using a marketplace
        /// image, you also use the plan element previously described.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string OSDiskCreateOption { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskCreateOption; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskCreateOption = value ?? null; }

        /// <summary>
        /// Specifies whether OS Disk should be deleted or detached upon VMSS Flex deletion
        /// (This feature is available for VMSS with Flexible OrchestrationMode only).
        /// <br><br> Possible values: <br><br> **Delete** If this value is used, the OS
        /// disk is deleted when VMSS Flex VM is deleted.<br><br> **Detach** If this value
        /// is used, the OS disk is retained after VMSS Flex VM is deleted. <br><br> The
        /// default value is set to **Delete**. For an Ephemeral OS Disk, the default value
        /// is set to **Delete**. User cannot change the delete option for Ephemeral OS
        /// Disk.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string OSDiskDeleteOption { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskDeleteOption; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskDeleteOption = value ?? null; }

        /// <summary>The disk name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string OSDiskName { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskName; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskName = value ?? null; }

        /// <summary>
        /// This property allows you to specify the type of the OS that is included in the
        /// disk if creating a VM from user-image or a specialized VHD. Possible values
        /// are: **Windows,** **Linux.**
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string OSDiskOstype { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskOstype; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskOstype = value ?? null; }

        /// <summary>
        /// Specifies the size of an empty data disk in gigabytes. This element can be used
        /// to overwrite the size of the disk in a virtual machine image. The property 'diskSizeGB'
        /// is the number of bytes x 1024^3 for the disk and the value cannot
        /// be larger than 1023.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public int? OSDiskSizeGb { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskSizeGb; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskSizeGb = value ?? default(int); }

        /// <summary>
        /// Specifies the container urls that are used to store operating system disks for
        /// the scale set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> OSDiskVhdContainer { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskVhdContainer; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskVhdContainer = value ?? null /* arrayOf */; }

        /// <summary>Specifies whether writeAccelerator should be enabled or disabled on the disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? OSDiskWriteAcceleratorEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskWriteAcceleratorEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).OSDiskWriteAcceleratorEnabled = value ?? default(bool); }

        /// <summary>Specifies whether the OS Image Scheduled event is enabled or disabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? OSImageNotificationProfileEnable { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IScheduledEventsProfileInternal)ScheduledEventsProfile).OSImageNotificationProfileEnable; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IScheduledEventsProfileInternal)ScheduledEventsProfile).OSImageNotificationProfileEnable = value ?? default(bool); }

        /// <summary>
        /// Length of time a Virtual Machine being reimaged or having its OS upgraded will
        /// have to potentially approve the OS Image Scheduled Event before the event is
        /// auto approved (timed out). The configuration is specified in ISO 8601 format,
        /// and the value must not exceed 15 minutes (PT15M)
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string OSImageNotificationProfileNotBeforeTimeout { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IScheduledEventsProfileInternal)ScheduledEventsProfile).OSImageNotificationProfileNotBeforeTimeout; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IScheduledEventsProfileInternal)ScheduledEventsProfile).OSImageNotificationProfileNotBeforeTimeout = value ?? null; }

        /// <summary>Backing field for <see cref="OSProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfile _oSProfile;

        /// <summary>
        /// Specifies the operating system settings for the virtual machines in the scale
        /// set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfile OSProfile { get => (this._oSProfile = this._oSProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.VirtualMachineScaleSetOSProfile()); set => this._oSProfile = value; }

        /// <summary>
        /// Specifies the password of the administrator account. <br><br> **Minimum-length
        /// (Windows):** 8 characters <br><br> **Minimum-length (Linux):** 6 characters
        /// <br><br> **Max-length (Windows):** 123 characters <br><br> **Max-length
        /// (Linux):** 72 characters <br><br> **Complexity requirements:** 3 out of 4
        /// conditions below need to be fulfilled <br> Has lower characters <br>Has upper
        /// characters <br> Has a digit <br> Has a special character (Regex match [\W_])
        /// <br><br> **Disallowed values:** "abc@123", "P@$$w0rd", "P@ssw0rd",
        /// "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1",
        /// "Password22", "iloveyou!" <br><br> For resetting the password, see [How to
        /// reset the Remote Desktop service or its login password in a Windows
        /// VM](https://docs.microsoft.com/troubleshoot/azure/virtual-machines/reset-rdp)
        /// <br><br> For resetting root password, see [Manage users, SSH, and check or
        /// repair disks on Azure Linux VMs using the VMAccess
        /// Extension](https://docs.microsoft.com/troubleshoot/azure/virtual-machines/troubleshoot-ssh-connection)
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public System.Security.SecureString OSProfileAdminPassword { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).AdminPassword; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).AdminPassword = value ?? null; }

        /// <summary>
        /// Specifies the name of the administrator account. <br><br> **Windows-only
        /// restriction:** Cannot end in "." <br><br> **Disallowed values:**
        /// "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3",
        /// "admin1", "1", "123", "a", "actuser", "adm", "admin2", "aspnet", "backup",
        /// "console", "david", "guest", "john", "owner", "root", "server", "sql",
        /// "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5".
        /// <br><br> **Minimum-length (Linux):** 1 character <br><br> **Max-length
        /// (Linux):** 64 characters <br><br> **Max-length (Windows):** 20 characters
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string OSProfileAdminUsername { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).AdminUsername; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).AdminUsername = value ?? null; }

        /// <summary>
        /// Specifies whether extension operations should be allowed on the virtual machine
        /// scale set. This may only be set to False when no extensions are present on the
        /// virtual machine scale set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? OSProfileAllowExtensionOperation { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).AllowExtensionOperation; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).AllowExtensionOperation = value ?? default(bool); }

        /// <summary>
        /// Specifies the computer name prefix for all of the virtual machines in the scale
        /// set. Computer name prefixes must be 1 to 15 characters long.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string OSProfileComputerNamePrefix { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).ComputerNamePrefix; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).ComputerNamePrefix = value ?? null; }

        /// <summary>
        /// Specifies a base-64 encoded string of custom data. The base-64 encoded string
        /// is decoded to a binary array that is saved as a file on the Virtual Machine.
        /// The maximum length of the binary array is 65535 bytes. For using cloud-init for
        /// your VM, see [Using cloud-init to customize a Linux VM during
        /// creation](https://docs.microsoft.com/azure/virtual-machines/linux/using-cloud-init)
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public System.Security.SecureString OSProfileCustomData { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).CustomData; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).CustomData = value ?? null; }

        /// <summary>Optional property which must either be set to True or omitted.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? OSProfileRequireGuestProvisionSignal { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).RequireGuestProvisionSignal; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).RequireGuestProvisionSignal = value ?? default(bool); }

        /// <summary>
        /// Specifies set of certificates that should be installed onto the virtual
        /// machines in the scale set. To install certificates on a virtual machine it is
        /// recommended to use the [Azure Key Vault virtual machine extension for
        /// Linux](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-linux)
        /// or the [Azure Key Vault virtual machine extension for
        /// Windows](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-windows).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVaultSecretGroup> OSProfileSecret { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).Secret; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).Secret = value ?? null /* arrayOf */; }

        /// <summary>
        /// Enables customers to patch their Azure VMs without requiring a reboot. For
        /// enableHotpatching, the 'provisionVMAgent' must be set to true and 'patchMode'
        /// must be set to 'AutomaticByPlatform'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? PatchSettingEnableHotpatching { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).PatchSettingEnableHotpatching; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).PatchSettingEnableHotpatching = value ?? default(bool); }

        /// <summary>
        /// Specifies whether ProxyAgent feature should be enabled on the virtual machine
        /// or virtual machine scale set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? ProxyAgentSettingEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).ProxyAgentSettingEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).ProxyAgentSettingEnabled = value ?? default(bool); }

        /// <summary>
        /// Increase the value of this property allows user to reset the key used for
        /// securing communication channel between guest and host.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public int? ProxyAgentSettingKeyIncarnationId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).ProxyAgentSettingKeyIncarnationId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).ProxyAgentSettingKeyIncarnationId = value ?? default(int); }

        /// <summary>
        /// Specifies the mode that ProxyAgent will execute on if the feature is enabled.
        /// ProxyAgent will start to audit or monitor but not enforce access control over
        /// requests to host endpoints in Audit mode, while in Enforce mode it will enforce
        /// access control. The default value is Enforce mode.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string ProxyAgentSettingMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).ProxyAgentSettingMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).ProxyAgentSettingMode = value ?? null; }

        /// <summary>Backing field for <see cref="ScheduledEventsProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IScheduledEventsProfile _scheduledEventsProfile;

        /// <summary>Specifies Scheduled Event related configurations.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IScheduledEventsProfile ScheduledEventsProfile { get => (this._scheduledEventsProfile = this._scheduledEventsProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ScheduledEventsProfile()); set => this._scheduledEventsProfile = value; }

        /// <summary>Backing field for <see cref="SecurityPostureReference" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityPostureReference _securityPostureReference;

        /// <summary>
        /// Specifies the security posture to be used for all virtual machines in the scale
        /// set. Minimum api-version: 2023-03-01
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityPostureReference SecurityPostureReference { get => (this._securityPostureReference = this._securityPostureReference ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.SecurityPostureReference()); set => this._securityPostureReference = value; }

        /// <summary>
        /// List of virtual machine extension names to exclude when applying the security
        /// posture.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> SecurityPostureReferenceExcludeExtension { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityPostureReferenceInternal)SecurityPostureReference).ExcludeExtension; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityPostureReferenceInternal)SecurityPostureReference).ExcludeExtension = value ?? null /* arrayOf */; }

        /// <summary>
        /// The security posture reference id in the form of
        /// /CommunityGalleries/{communityGalleryName}/securityPostures/{securityPostureName}/versions/{major.minor.patch}|{major.*}|latest
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string SecurityPostureReferenceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityPostureReferenceInternal)SecurityPostureReference).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityPostureReferenceInternal)SecurityPostureReference).Id = value ?? null; }

        /// <summary>Whether the security posture can be overridden by the user.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? SecurityPostureReferenceIsOverridable { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityPostureReferenceInternal)SecurityPostureReference).IsOverridable; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityPostureReferenceInternal)SecurityPostureReference).IsOverridable = value ?? default(bool); }

        /// <summary>Backing field for <see cref="SecurityProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfile _securityProfile;

        /// <summary>
        /// Specifies the Security related profile settings for the virtual machines in the
        /// scale set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfile SecurityProfile { get => (this._securityProfile = this._securityProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.SecurityProfile()); set => this._securityProfile = value; }

        /// <summary>Resource Id</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string SecurityProfileDiskEncryptionSetId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).SecurityProfileDiskEncryptionSetId; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).SecurityProfileDiskEncryptionSetId = value ?? null; }

        /// <summary>
        /// This property can be used by user in the request to enable or disable the Host
        /// Encryption for the virtual machine or virtual machine scale set. This will
        /// enable the encryption for all the disks including Resource/Temp disk at host
        /// itself. The default behavior is: The Encryption at host will be disabled unless
        /// this property is set to true for the resource.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? SecurityProfileEncryptionAtHost { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).EncryptionAtHost; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).EncryptionAtHost = value ?? default(bool); }

        /// <summary>
        /// Specifies the EncryptionType of the managed disk. It is set to
        /// DiskWithVMGuestState for encryption of the managed disk along with VMGuestState
        /// blob, VMGuestStateOnly for encryption of just the VMGuestState blob, and
        /// NonPersistedTPM for not persisting firmware state in the VMGuestState blob..
        /// **Note:** It can be set for only Confidential VMs.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string SecurityProfileSecurityEncryptionType { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).SecurityProfileSecurityEncryptionType; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).SecurityProfileSecurityEncryptionType = value ?? null; }

        /// <summary>
        /// Specifies the SecurityType of the virtual machine. It has to be set to any
        /// specified value to enable UefiSettings. The default behavior is: UefiSettings
        /// will not be enabled unless this property is set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string SecurityProfileSecurityType { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).SecurityType; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).SecurityType = value ?? null; }

        /// <summary>Backing field for <see cref="ServiceArtifactReference" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IServiceArtifactReference _serviceArtifactReference;

        /// <summary>
        /// Specifies the service artifact reference id used to set same image version for
        /// all virtual machines in the scale set when using 'latest' image version.
        /// Minimum api-version: 2022-11-01
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IServiceArtifactReference ServiceArtifactReference { get => (this._serviceArtifactReference = this._serviceArtifactReference ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ServiceArtifactReference()); set => this._serviceArtifactReference = value; }

        /// <summary>
        /// The service artifact reference id in the form of
        /// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/serviceArtifacts/{serviceArtifactName}/vmArtifactsProfiles/{vmArtifactsProfilesName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string ServiceArtifactReferenceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IServiceArtifactReferenceInternal)ServiceArtifactReference).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IServiceArtifactReferenceInternal)ServiceArtifactReference).Id = value ?? null; }

        /// <summary>The list of SSH public keys used to authenticate with linux based VMs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISshPublicKey> SshPublicKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).SshPublicKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).SshPublicKey = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="StorageProfile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfile _storageProfile;

        /// <summary>Specifies the storage settings for the virtual machine disks.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfile StorageProfile { get => (this._storageProfile = this._storageProfile ?? new Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.VirtualMachineScaleSetStorageProfile()); set => this._storageProfile = value; }

        /// <summary>
        /// Specifies the parameters that are used to add data disks to the virtual
        /// machines in the scale set. For more information about disks, see [About disks
        /// and VHDs for Azure virtual
        /// machines](https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetDataDisk> StorageProfileDataDisk { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).DataDisk; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).DataDisk = value ?? null /* arrayOf */; }

        /// <summary>
        /// Specifies the disk controller type configured for the virtual machines in the scale set. Minimum api-version: 2022-08-01
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string StorageProfileDiskControllerType { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).DiskControllerType; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfileInternal)StorageProfile).DiskControllerType = value ?? null; }

        /// <summary>Specifies whether the Terminate Scheduled event is enabled or disabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? TerminateNotificationProfileEnable { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IScheduledEventsProfileInternal)ScheduledEventsProfile).TerminateNotificationProfileEnable; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IScheduledEventsProfileInternal)ScheduledEventsProfile).TerminateNotificationProfileEnable = value ?? default(bool); }

        /// <summary>
        /// Configurable length of time a Virtual Machine being deleted will have to
        /// potentially approve the Terminate Scheduled Event before the event is auto
        /// approved (timed out). The configuration must be specified in ISO 8601 format,
        /// the default value is 5 minutes (PT5M)
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string TerminateNotificationProfileNotBeforeTimeout { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IScheduledEventsProfileInternal)ScheduledEventsProfile).TerminateNotificationProfileNotBeforeTimeout; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IScheduledEventsProfileInternal)ScheduledEventsProfile).TerminateNotificationProfileNotBeforeTimeout = value ?? null; }

        /// <summary>Backing field for <see cref="TimeCreated" /> property.</summary>
        private global::System.DateTime? _timeCreated;

        /// <summary>
        /// Specifies the time in which this VM profile for the Virtual Machine Scale Set
        /// was created. Minimum API version for this property is 2023-09-01. This value
        /// will be added to VMSS Flex VM tags when creating/updating the VMSS VM Profile
        /// with minimum api-version 2023-09-01. Examples: "2024-07-01T00:00:01.1234567+00:00"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Owned)]
        public global::System.DateTime? TimeCreated { get => this._timeCreated; }

        /// <summary>
        /// Specifies whether secure boot should be enabled on the virtual machine. Minimum
        /// api-version: 2020-12-01.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? UefiSettingSecureBootEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).UefiSettingSecureBootEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).UefiSettingSecureBootEnabled = value ?? default(bool); }

        /// <summary>
        /// Specifies whether vTPM should be enabled on the virtual machine. Minimum
        /// api-version: 2020-12-01.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? UefiSettingVTpmEnabled { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).UefiSettingVTpmEnabled; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfileInternal)SecurityProfile).UefiSettingVTpmEnabled = value ?? default(bool); }

        /// <summary>Backing field for <see cref="UserData" /> property.</summary>
        private string _userData;

        /// <summary>
        /// UserData for the virtual machines in the scale set, which must be base-64
        /// encoded. Customer should not pass any secrets in here. Minimum api-version:
        /// 2021-03-01.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Owned)]
        public string UserData { get => this._userData; set => this._userData = value; }

        /// <summary>
        /// Specifies the number of vCPUs available for the VM. When this property is not
        /// specified in the request body the default behavior is to set it to the value of
        /// vCPUs available for that VM size exposed in api response of [List all available
        /// virtual machine sizes in a
        /// region](https://docs.microsoft.com/en-us/rest/api/compute/resource-skus/list).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public int? VMSizePropertyVcpUsAvailable { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetHardwareProfileInternal)HardwareProfile).VMSizePropertyVcpUsAvailable; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetHardwareProfileInternal)HardwareProfile).VMSizePropertyVcpUsAvailable = value ?? default(int); }

        /// <summary>
        /// Specifies the vCPU to physical core ratio. When this property is not specified
        /// in the request body the default behavior is set to the value of vCPUsPerCore
        /// for the VM Size exposed in api response of [List all available virtual machine
        /// sizes in a
        /// region](https://docs.microsoft.com/en-us/rest/api/compute/resource-skus/list).
        /// **Setting this property to 1 also means that hyper-threading is disabled.**
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public int? VMSizePropertyVcpUsPerCore { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetHardwareProfileInternal)HardwareProfile).VMSizePropertyVcpUsPerCore; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetHardwareProfileInternal)HardwareProfile).VMSizePropertyVcpUsPerCore = value ?? default(int); }

        /// <summary>The list of Windows Remote Management listeners</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IWinRmListener> WinRmListener { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WinRmListener; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WinRmListener = value ?? null /* arrayOf */; }

        /// <summary>
        /// Specifies additional base-64 encoded XML formatted information that can be
        /// included in the Unattend.xml file, which is used by Windows Setup.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IAdditionalUnattendContent> WindowConfigurationAdditionalUnattendContent { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowConfigurationAdditionalUnattendContent; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowConfigurationAdditionalUnattendContent = value ?? null /* arrayOf */; }

        /// <summary>
        /// Indicates whether Automatic Updates is enabled for the Windows virtual machine.
        /// Default value is true. For virtual machine scale sets, this property can be
        /// updated and updates will take effect on OS reprovisioning.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? WindowConfigurationEnableAutomaticUpdate { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowConfigurationEnableAutomaticUpdate; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowConfigurationEnableAutomaticUpdate = value ?? default(bool); }

        /// <summary>
        /// Indicates whether VMAgent Platform Updates is enabled for the Windows virtual
        /// machine. Default value is false.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? WindowConfigurationEnableVMAgentPlatformUpdate { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowConfigurationEnableVMAgentPlatformUpdate; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowConfigurationEnableVMAgentPlatformUpdate = value ?? default(bool); }

        /// <summary>
        /// Indicates whether virtual machine agent should be provisioned on the virtual
        /// machine. When this property is not specified in the request body, it is set to
        /// true by default. This will ensure that VM Agent is installed on the VM so that
        /// extensions can be added to the VM later.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? WindowConfigurationProvisionVMAgent { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowConfigurationProvisionVMAgent; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowConfigurationProvisionVMAgent = value ?? default(bool); }

        /// <summary>
        /// Specifies the time zone of the virtual machine. e.g. "Pacific Standard Time".
        /// Possible values can be
        /// [TimeZoneInfo.Id](https://docs.microsoft.com/dotnet/api/system.timezoneinfo.id?#System_TimeZoneInfo_Id)
        /// value from time zones returned by
        /// [TimeZoneInfo.GetSystemTimeZones](https://docs.microsoft.com/dotnet/api/system.timezoneinfo.getsystemtimezones).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string WindowConfigurationTimeZone { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowConfigurationTimeZone; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowConfigurationTimeZone = value ?? null; }

        /// <summary>
        /// Specifies the mode of VM Guest patch assessment for the IaaS virtual
        /// machine.<br /><br /> Possible values are:<br /><br /> **ImageDefault** - You
        /// control the timing of patch assessments on a virtual machine.<br /><br />
        /// **AutomaticByPlatform** - The platform will trigger periodic patch assessments.
        /// The property provisionVMAgent must be true.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string WindowsConfigurationPatchSettingsAssessmentMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowsConfigurationPatchSettingsAssessmentMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowsConfigurationPatchSettingsAssessmentMode = value ?? null; }

        /// <summary>Enables customer to schedule patching without accidental upgrades</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public bool? WindowsConfigurationPatchSettingsAutomaticByPlatformSettingsBypassPlatformSafetyChecksOnUserSchedule { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowsConfigurationPatchSettingsAutomaticByPlatformSettingsBypassPlatformSafetyChecksOnUserSchedule; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowsConfigurationPatchSettingsAutomaticByPlatformSettingsBypassPlatformSafetyChecksOnUserSchedule = value ?? default(bool); }

        /// <summary>
        /// Specifies the reboot setting for all AutomaticByPlatform patch installation
        /// operations.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string WindowsConfigurationPatchSettingsAutomaticByPlatformSettingsRebootSetting { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowsConfigurationPatchSettingsAutomaticByPlatformSettingsRebootSetting; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowsConfigurationPatchSettingsAutomaticByPlatformSettingsRebootSetting = value ?? null; }

        /// <summary>
        /// Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual
        /// machines associated to virtual machine scale set with OrchestrationMode as
        /// Flexible.<br /><br /> Possible values are:<br /><br /> **Manual** - You
        /// control the application of patches to a virtual machine. You do this by
        /// applying patches manually inside the VM. In this mode, automatic updates are
        /// disabled; the property WindowsConfiguration.enableAutomaticUpdates must be
        /// false<br /><br /> **AutomaticByOS** - The virtual machine will automatically be
        /// updated by the OS. The property WindowsConfiguration.enableAutomaticUpdates
        /// must be true. <br /><br /> **AutomaticByPlatform** - the virtual machine will
        /// automatically updated by the platform. The properties provisionVMAgent and
        /// WindowsConfiguration.enableAutomaticUpdates must be true
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Origin(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PropertyOrigin.Inlined)]
        public string WindowsConfigurationPatchSettingsPatchMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowsConfigurationPatchSettingsPatchMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfileInternal)OSProfile).WindowsConfigurationPatchSettingsPatchMode = value ?? null; }

        /// <summary>Creates an new <see cref="BaseVirtualMachineProfile" /> instance.</summary>
        public BaseVirtualMachineProfile()
        {

        }
    }
    /// Describes the base virtual machine profile for fleet
    public partial interface IBaseVirtualMachineProfile :
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.IJsonSerializable
    {
        /// <summary>Specifies the gallery applications that should be made available to the VM/VMSS</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the gallery applications that should be made available to the VM/VMSS",
        SerializedName = @"galleryApplications",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVMGalleryApplication) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVMGalleryApplication> ApplicationProfileGalleryApplication { get; set; }
        /// <summary>Whether boot diagnostics should be enabled on the Virtual Machine.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Whether boot diagnostics should be enabled on the Virtual Machine.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? BootDiagnosticEnabled { get; set; }
        /// <summary>
        /// Uri of the storage account to use for placing the console output and
        /// screenshot. If storageUri is not specified while enabling boot diagnostics,
        /// managed storage will be used.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Uri of the storage account to use for placing the console output and
        screenshot. If storageUri is not specified while enabling boot diagnostics,
        managed storage will be used.",
        SerializedName = @"storageUri",
        PossibleTypes = new [] { typeof(string) })]
        string BootDiagnosticStorageUri { get; set; }
        /// <summary>Resource Id</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Resource Id",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(string) })]
        string CapacityReservationGroupId { get; set; }
        /// <summary>Specifies the ephemeral disk settings for operating system disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the ephemeral disk settings for operating system disk.",
        SerializedName = @"option",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("Local")]
        string DiffDiskSettingOption { get; set; }
        /// <summary>
        /// Specifies the ephemeral disk placement for operating system disk. Possible
        /// values are: **CacheDisk,** **ResourceDisk.** The defaulting behavior is:
        /// **CacheDisk** if one is configured for the VM size otherwise **ResourceDisk**
        /// is used. Refer to the VM size documentation for Windows VM at
        /// https://docs.microsoft.com/azure/virtual-machines/windows/sizes and Linux VM at
        /// https://docs.microsoft.com/azure/virtual-machines/linux/sizes to check which VM
        /// sizes exposes a cache disk.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the ephemeral disk placement for operating system disk. Possible
        values are: **CacheDisk,** **ResourceDisk.** The defaulting behavior is:
        **CacheDisk** if one is configured for the VM size otherwise **ResourceDisk**
        is used. Refer to the VM size documentation for Windows VM at
        https://docs.microsoft.com/azure/virtual-machines/windows/sizes and Linux VM at
        https://docs.microsoft.com/azure/virtual-machines/linux/sizes to check which VM
        sizes exposes a cache disk.",
        SerializedName = @"placement",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("CacheDisk", "ResourceDisk", "NvmeDisk")]
        string DiffDiskSettingPlacement { get; set; }
        /// <summary>Specifies ARM Resource ID of one of the user identities associated with the VM.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies ARM Resource ID of one of the user identities associated with the VM.",
        SerializedName = @"userAssignedIdentityResourceId",
        PossibleTypes = new [] { typeof(string) })]
        string EncryptionIdentityUserAssignedIdentityResourceId { get; set; }
        /// <summary>The virtual machine scale set child extension resources.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The virtual machine scale set child extension resources.",
        SerializedName = @"extensions",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetExtension) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetExtension> ExtensionProfileExtension { get; set; }
        /// <summary>
        /// Specifies the time alloted for all extensions to start. The time duration
        /// should be between 15 minutes and 120 minutes (inclusive) and should be
        /// specified in ISO 8601 format. The default value is 90 minutes (PT1H30M).
        /// Minimum api-version: 2020-06-01.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the time alloted for all extensions to start. The time duration
        should be between 15 minutes and 120 minutes (inclusive) and should be
        specified in ISO 8601 format. The default value is 90 minutes (PT1H30M).
        Minimum api-version: 2020-06-01.",
        SerializedName = @"extensionsTimeBudget",
        PossibleTypes = new [] { typeof(string) })]
        string ExtensionProfileExtensionsTimeBudget { get; set; }
        /// <summary>
        /// The ARM resource id in the form of
        /// /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The ARM resource id in the form of
        /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(string) })]
        string HealthProbeId { get; set; }
        /// <summary>Resource Id</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Resource Id",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(string) })]
        string Id { get; set; }
        /// <summary>
        /// Specified the community gallery image unique id for vm deployment. This can be
        /// fetched from community gallery image GET call.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specified the community gallery image unique id for vm deployment. This can be
        fetched from community gallery image GET call.",
        SerializedName = @"communityGalleryImageId",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceCommunityGalleryImageId { get; set; }
        /// <summary>
        /// Specifies in decimal numbers, the version of platform image or marketplace
        /// image used to create the virtual machine. This readonly field differs from 'version',
        /// only if the value specified in 'version' field is 'latest'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Specifies in decimal numbers, the version of platform image or marketplace
        image used to create the virtual machine. This readonly field differs from 'version',
        only if the value specified in 'version' field is 'latest'.",
        SerializedName = @"exactVersion",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceExactVersion { get;  }
        /// <summary>Resource Id</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Resource Id",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceId { get; set; }
        /// <summary>
        /// Specifies the offer of the platform image or marketplace image used to create
        /// the virtual machine.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the offer of the platform image or marketplace image used to create
        the virtual machine.",
        SerializedName = @"offer",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceOffer { get; set; }
        /// <summary>The image publisher.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The image publisher.",
        SerializedName = @"publisher",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferencePublisher { get; set; }
        /// <summary>
        /// Specified the shared gallery image unique id for vm deployment. This can be
        /// fetched from shared gallery image GET call.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specified the shared gallery image unique id for vm deployment. This can be
        fetched from shared gallery image GET call.",
        SerializedName = @"sharedGalleryImageId",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceSharedGalleryImageId { get; set; }
        /// <summary>The image SKU.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The image SKU.",
        SerializedName = @"sku",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceSku { get; set; }
        /// <summary>
        /// Specifies the version of the platform image or marketplace image used to create
        /// the virtual machine. The allowed formats are Major.Minor.Build or 'latest'.
        /// Major, Minor, and Build are decimal numbers. Specify 'latest' to use the latest
        /// version of an image available at deploy time. Even if you use 'latest', the VM
        /// image will not automatically update after deploy time even if a new version
        /// becomes available. Please do not use field 'version' for gallery image
        /// deployment, gallery image should always use 'id' field for deployment, to use 'latest'
        /// version of gallery image, just set
        /// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageName}'
        /// in the 'id' field without version input.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the version of the platform image or marketplace image used to create
        the virtual machine. The allowed formats are Major.Minor.Build or 'latest'.
        Major, Minor, and Build are decimal numbers. Specify 'latest' to use the latest
        version of an image available at deploy time. Even if you use 'latest', the VM
        image will not automatically update after deploy time even if a new version
        becomes available. Please do not use field 'version' for gallery image
        deployment, gallery image should always use 'id' field for deployment, to use 'latest'
        version of gallery image, just set
        '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageName}'
        in the 'id' field without version input.",
        SerializedName = @"version",
        PossibleTypes = new [] { typeof(string) })]
        string ImageReferenceVersion { get; set; }
        /// <summary>Specifies the virtual hard disk's uri.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the virtual hard disk's uri.",
        SerializedName = @"uri",
        PossibleTypes = new [] { typeof(string) })]
        string ImageUri { get; set; }
        /// <summary>
        /// Specifies that the image or disk that is being used was licensed on-premises.
        /// <br><br> Possible values for Windows Server operating system are: <br><br>
        /// Windows_Client <br><br> Windows_Server <br><br> Possible values for Linux
        /// Server operating system are: <br><br> RHEL_BYOS (for RHEL) <br><br> SLES_BYOS
        /// (for SUSE) <br><br> For more information, see [Azure Hybrid Use Benefit for
        /// Windows
        /// Server](https://docs.microsoft.com/azure/virtual-machines/windows/hybrid-use-benefit-licensing)
        /// <br><br> [Azure Hybrid Use Benefit for Linux
        /// Server](https://docs.microsoft.com/azure/virtual-machines/linux/azure-hybrid-benefit-linux)
        /// <br><br> Minimum api-version: 2015-06-15
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies that the image or disk that is being used was licensed on-premises.
        <br><br> Possible values for Windows Server operating system are: <br><br>
        Windows_Client <br><br> Windows_Server <br><br> Possible values for Linux
        Server operating system are: <br><br> RHEL_BYOS (for RHEL) <br><br> SLES_BYOS
        (for SUSE) <br><br> For more information, see [Azure Hybrid Use Benefit for
        Windows
        Server](https://docs.microsoft.com/azure/virtual-machines/windows/hybrid-use-benefit-licensing)
        <br><br> [Azure Hybrid Use Benefit for Linux
        Server](https://docs.microsoft.com/azure/virtual-machines/linux/azure-hybrid-benefit-linux)
        <br><br> Minimum api-version: 2015-06-15",
        SerializedName = @"licenseType",
        PossibleTypes = new [] { typeof(string) })]
        string LicenseType { get; set; }
        /// <summary>Specifies whether password authentication should be disabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies whether password authentication should be disabled.",
        SerializedName = @"disablePasswordAuthentication",
        PossibleTypes = new [] { typeof(bool) })]
        bool? LinuxConfigurationDisablePasswordAuthentication { get; set; }
        /// <summary>
        /// Indicates whether VMAgent Platform Updates is enabled for the Linux virtual
        /// machine. Default value is false.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Indicates whether VMAgent Platform Updates is enabled for the Linux virtual
        machine. Default value is false.",
        SerializedName = @"enableVMAgentPlatformUpdates",
        PossibleTypes = new [] { typeof(bool) })]
        bool? LinuxConfigurationEnableVMAgentPlatformUpdate { get; set; }
        /// <summary>
        /// Specifies the mode of VM Guest Patch Assessment for the IaaS virtual
        /// machine.<br /><br /> Possible values are:<br /><br /> **ImageDefault** - You
        /// control the timing of patch assessments on a virtual machine. <br /><br />
        /// **AutomaticByPlatform** - The platform will trigger periodic patch assessments.
        /// The property provisionVMAgent must be true.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the mode of VM Guest Patch Assessment for the IaaS virtual
        machine.<br /><br /> Possible values are:<br /><br /> **ImageDefault** - You
        control the timing of patch assessments on a virtual machine. <br /><br />
        **AutomaticByPlatform** - The platform will trigger periodic patch assessments.
        The property provisionVMAgent must be true.",
        SerializedName = @"assessmentMode",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("ImageDefault", "AutomaticByPlatform")]
        string LinuxConfigurationPatchSettingsAssessmentMode { get; set; }
        /// <summary>Enables customer to schedule patching without accidental upgrades</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Enables customer to schedule patching without accidental upgrades",
        SerializedName = @"bypassPlatformSafetyChecksOnUserSchedule",
        PossibleTypes = new [] { typeof(bool) })]
        bool? LinuxConfigurationPatchSettingsAutomaticByPlatformSettingsBypassPlatformSafetyChecksOnUserSchedule { get; set; }
        /// <summary>
        /// Specifies the reboot setting for all AutomaticByPlatform patch installation
        /// operations.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the reboot setting for all AutomaticByPlatform patch installation
        operations.",
        SerializedName = @"rebootSetting",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("Unknown", "IfRequired", "Never", "Always")]
        string LinuxConfigurationPatchSettingsAutomaticByPlatformSettingsRebootSetting { get; set; }
        /// <summary>
        /// Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual
        /// machines associated to virtual machine scale set with OrchestrationMode as
        /// Flexible.<br /><br /> Possible values are:<br /><br /> **ImageDefault** - The
        /// virtual machine's default patching configuration is used. <br /><br />
        /// **AutomaticByPlatform** - The virtual machine will be automatically updated by
        /// the platform. The property provisionVMAgent must be true
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual
        machines associated to virtual machine scale set with OrchestrationMode as
        Flexible.<br /><br /> Possible values are:<br /><br /> **ImageDefault** - The
        virtual machine's default patching configuration is used. <br /><br />
        **AutomaticByPlatform** - The virtual machine will be automatically updated by
        the platform. The property provisionVMAgent must be true",
        SerializedName = @"patchMode",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("ImageDefault", "AutomaticByPlatform")]
        string LinuxConfigurationPatchSettingsPatchMode { get; set; }
        /// <summary>
        /// Indicates whether virtual machine agent should be provisioned on the virtual
        /// machine. When this property is not specified in the request body, default
        /// behavior is to set it to true. This will ensure that VM Agent is installed on
        /// the VM so that extensions can be added to the VM later.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Indicates whether virtual machine agent should be provisioned on the virtual
        machine. When this property is not specified in the request body, default
        behavior is to set it to true. This will ensure that VM Agent is installed on
        the VM so that extensions can be added to the VM later.",
        SerializedName = @"provisionVMAgent",
        PossibleTypes = new [] { typeof(bool) })]
        bool? LinuxConfigurationProvisionVMAgent { get; set; }
        /// <summary>
        /// Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can
        /// only be used with data disks, it cannot be used with OS Disk.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can
        only be used with data disks, it cannot be used with OS Disk.",
        SerializedName = @"storageAccountType",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("Standard_LRS", "Premium_LRS", "StandardSSD_LRS", "UltraSSD_LRS", "Premium_ZRS", "StandardSSD_ZRS", "PremiumV2_LRS")]
        string ManagedDiskStorageAccountType { get; set; }
        /// <summary>
        /// specifies the Microsoft.Network API version used when creating networking
        /// resources in the Network Interface Configurations for Virtual Machine Scale Set
        /// with orchestration mode 'Flexible'
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"specifies the Microsoft.Network API version used when creating networking
        resources in the Network Interface Configurations for Virtual Machine Scale Set
        with orchestration mode 'Flexible'",
        SerializedName = @"networkApiVersion",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("2020-11-01")]
        string NetworkProfileNetworkApiVersion { get; set; }
        /// <summary>The list of network configurations.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The list of network configurations.",
        SerializedName = @"networkInterfaceConfigurations",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetNetworkConfiguration) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetNetworkConfiguration> NetworkProfileNetworkInterfaceConfiguration { get; set; }
        /// <summary>
        /// Specifies the caching requirements. Possible values are: **None,**
        /// **ReadOnly,** **ReadWrite.** The default values are: **None for Standard
        /// storage. ReadOnly for Premium storage.**
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the caching requirements. Possible values are: **None,**
        **ReadOnly,** **ReadWrite.** The default values are: **None for Standard
        storage. ReadOnly for Premium storage.**",
        SerializedName = @"caching",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("None", "ReadOnly", "ReadWrite")]
        string OSDiskCaching { get; set; }
        /// <summary>
        /// Specifies how the virtual machines in the scale set should be created. The only
        /// allowed value is: **FromImage.** This value is used when you are using an image
        /// to create the virtual machine. If you are using a platform image, you also use
        /// the imageReference element described above. If you are using a marketplace
        /// image, you also use the plan element previously described.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies how the virtual machines in the scale set should be created. The only
        allowed value is: **FromImage.** This value is used when you are using an image
        to create the virtual machine. If you are using a platform image, you also use
        the imageReference element described above. If you are using a marketplace
        image, you  also use the plan element previously described.",
        SerializedName = @"createOption",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("FromImage", "Empty", "Attach", "Copy", "Restore")]
        string OSDiskCreateOption { get; set; }
        /// <summary>
        /// Specifies whether OS Disk should be deleted or detached upon VMSS Flex deletion
        /// (This feature is available for VMSS with Flexible OrchestrationMode only).
        /// <br><br> Possible values: <br><br> **Delete** If this value is used, the OS
        /// disk is deleted when VMSS Flex VM is deleted.<br><br> **Detach** If this value
        /// is used, the OS disk is retained after VMSS Flex VM is deleted. <br><br> The
        /// default value is set to **Delete**. For an Ephemeral OS Disk, the default value
        /// is set to **Delete**. User cannot change the delete option for Ephemeral OS
        /// Disk.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies whether OS Disk should be deleted or detached upon VMSS Flex deletion
        (This feature is available for VMSS with Flexible OrchestrationMode only).
        <br><br> Possible values: <br><br> **Delete** If this value is used, the OS
        disk is deleted when VMSS Flex VM is deleted.<br><br> **Detach** If this value
        is used, the OS disk is retained after VMSS Flex VM is deleted. <br><br> The
        default value is set to **Delete**. For an Ephemeral OS Disk, the default value
        is set to **Delete**. User cannot change the delete option for Ephemeral OS
        Disk.",
        SerializedName = @"deleteOption",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("Delete", "Detach")]
        string OSDiskDeleteOption { get; set; }
        /// <summary>The disk name.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The disk name.",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string OSDiskName { get; set; }
        /// <summary>
        /// This property allows you to specify the type of the OS that is included in the
        /// disk if creating a VM from user-image or a specialized VHD. Possible values
        /// are: **Windows,** **Linux.**
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This property allows you to specify the type of the OS that is included in the
        disk if creating a VM from user-image or a specialized VHD. Possible values
        are: **Windows,** **Linux.**",
        SerializedName = @"osType",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("Windows", "Linux")]
        string OSDiskOstype { get; set; }
        /// <summary>
        /// Specifies the size of an empty data disk in gigabytes. This element can be used
        /// to overwrite the size of the disk in a virtual machine image. The property 'diskSizeGB'
        /// is the number of bytes x 1024^3 for the disk and the value cannot
        /// be larger than 1023.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the size of an empty data disk in gigabytes. This element can be used
        to overwrite the size of the disk in a virtual machine image. The property 'diskSizeGB'
        is the number of bytes x 1024^3 for the disk and the value cannot
        be larger than 1023.",
        SerializedName = @"diskSizeGB",
        PossibleTypes = new [] { typeof(int) })]
        int? OSDiskSizeGb { get; set; }
        /// <summary>
        /// Specifies the container urls that are used to store operating system disks for
        /// the scale set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the container urls that are used to store operating system disks for
        the scale set.",
        SerializedName = @"vhdContainers",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> OSDiskVhdContainer { get; set; }
        /// <summary>Specifies whether writeAccelerator should be enabled or disabled on the disk.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies whether writeAccelerator should be enabled or disabled on the disk.",
        SerializedName = @"writeAcceleratorEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? OSDiskWriteAcceleratorEnabled { get; set; }
        /// <summary>Specifies whether the OS Image Scheduled event is enabled or disabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies whether the OS Image Scheduled event is enabled or disabled.",
        SerializedName = @"enable",
        PossibleTypes = new [] { typeof(bool) })]
        bool? OSImageNotificationProfileEnable { get; set; }
        /// <summary>
        /// Length of time a Virtual Machine being reimaged or having its OS upgraded will
        /// have to potentially approve the OS Image Scheduled Event before the event is
        /// auto approved (timed out). The configuration is specified in ISO 8601 format,
        /// and the value must not exceed 15 minutes (PT15M)
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Length of time a Virtual Machine being reimaged or having its OS upgraded will
        have to potentially approve the OS Image Scheduled Event before the event is
        auto approved (timed out). The configuration is specified in ISO 8601 format,
        and the value must not exceed 15 minutes (PT15M)",
        SerializedName = @"notBeforeTimeout",
        PossibleTypes = new [] { typeof(string) })]
        string OSImageNotificationProfileNotBeforeTimeout { get; set; }
        /// <summary>
        /// Specifies the password of the administrator account. <br><br> **Minimum-length
        /// (Windows):** 8 characters <br><br> **Minimum-length (Linux):** 6 characters
        /// <br><br> **Max-length (Windows):** 123 characters <br><br> **Max-length
        /// (Linux):** 72 characters <br><br> **Complexity requirements:** 3 out of 4
        /// conditions below need to be fulfilled <br> Has lower characters <br>Has upper
        /// characters <br> Has a digit <br> Has a special character (Regex match [\W_])
        /// <br><br> **Disallowed values:** "abc@123", "P@$$w0rd", "P@ssw0rd",
        /// "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1",
        /// "Password22", "iloveyou!" <br><br> For resetting the password, see [How to
        /// reset the Remote Desktop service or its login password in a Windows
        /// VM](https://docs.microsoft.com/troubleshoot/azure/virtual-machines/reset-rdp)
        /// <br><br> For resetting root password, see [Manage users, SSH, and check or
        /// repair disks on Azure Linux VMs using the VMAccess
        /// Extension](https://docs.microsoft.com/troubleshoot/azure/virtual-machines/troubleshoot-ssh-connection)
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = false,
        Create = true,
        Update = true,
        Description = @"Specifies the password of the administrator account. <br><br> **Minimum-length
        (Windows):** 8 characters <br><br> **Minimum-length (Linux):** 6 characters
        <br><br> **Max-length (Windows):** 123 characters <br><br> **Max-length
        (Linux):** 72 characters <br><br> **Complexity requirements:** 3 out of 4
        conditions below need to be fulfilled <br> Has lower characters <br>Has upper
        characters <br> Has a digit <br> Has a special character (Regex match [\W_])
        <br><br> **Disallowed values:** ""abc@123"", ""P@$$w0rd"", ""P@ssw0rd"",
        ""P@ssword123"", ""Pa$$word"", ""pass@word1"", ""Password!"", ""Password1"",
        ""Password22"", ""iloveyou!"" <br><br> For resetting the password, see [How to
        reset the Remote Desktop service or its login password in a Windows
        VM](https://docs.microsoft.com/troubleshoot/azure/virtual-machines/reset-rdp)
        <br><br> For resetting root password, see [Manage users, SSH, and check or
        repair disks on Azure Linux VMs using the VMAccess
        Extension](https://docs.microsoft.com/troubleshoot/azure/virtual-machines/troubleshoot-ssh-connection)",
        SerializedName = @"adminPassword",
        PossibleTypes = new [] { typeof(System.Security.SecureString) })]
        System.Security.SecureString OSProfileAdminPassword { get; set; }
        /// <summary>
        /// Specifies the name of the administrator account. <br><br> **Windows-only
        /// restriction:** Cannot end in "." <br><br> **Disallowed values:**
        /// "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3",
        /// "admin1", "1", "123", "a", "actuser", "adm", "admin2", "aspnet", "backup",
        /// "console", "david", "guest", "john", "owner", "root", "server", "sql",
        /// "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5".
        /// <br><br> **Minimum-length (Linux):** 1 character <br><br> **Max-length
        /// (Linux):** 64 characters <br><br> **Max-length (Windows):** 20 characters
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the name of the administrator account. <br><br> **Windows-only
        restriction:** Cannot end in ""."" <br><br> **Disallowed values:**
        ""administrator"", ""admin"", ""user"", ""user1"", ""test"", ""user2"", ""test1"", ""user3"",
        ""admin1"", ""1"", ""123"", ""a"", ""actuser"", ""adm"", ""admin2"", ""aspnet"", ""backup"",
        ""console"", ""david"", ""guest"", ""john"", ""owner"", ""root"", ""server"", ""sql"",
        ""support"", ""support_388945a0"", ""sys"", ""test2"", ""test3"", ""user4"", ""user5"".
        <br><br> **Minimum-length (Linux):** 1  character <br><br> **Max-length
        (Linux):** 64 characters <br><br> **Max-length (Windows):** 20 characters",
        SerializedName = @"adminUsername",
        PossibleTypes = new [] { typeof(string) })]
        string OSProfileAdminUsername { get; set; }
        /// <summary>
        /// Specifies whether extension operations should be allowed on the virtual machine
        /// scale set. This may only be set to False when no extensions are present on the
        /// virtual machine scale set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies whether extension operations should be allowed on the virtual machine
        scale set. This may only be set to False when no extensions are present on the
        virtual machine scale set.",
        SerializedName = @"allowExtensionOperations",
        PossibleTypes = new [] { typeof(bool) })]
        bool? OSProfileAllowExtensionOperation { get; set; }
        /// <summary>
        /// Specifies the computer name prefix for all of the virtual machines in the scale
        /// set. Computer name prefixes must be 1 to 15 characters long.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the computer name prefix for all of the virtual machines in the scale
        set. Computer name prefixes must be 1 to 15 characters long.",
        SerializedName = @"computerNamePrefix",
        PossibleTypes = new [] { typeof(string) })]
        string OSProfileComputerNamePrefix { get; set; }
        /// <summary>
        /// Specifies a base-64 encoded string of custom data. The base-64 encoded string
        /// is decoded to a binary array that is saved as a file on the Virtual Machine.
        /// The maximum length of the binary array is 65535 bytes. For using cloud-init for
        /// your VM, see [Using cloud-init to customize a Linux VM during
        /// creation](https://docs.microsoft.com/azure/virtual-machines/linux/using-cloud-init)
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = false,
        Create = true,
        Update = true,
        Description = @"Specifies a base-64 encoded string of custom data. The base-64 encoded string
        is decoded to a binary array that is saved as a file on the Virtual Machine.
        The maximum length of the binary array is 65535 bytes. For using cloud-init for
        your VM, see [Using cloud-init to customize a Linux VM during
        creation](https://docs.microsoft.com/azure/virtual-machines/linux/using-cloud-init)",
        SerializedName = @"customData",
        PossibleTypes = new [] { typeof(System.Security.SecureString) })]
        System.Security.SecureString OSProfileCustomData { get; set; }
        /// <summary>Optional property which must either be set to True or omitted.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Optional property which must either be set to True or omitted.",
        SerializedName = @"requireGuestProvisionSignal",
        PossibleTypes = new [] { typeof(bool) })]
        bool? OSProfileRequireGuestProvisionSignal { get; set; }
        /// <summary>
        /// Specifies set of certificates that should be installed onto the virtual
        /// machines in the scale set. To install certificates on a virtual machine it is
        /// recommended to use the [Azure Key Vault virtual machine extension for
        /// Linux](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-linux)
        /// or the [Azure Key Vault virtual machine extension for
        /// Windows](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-windows).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies set of certificates that should be installed onto the virtual
        machines in the scale set. To install certificates on a virtual machine it is
        recommended to use the [Azure Key Vault virtual machine extension for
        Linux](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-linux)
        or the [Azure Key Vault virtual machine extension for
        Windows](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-windows).",
        SerializedName = @"secrets",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVaultSecretGroup) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVaultSecretGroup> OSProfileSecret { get; set; }
        /// <summary>
        /// Enables customers to patch their Azure VMs without requiring a reboot. For
        /// enableHotpatching, the 'provisionVMAgent' must be set to true and 'patchMode'
        /// must be set to 'AutomaticByPlatform'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Enables customers to patch their Azure VMs without requiring a reboot. For
        enableHotpatching, the 'provisionVMAgent' must be set to true and 'patchMode'
        must be set to 'AutomaticByPlatform'.",
        SerializedName = @"enableHotpatching",
        PossibleTypes = new [] { typeof(bool) })]
        bool? PatchSettingEnableHotpatching { get; set; }
        /// <summary>
        /// Specifies whether ProxyAgent feature should be enabled on the virtual machine
        /// or virtual machine scale set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies whether ProxyAgent feature should be enabled on the virtual machine
        or virtual machine scale set.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? ProxyAgentSettingEnabled { get; set; }
        /// <summary>
        /// Increase the value of this property allows user to reset the key used for
        /// securing communication channel between guest and host.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Increase the value of this property allows user to reset the key used for
        securing communication channel between guest and host.",
        SerializedName = @"keyIncarnationId",
        PossibleTypes = new [] { typeof(int) })]
        int? ProxyAgentSettingKeyIncarnationId { get; set; }
        /// <summary>
        /// Specifies the mode that ProxyAgent will execute on if the feature is enabled.
        /// ProxyAgent will start to audit or monitor but not enforce access control over
        /// requests to host endpoints in Audit mode, while in Enforce mode it will enforce
        /// access control. The default value is Enforce mode.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the mode that ProxyAgent will execute on if the feature is enabled.
        ProxyAgent will start to audit or monitor but not enforce access control over
        requests to host endpoints in Audit mode, while in Enforce mode it will enforce
        access control. The default value is Enforce mode.",
        SerializedName = @"mode",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("Audit", "Enforce")]
        string ProxyAgentSettingMode { get; set; }
        /// <summary>
        /// List of virtual machine extension names to exclude when applying the security
        /// posture.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"List of virtual machine extension names to exclude when applying the security
        posture.",
        SerializedName = @"excludeExtensions",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> SecurityPostureReferenceExcludeExtension { get; set; }
        /// <summary>
        /// The security posture reference id in the form of
        /// /CommunityGalleries/{communityGalleryName}/securityPostures/{securityPostureName}/versions/{major.minor.patch}|{major.*}|latest
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The security posture reference id in the form of
        /CommunityGalleries/{communityGalleryName}/securityPostures/{securityPostureName}/versions/{major.minor.patch}|{major.*}|latest",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(string) })]
        string SecurityPostureReferenceId { get; set; }
        /// <summary>Whether the security posture can be overridden by the user.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Whether the security posture can be overridden by the user.",
        SerializedName = @"isOverridable",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SecurityPostureReferenceIsOverridable { get; set; }
        /// <summary>Resource Id</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Resource Id",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(string) })]
        string SecurityProfileDiskEncryptionSetId { get; set; }
        /// <summary>
        /// This property can be used by user in the request to enable or disable the Host
        /// Encryption for the virtual machine or virtual machine scale set. This will
        /// enable the encryption for all the disks including Resource/Temp disk at host
        /// itself. The default behavior is: The Encryption at host will be disabled unless
        /// this property is set to true for the resource.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"This property can be used by user in the request to enable or disable the Host
        Encryption for the virtual machine or virtual machine scale set. This will
        enable the encryption for all the disks including Resource/Temp disk at host
        itself. The default behavior is: The Encryption at host will be disabled unless
        this property is set to true for the resource.",
        SerializedName = @"encryptionAtHost",
        PossibleTypes = new [] { typeof(bool) })]
        bool? SecurityProfileEncryptionAtHost { get; set; }
        /// <summary>
        /// Specifies the EncryptionType of the managed disk. It is set to
        /// DiskWithVMGuestState for encryption of the managed disk along with VMGuestState
        /// blob, VMGuestStateOnly for encryption of just the VMGuestState blob, and
        /// NonPersistedTPM for not persisting firmware state in the VMGuestState blob..
        /// **Note:** It can be set for only Confidential VMs.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the EncryptionType of the managed disk. It is set to
        DiskWithVMGuestState for encryption of the managed disk along with VMGuestState
        blob, VMGuestStateOnly for encryption of just the VMGuestState blob, and
        NonPersistedTPM for not persisting firmware state in the VMGuestState blob..
        **Note:** It can be set for only Confidential VMs.",
        SerializedName = @"securityEncryptionType",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("VMGuestStateOnly", "DiskWithVMGuestState", "NonPersistedTPM")]
        string SecurityProfileSecurityEncryptionType { get; set; }
        /// <summary>
        /// Specifies the SecurityType of the virtual machine. It has to be set to any
        /// specified value to enable UefiSettings. The default behavior is: UefiSettings
        /// will not be enabled unless this property is set.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the SecurityType of the virtual machine. It has to be set to any
        specified value to enable UefiSettings. The default behavior is: UefiSettings
        will not be enabled unless this property is set.",
        SerializedName = @"securityType",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("TrustedLaunch", "ConfidentialVM")]
        string SecurityProfileSecurityType { get; set; }
        /// <summary>
        /// The service artifact reference id in the form of
        /// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/serviceArtifacts/{serviceArtifactName}/vmArtifactsProfiles/{vmArtifactsProfilesName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The service artifact reference id in the form of
        /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/serviceArtifacts/{serviceArtifactName}/vmArtifactsProfiles/{vmArtifactsProfilesName}",
        SerializedName = @"id",
        PossibleTypes = new [] { typeof(string) })]
        string ServiceArtifactReferenceId { get; set; }
        /// <summary>The list of SSH public keys used to authenticate with linux based VMs.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The list of SSH public keys used to authenticate with linux based VMs.",
        SerializedName = @"publicKeys",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISshPublicKey) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISshPublicKey> SshPublicKey { get; set; }
        /// <summary>
        /// Specifies the parameters that are used to add data disks to the virtual
        /// machines in the scale set. For more information about disks, see [About disks
        /// and VHDs for Azure virtual
        /// machines](https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the parameters that are used to add data disks to the virtual
        machines in the scale set. For more information about disks, see [About disks
        and VHDs for Azure virtual
        machines](https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview).",
        SerializedName = @"dataDisks",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetDataDisk) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetDataDisk> StorageProfileDataDisk { get; set; }
        /// <summary>
        /// Specifies the disk controller type configured for the virtual machines in the scale set. Minimum api-version: 2022-08-01
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the disk controller type configured for the virtual machines in the scale set. Minimum api-version: 2022-08-01",
        SerializedName = @"diskControllerType",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("SCSI", "NVMe")]
        string StorageProfileDiskControllerType { get; set; }
        /// <summary>Specifies whether the Terminate Scheduled event is enabled or disabled.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies whether the Terminate Scheduled event is enabled or disabled.",
        SerializedName = @"enable",
        PossibleTypes = new [] { typeof(bool) })]
        bool? TerminateNotificationProfileEnable { get; set; }
        /// <summary>
        /// Configurable length of time a Virtual Machine being deleted will have to
        /// potentially approve the Terminate Scheduled Event before the event is auto
        /// approved (timed out). The configuration must be specified in ISO 8601 format,
        /// the default value is 5 minutes (PT5M)
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Configurable length of time a Virtual Machine being deleted will have to
        potentially approve the Terminate Scheduled Event before the event is auto
        approved (timed out). The configuration must be specified in ISO 8601 format,
        the default value is 5 minutes (PT5M)",
        SerializedName = @"notBeforeTimeout",
        PossibleTypes = new [] { typeof(string) })]
        string TerminateNotificationProfileNotBeforeTimeout { get; set; }
        /// <summary>
        /// Specifies the time in which this VM profile for the Virtual Machine Scale Set
        /// was created. Minimum API version for this property is 2023-09-01. This value
        /// will be added to VMSS Flex VM tags when creating/updating the VMSS VM Profile
        /// with minimum api-version 2023-09-01. Examples: "2024-07-01T00:00:01.1234567+00:00"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Read = true,
        Create = false,
        Update = false,
        Description = @"Specifies the time in which this VM profile for the Virtual Machine Scale Set
        was created. Minimum API version for this property is 2023-09-01. This value
        will be added to VMSS Flex VM tags when creating/updating the VMSS VM Profile
        with minimum api-version 2023-09-01. Examples: ""2024-07-01T00:00:01.1234567+00:00""",
        SerializedName = @"timeCreated",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? TimeCreated { get;  }
        /// <summary>
        /// Specifies whether secure boot should be enabled on the virtual machine. Minimum
        /// api-version: 2020-12-01.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies whether secure boot should be enabled on the virtual machine. Minimum
        api-version: 2020-12-01.",
        SerializedName = @"secureBootEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? UefiSettingSecureBootEnabled { get; set; }
        /// <summary>
        /// Specifies whether vTPM should be enabled on the virtual machine. Minimum
        /// api-version: 2020-12-01.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies whether vTPM should be enabled on the virtual machine. Minimum
        api-version: 2020-12-01.",
        SerializedName = @"vTpmEnabled",
        PossibleTypes = new [] { typeof(bool) })]
        bool? UefiSettingVTpmEnabled { get; set; }
        /// <summary>
        /// UserData for the virtual machines in the scale set, which must be base-64
        /// encoded. Customer should not pass any secrets in here. Minimum api-version:
        /// 2021-03-01.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"UserData for the virtual machines in the scale set, which must be base-64
        encoded. Customer should not pass any secrets in here. Minimum api-version:
        2021-03-01.",
        SerializedName = @"userData",
        PossibleTypes = new [] { typeof(string) })]
        string UserData { get; set; }
        /// <summary>
        /// Specifies the number of vCPUs available for the VM. When this property is not
        /// specified in the request body the default behavior is to set it to the value of
        /// vCPUs available for that VM size exposed in api response of [List all available
        /// virtual machine sizes in a
        /// region](https://docs.microsoft.com/en-us/rest/api/compute/resource-skus/list).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the number of vCPUs available for the VM. When this property is not
        specified in the request body the default behavior is to set it to the value of
        vCPUs available for that VM size exposed in api response of [List all available
        virtual machine sizes in a
        region](https://docs.microsoft.com/en-us/rest/api/compute/resource-skus/list).",
        SerializedName = @"vCPUsAvailable",
        PossibleTypes = new [] { typeof(int) })]
        int? VMSizePropertyVcpUsAvailable { get; set; }
        /// <summary>
        /// Specifies the vCPU to physical core ratio. When this property is not specified
        /// in the request body the default behavior is set to the value of vCPUsPerCore
        /// for the VM Size exposed in api response of [List all available virtual machine
        /// sizes in a
        /// region](https://docs.microsoft.com/en-us/rest/api/compute/resource-skus/list).
        /// **Setting this property to 1 also means that hyper-threading is disabled.**
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the vCPU to physical core ratio. When this property is not specified
        in the request body the default behavior is set to the value of vCPUsPerCore
        for the VM Size exposed in api response of [List all available virtual machine
        sizes in a
        region](https://docs.microsoft.com/en-us/rest/api/compute/resource-skus/list).
        **Setting this property to 1 also means that hyper-threading is disabled.**",
        SerializedName = @"vCPUsPerCore",
        PossibleTypes = new [] { typeof(int) })]
        int? VMSizePropertyVcpUsPerCore { get; set; }
        /// <summary>The list of Windows Remote Management listeners</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The list of Windows Remote Management listeners",
        SerializedName = @"listeners",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IWinRmListener) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IWinRmListener> WinRmListener { get; set; }
        /// <summary>
        /// Specifies additional base-64 encoded XML formatted information that can be
        /// included in the Unattend.xml file, which is used by Windows Setup.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies additional base-64 encoded XML formatted information that can be
        included in the Unattend.xml file, which is used by Windows Setup.",
        SerializedName = @"additionalUnattendContent",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IAdditionalUnattendContent) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IAdditionalUnattendContent> WindowConfigurationAdditionalUnattendContent { get; set; }
        /// <summary>
        /// Indicates whether Automatic Updates is enabled for the Windows virtual machine.
        /// Default value is true. For virtual machine scale sets, this property can be
        /// updated and updates will take effect on OS reprovisioning.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Indicates whether Automatic Updates is enabled for the Windows virtual machine.
        Default value is true. For virtual machine scale sets, this property can be
        updated and updates will take effect on OS reprovisioning.",
        SerializedName = @"enableAutomaticUpdates",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WindowConfigurationEnableAutomaticUpdate { get; set; }
        /// <summary>
        /// Indicates whether VMAgent Platform Updates is enabled for the Windows virtual
        /// machine. Default value is false.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Indicates whether VMAgent Platform Updates is enabled for the Windows virtual
        machine. Default value is false.",
        SerializedName = @"enableVMAgentPlatformUpdates",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WindowConfigurationEnableVMAgentPlatformUpdate { get; set; }
        /// <summary>
        /// Indicates whether virtual machine agent should be provisioned on the virtual
        /// machine. When this property is not specified in the request body, it is set to
        /// true by default. This will ensure that VM Agent is installed on the VM so that
        /// extensions can be added to the VM later.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Indicates whether virtual machine agent should be provisioned on the virtual
        machine. When this property is not specified in the request body, it is set to
        true by default. This will ensure that VM Agent is installed on the VM so that
        extensions can be added to the VM later.",
        SerializedName = @"provisionVMAgent",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WindowConfigurationProvisionVMAgent { get; set; }
        /// <summary>
        /// Specifies the time zone of the virtual machine. e.g. "Pacific Standard Time".
        /// Possible values can be
        /// [TimeZoneInfo.Id](https://docs.microsoft.com/dotnet/api/system.timezoneinfo.id?#System_TimeZoneInfo_Id)
        /// value from time zones returned by
        /// [TimeZoneInfo.GetSystemTimeZones](https://docs.microsoft.com/dotnet/api/system.timezoneinfo.getsystemtimezones).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the time zone of the virtual machine. e.g. ""Pacific Standard Time"".
        Possible values can be
        [TimeZoneInfo.Id](https://docs.microsoft.com/dotnet/api/system.timezoneinfo.id?#System_TimeZoneInfo_Id)
        value from time zones returned by
        [TimeZoneInfo.GetSystemTimeZones](https://docs.microsoft.com/dotnet/api/system.timezoneinfo.getsystemtimezones).",
        SerializedName = @"timeZone",
        PossibleTypes = new [] { typeof(string) })]
        string WindowConfigurationTimeZone { get; set; }
        /// <summary>
        /// Specifies the mode of VM Guest patch assessment for the IaaS virtual
        /// machine.<br /><br /> Possible values are:<br /><br /> **ImageDefault** - You
        /// control the timing of patch assessments on a virtual machine.<br /><br />
        /// **AutomaticByPlatform** - The platform will trigger periodic patch assessments.
        /// The property provisionVMAgent must be true.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the mode of VM Guest patch assessment for the IaaS virtual
        machine.<br /><br /> Possible values are:<br /><br /> **ImageDefault** - You
        control the timing of patch assessments on a virtual machine.<br /><br />
        **AutomaticByPlatform** - The platform will trigger periodic patch assessments.
        The property provisionVMAgent must be true.",
        SerializedName = @"assessmentMode",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("ImageDefault", "AutomaticByPlatform")]
        string WindowsConfigurationPatchSettingsAssessmentMode { get; set; }
        /// <summary>Enables customer to schedule patching without accidental upgrades</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Enables customer to schedule patching without accidental upgrades",
        SerializedName = @"bypassPlatformSafetyChecksOnUserSchedule",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WindowsConfigurationPatchSettingsAutomaticByPlatformSettingsBypassPlatformSafetyChecksOnUserSchedule { get; set; }
        /// <summary>
        /// Specifies the reboot setting for all AutomaticByPlatform patch installation
        /// operations.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the reboot setting for all AutomaticByPlatform patch installation
        operations.",
        SerializedName = @"rebootSetting",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("Unknown", "IfRequired", "Never", "Always")]
        string WindowsConfigurationPatchSettingsAutomaticByPlatformSettingsRebootSetting { get; set; }
        /// <summary>
        /// Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual
        /// machines associated to virtual machine scale set with OrchestrationMode as
        /// Flexible.<br /><br /> Possible values are:<br /><br /> **Manual** - You
        /// control the application of patches to a virtual machine. You do this by
        /// applying patches manually inside the VM. In this mode, automatic updates are
        /// disabled; the property WindowsConfiguration.enableAutomaticUpdates must be
        /// false<br /><br /> **AutomaticByOS** - The virtual machine will automatically be
        /// updated by the OS. The property WindowsConfiguration.enableAutomaticUpdates
        /// must be true. <br /><br /> **AutomaticByPlatform** - the virtual machine will
        /// automatically updated by the platform. The properties provisionVMAgent and
        /// WindowsConfiguration.enableAutomaticUpdates must be true
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual
        machines associated to virtual machine scale set with OrchestrationMode as
        Flexible.<br /><br /> Possible values are:<br /><br /> **Manual** - You
        control the application of patches to a virtual machine. You do this by
        applying patches manually inside the VM. In this mode, automatic updates are
        disabled; the property WindowsConfiguration.enableAutomaticUpdates must be
        false<br /><br /> **AutomaticByOS** - The virtual machine will automatically be
        updated by the OS. The property WindowsConfiguration.enableAutomaticUpdates
        must be true. <br /><br /> **AutomaticByPlatform** - the virtual machine will
        automatically updated by the platform. The properties provisionVMAgent and
        WindowsConfiguration.enableAutomaticUpdates must be true",
        SerializedName = @"patchMode",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("Manual", "AutomaticByOS", "AutomaticByPlatform")]
        string WindowsConfigurationPatchSettingsPatchMode { get; set; }

    }
    /// Describes the base virtual machine profile for fleet
    internal partial interface IBaseVirtualMachineProfileInternal

    {
        /// <summary>Specifies the gallery applications that should be made available to the VM/VMSS</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IApplicationProfile ApplicationProfile { get; set; }
        /// <summary>Specifies the gallery applications that should be made available to the VM/VMSS</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVMGalleryApplication> ApplicationProfileGalleryApplication { get; set; }
        /// <summary>Whether boot diagnostics should be enabled on the Virtual Machine.</summary>
        bool? BootDiagnosticEnabled { get; set; }
        /// <summary>
        /// Uri of the storage account to use for placing the console output and
        /// screenshot. If storageUri is not specified while enabling boot diagnostics,
        /// managed storage will be used.
        /// </summary>
        string BootDiagnosticStorageUri { get; set; }
        /// <summary>
        /// Specifies the capacity reservation related details of a scale set. Minimum
        /// api-version: 2021-04-01.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ICapacityReservationProfile CapacityReservation { get; set; }
        /// <summary>
        /// Specifies the capacity reservation group resource id that should be used for
        /// allocating the virtual machine or scaleset vm instances provided enough
        /// capacity has been reserved. Please refer to https://aka.ms/CapacityReservation
        /// for more details.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISubResource CapacityReservationGroup { get; set; }
        /// <summary>Resource Id</summary>
        string CapacityReservationGroupId { get; set; }
        /// <summary>
        /// Boot Diagnostics is a debugging feature which allows you to view Console Output
        /// and Screenshot to diagnose VM status. **NOTE**: If storageUri is being
        /// specified then ensure that the storage account is in the same region and
        /// subscription as the VM. You can easily view the output of your console log.
        /// Azure also enables you to see a screenshot of the VM from the hypervisor.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IBootDiagnostics DiagnosticProfileBootDiagnostic { get; set; }
        /// <summary>Specifies the boot diagnostic settings state.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IDiagnosticsProfile DiagnosticsProfile { get; set; }
        /// <summary>Specifies the ephemeral disk settings for operating system disk.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("Local")]
        string DiffDiskSettingOption { get; set; }
        /// <summary>
        /// Specifies the ephemeral disk placement for operating system disk. Possible
        /// values are: **CacheDisk,** **ResourceDisk.** The defaulting behavior is:
        /// **CacheDisk** if one is configured for the VM size otherwise **ResourceDisk**
        /// is used. Refer to the VM size documentation for Windows VM at
        /// https://docs.microsoft.com/azure/virtual-machines/windows/sizes and Linux VM at
        /// https://docs.microsoft.com/azure/virtual-machines/linux/sizes to check which VM
        /// sizes exposes a cache disk.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("CacheDisk", "ResourceDisk", "NvmeDisk")]
        string DiffDiskSettingPlacement { get; set; }
        /// <summary>Specifies ARM Resource ID of one of the user identities associated with the VM.</summary>
        string EncryptionIdentityUserAssignedIdentityResourceId { get; set; }
        /// <summary>
        /// Specifies a collection of settings for extensions installed on virtual machines
        /// in the scale set.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetExtensionProfile ExtensionProfile { get; set; }
        /// <summary>The virtual machine scale set child extension resources.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetExtension> ExtensionProfileExtension { get; set; }
        /// <summary>
        /// Specifies the time alloted for all extensions to start. The time duration
        /// should be between 15 minutes and 120 minutes (inclusive) and should be
        /// specified in ISO 8601 format. The default value is 90 minutes (PT1H30M).
        /// Minimum api-version: 2020-06-01.
        /// </summary>
        string ExtensionProfileExtensionsTimeBudget { get; set; }
        /// <summary>
        /// Specifies the hardware profile related details of a scale set. Minimum
        /// api-version: 2021-11-01.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetHardwareProfile HardwareProfile { get; set; }
        /// <summary>
        /// Specifies the properties for customizing the size of the virtual machine.
        /// Minimum api-version: 2021-11-01. Please follow the instructions in [VM
        /// Customization](https://aka.ms/vmcustomization) for more details.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVMSizeProperties HardwareProfileVMSizeProperty { get; set; }
        /// <summary>
        /// The ARM resource id in the form of
        /// /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...
        /// </summary>
        string HealthProbeId { get; set; }
        /// <summary>Resource Id</summary>
        string Id { get; set; }
        /// <summary>
        /// Specified the community gallery image unique id for vm deployment. This can be
        /// fetched from community gallery image GET call.
        /// </summary>
        string ImageReferenceCommunityGalleryImageId { get; set; }
        /// <summary>
        /// Specifies in decimal numbers, the version of platform image or marketplace
        /// image used to create the virtual machine. This readonly field differs from 'version',
        /// only if the value specified in 'version' field is 'latest'.
        /// </summary>
        string ImageReferenceExactVersion { get; set; }
        /// <summary>Resource Id</summary>
        string ImageReferenceId { get; set; }
        /// <summary>
        /// Specifies the offer of the platform image or marketplace image used to create
        /// the virtual machine.
        /// </summary>
        string ImageReferenceOffer { get; set; }
        /// <summary>The image publisher.</summary>
        string ImageReferencePublisher { get; set; }
        /// <summary>
        /// Specified the shared gallery image unique id for vm deployment. This can be
        /// fetched from shared gallery image GET call.
        /// </summary>
        string ImageReferenceSharedGalleryImageId { get; set; }
        /// <summary>The image SKU.</summary>
        string ImageReferenceSku { get; set; }
        /// <summary>
        /// Specifies the version of the platform image or marketplace image used to create
        /// the virtual machine. The allowed formats are Major.Minor.Build or 'latest'.
        /// Major, Minor, and Build are decimal numbers. Specify 'latest' to use the latest
        /// version of an image available at deploy time. Even if you use 'latest', the VM
        /// image will not automatically update after deploy time even if a new version
        /// becomes available. Please do not use field 'version' for gallery image
        /// deployment, gallery image should always use 'id' field for deployment, to use 'latest'
        /// version of gallery image, just set
        /// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageName}'
        /// in the 'id' field without version input.
        /// </summary>
        string ImageReferenceVersion { get; set; }
        /// <summary>Specifies the virtual hard disk's uri.</summary>
        string ImageUri { get; set; }
        /// <summary>
        /// Specifies that the image or disk that is being used was licensed on-premises.
        /// <br><br> Possible values for Windows Server operating system are: <br><br>
        /// Windows_Client <br><br> Windows_Server <br><br> Possible values for Linux
        /// Server operating system are: <br><br> RHEL_BYOS (for RHEL) <br><br> SLES_BYOS
        /// (for SUSE) <br><br> For more information, see [Azure Hybrid Use Benefit for
        /// Windows
        /// Server](https://docs.microsoft.com/azure/virtual-machines/windows/hybrid-use-benefit-licensing)
        /// <br><br> [Azure Hybrid Use Benefit for Linux
        /// Server](https://docs.microsoft.com/azure/virtual-machines/linux/azure-hybrid-benefit-linux)
        /// <br><br> Minimum api-version: 2015-06-15
        /// </summary>
        string LicenseType { get; set; }
        /// <summary>Specifies whether password authentication should be disabled.</summary>
        bool? LinuxConfigurationDisablePasswordAuthentication { get; set; }
        /// <summary>
        /// Indicates whether VMAgent Platform Updates is enabled for the Linux virtual
        /// machine. Default value is false.
        /// </summary>
        bool? LinuxConfigurationEnableVMAgentPlatformUpdate { get; set; }
        /// <summary>[Preview Feature] Specifies settings related to VM Guest Patching on Linux.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ILinuxPatchSettings LinuxConfigurationPatchSetting { get; set; }
        /// <summary>
        /// Specifies the mode of VM Guest Patch Assessment for the IaaS virtual
        /// machine.<br /><br /> Possible values are:<br /><br /> **ImageDefault** - You
        /// control the timing of patch assessments on a virtual machine. <br /><br />
        /// **AutomaticByPlatform** - The platform will trigger periodic patch assessments.
        /// The property provisionVMAgent must be true.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("ImageDefault", "AutomaticByPlatform")]
        string LinuxConfigurationPatchSettingsAssessmentMode { get; set; }
        /// <summary>
        /// Specifies additional settings for patch mode AutomaticByPlatform in VM Guest
        /// Patching on Linux.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ILinuxVMGuestPatchAutomaticByPlatformSettings LinuxConfigurationPatchSettingsAutomaticByPlatformSetting { get; set; }
        /// <summary>Enables customer to schedule patching without accidental upgrades</summary>
        bool? LinuxConfigurationPatchSettingsAutomaticByPlatformSettingsBypassPlatformSafetyChecksOnUserSchedule { get; set; }
        /// <summary>
        /// Specifies the reboot setting for all AutomaticByPlatform patch installation
        /// operations.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("Unknown", "IfRequired", "Never", "Always")]
        string LinuxConfigurationPatchSettingsAutomaticByPlatformSettingsRebootSetting { get; set; }
        /// <summary>
        /// Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual
        /// machines associated to virtual machine scale set with OrchestrationMode as
        /// Flexible.<br /><br /> Possible values are:<br /><br /> **ImageDefault** - The
        /// virtual machine's default patching configuration is used. <br /><br />
        /// **AutomaticByPlatform** - The virtual machine will be automatically updated by
        /// the platform. The property provisionVMAgent must be true
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("ImageDefault", "AutomaticByPlatform")]
        string LinuxConfigurationPatchSettingsPatchMode { get; set; }
        /// <summary>
        /// Indicates whether virtual machine agent should be provisioned on the virtual
        /// machine. When this property is not specified in the request body, default
        /// behavior is to set it to true. This will ensure that VM Agent is installed on
        /// the VM so that extensions can be added to the VM later.
        /// </summary>
        bool? LinuxConfigurationProvisionVMAgent { get; set; }
        /// <summary>Specifies the ssh key configuration for a Linux OS.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISshConfiguration LinuxConfigurationSsh { get; set; }
        /// <summary>
        /// Specifies the customer managed disk encryption set resource id for the managed
        /// disk.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IDiskEncryptionSetParameters ManagedDiskEncryptionSet { get; set; }
        /// <summary>Specifies the security profile for the managed disk.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVMDiskSecurityProfile ManagedDiskSecurityProfile { get; set; }
        /// <summary>
        /// Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can
        /// only be used with data disks, it cannot be used with OS Disk.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("Standard_LRS", "Premium_LRS", "StandardSSD_LRS", "UltraSSD_LRS", "Premium_ZRS", "StandardSSD_ZRS", "PremiumV2_LRS")]
        string ManagedDiskStorageAccountType { get; set; }
        /// <summary>
        /// Specifies properties of the network interfaces of the virtual machines in the
        /// scale set.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetNetworkProfile NetworkProfile { get; set; }
        /// <summary>
        /// A reference to a load balancer probe used to determine the health of an
        /// instance in the virtual machine scale set. The reference will be in the form:
        /// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/probes/{probeName}'.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IApiEntityReference NetworkProfileHealthProbe { get; set; }
        /// <summary>
        /// specifies the Microsoft.Network API version used when creating networking
        /// resources in the Network Interface Configurations for Virtual Machine Scale Set
        /// with orchestration mode 'Flexible'
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("2020-11-01")]
        string NetworkProfileNetworkApiVersion { get; set; }
        /// <summary>The list of network configurations.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetNetworkConfiguration> NetworkProfileNetworkInterfaceConfiguration { get; set; }
        /// <summary>
        /// Specifies the caching requirements. Possible values are: **None,**
        /// **ReadOnly,** **ReadWrite.** The default values are: **None for Standard
        /// storage. ReadOnly for Premium storage.**
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("None", "ReadOnly", "ReadWrite")]
        string OSDiskCaching { get; set; }
        /// <summary>
        /// Specifies how the virtual machines in the scale set should be created. The only
        /// allowed value is: **FromImage.** This value is used when you are using an image
        /// to create the virtual machine. If you are using a platform image, you also use
        /// the imageReference element described above. If you are using a marketplace
        /// image, you also use the plan element previously described.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("FromImage", "Empty", "Attach", "Copy", "Restore")]
        string OSDiskCreateOption { get; set; }
        /// <summary>
        /// Specifies whether OS Disk should be deleted or detached upon VMSS Flex deletion
        /// (This feature is available for VMSS with Flexible OrchestrationMode only).
        /// <br><br> Possible values: <br><br> **Delete** If this value is used, the OS
        /// disk is deleted when VMSS Flex VM is deleted.<br><br> **Detach** If this value
        /// is used, the OS disk is retained after VMSS Flex VM is deleted. <br><br> The
        /// default value is set to **Delete**. For an Ephemeral OS Disk, the default value
        /// is set to **Delete**. User cannot change the delete option for Ephemeral OS
        /// Disk.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("Delete", "Detach")]
        string OSDiskDeleteOption { get; set; }
        /// <summary>
        /// Specifies the ephemeral disk Settings for the operating system disk used by the
        /// virtual machine scale set.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IDiffDiskSettings OSDiskDiffDiskSetting { get; set; }
        /// <summary>Specifies information about the unmanaged user image to base the scale set on.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualHardDisk OSDiskImage { get; set; }
        /// <summary>The managed disk parameters.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetManagedDiskParameters OSDiskManagedDisk { get; set; }
        /// <summary>The disk name.</summary>
        string OSDiskName { get; set; }
        /// <summary>
        /// This property allows you to specify the type of the OS that is included in the
        /// disk if creating a VM from user-image or a specialized VHD. Possible values
        /// are: **Windows,** **Linux.**
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("Windows", "Linux")]
        string OSDiskOstype { get; set; }
        /// <summary>
        /// Specifies the size of an empty data disk in gigabytes. This element can be used
        /// to overwrite the size of the disk in a virtual machine image. The property 'diskSizeGB'
        /// is the number of bytes x 1024^3 for the disk and the value cannot
        /// be larger than 1023.
        /// </summary>
        int? OSDiskSizeGb { get; set; }
        /// <summary>
        /// Specifies the container urls that are used to store operating system disks for
        /// the scale set.
        /// </summary>
        System.Collections.Generic.List<string> OSDiskVhdContainer { get; set; }
        /// <summary>Specifies whether writeAccelerator should be enabled or disabled on the disk.</summary>
        bool? OSDiskWriteAcceleratorEnabled { get; set; }
        /// <summary>Specifies whether the OS Image Scheduled event is enabled or disabled.</summary>
        bool? OSImageNotificationProfileEnable { get; set; }
        /// <summary>
        /// Length of time a Virtual Machine being reimaged or having its OS upgraded will
        /// have to potentially approve the OS Image Scheduled Event before the event is
        /// auto approved (timed out). The configuration is specified in ISO 8601 format,
        /// and the value must not exceed 15 minutes (PT15M)
        /// </summary>
        string OSImageNotificationProfileNotBeforeTimeout { get; set; }
        /// <summary>
        /// Specifies the operating system settings for the virtual machines in the scale
        /// set.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSProfile OSProfile { get; set; }
        /// <summary>
        /// Specifies the password of the administrator account. <br><br> **Minimum-length
        /// (Windows):** 8 characters <br><br> **Minimum-length (Linux):** 6 characters
        /// <br><br> **Max-length (Windows):** 123 characters <br><br> **Max-length
        /// (Linux):** 72 characters <br><br> **Complexity requirements:** 3 out of 4
        /// conditions below need to be fulfilled <br> Has lower characters <br>Has upper
        /// characters <br> Has a digit <br> Has a special character (Regex match [\W_])
        /// <br><br> **Disallowed values:** "abc@123", "P@$$w0rd", "P@ssw0rd",
        /// "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1",
        /// "Password22", "iloveyou!" <br><br> For resetting the password, see [How to
        /// reset the Remote Desktop service or its login password in a Windows
        /// VM](https://docs.microsoft.com/troubleshoot/azure/virtual-machines/reset-rdp)
        /// <br><br> For resetting root password, see [Manage users, SSH, and check or
        /// repair disks on Azure Linux VMs using the VMAccess
        /// Extension](https://docs.microsoft.com/troubleshoot/azure/virtual-machines/troubleshoot-ssh-connection)
        /// </summary>
        System.Security.SecureString OSProfileAdminPassword { get; set; }
        /// <summary>
        /// Specifies the name of the administrator account. <br><br> **Windows-only
        /// restriction:** Cannot end in "." <br><br> **Disallowed values:**
        /// "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3",
        /// "admin1", "1", "123", "a", "actuser", "adm", "admin2", "aspnet", "backup",
        /// "console", "david", "guest", "john", "owner", "root", "server", "sql",
        /// "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5".
        /// <br><br> **Minimum-length (Linux):** 1 character <br><br> **Max-length
        /// (Linux):** 64 characters <br><br> **Max-length (Windows):** 20 characters
        /// </summary>
        string OSProfileAdminUsername { get; set; }
        /// <summary>
        /// Specifies whether extension operations should be allowed on the virtual machine
        /// scale set. This may only be set to False when no extensions are present on the
        /// virtual machine scale set.
        /// </summary>
        bool? OSProfileAllowExtensionOperation { get; set; }
        /// <summary>
        /// Specifies the computer name prefix for all of the virtual machines in the scale
        /// set. Computer name prefixes must be 1 to 15 characters long.
        /// </summary>
        string OSProfileComputerNamePrefix { get; set; }
        /// <summary>
        /// Specifies a base-64 encoded string of custom data. The base-64 encoded string
        /// is decoded to a binary array that is saved as a file on the Virtual Machine.
        /// The maximum length of the binary array is 65535 bytes. For using cloud-init for
        /// your VM, see [Using cloud-init to customize a Linux VM during
        /// creation](https://docs.microsoft.com/azure/virtual-machines/linux/using-cloud-init)
        /// </summary>
        System.Security.SecureString OSProfileCustomData { get; set; }
        /// <summary>
        /// Specifies the Linux operating system settings on the virtual machine. For a
        /// list of supported Linux distributions, see [Linux on Azure-Endorsed
        /// Distributions](https://docs.microsoft.com/azure/virtual-machines/linux/endorsed-distros).
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ILinuxConfiguration OSProfileLinuxConfiguration { get; set; }
        /// <summary>Optional property which must either be set to True or omitted.</summary>
        bool? OSProfileRequireGuestProvisionSignal { get; set; }
        /// <summary>
        /// Specifies set of certificates that should be installed onto the virtual
        /// machines in the scale set. To install certificates on a virtual machine it is
        /// recommended to use the [Azure Key Vault virtual machine extension for
        /// Linux](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-linux)
        /// or the [Azure Key Vault virtual machine extension for
        /// Windows](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-windows).
        /// </summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVaultSecretGroup> OSProfileSecret { get; set; }
        /// <summary>Specifies Windows operating system settings on the virtual machine.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IWindowsConfiguration OSProfileWindowsConfiguration { get; set; }
        /// <summary>
        /// Enables customers to patch their Azure VMs without requiring a reboot. For
        /// enableHotpatching, the 'provisionVMAgent' must be set to true and 'patchMode'
        /// must be set to 'AutomaticByPlatform'.
        /// </summary>
        bool? PatchSettingEnableHotpatching { get; set; }
        /// <summary>
        /// Specifies whether ProxyAgent feature should be enabled on the virtual machine
        /// or virtual machine scale set.
        /// </summary>
        bool? ProxyAgentSettingEnabled { get; set; }
        /// <summary>
        /// Increase the value of this property allows user to reset the key used for
        /// securing communication channel between guest and host.
        /// </summary>
        int? ProxyAgentSettingKeyIncarnationId { get; set; }
        /// <summary>
        /// Specifies the mode that ProxyAgent will execute on if the feature is enabled.
        /// ProxyAgent will start to audit or monitor but not enforce access control over
        /// requests to host endpoints in Audit mode, while in Enforce mode it will enforce
        /// access control. The default value is Enforce mode.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("Audit", "Enforce")]
        string ProxyAgentSettingMode { get; set; }
        /// <summary>Specifies OS Image Scheduled Event related configurations.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IOSImageNotificationProfile ScheduledEventProfileOSImageNotificationProfile { get; set; }
        /// <summary>Specifies Terminate Scheduled Event related configurations.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ITerminateNotificationProfile ScheduledEventProfileTerminateNotificationProfile { get; set; }
        /// <summary>Specifies Scheduled Event related configurations.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IScheduledEventsProfile ScheduledEventsProfile { get; set; }
        /// <summary>
        /// Specifies the security posture to be used for all virtual machines in the scale
        /// set. Minimum api-version: 2023-03-01
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityPostureReference SecurityPostureReference { get; set; }
        /// <summary>
        /// List of virtual machine extension names to exclude when applying the security
        /// posture.
        /// </summary>
        System.Collections.Generic.List<string> SecurityPostureReferenceExcludeExtension { get; set; }
        /// <summary>
        /// The security posture reference id in the form of
        /// /CommunityGalleries/{communityGalleryName}/securityPostures/{securityPostureName}/versions/{major.minor.patch}|{major.*}|latest
        /// </summary>
        string SecurityPostureReferenceId { get; set; }
        /// <summary>Whether the security posture can be overridden by the user.</summary>
        bool? SecurityPostureReferenceIsOverridable { get; set; }
        /// <summary>
        /// Specifies the Security related profile settings for the virtual machines in the
        /// scale set.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISecurityProfile SecurityProfile { get; set; }
        /// <summary>
        /// Specifies the customer managed disk encryption set resource id for the managed
        /// disk that is used for Customer Managed Key encrypted ConfidentialVM OS Disk and
        /// VMGuest blob.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IDiskEncryptionSetParameters SecurityProfileDiskEncryptionSet { get; set; }
        /// <summary>Resource Id</summary>
        string SecurityProfileDiskEncryptionSetId { get; set; }
        /// <summary>
        /// This property can be used by user in the request to enable or disable the Host
        /// Encryption for the virtual machine or virtual machine scale set. This will
        /// enable the encryption for all the disks including Resource/Temp disk at host
        /// itself. The default behavior is: The Encryption at host will be disabled unless
        /// this property is set to true for the resource.
        /// </summary>
        bool? SecurityProfileEncryptionAtHost { get; set; }
        /// <summary>
        /// Specifies the Managed Identity used by ADE to get access token for keyvault
        /// operations.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IEncryptionIdentity SecurityProfileEncryptionIdentity { get; set; }
        /// <summary>
        /// Specifies ProxyAgent settings while creating the virtual machine. Minimum
        /// api-version: 2023-09-01.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IProxyAgentSettings SecurityProfileProxyAgentSetting { get; set; }
        /// <summary>
        /// Specifies the EncryptionType of the managed disk. It is set to
        /// DiskWithVMGuestState for encryption of the managed disk along with VMGuestState
        /// blob, VMGuestStateOnly for encryption of just the VMGuestState blob, and
        /// NonPersistedTPM for not persisting firmware state in the VMGuestState blob..
        /// **Note:** It can be set for only Confidential VMs.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("VMGuestStateOnly", "DiskWithVMGuestState", "NonPersistedTPM")]
        string SecurityProfileSecurityEncryptionType { get; set; }
        /// <summary>
        /// Specifies the SecurityType of the virtual machine. It has to be set to any
        /// specified value to enable UefiSettings. The default behavior is: UefiSettings
        /// will not be enabled unless this property is set.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("TrustedLaunch", "ConfidentialVM")]
        string SecurityProfileSecurityType { get; set; }
        /// <summary>
        /// Specifies the security settings like secure boot and vTPM used while creating
        /// the virtual machine. Minimum api-version: 2020-12-01.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IUefiSettings SecurityProfileUefiSetting { get; set; }
        /// <summary>
        /// Specifies the service artifact reference id used to set same image version for
        /// all virtual machines in the scale set when using 'latest' image version.
        /// Minimum api-version: 2022-11-01
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IServiceArtifactReference ServiceArtifactReference { get; set; }
        /// <summary>
        /// The service artifact reference id in the form of
        /// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroup}/providers/Microsoft.Compute/galleries/{galleryName}/serviceArtifacts/{serviceArtifactName}/vmArtifactsProfiles/{vmArtifactsProfilesName}
        /// </summary>
        string ServiceArtifactReferenceId { get; set; }
        /// <summary>The list of SSH public keys used to authenticate with linux based VMs.</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.ISshPublicKey> SshPublicKey { get; set; }
        /// <summary>Specifies the storage settings for the virtual machine disks.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetStorageProfile StorageProfile { get; set; }
        /// <summary>
        /// Specifies the parameters that are used to add data disks to the virtual
        /// machines in the scale set. For more information about disks, see [About disks
        /// and VHDs for Azure virtual
        /// machines](https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview).
        /// </summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetDataDisk> StorageProfileDataDisk { get; set; }
        /// <summary>
        /// Specifies the disk controller type configured for the virtual machines in the scale set. Minimum api-version: 2022-08-01
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("SCSI", "NVMe")]
        string StorageProfileDiskControllerType { get; set; }
        /// <summary>
        /// Specifies information about the image to use. You can specify information about
        /// platform images, marketplace images, or virtual machine images. This element is
        /// required when you want to use a platform image, marketplace image, or virtual
        /// machine image, but is not used in other creation operations.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IImageReference StorageProfileImageReference { get; set; }
        /// <summary>
        /// Specifies information about the operating system disk used by the virtual
        /// machines in the scale set. For more information about disks, see [About disks
        /// and VHDs for Azure virtual
        /// machines](https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview).
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IVirtualMachineScaleSetOSDisk StorageProfileOSDisk { get; set; }
        /// <summary>Specifies whether the Terminate Scheduled event is enabled or disabled.</summary>
        bool? TerminateNotificationProfileEnable { get; set; }
        /// <summary>
        /// Configurable length of time a Virtual Machine being deleted will have to
        /// potentially approve the Terminate Scheduled Event before the event is auto
        /// approved (timed out). The configuration must be specified in ISO 8601 format,
        /// the default value is 5 minutes (PT5M)
        /// </summary>
        string TerminateNotificationProfileNotBeforeTimeout { get; set; }
        /// <summary>
        /// Specifies the time in which this VM profile for the Virtual Machine Scale Set
        /// was created. Minimum API version for this property is 2023-09-01. This value
        /// will be added to VMSS Flex VM tags when creating/updating the VMSS VM Profile
        /// with minimum api-version 2023-09-01. Examples: "2024-07-01T00:00:01.1234567+00:00"
        /// </summary>
        global::System.DateTime? TimeCreated { get; set; }
        /// <summary>
        /// Specifies whether secure boot should be enabled on the virtual machine. Minimum
        /// api-version: 2020-12-01.
        /// </summary>
        bool? UefiSettingSecureBootEnabled { get; set; }
        /// <summary>
        /// Specifies whether vTPM should be enabled on the virtual machine. Minimum
        /// api-version: 2020-12-01.
        /// </summary>
        bool? UefiSettingVTpmEnabled { get; set; }
        /// <summary>
        /// UserData for the virtual machines in the scale set, which must be base-64
        /// encoded. Customer should not pass any secrets in here. Minimum api-version:
        /// 2021-03-01.
        /// </summary>
        string UserData { get; set; }
        /// <summary>
        /// Specifies the number of vCPUs available for the VM. When this property is not
        /// specified in the request body the default behavior is to set it to the value of
        /// vCPUs available for that VM size exposed in api response of [List all available
        /// virtual machine sizes in a
        /// region](https://docs.microsoft.com/en-us/rest/api/compute/resource-skus/list).
        /// </summary>
        int? VMSizePropertyVcpUsAvailable { get; set; }
        /// <summary>
        /// Specifies the vCPU to physical core ratio. When this property is not specified
        /// in the request body the default behavior is set to the value of vCPUsPerCore
        /// for the VM Size exposed in api response of [List all available virtual machine
        /// sizes in a
        /// region](https://docs.microsoft.com/en-us/rest/api/compute/resource-skus/list).
        /// **Setting this property to 1 also means that hyper-threading is disabled.**
        /// </summary>
        int? VMSizePropertyVcpUsPerCore { get; set; }
        /// <summary>The list of Windows Remote Management listeners</summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IWinRmListener> WinRmListener { get; set; }
        /// <summary>
        /// Specifies additional base-64 encoded XML formatted information that can be
        /// included in the Unattend.xml file, which is used by Windows Setup.
        /// </summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IAdditionalUnattendContent> WindowConfigurationAdditionalUnattendContent { get; set; }
        /// <summary>
        /// Indicates whether Automatic Updates is enabled for the Windows virtual machine.
        /// Default value is true. For virtual machine scale sets, this property can be
        /// updated and updates will take effect on OS reprovisioning.
        /// </summary>
        bool? WindowConfigurationEnableAutomaticUpdate { get; set; }
        /// <summary>
        /// Indicates whether VMAgent Platform Updates is enabled for the Windows virtual
        /// machine. Default value is false.
        /// </summary>
        bool? WindowConfigurationEnableVMAgentPlatformUpdate { get; set; }
        /// <summary>[Preview Feature] Specifies settings related to VM Guest Patching on Windows.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IPatchSettings WindowConfigurationPatchSetting { get; set; }
        /// <summary>
        /// Indicates whether virtual machine agent should be provisioned on the virtual
        /// machine. When this property is not specified in the request body, it is set to
        /// true by default. This will ensure that VM Agent is installed on the VM so that
        /// extensions can be added to the VM later.
        /// </summary>
        bool? WindowConfigurationProvisionVMAgent { get; set; }
        /// <summary>
        /// Specifies the time zone of the virtual machine. e.g. "Pacific Standard Time".
        /// Possible values can be
        /// [TimeZoneInfo.Id](https://docs.microsoft.com/dotnet/api/system.timezoneinfo.id?#System_TimeZoneInfo_Id)
        /// value from time zones returned by
        /// [TimeZoneInfo.GetSystemTimeZones](https://docs.microsoft.com/dotnet/api/system.timezoneinfo.getsystemtimezones).
        /// </summary>
        string WindowConfigurationTimeZone { get; set; }
        /// <summary>
        /// Specifies the Windows Remote Management listeners. This enables remote Windows
        /// PowerShell.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IWinRmConfiguration WindowConfigurationWinRm { get; set; }
        /// <summary>
        /// Specifies the mode of VM Guest patch assessment for the IaaS virtual
        /// machine.<br /><br /> Possible values are:<br /><br /> **ImageDefault** - You
        /// control the timing of patch assessments on a virtual machine.<br /><br />
        /// **AutomaticByPlatform** - The platform will trigger periodic patch assessments.
        /// The property provisionVMAgent must be true.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("ImageDefault", "AutomaticByPlatform")]
        string WindowsConfigurationPatchSettingsAssessmentMode { get; set; }
        /// <summary>
        /// Specifies additional settings for patch mode AutomaticByPlatform in VM Guest
        /// Patching on Windows.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.Models.IWindowsVMGuestPatchAutomaticByPlatformSettings WindowsConfigurationPatchSettingsAutomaticByPlatformSetting { get; set; }
        /// <summary>Enables customer to schedule patching without accidental upgrades</summary>
        bool? WindowsConfigurationPatchSettingsAutomaticByPlatformSettingsBypassPlatformSafetyChecksOnUserSchedule { get; set; }
        /// <summary>
        /// Specifies the reboot setting for all AutomaticByPlatform patch installation
        /// operations.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("Unknown", "IfRequired", "Never", "Always")]
        string WindowsConfigurationPatchSettingsAutomaticByPlatformSettingsRebootSetting { get; set; }
        /// <summary>
        /// Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual
        /// machines associated to virtual machine scale set with OrchestrationMode as
        /// Flexible.<br /><br /> Possible values are:<br /><br /> **Manual** - You
        /// control the application of patches to a virtual machine. You do this by
        /// applying patches manually inside the VM. In this mode, automatic updates are
        /// disabled; the property WindowsConfiguration.enableAutomaticUpdates must be
        /// false<br /><br /> **AutomaticByOS** - The virtual machine will automatically be
        /// updated by the OS. The property WindowsConfiguration.enableAutomaticUpdates
        /// must be true. <br /><br /> **AutomaticByPlatform** - the virtual machine will
        /// automatically updated by the platform. The properties provisionVMAgent and
        /// WindowsConfiguration.enableAutomaticUpdates must be true
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ComputeFleet.PSArgumentCompleterAttribute("Manual", "AutomaticByOS", "AutomaticByPlatform")]
        string WindowsConfigurationPatchSettingsPatchMode { get; set; }

    }
}