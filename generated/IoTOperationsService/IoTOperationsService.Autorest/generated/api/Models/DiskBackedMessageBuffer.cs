// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models
{
    using static Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Extensions;

    /// <summary>DiskBackedMessageBuffer properties</summary>
    public partial class DiskBackedMessageBuffer :
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IDiskBackedMessageBuffer,
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IDiskBackedMessageBufferInternal
    {

        /// <summary>Backing field for <see cref="EphemeralVolumeClaimSpec" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpec _ephemeralVolumeClaimSpec;

        /// <summary>
        /// Use the specified persistent volume claim template to mount a "generic ephemeral volume" for the message buffer. See <https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes>
        /// for details.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpec EphemeralVolumeClaimSpec { get => (this._ephemeralVolumeClaimSpec = this._ephemeralVolumeClaimSpec ?? new Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.VolumeClaimSpec()); set => this._ephemeralVolumeClaimSpec = value; }

        /// <summary>
        /// AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> EphemeralVolumeClaimSpecAccessMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).AccessMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).AccessMode = value ?? null /* arrayOf */; }

        /// <summary>
        /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the
        /// core API group. For any other third-party types, APIGroup is required.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string EphemeralVolumeClaimSpecDataSourceApiGroup { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSourceApiGroup; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSourceApiGroup = value ?? null; }

        /// <summary>Kind is the type of resource being referenced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string EphemeralVolumeClaimSpecDataSourceKind { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSourceKind; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSourceKind = value ?? null; }

        /// <summary>Name is the name of resource being referenced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string EphemeralVolumeClaimSpecDataSourceName { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSourceName; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSourceName = value ?? null; }

        /// <summary>
        /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the
        /// core API group. For any other third-party types, APIGroup is required.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string EphemeralVolumeClaimSpecDataSourceRefApiGroup { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSourceRefApiGroup; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSourceRefApiGroup = value ?? null; }

        /// <summary>Kind is the type of resource being referenced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string EphemeralVolumeClaimSpecDataSourceRefKind { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSourceRefKind; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSourceRefKind = value ?? null; }

        /// <summary>Name is the name of resource being referenced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string EphemeralVolumeClaimSpecDataSourceRefName { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSourceRefName; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSourceRefName = value ?? null; }

        /// <summary>
        /// Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string EphemeralVolumeClaimSpecDataSourceRefNamespace { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSourceRefNamespace; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSourceRefNamespace = value ?? null; }

        /// <summary>
        /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirementsLimits EphemeralVolumeClaimSpecResourcesLimit { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).ResourceLimit; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).ResourceLimit = value ?? null /* model class */; }

        /// <summary>
        /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults
        /// to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirementsRequests EphemeralVolumeClaimSpecResourcesRequest { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).ResourceRequest; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).ResourceRequest = value ?? null /* model class */; }

        /// <summary>
        /// MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelectorMatchExpressions> EphemeralVolumeClaimSpecSelectorMatchExpression { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).SelectorMatchExpression; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).SelectorMatchExpression = value ?? null /* arrayOf */; }

        /// <summary>
        /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of
        /// matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements
        /// are ANDed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelectorMatchLabels EphemeralVolumeClaimSpecSelectorMatchLabel { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).SelectorMatchLabel; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).SelectorMatchLabel = value ?? null /* model class */; }

        /// <summary>
        /// Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string EphemeralVolumeClaimSpecStorageClassName { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).StorageClassName; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).StorageClassName = value ?? null; }

        /// <summary>
        /// volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim
        /// spec. This is a beta feature.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string EphemeralVolumeClaimSpecVolumeMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).VolumeMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).VolumeMode = value ?? null; }

        /// <summary>VolumeName is the binding reference to the PersistentVolume backing this claim.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string EphemeralVolumeClaimSpecVolumeName { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).VolumeName; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).VolumeName = value ?? null; }

        /// <summary>Backing field for <see cref="MaxSize" /> property.</summary>
        private string _maxSize;

        /// <summary>
        /// The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec,
        /// then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec
        /// are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir>
        /// for details.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Owned)]
        public string MaxSize { get => this._maxSize; set => this._maxSize = value; }

        /// <summary>Internal Acessors for EphemeralVolumeClaimSpec</summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpec Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IDiskBackedMessageBufferInternal.EphemeralVolumeClaimSpec { get => (this._ephemeralVolumeClaimSpec = this._ephemeralVolumeClaimSpec ?? new Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.VolumeClaimSpec()); set { {_ephemeralVolumeClaimSpec = value;} } }

        /// <summary>Internal Acessors for EphemeralVolumeClaimSpecDataSource</summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.ILocalKubernetesReference Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IDiskBackedMessageBufferInternal.EphemeralVolumeClaimSpecDataSource { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSource; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSource = value; }

        /// <summary>Internal Acessors for EphemeralVolumeClaimSpecDataSourceRef</summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IKubernetesReference Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IDiskBackedMessageBufferInternal.EphemeralVolumeClaimSpecDataSourceRef { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSourceRef; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).DataSourceRef = value; }

        /// <summary>Internal Acessors for EphemeralVolumeClaimSpecResource</summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirements Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IDiskBackedMessageBufferInternal.EphemeralVolumeClaimSpecResource { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).Resource; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).Resource = value; }

        /// <summary>Internal Acessors for EphemeralVolumeClaimSpecSelector</summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelector Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IDiskBackedMessageBufferInternal.EphemeralVolumeClaimSpecSelector { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).Selector; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)EphemeralVolumeClaimSpec).Selector = value; }

        /// <summary>Internal Acessors for PersistentVolumeClaimSpec</summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpec Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IDiskBackedMessageBufferInternal.PersistentVolumeClaimSpec { get => (this._persistentVolumeClaimSpec = this._persistentVolumeClaimSpec ?? new Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.VolumeClaimSpec()); set { {_persistentVolumeClaimSpec = value;} } }

        /// <summary>Internal Acessors for PersistentVolumeClaimSpecDataSource</summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.ILocalKubernetesReference Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IDiskBackedMessageBufferInternal.PersistentVolumeClaimSpecDataSource { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSource; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSource = value; }

        /// <summary>Internal Acessors for PersistentVolumeClaimSpecDataSourceRef</summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IKubernetesReference Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IDiskBackedMessageBufferInternal.PersistentVolumeClaimSpecDataSourceRef { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSourceRef; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSourceRef = value; }

        /// <summary>Internal Acessors for PersistentVolumeClaimSpecResource</summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirements Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IDiskBackedMessageBufferInternal.PersistentVolumeClaimSpecResource { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).Resource; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).Resource = value; }

        /// <summary>Internal Acessors for PersistentVolumeClaimSpecSelector</summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelector Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IDiskBackedMessageBufferInternal.PersistentVolumeClaimSpecSelector { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).Selector; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).Selector = value; }

        /// <summary>Backing field for <see cref="PersistentVolumeClaimSpec" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpec _persistentVolumeClaimSpec;

        /// <summary>
        /// Use the specified persistent volume claim template to mount a persistent volume for the message buffer.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpec PersistentVolumeClaimSpec { get => (this._persistentVolumeClaimSpec = this._persistentVolumeClaimSpec ?? new Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.VolumeClaimSpec()); set => this._persistentVolumeClaimSpec = value; }

        /// <summary>
        /// AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<string> PersistentVolumeClaimSpecAccessMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).AccessMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).AccessMode = value ?? null /* arrayOf */; }

        /// <summary>
        /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the
        /// core API group. For any other third-party types, APIGroup is required.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string PersistentVolumeClaimSpecDataSourceApiGroup { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSourceApiGroup; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSourceApiGroup = value ?? null; }

        /// <summary>Kind is the type of resource being referenced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string PersistentVolumeClaimSpecDataSourceKind { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSourceKind; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSourceKind = value ?? null; }

        /// <summary>Name is the name of resource being referenced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string PersistentVolumeClaimSpecDataSourceName { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSourceName; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSourceName = value ?? null; }

        /// <summary>
        /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the
        /// core API group. For any other third-party types, APIGroup is required.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string PersistentVolumeClaimSpecDataSourceRefApiGroup { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSourceRefApiGroup; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSourceRefApiGroup = value ?? null; }

        /// <summary>Kind is the type of resource being referenced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string PersistentVolumeClaimSpecDataSourceRefKind { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSourceRefKind; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSourceRefKind = value ?? null; }

        /// <summary>Name is the name of resource being referenced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string PersistentVolumeClaimSpecDataSourceRefName { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSourceRefName; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSourceRefName = value ?? null; }

        /// <summary>
        /// Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string PersistentVolumeClaimSpecDataSourceRefNamespace { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSourceRefNamespace; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).DataSourceRefNamespace = value ?? null; }

        /// <summary>
        /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirementsLimits PersistentVolumeClaimSpecResourcesLimit { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).ResourceLimit; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).ResourceLimit = value ?? null /* model class */; }

        /// <summary>
        /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults
        /// to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirementsRequests PersistentVolumeClaimSpecResourcesRequest { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).ResourceRequest; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).ResourceRequest = value ?? null /* model class */; }

        /// <summary>
        /// MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelectorMatchExpressions> PersistentVolumeClaimSpecSelectorMatchExpression { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).SelectorMatchExpression; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).SelectorMatchExpression = value ?? null /* arrayOf */; }

        /// <summary>
        /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of
        /// matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements
        /// are ANDed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelectorMatchLabels PersistentVolumeClaimSpecSelectorMatchLabel { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).SelectorMatchLabel; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).SelectorMatchLabel = value ?? null /* model class */; }

        /// <summary>
        /// Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string PersistentVolumeClaimSpecStorageClassName { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).StorageClassName; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).StorageClassName = value ?? null; }

        /// <summary>
        /// volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim
        /// spec. This is a beta feature.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string PersistentVolumeClaimSpecVolumeMode { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).VolumeMode; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).VolumeMode = value ?? null; }

        /// <summary>VolumeName is the binding reference to the PersistentVolume backing this claim.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Origin(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.PropertyOrigin.Inlined)]
        public string PersistentVolumeClaimSpecVolumeName { get => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).VolumeName; set => ((Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecInternal)PersistentVolumeClaimSpec).VolumeName = value ?? null; }

        /// <summary>Creates an new <see cref="DiskBackedMessageBuffer" /> instance.</summary>
        public DiskBackedMessageBuffer()
        {

        }
    }
    /// DiskBackedMessageBuffer properties
    public partial interface IDiskBackedMessageBuffer :
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.IJsonSerializable
    {
        /// <summary>
        /// AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1",
        SerializedName = @"accessModes",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> EphemeralVolumeClaimSpecAccessMode { get; set; }
        /// <summary>
        /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the
        /// core API group. For any other third-party types, APIGroup is required.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.",
        SerializedName = @"apiGroup",
        PossibleTypes = new [] { typeof(string) })]
        string EphemeralVolumeClaimSpecDataSourceApiGroup { get; set; }
        /// <summary>Kind is the type of resource being referenced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Kind is the type of resource being referenced",
        SerializedName = @"kind",
        PossibleTypes = new [] { typeof(string) })]
        string EphemeralVolumeClaimSpecDataSourceKind { get; set; }
        /// <summary>Name is the name of resource being referenced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Name is the name of resource being referenced",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string EphemeralVolumeClaimSpecDataSourceName { get; set; }
        /// <summary>
        /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the
        /// core API group. For any other third-party types, APIGroup is required.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.",
        SerializedName = @"apiGroup",
        PossibleTypes = new [] { typeof(string) })]
        string EphemeralVolumeClaimSpecDataSourceRefApiGroup { get; set; }
        /// <summary>Kind is the type of resource being referenced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Kind is the type of resource being referenced",
        SerializedName = @"kind",
        PossibleTypes = new [] { typeof(string) })]
        string EphemeralVolumeClaimSpecDataSourceRefKind { get; set; }
        /// <summary>Name is the name of resource being referenced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Name is the name of resource being referenced",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string EphemeralVolumeClaimSpecDataSourceRefName { get; set; }
        /// <summary>
        /// Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.",
        SerializedName = @"namespace",
        PossibleTypes = new [] { typeof(string) })]
        string EphemeralVolumeClaimSpecDataSourceRefNamespace { get; set; }
        /// <summary>
        /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
        SerializedName = @"limits",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirementsLimits) })]
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirementsLimits EphemeralVolumeClaimSpecResourcesLimit { get; set; }
        /// <summary>
        /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults
        /// to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
        SerializedName = @"requests",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirementsRequests) })]
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirementsRequests EphemeralVolumeClaimSpecResourcesRequest { get; set; }
        /// <summary>
        /// MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"MatchExpressions is a list of label selector requirements. The requirements are ANDed.",
        SerializedName = @"matchExpressions",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelectorMatchExpressions) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelectorMatchExpressions> EphemeralVolumeClaimSpecSelectorMatchExpression { get; set; }
        /// <summary>
        /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of
        /// matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements
        /// are ANDed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is ""key"", the operator is ""In"", and the values array contains only ""value"". The requirements are ANDed.",
        SerializedName = @"matchLabels",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelectorMatchLabels) })]
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelectorMatchLabels EphemeralVolumeClaimSpecSelectorMatchLabel { get; set; }
        /// <summary>
        /// Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1",
        SerializedName = @"storageClassName",
        PossibleTypes = new [] { typeof(string) })]
        string EphemeralVolumeClaimSpecStorageClassName { get; set; }
        /// <summary>
        /// volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim
        /// spec. This is a beta feature.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.",
        SerializedName = @"volumeMode",
        PossibleTypes = new [] { typeof(string) })]
        string EphemeralVolumeClaimSpecVolumeMode { get; set; }
        /// <summary>VolumeName is the binding reference to the PersistentVolume backing this claim.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"VolumeName is the binding reference to the PersistentVolume backing this claim.",
        SerializedName = @"volumeName",
        PossibleTypes = new [] { typeof(string) })]
        string EphemeralVolumeClaimSpecVolumeName { get; set; }
        /// <summary>
        /// The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec,
        /// then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec
        /// are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir>
        /// for details.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec, then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir> for details.",
        SerializedName = @"maxSize",
        PossibleTypes = new [] { typeof(string) })]
        string MaxSize { get; set; }
        /// <summary>
        /// AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1",
        SerializedName = @"accessModes",
        PossibleTypes = new [] { typeof(string) })]
        System.Collections.Generic.List<string> PersistentVolumeClaimSpecAccessMode { get; set; }
        /// <summary>
        /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the
        /// core API group. For any other third-party types, APIGroup is required.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.",
        SerializedName = @"apiGroup",
        PossibleTypes = new [] { typeof(string) })]
        string PersistentVolumeClaimSpecDataSourceApiGroup { get; set; }
        /// <summary>Kind is the type of resource being referenced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Kind is the type of resource being referenced",
        SerializedName = @"kind",
        PossibleTypes = new [] { typeof(string) })]
        string PersistentVolumeClaimSpecDataSourceKind { get; set; }
        /// <summary>Name is the name of resource being referenced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Name is the name of resource being referenced",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string PersistentVolumeClaimSpecDataSourceName { get; set; }
        /// <summary>
        /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the
        /// core API group. For any other third-party types, APIGroup is required.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.",
        SerializedName = @"apiGroup",
        PossibleTypes = new [] { typeof(string) })]
        string PersistentVolumeClaimSpecDataSourceRefApiGroup { get; set; }
        /// <summary>Kind is the type of resource being referenced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Kind is the type of resource being referenced",
        SerializedName = @"kind",
        PossibleTypes = new [] { typeof(string) })]
        string PersistentVolumeClaimSpecDataSourceRefKind { get; set; }
        /// <summary>Name is the name of resource being referenced</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Name is the name of resource being referenced",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        string PersistentVolumeClaimSpecDataSourceRefName { get; set; }
        /// <summary>
        /// Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.",
        SerializedName = @"namespace",
        PossibleTypes = new [] { typeof(string) })]
        string PersistentVolumeClaimSpecDataSourceRefNamespace { get; set; }
        /// <summary>
        /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
        SerializedName = @"limits",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirementsLimits) })]
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirementsLimits PersistentVolumeClaimSpecResourcesLimit { get; set; }
        /// <summary>
        /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults
        /// to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
        SerializedName = @"requests",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirementsRequests) })]
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirementsRequests PersistentVolumeClaimSpecResourcesRequest { get; set; }
        /// <summary>
        /// MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"MatchExpressions is a list of label selector requirements. The requirements are ANDed.",
        SerializedName = @"matchExpressions",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelectorMatchExpressions) })]
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelectorMatchExpressions> PersistentVolumeClaimSpecSelectorMatchExpression { get; set; }
        /// <summary>
        /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of
        /// matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements
        /// are ANDed.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is ""key"", the operator is ""In"", and the values array contains only ""value"". The requirements are ANDed.",
        SerializedName = @"matchLabels",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelectorMatchLabels) })]
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelectorMatchLabels PersistentVolumeClaimSpecSelectorMatchLabel { get; set; }
        /// <summary>
        /// Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1",
        SerializedName = @"storageClassName",
        PossibleTypes = new [] { typeof(string) })]
        string PersistentVolumeClaimSpecStorageClassName { get; set; }
        /// <summary>
        /// volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim
        /// spec. This is a beta feature.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.",
        SerializedName = @"volumeMode",
        PossibleTypes = new [] { typeof(string) })]
        string PersistentVolumeClaimSpecVolumeMode { get; set; }
        /// <summary>VolumeName is the binding reference to the PersistentVolume backing this claim.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Read = true,
        Create = true,
        Update = true,
        Description = @"VolumeName is the binding reference to the PersistentVolume backing this claim.",
        SerializedName = @"volumeName",
        PossibleTypes = new [] { typeof(string) })]
        string PersistentVolumeClaimSpecVolumeName { get; set; }

    }
    /// DiskBackedMessageBuffer properties
    internal partial interface IDiskBackedMessageBufferInternal

    {
        /// <summary>
        /// Use the specified persistent volume claim template to mount a "generic ephemeral volume" for the message buffer. See <https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes>
        /// for details.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpec EphemeralVolumeClaimSpec { get; set; }
        /// <summary>
        /// AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        /// </summary>
        System.Collections.Generic.List<string> EphemeralVolumeClaimSpecAccessMode { get; set; }
        /// <summary>
        /// This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
        /// * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data
        /// source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature
        /// gate is enabled, this field will always have the same contents as the DataSourceRef field.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.ILocalKubernetesReference EphemeralVolumeClaimSpecDataSource { get; set; }
        /// <summary>
        /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the
        /// core API group. For any other third-party types, APIGroup is required.
        /// </summary>
        string EphemeralVolumeClaimSpecDataSourceApiGroup { get; set; }
        /// <summary>Kind is the type of resource being referenced</summary>
        string EphemeralVolumeClaimSpecDataSourceKind { get; set; }
        /// <summary>Name is the name of resource being referenced</summary>
        string EphemeralVolumeClaimSpecDataSourceName { get; set; }
        /// <summary>
        /// Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local
        /// object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume
        /// binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner.
        /// This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must
        /// have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value
        /// automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource
        /// and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object,
        /// as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef
        /// preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the
        /// AnyVolumeDataSource feature gate to be enabled.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IKubernetesReference EphemeralVolumeClaimSpecDataSourceRef { get; set; }
        /// <summary>
        /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the
        /// core API group. For any other third-party types, APIGroup is required.
        /// </summary>
        string EphemeralVolumeClaimSpecDataSourceRefApiGroup { get; set; }
        /// <summary>Kind is the type of resource being referenced</summary>
        string EphemeralVolumeClaimSpecDataSourceRefKind { get; set; }
        /// <summary>Name is the name of resource being referenced</summary>
        string EphemeralVolumeClaimSpecDataSourceRefName { get; set; }
        /// <summary>
        /// Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.
        /// </summary>
        string EphemeralVolumeClaimSpecDataSourceRefNamespace { get; set; }
        /// <summary>
        /// Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled
        /// users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity
        /// recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirements EphemeralVolumeClaimSpecResource { get; set; }
        /// <summary>
        /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirementsLimits EphemeralVolumeClaimSpecResourcesLimit { get; set; }
        /// <summary>
        /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults
        /// to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirementsRequests EphemeralVolumeClaimSpecResourcesRequest { get; set; }
        /// <summary>A label query over volumes to consider for binding.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelector EphemeralVolumeClaimSpecSelector { get; set; }
        /// <summary>
        /// MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        /// </summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelectorMatchExpressions> EphemeralVolumeClaimSpecSelectorMatchExpression { get; set; }
        /// <summary>
        /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of
        /// matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements
        /// are ANDed.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelectorMatchLabels EphemeralVolumeClaimSpecSelectorMatchLabel { get; set; }
        /// <summary>
        /// Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        /// </summary>
        string EphemeralVolumeClaimSpecStorageClassName { get; set; }
        /// <summary>
        /// volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim
        /// spec. This is a beta feature.
        /// </summary>
        string EphemeralVolumeClaimSpecVolumeMode { get; set; }
        /// <summary>VolumeName is the binding reference to the PersistentVolume backing this claim.</summary>
        string EphemeralVolumeClaimSpecVolumeName { get; set; }
        /// <summary>
        /// The max size of the message buffer on disk. If a PVC template is specified using one of ephemeralVolumeClaimSpec or persistentVolumeClaimSpec,
        /// then this size is used as the request and limit sizes of that template. If neither ephemeralVolumeClaimSpec nor persistentVolumeClaimSpec
        /// are specified, then an emptyDir volume is mounted with this size as its limit. See <https://kubernetes.io/docs/concepts/storage/volumes/#emptydir>
        /// for details.
        /// </summary>
        string MaxSize { get; set; }
        /// <summary>
        /// Use the specified persistent volume claim template to mount a persistent volume for the message buffer.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpec PersistentVolumeClaimSpec { get; set; }
        /// <summary>
        /// AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
        /// </summary>
        System.Collections.Generic.List<string> PersistentVolumeClaimSpecAccessMode { get; set; }
        /// <summary>
        /// This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
        /// * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data
        /// source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature
        /// gate is enabled, this field will always have the same contents as the DataSourceRef field.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.ILocalKubernetesReference PersistentVolumeClaimSpecDataSource { get; set; }
        /// <summary>
        /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the
        /// core API group. For any other third-party types, APIGroup is required.
        /// </summary>
        string PersistentVolumeClaimSpecDataSourceApiGroup { get; set; }
        /// <summary>Kind is the type of resource being referenced</summary>
        string PersistentVolumeClaimSpecDataSourceKind { get; set; }
        /// <summary>Name is the name of resource being referenced</summary>
        string PersistentVolumeClaimSpecDataSourceName { get; set; }
        /// <summary>
        /// Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local
        /// object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume
        /// binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner.
        /// This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must
        /// have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value
        /// automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource
        /// and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object,
        /// as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef
        /// preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the
        /// AnyVolumeDataSource feature gate to be enabled.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IKubernetesReference PersistentVolumeClaimSpecDataSourceRef { get; set; }
        /// <summary>
        /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the
        /// core API group. For any other third-party types, APIGroup is required.
        /// </summary>
        string PersistentVolumeClaimSpecDataSourceRefApiGroup { get; set; }
        /// <summary>Kind is the type of resource being referenced</summary>
        string PersistentVolumeClaimSpecDataSourceRefKind { get; set; }
        /// <summary>Name is the name of resource being referenced</summary>
        string PersistentVolumeClaimSpecDataSourceRefName { get; set; }
        /// <summary>
        /// Namespace is the namespace of the resource being referenced. This field is required when the resource has a namespace.
        /// </summary>
        string PersistentVolumeClaimSpecDataSourceRefNamespace { get; set; }
        /// <summary>
        /// Resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled
        /// users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity
        /// recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirements PersistentVolumeClaimSpecResource { get; set; }
        /// <summary>
        /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirementsLimits PersistentVolumeClaimSpecResourcesLimit { get; set; }
        /// <summary>
        /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults
        /// to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimResourceRequirementsRequests PersistentVolumeClaimSpecResourcesRequest { get; set; }
        /// <summary>A label query over volumes to consider for binding.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelector PersistentVolumeClaimSpecSelector { get; set; }
        /// <summary>
        /// MatchExpressions is a list of label selector requirements. The requirements are ANDed.
        /// </summary>
        System.Collections.Generic.List<Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelectorMatchExpressions> PersistentVolumeClaimSpecSelectorMatchExpression { get; set; }
        /// <summary>
        /// MatchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of
        /// matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements
        /// are ANDed.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.IoTOperationsService.Models.IVolumeClaimSpecSelectorMatchLabels PersistentVolumeClaimSpecSelectorMatchLabel { get; set; }
        /// <summary>
        /// Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
        /// </summary>
        string PersistentVolumeClaimSpecStorageClassName { get; set; }
        /// <summary>
        /// volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim
        /// spec. This is a beta feature.
        /// </summary>
        string PersistentVolumeClaimSpecVolumeMode { get; set; }
        /// <summary>VolumeName is the binding reference to the PersistentVolume backing this claim.</summary>
        string PersistentVolumeClaimSpecVolumeName { get; set; }

    }
}