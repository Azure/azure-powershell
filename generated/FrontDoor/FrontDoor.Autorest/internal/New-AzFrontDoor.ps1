
# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Code generated by Microsoft (R) AutoRest Code Generator.Changes may cause incorrect behavior and will be lost if the code
# is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
Create a new Front Door with a Front Door name under the specified subscription and resource group.
.Description
Create a new Front Door with a Front Door name under the specified subscription and resource group.
.Example
New-AzFrontDoor -Name "frontDoor1" -ResourceGroupName "rg1" -RoutingRule $routingrule1 -BackendPool $backendpool1 -FrontendEndpoint $frontendEndpoint1 -LoadBalancingSetting $loadBalancingSetting1 -HealthProbeSetting $healthProbeSetting1 -BackendPoolsSetting $backendPoolsSetting1

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontDoor
.Notes
COMPLEX PARAMETER PROPERTIES

To create the parameters described below, construct a hash table containing the appropriate properties. For information on hash tables, run Get-Help about_Hash_Tables.

BACKENDPOOL <IBackendPool[]>: Backend pools available to routing rules.
  [Id <String>]: Resource ID.
  [Backend <List<IBackend>>]: The set of backends for this pool
    [Address <String>]: Location of the backend (IP address or FQDN)
    [BackendHostHeader <String>]: The value to use as the host header sent to the backend. If blank or unspecified, this defaults to the incoming host.
    [EnabledState <String>]: Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled'
    [HttpPort <Int32?>]: The HTTP TCP port number. Must be between 1 and 65535.
    [HttpsPort <Int32?>]: The HTTPS TCP port number. Must be between 1 and 65535.
    [Priority <Int32?>]: Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy.
    [PrivateLinkAlias <String>]: The Alias of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
    [PrivateLinkApprovalMessage <String>]: A custom message to be included in the approval request to connect to the Private Link
    [PrivateLinkLocation <String>]: The location of the Private Link resource. Required only if 'privateLinkResourceId' is populated
    [PrivateLinkResourceId <String>]: The Resource Id of the Private Link resource. Populating this optional field indicates that this backend is 'Private'
    [Weight <Int32?>]: Weight of this endpoint for load balancing purposes.
  [HealthProbeSettingId <String>]: Resource ID.
  [LoadBalancingSettingId <String>]: Resource ID.
  [Name <String>]: Resource name.

BACKENDPOOLSSETTING <IBackendPoolsSettings>: Settings for all backendPools
  [EnforceCertificateNameCheck <String>]: Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests.
  [SendRecvTimeoutInSeconds <Int32?>]: Send and receive timeout on forwarding request to the backend. When timeout is reached, the request fails and returns.

FRONTENDENDPOINT <IFrontendEndpoint[]>: Frontend endpoints available to routing rules.
  [Id <String>]: Resource ID.
  [CertificateSource <String>]: Defines the source of the SSL certificate
  [CertificateType <String>]: Defines the type of the certificate used for secure connections to a frontendEndpoint
  [HostName <String>]: The host name of the frontendEndpoint. Must be a domain name.
  [MinimumTlsVersion <String>]: The minimum TLS version required from the clients to establish an SSL handshake with Front Door.
  [Name <String>]: Resource name.
  [SecretName <String>]: The name of the Key Vault secret representing the full certificate PFX
  [SecretVersion <String>]: The version of the Key Vault secret representing the full certificate PFX
  [SessionAffinityEnabledState <String>]: Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'
  [SessionAffinityTtlInSeconds <Int32?>]: UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if applicable.
  [Vault <String>]: Resource ID.
  [WebApplicationFirewallPolicyLinkId <String>]: Resource ID.

HEALTHPROBESETTING <IHealthProbeSettingsModel[]>: Health probe settings associated with this Front Door instance.
  [Id <String>]: Resource ID.
  [EnabledState <String>]: Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool.
  [HealthProbeMethod <String>]: Configures which HTTP method to use to probe the backends defined under backendPools.
  [IntervalInSeconds <Int32?>]: The number of seconds between health probes.
  [Name <String>]: Resource name.
  [Path <String>]: The path to use for the health probe. Default is /
  [Protocol <String>]: Protocol scheme to use for this probe

LOADBALANCINGSETTING <ILoadBalancingSettingsModel[]>: Load balancing settings associated with this Front Door instance.
  [Id <String>]: Resource ID.
  [AdditionalLatencyInMilliseconds <Int32?>]: The additional latency in milliseconds for probes to fall into the lowest latency bucket
  [Name <String>]: Resource name.
  [SampleSize <Int32?>]: The number of samples to consider for load balancing decisions
  [SuccessfulSamplesRequired <Int32?>]: The number of samples within the sample period that must succeed

ROUTINGRULE <IRoutingRule[]>: Routing rules associated with this Front Door.
  [Id <String>]: Resource ID.
  [AcceptedProtocol <List<String>>]: Protocol schemes to match for this rule
  [EnabledState <String>]: Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'
  [FrontendEndpoint <List<ISubResource>>]: Frontend endpoints associated with this rule
    [Id <String>]: Resource ID.
  [Name <String>]: Resource name.
  [PatternsToMatch <List<String>>]: The route patterns of the rule.
  [RouteConfiguration <IRouteConfiguration>]: A reference to the routing configuration.
    OdataType <String>: 
  [RuleEngineId <String>]: Resource ID.
  [WebApplicationFirewallPolicyLinkId <String>]: Resource ID.
.Link
https://learn.microsoft.com/powershell/module/az.frontdoor/new-azfrontdoor
#>
function New-AzFrontDoor {
[OutputType([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontDoor])]
[CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
param(
    [Parameter(Mandatory)]
    [Alias('FrontDoorName')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Front Door which is globally unique.
    ${Name},

    [Parameter(Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [System.String]
    # Name of the Resource group within the Azure subscription.
    ${ResourceGroupName},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Path')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
    [System.String]
    # The subscription credentials which uniquely identify the Microsoft Azure subscription.
    # The subscription ID forms part of the URI for every service call.
    ${SubscriptionId},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IBackendPool[]]
    # Backend pools available to routing rules.
    ${BackendPool},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IBackendPoolsSettings]
    # Settings for all backendPools
    ${BackendPoolsSetting},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.PSArgumentCompleterAttribute("Enabled", "Disabled")]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.DefaultInfo(Script='"Enabled"')]
    [System.String]
    # Operational status of the Front Door load balancer.
    # Permitted values are 'Enabled' or 'Disabled'
    ${EnabledState},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # A friendly name for the frontDoor
    ${FriendlyName},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IFrontendEndpoint[]]
    # Frontend endpoints available to routing rules.
    ${FrontendEndpoint},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IHealthProbeSettingsModel[]]
    # Health probe settings associated with this Front Door instance.
    ${HealthProbeSetting},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.ILoadBalancingSettingsModel[]]
    # Load balancing settings associated with this Front Door instance.
    ${LoadBalancingSetting},

    [Parameter(ParameterSetName='CreateExpanded')]
    [AllowEmptyCollection()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IRoutingRule[]]
    # Routing rules associated with this Front Door.
    ${RoutingRule},

    [Parameter(ParameterSetName='CreateExpanded')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Models.IResourceTags]))]
    [System.Collections.Hashtable]
    # Resource tags.
    ${Tag},

    [Parameter(ParameterSetName='CreateViaJsonFilePath', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Path of Json file supplied to the Create operation
    ${JsonFilePath},

    [Parameter(ParameterSetName='CreateViaJsonString', Mandatory)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Body')]
    [System.String]
    # Json string supplied to the Create operation
    ${JsonString},

    [Parameter()]
    [Alias('AzureRMContext', 'AzureCredential')]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Azure')]
    [System.Management.Automation.PSObject]
    # The DefaultProfile parameter is not functional.
    # Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.
    ${DefaultProfile},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command as a job
    ${AsJob},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Wait for .NET debugger to attach
    ${Break},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be appended to the front of the pipeline
    ${HttpPipelineAppend},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.SendAsyncStep[]]
    # SendAsync Pipeline Steps to be prepended to the front of the pipeline
    ${HttpPipelinePrepend},

    [Parameter()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Run the command asynchronously
    ${NoWait},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Uri]
    # The URI for the proxy server to use
    ${Proxy},

    [Parameter(DontShow)]
    [ValidateNotNull()]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.PSCredential]
    # Credentials for a proxy server to use for the remote call
    ${ProxyCredential},

    [Parameter(DontShow)]
    [Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Category('Runtime')]
    [System.Management.Automation.SwitchParameter]
    # Use the default credentials for the proxy
    ${ProxyUseDefaultCredentials}
)

begin {
    try {
        $outBuffer = $null
        if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer)) {
            $PSBoundParameters['OutBuffer'] = 1
        }
        $parameterSet = $PSCmdlet.ParameterSetName
        
        $testPlayback = $false
        $PSBoundParameters['HttpPipelinePrepend'] | Foreach-Object { if ($_) { $testPlayback = $testPlayback -or ('Microsoft.Azure.PowerShell.Cmdlets.FrontDoor.Runtime.PipelineMock' -eq $_.Target.GetType().FullName -and 'Playback' -eq $_.Target.Mode) } }

        $mapping = @{
            CreateExpanded = 'Az.FrontDoor.private\New-AzFrontDoor_CreateExpanded';
            CreateViaJsonFilePath = 'Az.FrontDoor.private\New-AzFrontDoor_CreateViaJsonFilePath';
            CreateViaJsonString = 'Az.FrontDoor.private\New-AzFrontDoor_CreateViaJsonString';
        }
        if (('CreateExpanded', 'CreateViaJsonFilePath', 'CreateViaJsonString') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('SubscriptionId') ) {
            if ($testPlayback) {
                $PSBoundParameters['SubscriptionId'] = . (Join-Path $PSScriptRoot '..' 'utils' 'Get-SubscriptionIdTestSafe.ps1')
            } else {
                $PSBoundParameters['SubscriptionId'] = (Get-AzContext).Subscription.Id
            }
        }
        if (('CreateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('EnabledState') ) {
            $PSBoundParameters['EnabledState'] = "Enabled"
        }
        if (('CreateExpanded') -contains $parameterSet -and -not $PSBoundParameters.ContainsKey('Location') ) {
            $PSBoundParameters['Location'] = "global"
        }

        $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Cmdlet)
        if ($wrappedCmd -eq $null) {
            $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand(($mapping[$parameterSet]), [System.Management.Automation.CommandTypes]::Function)
        }
        $scriptCmd = {& $wrappedCmd @PSBoundParameters}
        $steppablePipeline = $scriptCmd.GetSteppablePipeline($MyInvocation.CommandOrigin)
        $steppablePipeline.Begin($PSCmdlet)
    } catch {

        throw
    }
}

process {
    try {
        $steppablePipeline.Process($_)
    } catch {

        throw
    }

}
end {
    try {
        $steppablePipeline.End()

    } catch {

        throw
    }
} 
}
