# Please don't use ADO UI defined scheduled triggers because it takes precedence over YAML scheduled triggers.
# https://docs.microsoft.com/en-us/azure/devops/pipelines/process/scheduled-triggers
schedules:
- cron: "0 0 * * *"
  displayName: Daily Midnight Build
  branches:
    include:
    - master

pr: none
trigger: none

pool:
  vmImage: 'windows-2019'

steps:
- task: PowerShell@2
  displayName: Clean Existing Modules
  inputs:
    targetType: 'inline'
    script: |
      # Remove Az.* modules
      $modules = Get-Module -Name Az.* -ListAvailable
      if($modules){
        Write-Host "Removing Az modules..."
        $dirctory = Split-Path $modules[0].Path | Split-Path | Split-Path
        Remove-Item –path $dirctory –recurse -force
        Write-Host "Az modules removed."
      }

      # Check Az
      Get-Module -Name Az.* -ListAvailable

      # Remove AzureRM.* modules
      $modules = Get-Module -Name AzureRM.* -ListAvailable
      if($modules){
        Write-Host "Removing AzureRM modules..."
        $dirctory = Split-Path $modules[0].Path | Split-Path | Split-Path
        Remove-Item –path $dirctory –recurse -force
        Write-Host "AzureRM modules removed."
      }

      # Check AzureRM
      Get-Module -Name AzureRM.* -ListAvailable
    pwsh: true
   
- task: PowerShell@2
  displayName: Install Az Modules from PSGallery
  inputs:
    targetType: 'inline'
    script: |
      # Check PSGallery
      $psGallery = Get-PSRepository -Name PSGallery
      if(!$psGallery){
        # Set up PSGallery
        Write-Host "Registering PSGallery..."
        Register-PSRepository -Default -InstallationPolicy Trusted
      }else{
        Write-Host "Setting PSGallery Trusted..."
        Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
      }

      Write-Host "Installing Az..."
      Install-Module -Name Az -Repository PSGallery -AllowClobber -Force 
      
      # Check Az
      Get-Module -Name Az.* -ListAvailable
    pwsh: true
- task: PowerShell@2
  displayName: Connect AzAccount 
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "Connecting Az.Account..."
      $secret = ConvertTo-SecureString -String $(password) -AsPlainText -Force
      $credential = New-Object -TypeName System.Management.Automation.PSCredential($(servicePrincipal), $secret)
      Connect-AzAccount -ServicePrincipal -Credential $credential -Tenant $(tenantId)
      Set-AzContext -Subscription "Azure SDK Powershell Test"
      Enable-AzureRmAlias
    pwsh: true

- task: PowerShell@2
  displayName: Run Smoke Test 
  inputs:
    filePath: './tools/Test/SmokeTest/RmCoreSmokeTests.ps1'
    pwsh: true

- task: PowerShell@2
  displayName: 'Run Smoke Test Reversely'
  inputs:
    filePath: './tools/Test/SmokeTest/RmCoreSmokeTests.ps1'
    arguments: '-Reverse'
    pwsh: true


- task: PowerShell@2
  displayName: Clean Az Modules
  inputs:
    targetType: 'inline'
    script: |
      # Remove Az.* modules
      $modules = Get-Module -Name Az.* -ListAvailable
      if($modules){
        Write-Host "Removing Az modules..."
        $dirctory = Split-Path $modules[0].Path | Split-Path | Split-Path
        Remove-Item –path $dirctory –recurse -force
        Write-Host "Az modules removed."
      }

      # Check Az
      Get-Module -Name Az.* -ListAvailable
    pwsh: true


- task: PowerShell@2
  displayName: Update Az Modules
  inputs:
    targetType: 'inline'
    script: |
      # Get previous version of az
      $versions = (find-module az -Repository PSGallery -AllVersions).Version |
       %{[system.version]$_} | 
       sort -Descending -Top 2 | 
       %{[System.String]$_}

      if($versions.Count -ge 2){
        # Install previous version of Az
        $previousVersion = $versions[1]
        Write-Host '$previousVersion:',$previousVersion

        Install-Module -Name Az -Repository PSGallery -RequiredVersion $previousVersion -AllowClobber -Force

        #Update Az
        Update-Module -Name Az
        
        # Check Az
        Write-Host "Get latest version of Az"
        Get-Module -Name Az.* -ListAvailable

        # Reuse connected account and select subscription for test
        Enable-AzureRmAlias
        Set-AzContext -Subscription "Azure SDK Powershell Test"
      }
    pwsh: true

- task: PowerShell@2
  displayName: Run Smoke Test 
  inputs:
    filePath: './tools/Test/SmokeTest/RmCoreSmokeTests.ps1'
    pwsh: true

- task: PowerShell@2
  displayName: 'Run Smoke Test Reversely'
  inputs:
    filePath: './tools/Test/SmokeTest/RmCoreSmokeTests.ps1'
    arguments: '-Reverse'
    pwsh: true

- task: PowerShell@2
  displayName: Clean Az Modules
  inputs:
    targetType: 'inline'
    script: |
      # Remove Az.* modules
      $modules = Get-Module -Name Az.* -ListAvailable
      if($modules){
        Write-Host "Removing Az modules..."
        $dirctory = Split-Path $modules[0].Path | Split-Path | Split-Path
        Remove-Item –path $dirctory –recurse -force
        Write-Host "Az modules removed."
      }

      # Check Az
      Get-Module -Name Az.* -ListAvailable
    pwsh: true

- task: PowerShell@2
  displayName: Install an individual module
  inputs:
    targetType: 'inline'
    script: |
      Install-Module -Name Az.Compute -Repository PSGallery -AllowClobber -Force 
      Get-AzVM
      Get-Module
    pwsh: true

- task: PowerShell@2
  displayName: Update an individual module
  inputs:
    targetType: 'inline'
    script: |
      # Get previous version of Az.Compute
      $versions = (find-module Az.Compute -Repository PSGallery -AllVersions).Version |
       %{[system.version]$_} | 
       sort -Descending -Top 2 | 
       %{[System.String]$_}

      if($versions.Count -ge 2){
        # Install previous version of Az.Compute
        $previousVersion = $versions[1]
        Write-Host '$previousVersion:', $previousVersion
        Install-Module -Name Az.Compute -Repository PSGallery -RequiredVersion $previousVersion -AllowClobber -Force

        #Update Az.Compute
        Update-Module -Name Az.Compute
        Write-Host "Installed latest version of Az.Compute"

        # Check Az.Compute
        Get-AzVM
        Get-Module
      }
    pwsh: true

- task: PowerShell@2
  displayName: Clean Az Modules
  inputs:
    targetType: 'inline'
    script: |
      # Remove Az.* modules
      $modules = Get-Module -Name Az.* -ListAvailable
      if($modules){
        Write-Host "Removing Az modules..."
        $dirctory = Split-Path $modules[0].Path | Split-Path | Split-Path
        Remove-Item –path $dirctory –recurse -force
        Write-Host "Az modules removed."
      }

      # Check Az
      Get-Module -Name Az.* -ListAvailable
    pwsh: true

- task: PowerShell@2
  displayName: Install Az on top of an individual module
  inputs:
    targetType: 'inline'
    script: |
      # Get previous version of Az.Compute
      $versions = (find-module Az.Compute -Repository PSGallery -AllVersions).Version |
       %{[system.version]$_} | 
       sort -Descending -Top 2 | 
       %{[System.String]$_}

      if($versions.Count -ge 2){
        # Install previous version of Az.Compute        
        $previousVersion = $versions[1]
        Write-Host '$previousVersion:', $previousVersion
        Write-Host "Installed previous version of Az.Compute"

        Install-Module -Name Az.Compute -Repository PSGallery -RequiredVersion $previousVersion -AllowClobber -Force

        #Install Az
        Install-Module -Name Az -Repository PSGallery -AllowClobber -Force
        
        Write-Host "Installed latest version of Az"
        Get-AzVM
        Get-Module
      }
    pwsh: true

- task: PowerShell@2
  displayName: Clean Az Modules
  inputs:
    targetType: 'inline'
    script: |
      # Remove Az.* modules
      $modules = Get-Module -Name Az.* -ListAvailable
      if($modules){
        Write-Host "Removing Az modules..."
        $dirctory = Split-Path $modules[0].Path | Split-Path | Split-Path
        Remove-Item –path $dirctory –recurse -force
        Write-Host "Az modules removed."
      }

      # Check Az
      Get-Module -Name Az.* -ListAvailable
    pwsh: true

- task: PowerShell@2
  displayName: Install an individual module on top of Az
  inputs:
    targetType: 'inline'
    script: |
      # Get previous version of Az
      $versions = (find-module Az -Repository PSGallery -AllVersions).Version |
       %{[system.version]$_} | 
       sort -Descending -Top 2 | 
       %{[System.String]$_}

      if($versions.Count -ge 2){
        # Install previous version of Az
        $previousVersion = $versions[1]
        Write-Host '$previousVersion:', $previousVersion
        Install-Module -Name Az -Repository PSGallery -RequiredVersion $previousVersion -AllowClobber -Force

        #Install Az.Compute
        Install-Module -Name Az.Compute -Repository PSGallery -AllowClobber -Force        
        
        Write-Host "Installed latest Az.Compute"
        Get-AzVM
        Get-Module
      }
    pwsh: true