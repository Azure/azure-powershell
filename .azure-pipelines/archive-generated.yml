parameters:
- name: TargetModule
  displayName: 'List of target modules, all modules if not provided'
  type: string
  default: 'all'
- name: ForceRegenerate
  displayName: 'Force regenerate autorest generated modules when pipeline triggered manually'
  type: boolean
  default: false

variables:
  WindowsName: windows
  WindowsAgentPoolName: pool-windows-2019
  WindowsAgentPoolVMImage: ''
  LinuxName: linux
  LinuxAgentPoolName: pool-ubuntu-2004
  LinuxAgentPoolVMImage: ''
  MacOSName: macOS
  MacOSAgentPoolName: 'Azure Pipelines'
  MacOSAgentPoolVMImage: macOS-latest
  TestFramework: net6.0
  TestTarget: Test
  Configuration: Debug
  DebugLocalBuildTasks: true
  BuildTimeoutInMinutes: 120
  AnalysisTimeoutInMinutes: 120
  TestTimeoutInMinutes: 180
  BuildAzPredictor: false
  EnableTestCoverage: true
  TestCoverageLocation: $(Build.SourcesDirectory)/artifacts
  PowerShellPlatform: PowerShell Core
  AZURE_CLIENTS_SHOW_SECRETS_WARNING: true


trigger:
  branches:
    include:
      - future

jobs:
- job: Build
  displayName: Build
  condition: succeeded()
  timeoutInMinutes: ${{ variables.BuildTimeoutInMinutes }}
  pool: pool-windows-2019

  steps:
  - checkout: self
  - template: util/get-github-pat-steps.yml
  - task: PowerShell@2
    name: 'Initialize'
    displayName: 'Initialize Build'
    inputs:
      targetType: inline
      pwsh: true
      script: |
        $filesChangedOutputPath = Join-Path "$(Build.SourcesDirectory)" 'artifacts' 'FilesChanged.txt'
        Write-Host "##vso[task.setvariable variable=FilesChangedOutputPath]$filesChangedOutputPath"
        New-Item -Type File -Path $filesChangedOutputPath -Force

        $forceRegenerate = $false
        if ('true' -eq '${{ parameters.ForceRegenerate }}') {
          $forceRegenerate = $true
        }

        $filesChangedScriptPath = Join-Path "$(Build.SourcesDirectory)" 'tools' 'BuildScripts' 'FilesChangedScript.psm1'
        Import-Module $filesChangedScriptPath
        $filesChanged = Get-OutdatedModuleFromTargetModule -RepoRoot "$(Build.SourcesDirectory)" -TargetModule "${{ parameters.TargetModule }}" -ForceRegenerate $forceRegenerate
        if (($null -eq $filesChanged) -or (0 -eq $filesChanged.Length)) {
          Write-Warning "no modules found need to be archived"
          #Write-Host "##vso[task.setvariable variable=Terminate;isOutput=true]true"
          Write-Host "##vso[task.setvariable variable=Terminate]true"
          exit 0
        }
        $filesChanged | ForEach-Object { Join-Path 'src' $_ } | Out-File $filesChangedOutputPath
  - ${{ if ne(variables.Terminate, 'true') }}:
    - task: PowerShell@2
      displayName: 'Create branch for generated assets'
      inputs:
        targetType: inline
        pwsh: true
        script: |
          Write-Warning 'first'
          Write-Warning "${{ variables.FilesChangedOutputPath }}"
          Write-Warning 'second'
          Write-Warning "${{ variables.Terminate }}"

          $baseBranchName = "origin/$(Build.SourceBranchName)"
          $tmpBranchName = "archive/$(Build.SourceBranchName)/$(Build.Reason)"
          if ("$(Build.reason)" -in @('IndividualCI', 'BatchedCI')) {
            $tmpBranchName += "/$(Build.SourceVersion)"
          }
          Write-Host "##vso[task.setvariable variable=TmpBranchName]$tmpBranchName"
          Write-Host "##vso[task.setvariable variable=BaseBranchName]$baseBranchName"
          Write-Host "##[section]Switch from $baseBranchName to $tmpBranchName"
          git fetch origin $(Build.SourceBranchName)
          git checkout -b $tmpBranchName $baseBranchName
    - template: util/build-steps.yml
      parameters:
        configuration: ${{ variables.Configuration }}
        testFramework: ${{ variables.TestFramework }}
        powerShellPlatform: ${{ variables.PowerShellPlatform }}
        filesChangedOutputPath: $(FilesChangedOutputPath)
        TargetModule: ${{ parameters.TargetModule }}
        ForceRegenerate: ${{ parameters.ForceRegenerate }}
    - task: PowerShell@2
      displayName: 'push archive branch after build'
      inputs:
        targetType: inline
        pwsh: true
        script: |
          if ("$(Build.reason)" -in @('IndividualCI', 'BatchedCI')) {
            $prTitle = "[skip ci] Archive $(Build.SourceVersion)"
          } else {
            #TODO: replace $(Build.reason) with account when manual and datetime when schedule
            $prTitle = "[skip ci] Archive $(Build.reason)"
          }
          $tmpBranchName = "$(TmpBranchName)"
          $baseBranchName = "$(BaseBranchName)"
          $generatedPath = Join-Path "$(Build.SourcesDirectory)" 'generated'
          $diff = ( git status --short --untracked-files $generatedPath)
          if ((-not $diff) -or ($null -eq $diff) -or (0 -eq $diff.Count)) {
            return
          }
          #TODO: add better PR description
          $prDescription = ""
          $prScriptPath = Join-Path "$(Build.SourcesDirectory)" 'tools' 'Github' 'CreatePR.ps1'

          git config user.email "65331932+azure-powershell-bot@users.noreply.github.com";
          git config user.name "azure-powershell-bot";
          git remote set-url origin https://azure-powershell-bot:$(GithubToken)@github.com/Azure/azure-powershell.git;
          git add $generatedPath
          git commit -m $prTitle
          git push origin $tmpBranchName --force
          
          . $prScriptPath -Title $prTitle -HeadBranch $tmpBranchName -BaseBranch "$(Build.SourceBranchName)" -BotAccessToken $(GithubToken) -Description $prDescription

          <#
            this commidId will be useful when we push directly to target branch in the future
            $commitId = (git rev-parse HEAD)
          #>

- job: Analyze
  displayName: Analyze
  dependsOn: Build
  condition: and(succeeded(), ne(dependencies.Build.outputs['Initialize.Terminate'], 'true'))
  timeoutInMinutes: ${{ variables.AnalysisTimeoutInMinutes }}
  pool: pool-windows-2019

  steps:
  - template: util/analyze-steps.yml
    parameters:
      configuration: ${{ variables.Configuration }}
      testFramework: ${{ variables.TestFramework }}
      powerShellPlatform: ${{ variables.PowerShellPlatform }}

- job: Test
  displayName: Test
  dependsOn: Build
  condition: and(succeeded(), ne(dependencies.Build.outputs['Initialize.Terminate'], 'true'))
  timeoutInMinutes: ${{ variables.TestTimeoutInMinutes }}
  strategy:
    matrix:
      windows:
        OSName: ${{ variables.WindowsName }}
        agentPoolName: ${{ variables.WindowsAgentPoolName }}
        agentPoolVMImage: ${{ variables.WindowsAgentPoolVMImage }}
      linux:
        OSName: ${{ variables.LinuxName }}
        agentPoolName: ${{ variables.LinuxAgentPoolName }}
        agentPoolVMImage: ${{ variables.LinuxAgentPoolVMImage }}
      macOS:
        OSName: ${{ variables.MacOSName }}
        agentPoolName: ${{ variables.MacOSAgentPoolName }}
        agentPoolVMImage: ${{ variables.MacOSAgentPoolVMImage }}
  pool:
    name: $(agentPoolName)
    vmImage: $(agentPoolVMImage)

  steps:
  - template: util/test-steps.yml
    parameters:
      osName: $(OSName)
      testFramework: ${{ variables.TestFramework }}
      testTarget: ${{ variables.TestTarget }}
      configuration: ${{ variables.Configuration }}
      powerShellPlatform: ${{ variables.PowerShellPlatform }}