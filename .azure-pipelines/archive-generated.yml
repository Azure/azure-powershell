parameters:
- name: TargetModule
  displayName: 'List of target modules, all modules if not provided'
  type: string
  default: 'all'
- name: ForceRegenerate
  displayName: 'Force regenerate autorest generated modules when pipeline triggered manually'
  type: boolean
  default: false

variables:
  WindowsName: windows
  WindowsAgentPoolName: pool-windows-2019
  WindowsAgentPoolVMImage: ''
  LinuxName: linux
  LinuxAgentPoolName: pool-ubuntu-2004
  LinuxAgentPoolVMImage: ''
  MacOSName: macOS
  MacOSAgentPoolName: 'Azure Pipelines'
  MacOSAgentPoolVMImage: macOS-latest
  TestFramework: net6.0
  TestTarget: Test
  Configuration: Debug
  DebugLocalBuildTasks: true
  BuildTimeoutInMinutes: 120
  AnalysisTimeoutInMinutes: 120
  TestTimeoutInMinutes: 180
  BuildAzPredictor: false
  EnableTestCoverage: true
  TestCoverageLocation: $(Build.SourcesDirectory)/artifacts
  PowerShellPlatform: PowerShell Core
  AZURE_CLIENTS_SHOW_SECRETS_WARNING: true

trigger:
  batch: true
  branches:
    include:
      - future

jobs:
- job: Build
  displayName: Build
  condition: succeeded()
  timeoutInMinutes: ${{ variables.BuildTimeoutInMinutes }}
  pool: pool-windows-2019

  steps:
  - checkout: self
  - template: util/get-github-pat-steps.yml
  - task: PowerShell@2
    name: 'Initialize'
    displayName: 'Initialize Build'
    inputs:
      targetType: inline
      pwsh: true
      script: |
        $filesChangedOutputPath = Join-Path "$(Build.SourcesDirectory)" 'artifacts' 'FilesChanged.txt'
        Write-Host "##vso[task.setvariable variable=FilesChangedOutputPath]$filesChangedOutputPath"
        New-Item -Type File -Path $filesChangedOutputPath -Force

        $forceRegenerate = $false
        if ('true' -eq '${{ parameters.ForceRegenerate }}') {
          $forceRegenerate = $true
        }

        $filesChangedScriptPath = Join-Path "$(Build.SourcesDirectory)" 'tools' 'BuildScripts' 'FilesChangedScript.psm1'
        Import-Module $filesChangedScriptPath
        $filesChanged = Get-OutdatedModuleFromTargetModule -RepoRoot "$(Build.SourcesDirectory)" -TargetModule "${{ parameters.TargetModule }}" -ForceRegenerate $forceRegenerate
        if (($null -eq $filesChanged) -or (0 -eq $filesChanged.Length)) {
          <# 
            Yabo: have to fail build job to terminate this run because: 
              1. this job have build template involved and template does not accept condition
              2. the $  {{ if() }} conditional evaluation is a template expression syntax which was evaluated when compile this YAML, which means cannot use runtime variables in this condition
          #>
          Write-Host "##vso[task.logissue type=warning]no modules found need to be archived, terminate current run."
          exit 1
        }
        #Yabo: cannot use join-path because in ci-config we use slash, backslash cannot match
        $filesChanged | ForEach-Object { 'src/' + $_ } | Out-File $filesChangedOutputPath
  - task: PowerShell@2
    displayName: 'Create branch for generated assets'
    inputs:
      targetType: inline
      pwsh: true
      script: |
        $baseBranchName = "origin/$(Build.SourceBranchName)"
        $tmpBranchName = "archive/$(Build.SourceBranchName)/$(Build.Reason)"
        if ("$(Build.reason)" -in @('IndividualCI', 'BatchedCI')) {
          $tmpBranchName += "/$(Build.SourceVersion)"
        }
        Write-Host "##vso[task.setvariable variable=TmpBranchName]$tmpBranchName"
        Write-Host "##vso[task.setvariable variable=BaseBranchName]$baseBranchName"
        Write-Host "##[section]Switch from $baseBranchName to $tmpBranchName"
        git fetch origin $(Build.SourceBranchName)
        git checkout -b $tmpBranchName $baseBranchName
  - template: util/build-steps.yml
    parameters:
      configuration: ${{ variables.Configuration }}
      testFramework: ${{ variables.TestFramework }}
      powerShellPlatform: ${{ variables.PowerShellPlatform }}
      filesChangedOutputPath: $(FilesChangedOutputPath)
      TargetModule: ${{ parameters.TargetModule }}
      ForceRegenerate: ${{ parameters.ForceRegenerate }}
  - task: PowerShell@2
    displayName: 'push archive branch after build'
    inputs:
      targetType: inline
      pwsh: true
      script: |
        if ("$(Build.reason)" -in @('IndividualCI', 'BatchedCI')) {
          $prTitle = "[skip ci] Archive $(Build.SourceVersion)"
        } else {
          #TODO: replace $(Build.reason) with account when manual and datetime when schedule
          $prTitle = "[skip ci] Archive $(Build.reason)"
        }
        $tmpBranchName = "$(TmpBranchName)"
        $baseBranchName = "$(BaseBranchName)"
        $generatedPath = Join-Path "$(Build.SourcesDirectory)" 'generated'
        $diff = ( git status --short --untracked-files $generatedPath)
        if ((-not $diff) -or ($null -eq $diff) -or (0 -eq $diff.Count)) {
          return
        }
        #TODO: add better PR description
        $prDescription = ""
        $prScriptPath = Join-Path "$(Build.SourcesDirectory)" 'tools' 'Github' 'CreatePR.ps1'

        git config user.email "65331932+azure-powershell-bot@users.noreply.github.com";
        git config user.name "azure-powershell-bot";
        git remote set-url origin https://azure-powershell-bot:$(GithubToken)@github.com/Azure/azure-powershell.git;
        git add $generatedPath
        git commit -m $prTitle
        git push origin $tmpBranchName --force
        
        . $prScriptPath -Title $prTitle -HeadBranch $tmpBranchName -BaseBranch "$(Build.SourceBranchName)" -BotAccessToken $(GithubToken) -Description $prDescription

        <#
          this commidId will be useful when we push directly to target branch in the future
          $commitId = (git rev-parse HEAD)
        #>

- job: Analyze
  displayName: Analyze
  dependsOn: Build
  condition: succeeded()
  timeoutInMinutes: ${{ variables.AnalysisTimeoutInMinutes }}
  pool: pool-windows-2019

  steps:
  - template: util/analyze-steps.yml
    parameters:
      configuration: ${{ variables.Configuration }}
      testFramework: ${{ variables.TestFramework }}
      powerShellPlatform: ${{ variables.PowerShellPlatform }}

- job: Test
  displayName: Test
  dependsOn: Build
  condition: succeeded()
  timeoutInMinutes: ${{ variables.TestTimeoutInMinutes }}
  strategy:
    matrix:
      windows:
        OSName: ${{ variables.WindowsName }}
        agentPoolName: ${{ variables.WindowsAgentPoolName }}
        agentPoolVMImage: ${{ variables.WindowsAgentPoolVMImage }}
      linux:
        OSName: ${{ variables.LinuxName }}
        agentPoolName: ${{ variables.LinuxAgentPoolName }}
        agentPoolVMImage: ${{ variables.LinuxAgentPoolVMImage }}
      macOS:
        OSName: ${{ variables.MacOSName }}
        agentPoolName: ${{ variables.MacOSAgentPoolName }}
        agentPoolVMImage: ${{ variables.MacOSAgentPoolVMImage }}
  pool:
    name: $(agentPoolName)
    vmImage: $(agentPoolVMImage)

  steps:
  - template: util/test-steps.yml
    parameters:
      osName: $(OSName)
      testFramework: ${{ variables.TestFramework }}
      testTarget: ${{ variables.TestTarget }}
      configuration: ${{ variables.Configuration }}
      powerShellPlatform: ${{ variables.PowerShellPlatform }}
