<?xml version="1.0" encoding="utf-8"?>
<!--
  Available Targets:

  /t:Clean
    Removes temporary build outputs.

  /t:Build
    Builds assemblies.

  /t:Test
    Runs tests

  /t:Publish
    Creates local nuget packages and MSI

  /p:CodeSign=True
    Code sign binaries, mainly for official release. Default is false.

  /p:CodeSign=True;DelaySign=True
    Test the code sign workflow locally.

  /p:Scope
    'Subfolder under src': An individual cmdlet module
    By default, it builds everything

  /p:SkipHelp=True
    Skips help generation, mainly for local builds to save time.
-->
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <Import Project="$(MSBuildThisFileDirectory)Repo.props" />

  <!-- Define default build properties -->
  <PropertyGroup>
    <LibraryRoot>$(MSBuildThisFileDirectory)</LibraryRoot>
    <LibrarySourceFolder>$(LibraryRoot)src</LibrarySourceFolder>
    <LibraryToolsFolder>$(LibraryRoot)tools</LibraryToolsFolder>
    <LocalFeedFolder>$(LibraryToolsFolder)/LocalFeed</LocalFeedFolder>
    <Configuration Condition=" '$(Configuration)' != 'Release'">Debug</Configuration>
    <CodeSign Condition ="'$(CodeSign)' == ''">false</CodeSign>
    <!--Set this true only if you want to test the code sign workflow locally-->
    <DelaySign Condition ="'$(DelaySign)' == ''">false</DelaySign>
    <SignedOutputRootDir>$(LibraryRoot)signed</SignedOutputRootDir>
    <PackageDirectory>$(LibraryRoot)/artifacts</PackageDirectory>
    <TestOutputDirectory>$(PackageDirectory)/TestResults</TestOutputDirectory>
    <StaticAnalysisOutputDirectory>$(PackageDirectory)/StaticAnalysisResults</StaticAnalysisOutputDirectory>
    <BuildInParallel Condition="'$(BuildInParallel)' == ''">true</BuildInParallel>
    <NuGetPublishingSource Condition=" '$(NuGetPublishingSource)' == '' ">$(LibrarySourceFolder)</NuGetPublishingSource>
    <Scope Condition="$(Scope) == ''" >All</Scope>
    <NetCore Condition="'$(NetCore)' != 'false'">true</NetCore>
    <RunStaticAnalysis Condition="'$(RunStaticAnalysis)' != 'false'">true</RunStaticAnalysis>
    <Scope Condition="$(NetCore) == 'true'">Netcore</Scope>
    <!-- Set Skips -->
    <SkipHelp Condition ="'$(SkipHelp)' != 'true'">false</SkipHelp>
    <NuGetCommand>$(MSBuildProjectDirectory)/tools/NuGet.exe</NuGetCommand>
    <LibraryNugetPackageFolder>$(LibrarySourceFolder)/packages</LibraryNugetPackageFolder>
    <NuGetRestoreConfigFile>$(MSBuildProjectDirectory)/NuGet.Config</NuGetRestoreConfigFile>
    <!-- Partial Commands -->
    <PowerShellCoreCommand Condition=" '$(PowerShellCoreCommand)' == '' ">pwsh</PowerShellCoreCommand>
    <PowerShellCoreCommandPrefix>$(PowerShellCoreCommand) -NonInteractive -NoLogo -NoProfile -Command</PowerShellCoreCommandPrefix>
    <!-- CI build related -->
    <CIToolsPath>$(OnPremiseBuildTasks)</CIToolsPath>
    <OnPremiseBuild Condition="Exists($(OnPremiseBuildTasks))">true</OnPremiseBuild>
    <OnPremiseBuild Condition="!Exists($(OnPremiseBuildTasks))">false</OnPremiseBuild>
    <!-- CISignRepo is an environment variable that points to ci-signing repo clone -->
    <CISignRepoPath>$(CISignRepo)</CISignRepoPath>
  </PropertyGroup>

  <!-- Tasks -->
  <UsingTask TaskName="SetEnvVar" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)/Microsoft.Build.Tasks.Core.dll" >
    <ParameterGroup>
      <EnvName ParameterType="System.String" Required="true" />
      <EnvValue ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[System.Environment.SetEnvironmentVariable(EnvName, EnvValue);]]>
      </Code>
    </Task>
  </UsingTask>
  <UsingTask Condition="$(OnPremiseBuild)" TaskName="CorporateValidation" AssemblyFile="$(CIToolsPath)/Microsoft.WindowsAzure.Tools.Build.Tasks.OnPremise.dll" />
  <Import Condition="$(OnPremiseBuild)" Project="$(CIToolsPath)/Microsoft.WindowsAzure.Build.OnPremise.msbuild" />
  <UsingTask TaskName="ESRPSignTask" AssemblyFile="$(CISignRepoPath)\tools\sdkbuildtools\tasks\MS.Az.Sdk.OnPremise.Build.Tasks.dll" />

  <!-- Clean the build in all configurations -->
  <Target Name="Clean">
    <Message Importance="high" Text="Cleaning Cmdlets..." />

    <!-- Clean out the NuGet cache -->
    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;Remove-Item -Path (Join-Path ($env:USERPROFILE) .nuget packages) -Recurse -Force -Confirm:$false -ErrorAction Ignore&quot;" IgnoreExitCode="true" />

    <!-- Remove Package, Publish, bin, obj, and TestResults directories -->
    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;Remove-Item -Path $(PackageDirectory) -Recurse -Force -Confirm:$false -ErrorAction Ignore&quot;" IgnoreExitCode="true" />
    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;Get-ChildItem -Path $(MSBuildThisFileDirectory) -Recurse -Include 'bin','obj','TestResults' | Remove-Item -Recurse -Force -Confirm:$false -ErrorAction Ignore&quot;" IgnoreExitCode="true" />
  </Target>

  <Target Name="FilterBuild">
    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;. $(LibraryToolsFolder)/CreateFilterMappings.ps1&quot;" />

    <!-- Get all of the files changed in the given pull request -->
    <FilesChangedTask RepositoryOwner="Azure" RepositoryName="azure-powershell" PullRequestNumber="$(PullRequestNumber)">
      <Output TaskParameter="FilesChanged" ItemName="FilesChanged" />
    </FilesChangedTask>

    <!-- Get the list of modules changed -->
    <FilterTask FilesChanged="@(FilesChanged)" MapFilePath="./ModuleMappings.json">
      <Output TaskParameter="Output" ItemName="ModulesChanged" />
    </FilterTask>
    <Message Text="Filtering help generation and StaticAnalysis by the following modules:" />
    <Message Text="%(ModulesChanged.Identity)" />
    <Message Text="Total: @(ModulesChanged->Count())" />
    <Message Text="" />

    <!-- Get the list of solutions to build -->
    <FilterTask FilesChanged="@(FilesChanged)" MapFilePath="./SolutionMappings.json">
      <Output TaskParameter="Output" ItemName="CmdletSolutionsToBuild" />
    </FilterTask>
    <Message Text="Filtering solutions to build by the following:" />
    <Message Text="%(CmdletSolutionsToBuild.Identity)" />
    <Message Text="Total: @(CmdletSolutionsToBuild->Count())" />
    <Message Text="" />

    <!--Get the list of tests to be run based on files changed from a specified PullRequestNumber. Mapping between paths and test DLLs is used to produce the list.-->
    <FilterTask FilesChanged="@(FilesChanged)" MapFilePath="./TestMappings.json">
      <Output TaskParameter="Output" ItemName="XUnitTests" />
    </FilterTask>
    <Message Text="Using these test assemblies:" />
    <Message Text="%(XUnitTests.Identity)" />
    <Message Text="Total: @(XunitTests->Count())" />
    <Message Text="" />
  </Target>

  <!-- Build all flavors of the Cmdlets -->
  <!-- TODO: Reimplement the FilterBuild and update RepoTasks to NetStandard -->
  <Target Name="Build">
    <Message Importance="high" Text="Building Cmdlets..." />

    <MakeDir Directories="$(PackageDirectory)" />

    <!-- Copy appropriate targets -->
    <Copy SourceFiles="$(RepoBuild)after.Azure.PowerShell.sln.targets" DestinationFolder="$(RepoArtifacts)" />

    <!-- Build and create package content -->
    <Exec Command="dotnet --version" />
    <Exec Command="dotnet new sln -n Azure.PowerShell -o $(RepoArtifacts) --force" />
    <ItemGroup>
      <CsprojFiles Include="$(LibraryRoot)src/**/*.csproj" Exclude="$(LibraryRoot)src/**/*.Test.csproj" />
    </ItemGroup>
    <ItemGroup Condition="'$(CodeSign)' == 'false'">
      <CsprojFiles Include="$(LibraryRoot)src/**/*.Test.csproj" />
    </ItemGroup>
    <!-- https://github.com/dotnet/cli/issues/6295#issuecomment-346973582 -->
    <Exec Command="dotnet sln $(RepoArtifacts)Azure.PowerShell.sln add &quot;%(CsprojFiles.FullPath)&quot;" />
    <Exec Command="dotnet sln $(RepoArtifacts)Azure.PowerShell.sln add &quot;$(RepoTools)Tools.Common/Tools.Common.Netcore.csproj&quot; &quot;$(RepoTools)StaticAnalysis/StaticAnalysis.Netcore.csproj&quot;" Condition="'$(CodeSign)' == 'false'" />
    <PropertyGroup>
      <BuildAction Condition="'$(CodeSign)' == 'false'">build</BuildAction>
      <BuildAction Condition="'$(CodeSign)' == 'true'">publish</BuildAction>
    </PropertyGroup>
    <Exec Command="dotnet $(BuildAction) $(RepoArtifacts)Azure.PowerShell.sln -c $(Configuration)" />

    <!-- Publish static analysis for use cross-plat -->
    <Exec Command="dotnet publish $(RepoTools)StaticAnalysis/StaticAnalysis.Netcore.csproj --no-build -c $(Configuration) -f netcoreapp2.1 -o $(RepoArtifacts)StaticAnalysis" Condition="'$(CodeSign)' == 'false'" />

    <!-- Delete powershell runtime files -->
    <ItemGroup>
      <RedundantDlls Include="$(PackageDirectory)/$(Configuration)/**/Microsoft.Powershell.*.dll" />
      <RedundantDlls Include="$(PackageDirectory)/$(Configuration)/**/System*.dll" Exclude="
$(PackageDirectory)/$(Configuration)/**/System.Security.Cryptography.ProtectedData.dll;
$(PackageDirectory)/$(Configuration)/**/System.Configuration.ConfigurationManager.dll;
$(PackageDirectory)/$(Configuration)/**/System.Runtime.CompilerServices.Unsafe.dll;
$(PackageDirectory)/$(Configuration)/**/System.IO.FileSystem.AccessControl.dll;
$(PackageDirectory)/$(Configuration)/**/System.Buffers.dll;
$(PackageDirectory)/$(Configuration)/**/System.Text.Encodings.Web.dll" />
      <RedundantDlls Include="$(PackageDirectory)/$(Configuration)/**/Microsoft.VisualBasic.dll" />
      <RedundantDlls Include="$(PackageDirectory)/$(Configuration)/**/Microsoft.CSharp.dll" />
      <RedundantDlls Include="$(PackageDirectory)/$(Configuration)/**/Microsoft.CodeAnalysis.dll" />
      <RedundantDlls Include="$(PackageDirectory)/$(Configuration)/**/Microsoft.CodeAnalysis.CSharp.dll" />
    </ItemGroup>
    <Delete Files="@(RedundantDlls->'%(FullPath)')" />

    <!-- Update module manifests -->
    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;. $(LibraryToolsFolder)/UpdateModules.ps1 -BuildConfig $(Configuration) -Scope $(Scope)&quot;" />
    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;. $(LibraryToolsFolder)/CleanupBuild.ps1 -BuildConfig $(Configuration)&quot;" Condition="'$(CodeSign)' == 'true'" />

    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;. $(LibraryToolsFolder)/NewOutputTypeIndex.ps1 -OutputFile $(PackageDirectory)/outputtypes.json -BuildConfig $(Configuration)&quot;" Condition="'$(CodeSign)' == 'true'" />
    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;. $(LibraryToolsFolder)/NewHelpIndex.ps1 -OutputFile $(PackageDirectory)/index.json -BuildConfig $(Configuration)&quot;" Condition="'$(CodeSign)' == 'true'" />
  </Target>

  <Target Name="OnPremChecks" Condition="'$(OnPremiseBuild)'">
    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;$(RepoTools)CheckBinScope.ps1 -BuildConfig $(Configuration) -CIToolsPath $(CIToolsPath)&quot;" />
    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;$(RepoTools)CheckPoliCheck.ps1 -BuildConfig $(Configuration) -CIToolsPath $(CIToolsPath)&quot;" />
    <OnError ExecuteTargets="OnPremChecksErrorMessage" />
  </Target>

  <Target Name="OnPremChecksErrorMessage">
    <Error Text="BinScope or PoliCheck failed. Please check the files in artifacts/BinScope, or Severity 1 issues in artifacts/PoliCheck-Scan.html" />
  </Target>

  <Target Name="GenerateHelp" Condition="'$(SkipHelp)' == 'false'">
    <Message Importance="high" Text="Running help generation..." />
    <MakeDir Directories="$(StaticAnalysisOutputDirectory)" />

    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;Set-Variable -Name ProgressPreference -Value 'SilentlyContinue';. $(LibraryToolsFolder)/GenerateHelp.ps1 -ValidateMarkdownHelp -GenerateMamlHelp -BuildConfig $(Configuration)&quot;" />
    <Exec Command="dotnet $(RepoArtifacts)StaticAnalysis/StaticAnalysis.Netcore.dll -p $(RepoArtifacts)$(Configuration) -r $(StaticAnalysisOutputDirectory) -h -u -m @(ModulesChanged)" Condition="'$(RunStaticAnalysis)' == 'true'" />
  </Target>

  <!-- Everything except Publish -->
  <Target Name="Full" DependsOnTargets="Clean;Build;OnPremChecks;GenerateHelp;StaticAnalysis;Test" />

  <Target Name="StaticAnalysis" Condition="'$(RunStaticAnalysis)' == 'true'">
    <Message Importance="high" Text="Running static analysis..." />
    <MakeDir Directories="$(StaticAnalysisOutputDirectory)" />

    <Exec Command="dotnet $(RepoArtifacts)StaticAnalysis/StaticAnalysis.Netcore.dll -p $(RepoArtifacts)$(Configuration) -r $(StaticAnalysisOutputDirectory) -s -u -m @(ModulesChanged)" />
    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;. $(LibraryToolsFolder)/CheckAssemblies.ps1 -BuildConfig $(Configuration) &quot;" />
    <OnError ExecuteTargets="StaticAnalysisErrorMessage" />
  </Target>

  <Target Name="StaticAnalysisErrorMessage">
    <Error Text="StaticAnalysis has failed. Please follow the instructions on this doc: https://github.com/Azure/azure-powershell/blob/master/documentation/Debugging-StaticAnalysis-Errors.md" />
  </Target>

  <Target Name="ChangeLogCheck">
    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;. $(LibraryToolsFolder)/CheckChangeLog.ps1 -FilesChanged '@(FilesChanged)'&quot;" Condition=" '$(Scope)' == 'All' or '$(Scope)' == 'Latest' " />
    <OnError ExecuteTargets="ChangeLogErrorMessage" />
  </Target>

  <Target Name="ChangeLogErrorMessage">
    <Error Text="Modified files were found with no update to their change log. Please add a snippet to the affected modules' change log." />
  </Target>

  <Target Name="Publish" Condition="'$(CodeSign)' == 'true'">
    <Message Importance="high" Text="Publishing Cmdlets using $(Scope) scope" />
    <Error Condition="'$(NuGetKey)' == ''" Text="You must provide the NuGetKey parameter to the build: /p:NuGetKey=YOUR_PUBLISHING_KEY" />
    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;. $(LibraryToolsFolder)/PublishModules.ps1 -IsNetCore:$$(NetCore) -BuildConfig $(Configuration) -Scope $(Scope) -ApiKey $(NuGetKey) -RepositoryLocation \&quot;$(NuGetPublishingSource)\&quot;&quot; -NugetExe $(NuGetCommand)" />
  </Target>

  <Target Name="BuildInstaller" AfterTargets="Publish" Condition="'$(Scope)' == 'All' or '$(Scope)' == 'Latest' or '$(Scope)' == 'Netcore'">
    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;. Register-PSRepository -Name MSIcreationrepository -SourceLocation $(PackageDirectory) -InstallationPolicy Trusted &quot;" />
    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;. $(LibraryRoot)/setup/generate.ps1 -repository MSIcreationrepository &quot;" />
    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;. Unregister-PSRepository -Name MSIcreationrepository &quot;" />
  </Target>

  <Target Name="Test">
    <Message Importance="high" Text="Running check in tests..." />
    <MakeDir Directories="$(TestOutputDirectory)" ContinueOnError="false" />

    <!-- https://github.com/Microsoft/msbuild/issues/3157#issuecomment-378002971 -->
    <!-- https://github.com/xunit/xunit/issues/1154#issuecomment-405366373 -->
    <Exec Command="dotnet test $(RepoArtifacts)Azure.PowerShell.sln --filter &quot;AcceptanceType=CheckIn%26RunType!=DesktopOnly&quot; --configuration $(Configuration) --framework netcoreapp2.0 --logger trx" />

    <ItemGroup>
      <TestResults Include="$(LibraryRoot)src/**/TestResults/*.trx" />
    </ItemGroup>
    <Copy SourceFiles="@(TestResults)" DestinationFolder="$(TestOutputDirectory)" />

    <OnError ExecuteTargets="TestFailureErrorMessage" />
  </Target>

  <Target Name="TestFailureErrorMessage">
    <Error Text="Test failures occured, check the files in artifacts/TestResults" />
  </Target>

  <Target Name="CodeSignBinaries" AfterTargets="Build" Condition="'$(CodeSign)' == 'true'">
    <Message Text="====> Executing CodeSignBinaries Target..." Importance="high" />
    <Message Text="----> Dlls signing section" Importance="high" />

    <!-- Azure -->
    <ItemGroup Condition="'$(Scope)' == 'All' or '$(Scope)' == 'Latest' or '$(Scope)' == 'Netcore'">
      <DelaySignedAssembliesToSign Include="$(PackageDirectory)\$(Configuration)\**\Microsoft*Azure*PowerShell*Cmdlets*.dll" Exclude="$(PackageDirectory)\$(Configuration)\**\Microsoft*Azure*PowerShell*Cmdlets*.Test.dll" />
    </ItemGroup>

    <Message Importance="high" Text="$(PackageDirectory)\$(Configuration) does not contains any files to sign. Code sign will skip." Condition="'@(DelaySignedAssembliesToSign)' == ''" />
    <ESRPSignTask CopyBackSignedFilesToOriginalLocation="true" UnsignedFileList="@(DelaySignedAssembliesToSign)" SignLogDirPath="$(LibraryRoot)dlls-signing.log"  Condition="!$(DelaySign) and '@(DelaySignedAssembliesToSign)' != ''" />

    <!-- Copying shortcut to be signed -->
    <Copy SourceFiles="$(LibraryRoot)tools\Az\Az.psm1" DestinationFolder="$(PackageDirectory)\$(Configuration)" Condition="'$(Scope)' == 'Netcore'" />

    <Message Text="----> Scripts signing section" Importance="high" />
    <!-- Azure -->
    <ItemGroup Condition="'$(Scope)' == 'All' or '$(Scope)' == 'Latest' or '$(Scope)' == 'Netcore'">
      <ScriptsToSign Include="$(PackageDirectory)\$(Configuration)\**\*.ps1" />
      <ScriptsToSign Include="$(PackageDirectory)\$(Configuration)\**\*.psm1" />
      <ScriptsToSign Include="$(PackageDirectory)\$(Configuration)\**\*.ps1xml" />
      <ScriptsToSign Include="$(PackageDirectory)\$(Configuration)\**\*.js" />
    </ItemGroup>

    <ESRPSignTask CopyBackSignedFilesToOriginalLocation="true" UnsignedFileList="@(ScriptsToSign)" SignLogDirPath="$(LibraryRoot)scripts-signing.log"  Condition="!$(DelaySign) and '@(ScriptsToSign)' != ''" />

    <!-- RemoveCodeSignArtifacts.ps1 -->
    <Message Text="----> Remove artifacts section" Importance="high" />
    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;Get-ChildItem -Path $(PackageDirectory) -Recurse -Include 'Signed','Unsigned' | Remove-Item -Recurse -Force -Confirm:$false -ErrorAction Ignore&quot;" IgnoreExitCode="true" />
    
    <!-- CheckSignature.ps1 -->
    <Message Text="----> CheckSignature section" Importance="high" />
    <Exec Command="$(PowerShellCoreCommandPrefix) &quot;. $(LibraryToolsFolder)\CheckSignature.ps1 -CustomPath $(PackageDirectory)\$(Configuration)&quot;" Condition="'$(Scope)' != 'Stack'" />

    <!-- Copy files back after signing -->
    <Copy SourceFiles="$(PackageDirectory)\$(Configuration)\Az.psm1" DestinationFolder="$(LibraryRoot)tools\Az" Condition="'$(Scope)' == 'Netcore'" />
  </Target>

  <Target Name="CodeSignInstaller" AfterTargets="BuildInstaller" Condition="'$(CodeSign)' == 'true'">
    <Message Text="----> CodeSignInstaller section" Importance="high" />

    <GetFrameworkSdkPath>
      <Output TaskParameter="Path" PropertyName="WindowsSdkPath" />
    </GetFrameworkSdkPath>

    <ItemGroup>
      <InstallersToSign Include="$(LibraryRoot)\setup\*.msi" />
    </ItemGroup>

    <Message Importance="high" Text="$(LibraryRoot)\setup does not contain any installers to sign. Code sign will skip." Condition="'@(InstallersToSign)' == ''" />

    <ESRPSignTask SignedFilesRootDirPath="$(SignedOutputRootDir)" UnsignedFileList="@(InstallersToSign)" SignLogDirPath="$(LibraryRoot)\msi-signing.log"  Condition="!$(DelaySign) and '@(InstallersToSign)' != ''" />

    <!--If we are testing locally then we copy the binaries and do not submit to the code sign server-->
    <Copy SourceFiles="@(InstallersToSign)" DestinationFolder="signed" Condition="$(DelaySign)" />
    <SetEnvVar EnvName="SignedMsiDir" EnvValue="$(SignedOutputRootDir)" />
  </Target>

</Project>
