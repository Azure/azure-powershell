<#
    .SYNOPSIS
        Tools for Measure-MarkdownOrScript.ps1.
    .NOTES
        File Name:  utils.ps1
        Class:  Scale
                Missing
                DeletePromptAndSeparateOutput
                AnalysisOutput
        Functions:  Get-ExamplesDetailsFromMd
                    Get-NonExceptionRecord
                    Get-RecordsNotInAllowList
                    Measure-SectionMissingAndOutputScript
                    Merge-Contents
                    Merge-Scripts
                    Get-ScriptAnalyzerResult
                    Set-AnalysisOutput
                    Set-ExampleProperties
#>

$SYNOPSIS_HEADING = "## SYNOPSIS"
$SYNTAX_HEADING = "## SYNTAX"
$DESCRIPTION_HEADING = "## DESCRIPTION"
$EXAMPLES_HEADING = "## EXAMPLES"
$PARAMETERS_HEADING = "## PARAMETERS"

class AnalysisOutput{
    [string]$Module
    [string]$Cmdlet
    [int]$Example
    [string]$Line
    [string]$RuleName
    [int]$ProblemID
    [int]$Severity
    [string]$Description
    [string]$Extent
    [String]$Remediation
} 

<#
    .SYNOPSIS
    Get examples details from ".md".
    .DESCRIPTION
    Split title, code, output, description line by line according to block identifiers.
#>
function Get-ExamplesDetailsFromMd {
    param (
        [string]$Module,
        [string]$Cmdlet,
        [string]$MarkdownPath
    )

    $errors = @()
    $missingSeverity = 1
    $Extent = $MarkdownPath
    $blockTypeList = ("yaml","json")
    $fileContent = Get-Content $MarkdownPath
    $indexOfExamples = $fileContent.IndexOf($EXAMPLES_HEADING)
    $indexOfParameters = $fileContent.IndexOf($PARAMETERS_HEADING)
    if($indexOfExamples -eq -1){
        $RuleName = "MissingExamplesHeading"
        $ProblemID = 5060
        $Description = "'## EXAMPLES' is missing."
        $Remediation = "Mark '## EXAMPLES' for your reference docs."
        $errors += Set-AnalysisOutput $Module $Cmdlet 0 0 $RuleName $ProblemID $missingSeverity $Description $Extent $Remediation
        return
    }
    if($indexOfParameters -eq -1){
        $RuleName = "MissingParametersHeading"
        $ProblemID = 5061
        $Description = "'## PARAMETERS' is missing."
        $Remediation = "Mark '## PARAMETERS' for your reference docs."
        $errors += Set-AnalysisOutput $Module $Cmdlet 0 0 $RuleName $ProblemID $missingSeverity $Description $Extent $Remediation
        return
    }

    $exampleNumber = 0
    $examplesProperties = @()
    $examplesContent = $fileContent[$indexOfExamples..$($indexOfParameters - 1)]
    $firstExample = $true
    $needRecord = $false
    foreach ($exampleLine in $examplesContent) {
        if($exampleLine.StartsWith("###")){
            if(!$firstExample -and $needRecord){
                if(!$codeBlockComplete -or !$outputBlockComplete -or !$otherTypeBlockComplete){
                    $RuleName = "BlockIdentifiersNotMatched"
                    $ProblemID = 5064
                    $Description = "The start and end identifiers of the code block do not match."
                    $Remediation = "Please check whether the start or end identifier (triple backticks) of the code block is missing."
                    $errors += Set-AnalysisOutput $Module $Cmdlet $exampleNumber 0 $RuleName $ProblemID $missingSeverity $Description $Extent $Remediation
                    if(!$codeBlockComplete){
                        $exampleCodes = "#BlockIdentifiersNotMatched"
                    }
                }
                $examplesProperties += Set-ExampleProperties $exampleNumber $exampleTitle $exampleCodes $exampleOutputs $hasOutputBlock $exampleDescriptions
            }
            # Initialize states
            $exampleNumber++
            $exampleTitle = ($exampleLine -split "###")[1]
            $exampleCodes = @()
            $exampleOutputs = @()
            $exampleDescriptions = @()
            $needRecord = $true
            $firstCodeBlock = $true
            $codeBlockComplete = $true
            $outputBlockComplete = $true
            $otherTypeBlockComplete = $true
            $hasOutputBlock = $false
            $firstExample = $false
        }
        elseif($exampleLine -eq "<!-- Aladdin Generated Example -->" -or $exampleLine -match "<!-- Skip.*-->"){
            # Skip the autogenerated example and the example whose output can not be splitted from code
            $needRecord = $false
            continue
        }
        elseif($needRecord){
            if($exampleLine.StartsWith("``````powershell","CurrentCultureIgnoreCase")){
                # Find the head of code block with tag: powershell
                $codeBlockComplete = $false
            }
            elseif($exampleLine.StartsWith("``````output","CurrentCultureIgnoreCase")){
                # Find the head of output block with tag: output
                $outputBlockComplete = $false
                $hasOutputBlock = $true
            }
            elseif($exampleLine -match "^``````\w+"){
                $blockType = ($exampleLine -split "``````")[1]
                if($blockType -notin $blockTypeList){
                    $RuleName = "BlockTypeUnsupported"
                    $ProblemID = 5062
                    $Description = "The language identifier $blockType is not supported."
                    $Remediation = "Please check the spelling or contact Azure PowerShell team."
                    $errors += Set-AnalysisOutput $Module $Cmdlet $exampleNumber 0 $RuleName $ProblemID $missingSeverity $Description $Extent $Remediation
                }
                $otherTypeBlockComplete = $false
            }
            elseif($exampleLine -match "\A\s*``````\s*\Z"){
                if($codeBlockComplete -and $outputBlockComplete -and $otherTypeBlockComplete){
                    if($firstCodeBlock){
                        # Find the first head of code block without tag: powershell
                        $codeBlockComplete = $false
                        $firstCodeBlock = $false
                    }
                    else{
                        $RuleName = "UnclearBlockType"
                        $ProblemID = 5063
                        $Description = "The code blocks are missing language identifiers."
                        $Remediation = "The type of the code block needs to be clearly indicated with 'powershell' or 'output'."
                        $errors += Set-AnalysisOutput $Module $Cmdlet $exampleNumber 0 $RuleName $ProblemID $missingSeverity $Description $Extent $Remediation
                        $otherTypeBlockComplete = $false
                    }
                }
                elseif(!$codeBlockComplete -and $outputBlockComplete -and $otherTypeBlockComplete){
                    # Find the tail of code block
                    $codeBlockComplete = $true
                }
                elseif($codeBlockComplete -and !$outputBlockComplete -and $otherTypeBlockComplete){
                    # Find the tail of output block
                    $outputBlockComplete = $true
                }
                elseif($codeBlockComplete -and $outputBlockComplete -and !$otherTypeBlockComplete){
                    # Find the tail of other-type block
                    $otherTypeBlockComplete = $true
                }
            }
            elseif(($codeBlockComplete + $outputBlockComplete + $otherTypeBlockComplete)-le 1){
                # Report BlockPromptsNotMatched later
            }
            elseif(!$codeBlockComplete){
                # Find codes in code block
                $exampleCodes += $exampleLine
            }
            elseif(!$outputBlockComplete){
                # Find outputs in output block
                $exampleOutputs += $exampleLine
            }
            elseif(!$otherTypeBlockComplete){
                # Find outputs in other-type block, skip
            }
            else{
                # Find descriptions
                if($exampleLine.Trim() -ne ""){
                   $exampleDescriptions += $exampleLine 
                }
            }
        }
    }
    if($needRecord){
        if(!$codeBlockComplete -or !$outputBlockComplete -or !$otherTypeBlockComplete){
            $RuleName = "BlockIdentifiersNotMatched"
            $ProblemID = 5064
            $Description = "The start and end identifiers of the code block do not match."
            $Remediation = "Please check whether the start or end identifier (triple backticks) of the code block is missing."
            $errors += Set-AnalysisOutput $Module $Cmdlet $exampleNumber 0 $RuleName $ProblemID $missingSeverity $Description $Extent $Remediation
            if(!$codeBlockComplete){
                $exampleCodes = "#BlockIdentifiersNotMatched"
            }
        }
        $examplesProperties += Set-ExampleProperties $exampleNumber $exampleTitle $exampleCodes $exampleOutputs $hasOutputBlock $exampleDescriptions
    }
    return ($examplesProperties, $errors)
}

<#
    .SYNOPSIS
    Set example properties.
#>
function Set-ExampleProperties{
    param(
        [int] $exampleNumber,
        [string] $exampleTitle,
        [string[]] $exampleCodes,
        [string[]] $exampleOutputs,
        [Boolean] $hasOutputBlock,
        [string[]] $exampleDescriptions
    )
    $examplesProperty = [PSCustomObject]@{
        Num = $exampleNumber
        Title = $exampleTitle
        Codes = $exampleCodes
        Outputs = $exampleOutputs
        OutputBlock = $hasOutputBlock
        Description = $exampleDescriptions

    }
    return $examplesProperty
}

<#
    .SYNOPSIS
    Check whether the docs are complete, integrate examples to one script.
#>
function Measure-SectionMissingAndOutputScript {
    param (
        [string]$Module,
        [string]$Cmdlet,
        [string]$MarkdownPath,
        [string]$TempScriptPath,
        [int]$TotalLine
    )
    $missingSeverity = 1

    $fileContent = Get-Content $MarkdownPath -Raw

    $indexOfSynopsis = $fileContent.IndexOf($SYNOPSIS_HEADING)
    $indexOfSyntax = $fileContent.IndexOf($SYNTAX_HEADING)
    $indexOfDescription = $fileContent.IndexOf($DESCRIPTION_HEADING)
    $indexOfExamples = $fileContent.IndexOf($EXAMPLES_HEADING)

    $missingSynopsis = 0
    $missingDescription = 0
    $exampleNum = 0
    $exampleLine = 0
    $Extent = $MarkdownPath

    $codeMap = @()

    ($examplesDetails, $errors) = Get-ExamplesDetailsFromMd $Module $Cmdlet $MarkdownPath

    # If Synopsis section exists
    if ($indexOfSynopsis -ne -1) {
        $synopsisContent = $fileContent.Substring($indexOfSynopsis + $SYNOPSIS_HEADING.Length, $indexOfSyntax - ($indexOfSynopsis + $SYNOPSIS_HEADING.Length))
        if ($synopsisContent.Trim().Length -eq 0) {
            $missingSynopsis = 1
        }
        else {
            $missingSynopsis = ($synopsisContent | Select-String -Pattern "{{[A-Za-z ]*}}").Count
        }
    }
    else {
        $missingSynopsis = 1
    }
    if($missingSynopsis -ne 0){
        $Description = "Synopsis is missing."
        $RuleName = "MissingSynopsis"
        $ProblemID = 5040
        $Remediation = "Add Synopsis. Remove any placeholders."
        $errors += Set-AnalysisOutput $Module $Cmdlet $exampleNum $exampleLine $RuleName $ProblemID $missingSeverity $Description $Extent $Remediation
    }

    # If Description section exists
    if ($indexOfDescription -ne -1) {
        $descriptionContent = $fileContent.Substring($indexOfDescription + $DESCRIPTION_HEADING.Length, $indexOfExamples - ($indexOfDescription + $DESCRIPTION_HEADING.Length))
        if ($descriptionContent.Trim() -eq "") {
            $missingDescription = 1
        }
        else {
            $missingDescription = ($descriptionContent | Select-String -Pattern "{{[A-Za-z ]*}}").Count
        }
    }
    else {
        $missingDescription = 1
    }
    if($missingDescription -ne 0){
        $Description = "Description is missing."
        $RuleName = "MissingDescription"
        $ProblemID = 5041
        $Remediation = "Add Description. Remove any placeholders."
        $errors += Set-AnalysisOutput $Module $Cmdlet $exampleNum $exampleLine $RuleName $ProblemID $missingSeverity $Description $Extent $Remediation
    }

    # If no examples
    if ($examplesDetails.Count -eq 0) {
        if($fileContent -notmatch "<!-- Aladdin Generated Example -->" -and $fileContent -notmatch "<!-- Skip.*-->"){
            $Description = "Example is missing."
            $RuleName = "MissingExample"
            $ProblemID = 5042
            $Remediation = "Add Example. Remove any placeholders."
            $errors += Set-AnalysisOutput $Module $Cmdlet $exampleNum $exampleLine $RuleName $ProblemID $missingSeverity $Description $Extent $Remediation
        }
    }
    else {
        foreach ($exampleDetails in $examplesDetails) {
            $exampleNumber = $exampleDetails.Num
            $exampleCodes = $exampleDetails.Codes
            $missingExampleTitle = ($exampleDetails.Title | Where-Object{$_ -match "{{[A-Za-z ]*}}"}).Count
            $missingExampleCode = ($exampleDetails.Codes | Where-Object{$_ -match "{{[A-Za-z ]*}}"}).Count
            $missingExampleOutput = ($exampleDetails.Outputs | Where-Object{$_ -match "{{[A-Za-z ]*}}"}).Count
            $missingExampleDescription = ($exampleDetails.Description | Where-Object{$_ -match "{{[A-Za-z ]*}}"}).Count
            $needDeleting = ($exampleDetails.Codes | Where-Object{$_ -cmatch "^([A-Za-z \t\\:>])*(PS|[A-Za-z]:)(\w|[\\/\[\].\- ])*(>|&gt;)+( PS)*[ \t]*"}).Count
            switch ($exampleDetails) {
                {$exampleDetails.Title -eq "" -or $missingExampleTitle -ne 0} {
                    $Description = "Title of the example is missing."
                    $RuleName = "MissingExampleTitle"
                    $ProblemID = 5043
                    $Remediation = "Add title for the example. Remove any placeholders."
                    $errors += Set-AnalysisOutput $Module $Cmdlet $exampleDetails.Num $exampleLine $RuleName $ProblemID $missingSeverity $Description $Extent $Remediation
                }
                {$exampleDetails.Codes.Count -eq 0 -or $exampleDetails.Codes.Trim().Length -eq 0 -or $missingExampleCode -ne 0} {
                    $missingExampleCode = 1
                    $Description = "Code of the example is missing."
                    $RuleName = "MissingExampleCode"
                    $ProblemID = 5044
                    $Remediation = "Add code for the example. Remove any placeholders."
                    $errors += Set-AnalysisOutput $Module $Cmdlet $exampleDetails.Num $exampleLine $RuleName $ProblemID $missingSeverity $Description $Extent $Remediation
                }
                {($exampleDetails.OutputBlock -and ($exampleDetails.Outputs.Count -eq 0 -or $exampleDetails.Outputs.Trim().Length -eq 0)) -or $missingExampleOutput -ne 0} {
                    $Description = "Output of the example is missing."
                    $RuleName = "MissingExampleOutput"
                    $ProblemID = 5045
                    $Remediation = "Add output for the example. Remove any placeholders."
                    $errors += Set-AnalysisOutput $Module $Cmdlet $exampleDetails.Num $exampleLine $RuleName $ProblemID $missingSeverity $Description $Extent $Remediation
                }
                {$exampleDetails.Description -eq "" -or $missingExampleDescription -ne 0} {
                    $Description = "Description of the example is missing."
                    $RuleName = "MissingExampleDescription"
                    $ProblemID = 5046
                    $Remediation = "Add description for the example. Remove any placeholders."
                    $errors += Set-AnalysisOutput $Module $Cmdlet $exampleDetails.Num $exampleLine $RuleName $ProblemID $missingSeverity $Description $Extent $Remediation
                }
                {$needDeleting -ne 0}{
                    $Description = "The prompt of example need to be deleted."
                    $RuleName = "NeedDeleting"
                    $ProblemID = 5050
                    $Remediation = "Delete the prompt of example."
                    $errors += Set-AnalysisOutput $Module $Cmdlet $exampleDetails.Num $exampleLine $RuleName $ProblemID $missingSeverity $Description $Extent $Remediation
                    $exampleCodes = $exampleCodes | ForEach-Object{ $_ -replace "^([A-Za-z \t\\:>])*(PS|[A-Za-z]:)(\w|[\\/\[\].\- ])*(>|&gt;)+( PS)*[ \t]*"}
                }
            }

            # Output example codes to "TempScript.ps1"
            if ($missingExampleCode -eq 0) {
                if($line -ne 0){
                    ($tempCodeMap, $TotalLine) = Merge-Contents -Content $exampleCodes -Module $Module -Cmdlet $Cmdlet -Example $exampleNumber -TotalLine $TotalLine -TempScriptPath $TempScriptPath
                    $codeMap += $tempCodeMap
                }
            }
        }
    }
    # Except records in allow list
    $errors = Get-RecordsNotInAllowList $errors
    # Except the suppressed records
    $errors = Get-NonExceptionRecord $errors

    return @{
        Errors = $errors
        CodeMap = $codeMap
        TotalLine = $TotalLine
    }
}

<#
    .SYNOPSIS
    Merge the example codes or scripts into one PowerShell script and generate the code map. 
#>
function Merge-Contents {
    param(
        [string[]]$Contents,
        [string]$Module,
        [string]$Cmdlet,
        [int]$Example,
        [int]$TotalLine,
        [string]$TempScriptPath
    )
    $codeMap =@()
    $line = $Contents.Count
    $functionHead = "function $Module"
    if($null -ne $Cmdlet){
        $functionHead += "-$Cmdlet"
    }
    if($null -ne $exampleNumber){
        $functionHead += "-$exampleNumber"
    }
    $functionHead += "{"
    Add-Content -Path (Get-Item $TempScriptPath).FullName -Value $functionHead
    Add-Content -Path (Get-Item $TempScriptPath).FullName -Value $Contents
    Add-Content -Path (Get-Item $TempScriptPath).FullName -Value "}"
    for($i = 0; $i -le $line + 1; $i++){
        $codeMap += @{
            TotalLine = $TotalLine + $i
            Module = $Module
            Cmdlet = $Cmdlet
            Example = $Example
            Line = $i
        }
    }
    $TotalLine = $TotalLine + $line + 2
    return ($codeMap, $TotalLine)
}

<#
    .SYNOPSIS
    Merge PowerShell scripts into one and generate the code map. 
#>
function Merge-Scripts {
    param(
        [string]$ScriptPaths,
        [switch]$Recurse,
        [string]$TempScriptPath
    )
    $TotalLine = 1
    $codeMap = @()
    foreach($_ in Get-ChildItem $ScriptPaths -Recurse:$Recurse.IsPresent){
        if((Test-Path $_ -PathType Leaf) -and $_.FullName.EndsWith(".ps1")){
            $fileName = (Get-Item -Path $_.FullName).Name
            $scriptContent = Get-Content $_
            ($tempCodeMap, $TotalLine) = Merge-Contents -Content $scriptContent -Module $fileName -TotalLine $TotalLine -TempScriptPath $TempScriptPath
            $codeMap += $tempCodeMap  
        }
    }
    return $codeMap
}

<#
    .SYNOPSIS
    Set properties for an AnalysisOutput object.
#>
function Set-AnalysisOutput {
    param(
        [string]$Module,
        [string]$Cmdlet,
        [int]$Example,
        [string]$Line,
        [string]$RuleName,
        [int]$ProblemID,
        [int]$Severity,
        [string]$Description,
        [string]$Extent,
        [String]$Remediation
    )
    $result = [AnalysisOutput]@{
        Module = $Module
        Cmdlet = $Cmdlet
        Example = $Example
        Line = $Line
        RuleName = $RuleName
        ProblemID = $ProblemID
        Severity = $Severity
        Description = $Description
        Extent = $Extent
        Remediation = $Remediation
    }
    return $result
}

<#
    .SYNOPSIS
    Invoke PSScriptAnalyzer with custom rules, return the error set.
    .PARAMETER RulePath
    PSScriptAnalyzer custom rules path. Supports wildcard.
#>
function Get-ScriptAnalyzerResult {
    param (
        [string]$ScriptPath,
        [Parameter(Mandatory)]
        [string[]]$RulePaths,
        [switch]$IncludeDefaultRules,
        [Object[]]$CodeMap
    )
    # Validate script file exists.
    if (!(Test-Path $ScriptPath -PathType Leaf)) {
        throw "Cannot find cached script file '$ScriptPath'."
    }
    
    # Invoke PSScriptAnalyzer : input scriptblock, output error set in $result with property: RuleName, Message, Extent
    if ($null -eq $RulePaths) {
        $analysisResults = Invoke-ScriptAnalyzer -Path $ScriptPath -IncludeDefaultRules:$IncludeDefaultRules.IsPresent
    }
    else {
        $analysisResults = Invoke-ScriptAnalyzer -Path $ScriptPath -CustomRulePath $RulePaths -IncludeDefaultRules:$IncludeDefaultRules.IsPresent
    }
    $errors = @()
    foreach($analysisResult in $analysisResults){
        if($analysisResult.Severity -eq "ParseError"){
            $Severity = 1
        }
        elseif($analysisResult.Severity -eq "Error"){
            $Severity = 1
        }
        elseif($analysisResult.Severity -eq "Warning"){
            $Severity = 2
        }
        elseif($analysisResult.Severity -eq "Information"){
            $Severity = 3
        }
        $locationMessage = $CodeMap[$analysisResult.Line - 1]
        if($analysisResult.RuleSuppressionID -ge 5000 -and $analysisResult.RuleSuppressionID -le 5199){
            $result = [AnalysisOutput]@{
                Module = $locationMessage.Module
                Cmdlet = $locationMessage.Cmdlet
                Example = $locationMessage.Example
                Line = $locationMessage.Line
                RuleName = $analysisResult.RuleName
                Description = ($analysisResult.Message -split "#@#")[0] -replace "`"","`'" -replace "`n"," " -replace "`r"," "
                Severity = $Severity
                Extent = $analysisResult.Extent.ToString().Trim() -replace "`"","`'" -replace "`n"," " -replace "`r"," "
                ProblemID = $analysisResult.RuleSuppressionID
                Remediation = ($analysisResult.Message -split "#@#")[1] -replace "`"","`'" -replace "`n"," " -replace "`r"," "
            }
        }
        else{
            $result = [AnalysisOutput]@{
                Module = $locationMessage.Module
                Cmdlet = $locationMessage.Cmdlet
                Example = $locationMessage.Example
                Line = $locationMessage.Line
                RuleName = $analysisResult.RuleName
                Description = $analysisResult.Message -replace "`"","`'" -replace "`n"," " -replace "`r"," "
                Severity = $Severity
                Extent = $analysisResult.Extent.ToString().Trim() -replace "`"","`'" -replace "`n"," " -replace "`r"," "
                ProblemID = 5200
                Remediation = "Unexpected Error. Please check [Trouble Shotting for Unexpected Errors in Example Issues](https://github.com/Azure/azure-powershell/blob/main/documentation/Debugging-StaticAnalysis-Errors.md#Troubleshotting-Example-Issues) for more details."
            }
        }
        $errors += $result 
    }
    # Except records in allow list
    $errors = Get-RecordsNotInAllowList $errors
    # Except the suppressed records
    $errors = Get-NonExceptionRecord $errors

    return $errors
}

<#
    .SYNOPSIS
    Except the suppressed records. It is independent of ExampleIssues.cs.
#>
function Get-NonExceptionRecord{
    param(
        [AnalysisOutput[]]$records
    )
    $exceptionPaths = "$PSScriptRoot\..\..\..\tools\StaticAnalysis\Exceptions"
    $errors = @()
    foreach($record in $records){
        $needAdd = $true
        $exceptionPath = Join-Path -Path $exceptionPaths -ChildPath "Az.$($record.Module)" -AdditionalChildPath "ExampleIssues.csv"
        if(Test-Path -Path $exceptionPath){
            $exceptionContents = Import-Csv -Path $exceptionPath
            foreach($exceptionContent in $exceptionContents) {
                if($exceptionContent.Module -eq $record.Module -and $exceptionContent.Cmdlet -eq $record.Cmdlet -and $exceptionContent.Example -eq $record.Example -and $exceptionContent.Line -eq $record.Line -and $exceptionContent.Description -eq $record.Description){
                    $needAdd = $false
                    break
                }
            }
        }
        if($needAdd){
            $errors += $record
        }
    }
    return $errors
}

<#
    .SYNOPSIS
    Get AnalysisOutput entries not in the allow list.
#>
function Get-RecordsNotInAllowList{
    param (
        [AnalysisOutput[]]$records
    )
    return $records | Where-Object {
        # Skip the unexpected error caused by using <xxx> to assign parameters
        if($_.RuleName -eq "RedirectionNotSupported"){
            return $false
        }
        # Skip the invaild cmdlet "<"
        $CommandName = ($_.Description -split " ")[0]
        if($CommandName -eq "<"){
            return $false
        }
        # Skip NeedDeleting in Storage
        if($_.RuleName -eq "NeedDeleting" -and $_.Module -eq "Storage"){
            return $false
        }
        return $true
    }
}
