// ----------------------------------------------------------------------------------
//
// Copyright Microsoft Corporation
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------------------------------------------------------------

using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;

namespace Az.Tools.Predictor.SourceGenerator;

sealed class SettingProperty
{
    public string Name { get; set; }

    public string Type { get; set; }

    public string Value { get; set; }
}

/// <summary>
/// The source generator to create the part of the Settings class from the json file.
///
/// It gathers the key:value pair from the json file, and generates the public properties accordingly.
/// The key from the json is the property name and the value from the json is the property value. It infers
/// the property type based on the value.
/// The generated properties are the default values of the settings.
/// In addition to generating the properties, it also generate the method to get the settings from the user's profile,
/// and override the property accordingly if it's set in the user's profile setting.
/// </summary>
[Generator]
public class SettingsSourceGenerator : ISourceGenerator
{
    private const string _StringType = "string";
    private const string _IntType = "int?";
    private const string _DoubleType = "double?";
    private const string _BoolType = "bool?";

    /// <inheritdoc />
    public void Execute(GeneratorExecutionContext context)
    {
        var settingClass = context.Compilation.GetTypeByMetadataName("Microsoft.Azure.PowerShell.Tools.AzPredictor.Settings");

        if (settingClass is null)
        {
            throw new InvalidOperationException("Is the class Settings renamed?");
        }

        var generatedSource = new StringBuilder($@"
// ----------------------------------------------------------------------------------
//
// Copyright Microsoft Corporation
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------------------------------------------------------------

namespace {settingClass.ContainingNamespace}
{{
    // This file is generated from the source generator. DO NOT edit this file.
    sealed partial class {settingClass.Name}
    {{
");

        var settingFilePath = context.AdditionalFiles.Single((file) => file.Path.EndsWith("AzPredictorSettings.json", StringComparison.Ordinal)).Path;

        var fileContent = File.ReadAllText(settingFilePath, Encoding.UTF8);
        var jsonDocument = JsonDocument.Parse(fileContent);
        var jsonRoot = jsonDocument.RootElement;
        var settingProperties = new List<SettingProperty>();

        // Parse the json file and gather the property information, including name, type, and value.

        foreach (var element in jsonRoot.EnumerateObject())
        {
            var addedProperty = new SettingProperty()
            {
                Name = element.Name.Substring(0, 1).ToUpperInvariant() + element.Name.Substring(1),
            };

            // There are only three types used in the json file: bool, int, and string.
            // So we only need to handle those right now. Expand to other types when we need to.

            switch (element.Value.ValueKind)
            {
                case JsonValueKind.String:
                    addedProperty.Type = SettingsSourceGenerator._StringType;
                    addedProperty.Value = $"\"{element.Value.GetString()}\"";
                    break;
                case JsonValueKind.Number:
                    if (element.Value.TryGetInt32(out var intValue))
                    {
                        addedProperty.Value = intValue.ToString(CultureInfo.InvariantCulture);
                        addedProperty.Type = SettingsSourceGenerator._IntType;
                    }
                    else if (element.Value.TryGetDouble(out var doubleValue))
                    {
                        addedProperty.Value = doubleValue.ToString(CultureInfo.InvariantCulture);
                        addedProperty.Type = SettingsSourceGenerator._DoubleType;
                    }
                    break;
                case JsonValueKind.True:
                    goto case JsonValueKind.False;
                case JsonValueKind.False:
                    addedProperty.Type = SettingsSourceGenerator._BoolType;
                    addedProperty.Value = element.Value.ValueKind == JsonValueKind.True ? "true" : "false";
                    break;
                default:
                    throw new InvalidOperationException($"The type {element.Value.ValueKind.ToString()} isn't supported yet.");
            }

            settingProperties.Add(addedProperty);
        }

        // Generate the properties in the class Settings.

        foreach (var p in settingProperties)
        {
            _ = generatedSource.Append($@"
            public {p.Type} {p.Name} {{ get; set; }} = {p.Value};

");
        }

        // Generate the method to override the properties values from user's profile settings.

        _ = generatedSource.Append($@"
            private void OverrideSettingsFrom(Settings otherSettings)
            {{
");

        foreach (var p in settingProperties)
        {
            if (string.Equals(p.Type, SettingsSourceGenerator._IntType, StringComparison.Ordinal) ||
                string.Equals(p.Type, SettingsSourceGenerator._DoubleType, StringComparison.Ordinal))
            {
                _ = generatedSource.Append($@"
                if (otherSettings.{p.Name}.HasValue && otherSettings.{p.Name}.Value > 0)
                {{
                    {p.Name} = otherSettings.{p.Name}.Value;
                }}
");
            }
            else if (string.Equals(p.Type, SettingsSourceGenerator._StringType, StringComparison.Ordinal))
            {
                _ = generatedSource.Append($@"
                if (!string.IsNullOrWhiteSpace(otherSettings.{p.Name}))
                {{
                    {p.Name} = otherSettings.{p.Name};
                }}
");
            }
            else
            {
                _ = generatedSource.Append($@"
                if (otherSettings.{p.Name} != null)
                {{
                    {p.Name} = otherSettings.{p.Name}.Value;
                }}
");
            }
        }

        _ = generatedSource.Append(@"
            }
");

        _ = generatedSource.Append(@"
    }
}");

        context.AddSource("Settings.generated.cs", generatedSource.ToString());
    }

    /// <inheritdoc />
    public void Initialize(GeneratorInitializationContext context)
    {
    }
}
