// ----------------------------------------------------------------------------------
//
// Copyright Microsoft Corporation
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Management.Automation.Language;
using System.Text;
using System.Threading;

namespace Microsoft.Azure.PowerShell.Tools.AzPredictor
{
    /// <summary>
    /// Caches predictions from Aladdin service, queries user input, e.g. "Connec" and returns autocompleted version, or null.
    /// </summary>
    public sealed class Predictor
    {
        private readonly IList<string> _raw;
        private readonly IList<Prediction> _predictions;

        /// <summary>
        /// Predictor must be initialized with a list of string suggestions.
        /// </summary>
        /// <param name="modelPredictions">List of suggestions from the model, sorted by frequency (most to least)</param>
        public Predictor(IList<string> modelPredictions)
        {
            this._raw = modelPredictions;
            this._predictions = new List<Prediction>();
            foreach (var predictionTextRaw in modelPredictions)
            {
                var predictionText = EscapePredictionText(predictionTextRaw);
                Ast ast = Parser.ParseInput(predictionText, out Token[] tokens, out _);
                var commandAst = (ast.Find((ast) => ast is CommandAst, searchNestedScriptBlocks: false) as CommandAst);

                if (commandAst?.CommandElements[0] is StringConstantExpressionAst commandName)
                {
                    var existingPrediction = this._predictions.FirstOrDefault(p => string.Equals(p.Command.Value, commandName.Value, StringComparison.OrdinalIgnoreCase));
                    var parameterSet = new ParameterSet(commandAst);

                    if (existingPrediction != null)
                    {
                        existingPrediction.ParameterSets.Add(parameterSet);
                    }
                    else
                    {
                        this._predictions.Add(new Prediction(commandName, parameterSet));
                    }
                }
            }
        }

        /// <summary>
        /// Given a user input PowerShell AST, returns prediction text.
        /// </summary>
        /// <param name="input">PowerShell AST input of the user, generated by PSReadLine</param>
        /// <param name="cancellationToken">The cancellation token</param>
        /// <returns>The predicted text for the input</returns>
        public string Query(Ast input, CancellationToken cancellationToken)
        {
            var commandAst = input.FindAll(p => p is CommandAst, true).LastOrDefault() as CommandAst;
            var prediction = GetCommandPrediction(commandAst, input, cancellationToken);
            if (prediction.Item1 == null)
            {
                return null;
            }
            else
            {
                cancellationToken.ThrowIfCancellationRequested();

                var predictionText = ArrangeParameters(prediction.Item1, new ParameterSet(commandAst));
                if ((predictionText == null)
                    || (predictionText.Length <= input.Extent.Text.Length))
                {
                    return null;
                }
                else
                {
                    return predictionText;
                }
            }
        }

        /// <summary>
        /// Gets the top N predictions from the list.
        /// </summary>
        /// <param name="topN">The number of prediction from the top.</param>
        /// <returns>Collection predictions</returns>
        internal IEnumerable<string> GetTopNPrediction(int topN)
        {
            return this._raw.Take(topN);
        }

        /// <summary>
        /// Get the index in the prediction list of the user input
        /// If the user input does not match any command in predictions, then return -1.
        /// </summary>
        /// <param name="commandAst">The relevant command to autocomplete</param>
        /// <param name="input">PowerShell AST input of the user, generated by PSReadLine</param>
        /// <param name="cancellationToken">The cancellation token</param>
        internal ValueTuple<Prediction, int> GetCommandPrediction(CommandAst commandAst, Ast input, CancellationToken cancellationToken)
        {
            if (commandAst?.CommandElements[0] is StringConstantExpressionAst commandName)
            {
                cancellationToken.ThrowIfCancellationRequested();

                var commandIsFinished = (((commandAst?.CommandElements != null) && (commandAst.CommandElements.Count > 1))
                    || ((input as ScriptBlockAst)?.Extent?.Text?.EndsWith(' ') == true));

                if (commandIsFinished)
                {
                    return this._predictions.Where((p) => p.Command.Value.Equals(commandName.Value, StringComparison.OrdinalIgnoreCase))
                        .Select((p, i) => ValueTuple.Create(p, i))
                        .FirstOrDefault();
                }
                else
                {
                    return this._predictions.Where((p) => p.Command.Value.StartsWith(commandName.Value, StringComparison.OrdinalIgnoreCase))
                        .Select((p, i) => ValueTuple.Create(p, i))
                        .FirstOrDefault();
                }
            }

            return ValueTuple.Create<Prediction, int>(null, -1);
        }

        /// <summary>
        /// Arranges parameters in the order of the input.
        ///
        /// Predictions should be flexible, e.g. if "Command -Name N -Location L" is a possibility,
        /// then "Command -Location L -Name N" should also be possible.
        ///
        /// StringBuilder is used to minimize GC pressure, and is passed along throughout the arrangement process.
        /// </summary>
        /// <param name="prediction">Chosen prediction candidate</param>
        /// <param name="inputParameters">Parameter set of the user input</param>
        /// <returns>The arranged parameters</returns>
        private static string ArrangeParameters(Prediction prediction, ParameterSet inputParameters)
        {
            var predictionSet = FindFirstMatchingParameterSet(prediction.Command.Value, prediction.ParameterSets, inputParameters, out StringBuilder builder, out HashSet<int> usedParams);

            if (predictionSet != null)
            {
                PredictRestOfParameters(builder, predictionSet, usedParams);
                return UnescapePredictionText(builder.ToString());
            }
            else
            {
                return null;
            }
        }


        /// <summary>
        /// Finds the first parameter set of the prediction that contains all the parameters of the input AST.
        /// </summary>
        /// <param name="command">The name of the command</param>
        /// <param name="parameterSets">List of ParameterSet candidates for the predicted command, sorted by frequency</param>
        /// <param name="inputParameters">Parsed ParameterSet from the user input AST</param>
        /// <param name="builder">StringBuilder that aggregates the prediction text output</param>
        /// <param name="usedParams">Set of used parameters for the resulting set, if any.</param>
        private static ParameterSet FindFirstMatchingParameterSet(string command, IList<ParameterSet> parameterSets, ParameterSet inputParameters, out StringBuilder builder, out HashSet<int> usedParams)
        {
            usedParams = new HashSet<int>();
            builder = new StringBuilder();
            foreach (ParameterSet parameterSet in parameterSets)
            {
                builder.Clear();
                builder.Append(command);
                usedParams.Clear();
                if (DoesPredictionParameterSetMatchInput(parameterSet, inputParameters, builder, usedParams))
                {
                    return parameterSet;
                }
            }
            return null;
        }


        /// <summary>
        /// Appends unused parameters to the builder.
        /// </summary>
        /// <param name="builder">StringBuilder that aggregates the prediction text output</param>
        /// <param name="parameterSet">Chosen prediction parameter set.</param>
        /// <param name="usedParams">Set of used parameters for set.</param>
        private static void PredictRestOfParameters(StringBuilder builder, ParameterSet parameterSet, HashSet<int> usedParams)
        {
            for (var j = 0; j < parameterSet.Parameters.Count; j++)
            {
                if (!usedParams.Contains(j))
                {
                    _ = builder.Append(AzPredictorConstants.CommandParameterSeperator);
                    _ = builder.Append(parameterSet.Parameters[j].Item1);
                    if (parameterSet.Parameters[j].Item2 != null)
                    {
                        _ = builder.Append(AzPredictorConstants.CommandParameterSeperator);
                        // TODO: add local parameter suggestion
                        _ = builder.Append(parameterSet.Parameters[j].Item2);
                    }
                }
            }
        }

        /// <summary>
        /// Determines if parameter set contains all of the parameters of the input.
        /// </summary>
        /// <param name="predictionParameters">Candidate prediction parameter set.</param>
        /// <param name="inputParameters">Parsed ParameterSet from the user input AST</param>
        /// <param name="builder">StringBuilder that aggregates the prediction text output</param>
        /// <param name="usedParams">Set of used parameters for set.</param>
        private static bool DoesPredictionParameterSetMatchInput(ParameterSet predictionParameters, ParameterSet inputParameters, StringBuilder builder, HashSet<int> usedParams)
        {
            foreach (var inputParameter in inputParameters.Parameters)
            {
                var matchIndex = FindParameterPositionInSet(predictionParameters, inputParameter, usedParams);
                if (matchIndex == -1)
                {
                    return false;
                }
                else
                {
                    usedParams.Add(matchIndex);
                    _ = builder.Append(AzPredictorConstants.CommandParameterSeperator);
                    _ = builder.Append(predictionParameters.Parameters[matchIndex].Item1);

                    if (inputParameter.Item2 != null)
                    {
                        _ = builder.Append(AzPredictorConstants.CommandParameterSeperator);
                        _ = builder.Append(inputParameter.Item2);
                    }
                    else
                    {
                        if (predictionParameters.Parameters[matchIndex].Item2 != null && predictionParameters.Parameters[matchIndex].Item2.ToString().Length > 0)
                        {
                            _ = builder.Append(AzPredictorConstants.CommandParameterSeperator);
                            // TODO: add local parameter suggestion
                            _ = builder.Append(predictionParameters.Parameters[matchIndex].Item2);
                        }
                    }
                }
            }
            return true;
        }


        /// <summary>
        /// Determines the index of the given parameter in the parameter set.
        /// </summary>
        /// <param name="predictionSet">Prediction parameter setto find parameter position in.</param>
        /// <param name="parameter">A tuple, parameter AST, and argument AST (or null), representing the parameter.</param>
        /// <param name="usedParams">Set of used parameters for set.</param>
        private static int FindParameterPositionInSet(ParameterSet predictionSet, Tuple<Ast, Ast> parameter, HashSet<int> usedParams)
        {
            for (var k = 0; k < predictionSet.Parameters.Count; k++)
            {
                var isPrefixed = predictionSet.Parameters[k].Item1.ToString().StartsWith(parameter.Item1.ToString(), StringComparison.OrdinalIgnoreCase);
                var hasNotBeenUsed = !usedParams.Contains(k);
                if (isPrefixed && hasNotBeenUsed)
                {
                    return k;
                }
            }

            return -1;
        }

        /// <summary>
        /// Escaping the prediction text is necessary because KnowledgeBase predicted suggestions
        /// such as "&lt;PSSubnetConfig&gt;" are incorrectly identified as pipe operators
        /// </summary>
        /// <param name="text">The text to escape.</param>
        private static string EscapePredictionText(string text)
        {
            return text.Replace("<", "'<").Replace(">", ">'");
        }

        private static string UnescapePredictionText(string text)
        {
            return text.Replace("'<", "<").Replace(">'", ">");
        }
    }
}
