// ----------------------------------------------------------------------------------
//
// Copyright Microsoft Corporation
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Management.Automation.Language;
using System.Management.Automation.Subsystem;
using System.Text;
using System.Threading;

namespace Microsoft.Azure.PowerShell.Tools.AzPredictor
{
    /// <summary>
    /// Caches predictions from Aladdin service, queries user input, e.g. "Connec" and returns autocompleted version, or null.
    /// </summary>
    internal sealed class Predictor
    {
        private readonly IList<Prediction> _predictions;
        private readonly ParameterValuePredictor _parameterValuePredictor;

        /// <summary>
        /// Predictor must be initialized with a list of string suggestions.
        /// </summary>
        /// <param name="modelPredictions">List of suggestions from the model, sorted by frequency (most to least)</param>
        /// <param name="parameterValuePredictor">Provide the prediction to the parameter values.</param>
        public Predictor(IList<string> modelPredictions, ParameterValuePredictor parameterValuePredictor)
        {
            this._parameterValuePredictor = parameterValuePredictor;
            this._predictions = new List<Prediction>();

            foreach (var predictionTextRaw in modelPredictions ?? Enumerable.Empty<string>())
            {
                var predictionText = EscapePredictionText(predictionTextRaw);
                Ast ast = Parser.ParseInput(predictionText, out Token[] tokens, out _);
                var commandAst = (ast.Find((ast) => ast is CommandAst, searchNestedScriptBlocks: false) as CommandAst);

                if (commandAst?.CommandElements[0] is StringConstantExpressionAst commandName)
                {
                    var existingPrediction = this._predictions.FirstOrDefault(p => string.Equals(p.Command, commandName.Value, StringComparison.OrdinalIgnoreCase));
                    var parameterSet = new ParameterSet(commandAst);

                    if (existingPrediction != null)
                    {
                        existingPrediction.ParameterSets.Add(parameterSet);
                    }
                    else
                    {
                        this._predictions.Add(new Prediction(commandName.Value, parameterSet));
                    }
                }
            }
        }

        /// <summary>
        /// Given a user input PowerShell AST, returns prediction text.
        /// </summary>
        /// <param name="input">PowerShell AST input of the user, generated by PSReadLine</param>
        /// <param name="suggestionCount">The number of suggestion to return.</param>
        /// <param name="cancellationToken">The cancellation token</param>
        /// <returns>The collection of predicted texts for the user input and the parameter set that constructs the predicted texts.</returns>
        public IDictionary<string, IList<Tuple<string, string>>> Query(Ast input, int suggestionCount, CancellationToken cancellationToken)
        {
            if (suggestionCount <= 0)
            {
                return null;
            }

            var commandAst = input.FindAll(p => p is CommandAst, true).LastOrDefault() as CommandAst;
            var commandName = (commandAst?.CommandElements?.FirstOrDefault() as StringConstantExpressionAst)?.Value;

            if (string.IsNullOrWhiteSpace(commandName))
            {
                return null;
            }

            var inputParameterSet = new ParameterSet(commandAst);

            // This stores the neccessary information to build the results.
            // Each element in the list is a ValueTuple and each such tuple has this component
            // 1. The parameter list from the predictions.
            // 2. The index of the element that the user input matches in the previous parameter list.
            // 3. The string that's built so far for the final result.
            var results = new List<ValueTuple<IList<Tuple<string, string>>, HashSet<int>, StringBuilder>>();

            var isCommandNameComplete = (((commandAst?.CommandElements != null) && (commandAst.CommandElements.Count > 1)) || ((input as ScriptBlockAst)?.Extent?.Text?.EndsWith(' ') == true));

            Func<string, bool> commandNameQuery = (command) => command.Equals(commandName, StringComparison.OrdinalIgnoreCase);
            if (!isCommandNameComplete)
            {
                commandNameQuery = (command) => command.StartsWith(commandName, StringComparison.OrdinalIgnoreCase);
            }

            // Try to find the matching command and arrange the parameters in the order of the input.
            //
            // Predictions should be flexible, e.g. if "Command -Name N -Location L" is a possibility,
            // then "Command -Location L -Name N" should also be possible.
            //
            // resultBuilder and usedParams are stored in results to help prediction more flexible.

            for (var i = 0; i < _predictions.Count && results.Count < suggestionCount; ++i)
            {
                if (commandNameQuery(_predictions[i].Command))
                {
                    foreach (var parameterSet in _predictions[i].ParameterSets)
                    {
                        cancellationToken.ThrowIfCancellationRequested();

                        var resultBuilder = new StringBuilder(_predictions[i].Command);
                        var usedParams = new HashSet<int>();

                        if (DoesPredictionParameterSetMatchInput(resultBuilder, inputParameterSet, parameterSet, usedParams))
                        {
                            results.Add(ValueTuple.Create(parameterSet.Parameters, usedParams, resultBuilder));

                            if (results.Count == suggestionCount)
                            {
                                break;
                            }
                        }
                    }
                }
            }

            cancellationToken.ThrowIfCancellationRequested();

            return results.Select((r) =>
                    {
                        PredictRestOfParameters(r.Item3, r.Item1, r.Item2);
                        var prediction = UnescapePredictionText(r.Item3);

                        if (prediction.Length <= input.Extent.Text.Length)
                        {
                            return ValueTuple.Create<string, List<Tuple<string, string>>>(null, null);
                        }

                        return ValueTuple.Create(prediction?.ToString(), r.Item1);
                    })
                    .Where((t) => t.Item1 != null)
                    .ToDictionary((t) => t.Item1, (t) => t.Item2);
        }

        /// <summary>
        /// Appends unused parameters to the builder.
        /// </summary>
        /// <param name="builder">StringBuilder that aggregates the prediction text output</param>
        /// <param name="parameters">Chosen prediction parameters.</param>
        /// <param name="usedParams">Set of used parameters for set.</param>
        private void PredictRestOfParameters(StringBuilder builder, IList<Tuple<string, string>> parameters, HashSet<int> usedParams)
        {
            for (var j = 0; j < parameters.Count; j++)
            {
                if (!usedParams.Contains(j))
                {
                    BuildParameterValue(builder, parameters[j]);
                }
            }
        }

        /// <summary>
        /// Determines if parameter set contains all of the parameters of the input.
        /// </summary>
        /// <param name="builder">StringBuilder that aggregates the prediction text output</param>
        /// <param name="inputParameters">Parsed ParameterSet from the user input AST</param>
        /// <param name="predictionParameters">Candidate prediction parameter set.</param>
        /// <param name="usedParams">Set of used parameters for set.</param>
        private bool DoesPredictionParameterSetMatchInput(StringBuilder builder, ParameterSet inputParameters, ParameterSet predictionParameters, HashSet<int> usedParams)
        {
            foreach (var inputParameter in inputParameters.Parameters)
            {
                var matchIndex = FindParameterPositionInSet(inputParameter, predictionParameters, usedParams);
                if (matchIndex == -1)
                {
                    return false;
                }
                else
                {
                    usedParams.Add(matchIndex);
                    if (inputParameter.Item2 != null)
                    {
                        _ = builder.Append(AzPredictorConstants.CommandParameterSeperator);
                        _ = builder.Append(predictionParameters.Parameters[matchIndex].Item1);

                        _ = builder.Append(AzPredictorConstants.CommandParameterSeperator);
                        _ = builder.Append(inputParameter.Item2);
                    }
                    else
                    {
                        BuildParameterValue(builder, predictionParameters.Parameters[matchIndex]);
                    }
                }
            }
            return true;
        }

        /// <summary>
        /// Create the parameter values from the history commandlines.
        ///
        /// For example:
        /// history command line
        /// > New-AzVM -Name "TestVM" ...
        /// prediction:
        /// > Get-AzVM -VMName &lt;TestVM&gt;
        /// "TestVM" is predicted for Get-AzVM.
        /// </summary>
        /// <param name="builder">The string builder to create the whole predicted command line.</param>
        /// <param name="parameter">The parameter name and vlaue from prediction</param>
        private void BuildParameterValue(StringBuilder builder, Tuple<string, string> parameter)
        {
            var parameterName = parameter.Item1;
            _ = builder.Append(AzPredictorConstants.CommandParameterSeperator);
            _ = builder.Append(parameterName);

            string parameterValue = this._parameterValuePredictor?.GetParameterValueFromAzCommand(parameterName);

            if (string.IsNullOrWhiteSpace(parameterValue))
            {
                parameterValue = parameter.Item2;
            }

            if (!string.IsNullOrWhiteSpace(parameterValue))
            {
                _ = builder.Append(AzPredictorConstants.CommandParameterSeperator);
                _ = builder.Append(parameterValue);
            }
        }

        /// <summary>
        /// Determines the index of the given parameter in the parameter set.
        /// </summary>
        /// <param name="parameter">A tuple, parameter AST, and argument AST (or null), representing the parameter.</param>
        /// <param name="predictionSet">Prediction parameter setto find parameter position in.</param>
        /// <param name="usedParams">Set of used parameters for set.</param>
        private static int FindParameterPositionInSet(Tuple<string, string> parameter, ParameterSet predictionSet, HashSet<int> usedParams)
        {
            for (var k = 0; k < predictionSet.Parameters.Count; k++)
            {
                var isPrefixed = predictionSet.Parameters[k].Item1.StartsWith(parameter.Item1, StringComparison.OrdinalIgnoreCase);
                var hasNotBeenUsed = !usedParams.Contains(k);
                if (isPrefixed && hasNotBeenUsed)
                {
                    return k;
                }
            }

            return -1;
        }

        /// <summary>
        /// Escaping the prediction text is necessary because KnowledgeBase predicted suggestions
        /// such as "&lt;PSSubnetConfig&gt;" are incorrectly identified as pipe operators
        /// </summary>
        /// <param name="text">The text to escape.</param>
        private static string EscapePredictionText(string text)
        {
            return text.Replace("<", "'<").Replace(">", ">'");
        }

        private static StringBuilder UnescapePredictionText(StringBuilder text)
        {
            return text.Replace("'<", "<").Replace(">'", ">");
        }
    }
}
