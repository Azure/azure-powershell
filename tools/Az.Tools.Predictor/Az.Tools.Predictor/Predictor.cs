// ----------------------------------------------------------------------------------
//
// Copyright Microsoft Corporation
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Management.Automation.Language;
using System.Text;
using System.Threading;

namespace Microsoft.Azure.PowerShell.Tools.AzPredictor
{
    /// <summary>
    /// Caches predictions from Aladdin service, queries user input, e.g. "Connec" and returns autocompleted version, or null.
    /// </summary>
    internal sealed class Predictor
    {
        private readonly IList<Prediction> _predictions;
        private readonly ParameterValuePredictor _parameterValuePredictor;

        /// <summary>
        /// Predictor must be initialized with a list of string suggestions.
        /// </summary>
        /// <param name="modelPredictions">List of suggestions from the model, sorted by frequency (most to least)</param>
        /// <param name="parameterValuePredictor">Provide the prediction to the parameter values.</param>
        public Predictor(IList<string> modelPredictions, ParameterValuePredictor parameterValuePredictor)
        {
            this._parameterValuePredictor = parameterValuePredictor;
            this._predictions = new List<Prediction>();

            foreach (var predictionTextRaw in modelPredictions ?? Enumerable.Empty<string>())
            {
                var predictionText = EscapePredictionText(predictionTextRaw);
                Ast ast = Parser.ParseInput(predictionText, out Token[] tokens, out _);
                var commandAst = (ast.Find((ast) => ast is CommandAst, searchNestedScriptBlocks: false) as CommandAst);

                if (commandAst?.CommandElements[0] is StringConstantExpressionAst commandName)
                {
                    var existingPrediction = this._predictions.FirstOrDefault(p => string.Equals(p.Command.Value, commandName.Value, StringComparison.OrdinalIgnoreCase));
                    var parameterSet = new ParameterSet(commandAst);

                    if (existingPrediction != null)
                    {
                        existingPrediction.ParameterSets.Add(parameterSet);
                    }
                    else
                    {
                        this._predictions.Add(new Prediction(commandName, parameterSet));
                    }
                }
            }
        }

        /// <summary>
        /// Given a user input PowerShell AST, returns prediction text.
        /// </summary>
        /// <param name="input">PowerShell AST input of the user, generated by PSReadLine</param>
        /// <param name="cancellationToken">The cancellation token</param>
        /// <returns>The predicted text for the input</returns>
        public string Query(Ast input, CancellationToken cancellationToken)
        {
            var commandAst = input.FindAll(p => p is CommandAst, true).LastOrDefault() as CommandAst;
            var commandName = (commandAst?.CommandElements?.FirstOrDefault() as StringConstantExpressionAst)?.Value;
            var isCommandNameComplete = (((commandAst?.CommandElements != null) && (commandAst.CommandElements.Count > 1)) || ((input as ScriptBlockAst)?.Extent?.Text?.EndsWith(' ') == true));
            var prediction = GetCommandPrediction(commandName, isCommandNameComplete, cancellationToken);
            if (prediction.Item1 == null)
            {
                return null;
            }
            else
            {
                cancellationToken.ThrowIfCancellationRequested();

                var predictionText = ArrangeParameters(prediction.Item1, new ParameterSet(commandAst));
                if ((predictionText == null)
                    || (predictionText.Length <= input.Extent.Text.Length))
                {
                    return null;
                }
                else
                {
                    return predictionText;
                }
            }
        }

        /// <summary>
        /// Get the index in the prediction list of the user input
        /// If the user input does not match any command in predictions, then return -1.
        /// </summary>
        /// <param name="commandNameOrPrefix">The whole or partial command name</param>
        /// <param name="isCommandNameComplete">Indicates whether <paramref name="commandNameOrPrefix"/> is the entire command name.</param>
        /// <param name="cancellationToken">The cancellation token</param>
        internal ValueTuple<Prediction, int> GetCommandPrediction(string commandNameOrPrefix, bool isCommandNameComplete, CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (!string.IsNullOrWhiteSpace(commandNameOrPrefix))
            {
                if (isCommandNameComplete)
                {
                    return this._predictions.Where((p) => p.Command.Value.Equals(commandNameOrPrefix, StringComparison.OrdinalIgnoreCase))
                        .Select((p, i) => ValueTuple.Create(p, i))
                        .FirstOrDefault();
                }
                else
                {
                    return this._predictions.Where((p) => p.Command.Value.StartsWith(commandNameOrPrefix, StringComparison.OrdinalIgnoreCase))
                        .Select((p, i) => ValueTuple.Create(p, i))
                        .FirstOrDefault();
                }
            }

            return ValueTuple.Create<Prediction, int>(null, -1);
        }

        /// <summary>
        /// Arranges parameters in the order of the input.
        ///
        /// Predictions should be flexible, e.g. if "Command -Name N -Location L" is a possibility,
        /// then "Command -Location L -Name N" should also be possible.
        ///
        /// StringBuilder is used to minimize GC pressure, and is passed along throughout the arrangement process.
        /// </summary>
        /// <param name="prediction">Chosen prediction candidate</param>
        /// <param name="inputParameters">Parameter set of the user input</param>
        /// <returns>The arranged parameters</returns>
        private string ArrangeParameters(Prediction prediction, ParameterSet inputParameters)
        {
            var predictionSet = FindFirstMatchingParameterSet(prediction.Command.Value, prediction.ParameterSets, inputParameters, out StringBuilder builder, out HashSet<int> usedParams);

            if (predictionSet != null)
            {
                PredictRestOfParameters(builder, predictionSet, usedParams);
                return UnescapePredictionText(builder.ToString());
            }
            else
            {
                return null;
            }
        }


        /// <summary>
        /// Finds the first parameter set of the prediction that contains all the parameters of the input AST.
        /// </summary>
        /// <param name="command">The name of the command</param>
        /// <param name="parameterSets">List of ParameterSet candidates for the predicted command, sorted by frequency</param>
        /// <param name="inputParameters">Parsed ParameterSet from the user input AST</param>
        /// <param name="builder">StringBuilder that aggregates the prediction text output</param>
        /// <param name="usedParams">Set of used parameters for the resulting set, if any.</param>
        private ParameterSet FindFirstMatchingParameterSet(string command, IList<ParameterSet> parameterSets, ParameterSet inputParameters, out StringBuilder builder, out HashSet<int> usedParams)
        {
            usedParams = new HashSet<int>();
            builder = new StringBuilder();
            foreach (ParameterSet parameterSet in parameterSets)
            {
                builder.Clear();
                builder.Append(command);
                usedParams.Clear();
                if (DoesPredictionParameterSetMatchInput(builder, inputParameters, parameterSet, usedParams))
                {
                    return parameterSet;
                }
            }
            return null;
        }


        /// <summary>
        /// Appends unused parameters to the builder.
        /// </summary>
        /// <param name="builder">StringBuilder that aggregates the prediction text output</param>
        /// <param name="parameterSet">Chosen prediction parameter set.</param>
        /// <param name="usedParams">Set of used parameters for set.</param>
        private void PredictRestOfParameters(StringBuilder builder, ParameterSet parameterSet, HashSet<int> usedParams)
        {
            for (var j = 0; j < parameterSet.Parameters.Count; j++)
            {
                if (!usedParams.Contains(j))
                {
                    BuildParameterValue(builder, parameterSet.Parameters[j]);
                }
            }
        }

        /// <summary>
        /// Determines if parameter set contains all of the parameters of the input.
        /// </summary>
        /// <param name="builder">StringBuilder that aggregates the prediction text output</param>
        /// <param name="inputParameters">Parsed ParameterSet from the user input AST</param>
        /// <param name="predictionParameters">Candidate prediction parameter set.</param>
        /// <param name="usedParams">Set of used parameters for set.</param>
        private bool DoesPredictionParameterSetMatchInput(StringBuilder builder, ParameterSet inputParameters, ParameterSet predictionParameters, HashSet<int> usedParams)
        {
            foreach (var inputParameter in inputParameters.Parameters)
            {
                var matchIndex = FindParameterPositionInSet(inputParameter, predictionParameters, usedParams);
                if (matchIndex == -1)
                {
                    return false;
                }
                else
                {
                    usedParams.Add(matchIndex);
                    if (inputParameter.Item2 != null)
                    {
                        _ = builder.Append(AzPredictorConstants.CommandParameterSeperator);
                        _ = builder.Append(predictionParameters.Parameters[matchIndex].Item1);

                        _ = builder.Append(AzPredictorConstants.CommandParameterSeperator);
                        _ = builder.Append(inputParameter.Item2);
                    }
                    else
                    {
                        BuildParameterValue(builder, predictionParameters.Parameters[matchIndex]);
                    }
                }
            }
            return true;
        }

        /// <summary>
        /// Create the parameter values from the history commandlines.
        ///
        /// For example:
        /// history command line
        /// > New-AzVM -Name "TestVM" ...
        /// prediction:
        /// > Get-AzVM -VMName &lt;TestVM&gt;
        /// "TestVM" is predicted for Get-AzVM.
        /// </summary>
        /// <param name="builder">The string builder to create the whole predicted command line.</param>
        /// <param name="parameter">The parameter name and vlaue from prediction</param>
        private void BuildParameterValue(StringBuilder builder, Tuple<Ast, Ast> parameter)
        {
            var parameterName = parameter.Item1.ToString();
            _ = builder.Append(AzPredictorConstants.CommandParameterSeperator);
            _ = builder.Append(parameterName);

            string parameterValue = this._parameterValuePredictor?.GetParameterValueFromAzCommand(parameterName);

            if (string.IsNullOrWhiteSpace(parameterValue))
            {
                parameterValue = parameter.Item2?.ToString();
            }

            if (!string.IsNullOrWhiteSpace(parameterValue))
            {
                _ = builder.Append(AzPredictorConstants.CommandParameterSeperator);
                _ = builder.Append(parameterValue);
            }
        }

        /// <summary>
        /// Determines the index of the given parameter in the parameter set.
        /// </summary>
        /// <param name="parameter">A tuple, parameter AST, and argument AST (or null), representing the parameter.</param>
        /// <param name="predictionSet">Prediction parameter setto find parameter position in.</param>
        /// <param name="usedParams">Set of used parameters for set.</param>
        private static int FindParameterPositionInSet(Tuple<Ast, Ast> parameter, ParameterSet predictionSet, HashSet<int> usedParams)
        {
            for (var k = 0; k < predictionSet.Parameters.Count; k++)
            {
                var isPrefixed = predictionSet.Parameters[k].Item1.ToString().StartsWith(parameter.Item1.ToString(), StringComparison.OrdinalIgnoreCase);
                var hasNotBeenUsed = !usedParams.Contains(k);
                if (isPrefixed && hasNotBeenUsed)
                {
                    return k;
                }
            }

            return -1;
        }

        /// <summary>
        /// Escaping the prediction text is necessary because KnowledgeBase predicted suggestions
        /// such as "&lt;PSSubnetConfig&gt;" are incorrectly identified as pipe operators
        /// </summary>
        /// <param name="text">The text to escape.</param>
        private static string EscapePredictionText(string text)
        {
            return text.Replace("<", "'<").Replace(">", ">'");
        }

        private static string UnescapePredictionText(string text)
        {
            return text.Replace("'<", "<").Replace(">'", ">");
        }
    }
}
