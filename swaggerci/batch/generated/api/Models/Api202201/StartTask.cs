// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Extensions;

    /// <summary>
    /// In some cases the start task may be re-run even though the node was not rebooted. Due to this, start tasks should be idempotent
    /// and exit gracefully if the setup they're performing has already been done. Special care should be taken to avoid start
    /// tasks which create breakaway process or install/launch services from the start task working directory, as this will block
    /// Batch from being able to re-run the start task.
    /// </summary>
    public partial class StartTask :
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IStartTask,
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IStartTaskInternal
    {

        /// <summary>The default value is nonAdmin.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.ElevationLevel? AutoUserElevationLevel { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IUserIdentityInternal)UserIdentity).AutoUserElevationLevel; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IUserIdentityInternal)UserIdentity).AutoUserElevationLevel = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.ElevationLevel)""); }

        /// <summary>
        /// The default value is Pool. If the pool is running Windows a value of Task should be specified if stricter isolation between
        /// tasks is required. For example, if the task mutates the registry in a way which could impact other tasks, or if certificates
        /// have been specified on the pool which should not be accessible by normal tasks but should be accessible by start tasks.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.AutoUserScope? AutoUserScope { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IUserIdentityInternal)UserIdentity).AutoUserScope; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IUserIdentityInternal)UserIdentity).AutoUserScope = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.AutoUserScope)""); }

        /// <summary>Backing field for <see cref="CommandLine" /> property.</summary>
        private string _commandLine;

        /// <summary>
        /// The command line does not run under a shell, and therefore cannot take advantage of shell features such as environment
        /// variable expansion. If you want to take advantage of such features, you should invoke the shell in the command line, for
        /// example using "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. Required if any other properties of the
        /// startTask are specified.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public string CommandLine { get => this._commandLine; set => this._commandLine = value; }

        /// <summary>Backing field for <see cref="ContainerSetting" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettings _containerSetting;

        /// <summary>
        /// When this is specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the root of Azure Batch directories
        /// on the node) are mapped into the container, all task environment variables are mapped into the container, and the task
        /// command line is executed in the container.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettings ContainerSetting { get => (this._containerSetting = this._containerSetting ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.TaskContainerSettings()); set => this._containerSetting = value; }

        /// <summary>
        /// These additional options are supplied as arguments to the "docker create" command, in addition to those controlled by
        /// the Batch Service.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ContainerSettingContainerRunOption { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).ContainerRunOption; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).ContainerRunOption = value ?? null; }

        /// <summary>
        /// This is the full image reference, as would be specified to "docker pull". If no tag is provided as part of the image name,
        /// the tag ":latest" is used as a default.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string ContainerSettingImageName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).ImageName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).ImageName = value ?? null; }

        /// <summary>
        /// A flag to indicate where the container task working directory is. The default is 'taskWorkingDirectory'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.ContainerWorkingDirectory? ContainerSettingWorkingDirectory { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).WorkingDirectory; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).WorkingDirectory = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.ContainerWorkingDirectory)""); }

        /// <summary>Backing field for <see cref="EnvironmentSetting" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IEnvironmentSetting[] _environmentSetting;

        /// <summary>A list of environment variable settings for the start task.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IEnvironmentSetting[] EnvironmentSetting { get => this._environmentSetting; set => this._environmentSetting = value; }

        /// <summary>The ARM resource id of the user assigned identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string IdentityReferenceResourceId { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).IdentityReferenceResourceId; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).IdentityReferenceResourceId = value ?? null; }

        /// <summary>Backing field for <see cref="MaxTaskRetryCount" /> property.</summary>
        private int? _maxTaskRetryCount;

        /// <summary>
        /// The Batch service retries a task if its exit code is nonzero. Note that this value specifically controls the number of
        /// retries. The Batch service will try the task once, and may then retry up to this limit. For example, if the maximum retry
        /// count is 3, Batch tries the task up to 4 times (one initial try and 3 retries). If the maximum retry count is 0, the Batch
        /// service does not retry the task. If the maximum retry count is -1, the Batch service retries the task without limit, however
        /// this is not recommended for a start task or any task. The default value is 0 (no retries).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public int? MaxTaskRetryCount { get => this._maxTaskRetryCount; set => this._maxTaskRetryCount = value; }

        /// <summary>Internal Acessors for ContainerSetting</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettings Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IStartTaskInternal.ContainerSetting { get => (this._containerSetting = this._containerSetting ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.TaskContainerSettings()); set { {_containerSetting = value;} } }

        /// <summary>Internal Acessors for ContainerSettingRegistry</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IContainerRegistry Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IStartTaskInternal.ContainerSettingRegistry { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).Registry; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).Registry = value; }

        /// <summary>Internal Acessors for RegistryIdentityReference</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IComputeNodeIdentityReference Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IStartTaskInternal.RegistryIdentityReference { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).RegistryIdentityReference; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).RegistryIdentityReference = value; }

        /// <summary>Internal Acessors for UserIdentity</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IUserIdentity Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IStartTaskInternal.UserIdentity { get => (this._userIdentity = this._userIdentity ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.UserIdentity()); set { {_userIdentity = value;} } }

        /// <summary>Internal Acessors for UserIdentityAutoUser</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IAutoUserSpecification Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IStartTaskInternal.UserIdentityAutoUser { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IUserIdentityInternal)UserIdentity).AutoUser; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IUserIdentityInternal)UserIdentity).AutoUser = value; }

        /// <summary>The password to log into the registry server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string RegistryPassword { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).RegistryPassword; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).RegistryPassword = value ?? null; }

        /// <summary>If omitted, the default is "docker.io".</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string RegistryServer { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).RegistryServer; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).RegistryServer = value ?? null; }

        /// <summary>The user name to log into the registry server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string RegistryUserName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).RegistryUserName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettingsInternal)ContainerSetting).RegistryUserName = value ?? null; }

        /// <summary>Backing field for <see cref="ResourceFile" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IResourceFile[] _resourceFile;

        /// <summary>
        /// A list of files that the Batch service will download to the compute node before running the command line.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IResourceFile[] ResourceFile { get => this._resourceFile; set => this._resourceFile = value; }

        /// <summary>Backing field for <see cref="UserIdentity" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IUserIdentity _userIdentity;

        /// <summary>If omitted, the task runs as a non-administrative user unique to the task.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IUserIdentity UserIdentity { get => (this._userIdentity = this._userIdentity ?? new Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.UserIdentity()); set => this._userIdentity = value; }

        /// <summary>
        /// The userName and autoUser properties are mutually exclusive; you must specify one but not both.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Inlined)]
        public string UserIdentityUserName { get => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IUserIdentityInternal)UserIdentity).UserName; set => ((Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IUserIdentityInternal)UserIdentity).UserName = value ?? null; }

        /// <summary>Backing field for <see cref="WaitForSuccess" /> property.</summary>
        private bool? _waitForSuccess;

        /// <summary>
        /// If true and the start task fails on a compute node, the Batch service retries the start task up to its maximum retry count
        /// (maxTaskRetryCount). If the task has still not completed successfully after all retries, then the Batch service marks
        /// the compute node unusable, and will not schedule tasks to it. This condition can be detected via the node state and scheduling
        /// error detail. If false, the Batch service will not wait for the start task to complete. In this case, other tasks can
        /// start executing on the compute node while the start task is still running; and even if the start task fails, new tasks
        /// will continue to be scheduled on the node. The default is true.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Origin(Microsoft.Azure.PowerShell.Cmdlets.Batch.PropertyOrigin.Owned)]
        public bool? WaitForSuccess { get => this._waitForSuccess; set => this._waitForSuccess = value; }

        /// <summary>Creates an new <see cref="StartTask" /> instance.</summary>
        public StartTask()
        {

        }
    }
    /// In some cases the start task may be re-run even though the node was not rebooted. Due to this, start tasks should be idempotent
    /// and exit gracefully if the setup they're performing has already been done. Special care should be taken to avoid start
    /// tasks which create breakaway process or install/launch services from the start task working directory, as this will block
    /// Batch from being able to re-run the start task.
    public partial interface IStartTask :
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.IJsonSerializable
    {
        /// <summary>The default value is nonAdmin.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default value is nonAdmin.",
        SerializedName = @"elevationLevel",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.ElevationLevel) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.ElevationLevel? AutoUserElevationLevel { get; set; }
        /// <summary>
        /// The default value is Pool. If the pool is running Windows a value of Task should be specified if stricter isolation between
        /// tasks is required. For example, if the task mutates the registry in a way which could impact other tasks, or if certificates
        /// have been specified on the pool which should not be accessible by normal tasks but should be accessible by start tasks.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default value is Pool. If the pool is running Windows a value of Task should be specified if stricter isolation between tasks is required. For example, if the task mutates the registry in a way which could impact other tasks, or if certificates have been specified on the pool which should not be accessible by normal tasks but should be accessible by start tasks.",
        SerializedName = @"scope",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.AutoUserScope) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.AutoUserScope? AutoUserScope { get; set; }
        /// <summary>
        /// The command line does not run under a shell, and therefore cannot take advantage of shell features such as environment
        /// variable expansion. If you want to take advantage of such features, you should invoke the shell in the command line, for
        /// example using "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. Required if any other properties of the
        /// startTask are specified.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The command line does not run under a shell, and therefore cannot take advantage of shell features such as environment variable expansion. If you want to take advantage of such features, you should invoke the shell in the command line, for example using ""cmd /c MyCommand"" in Windows or ""/bin/sh -c MyCommand"" in Linux. Required if any other properties of the startTask are specified.",
        SerializedName = @"commandLine",
        PossibleTypes = new [] { typeof(string) })]
        string CommandLine { get; set; }
        /// <summary>
        /// These additional options are supplied as arguments to the "docker create" command, in addition to those controlled by
        /// the Batch Service.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"These additional options are supplied as arguments to the ""docker create"" command, in addition to those controlled by the Batch Service.",
        SerializedName = @"containerRunOptions",
        PossibleTypes = new [] { typeof(string) })]
        string ContainerSettingContainerRunOption { get; set; }
        /// <summary>
        /// This is the full image reference, as would be specified to "docker pull". If no tag is provided as part of the image name,
        /// the tag ":latest" is used as a default.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This is the full image reference, as would be specified to ""docker pull"". If no tag is provided as part of the image name, the tag "":latest"" is used as a default.",
        SerializedName = @"imageName",
        PossibleTypes = new [] { typeof(string) })]
        string ContainerSettingImageName { get; set; }
        /// <summary>
        /// A flag to indicate where the container task working directory is. The default is 'taskWorkingDirectory'.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A flag to indicate where the container task working directory is. The default is 'taskWorkingDirectory'.",
        SerializedName = @"workingDirectory",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.ContainerWorkingDirectory) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.ContainerWorkingDirectory? ContainerSettingWorkingDirectory { get; set; }
        /// <summary>A list of environment variable settings for the start task.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A list of environment variable settings for the start task.",
        SerializedName = @"environmentSettings",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IEnvironmentSetting) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IEnvironmentSetting[] EnvironmentSetting { get; set; }
        /// <summary>The ARM resource id of the user assigned identity.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The ARM resource id of the user assigned identity.",
        SerializedName = @"resourceId",
        PossibleTypes = new [] { typeof(string) })]
        string IdentityReferenceResourceId { get; set; }
        /// <summary>
        /// The Batch service retries a task if its exit code is nonzero. Note that this value specifically controls the number of
        /// retries. The Batch service will try the task once, and may then retry up to this limit. For example, if the maximum retry
        /// count is 3, Batch tries the task up to 4 times (one initial try and 3 retries). If the maximum retry count is 0, the Batch
        /// service does not retry the task. If the maximum retry count is -1, the Batch service retries the task without limit, however
        /// this is not recommended for a start task or any task. The default value is 0 (no retries).
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The Batch service retries a task if its exit code is nonzero. Note that this value specifically controls the number of retries. The Batch service will try the task once, and may then retry up to this limit. For example, if the maximum retry count is 3, Batch tries the task up to 4 times (one initial try and 3 retries). If the maximum retry count is 0, the Batch service does not retry the task. If the maximum retry count is -1, the Batch service retries the task without limit, however this is not recommended for a start task or any task. The default value is 0 (no retries).",
        SerializedName = @"maxTaskRetryCount",
        PossibleTypes = new [] { typeof(int) })]
        int? MaxTaskRetryCount { get; set; }
        /// <summary>The password to log into the registry server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The password to log into the registry server.",
        SerializedName = @"password",
        PossibleTypes = new [] { typeof(string) })]
        string RegistryPassword { get; set; }
        /// <summary>If omitted, the default is "docker.io".</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If omitted, the default is ""docker.io"".",
        SerializedName = @"registryServer",
        PossibleTypes = new [] { typeof(string) })]
        string RegistryServer { get; set; }
        /// <summary>The user name to log into the registry server.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The user name to log into the registry server.",
        SerializedName = @"username",
        PossibleTypes = new [] { typeof(string) })]
        string RegistryUserName { get; set; }
        /// <summary>
        /// A list of files that the Batch service will download to the compute node before running the command line.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A list of files that the Batch service will download to the compute node before running the command line.",
        SerializedName = @"resourceFiles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IResourceFile) })]
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IResourceFile[] ResourceFile { get; set; }
        /// <summary>
        /// The userName and autoUser properties are mutually exclusive; you must specify one but not both.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The userName and autoUser properties are mutually exclusive; you must specify one but not both.",
        SerializedName = @"userName",
        PossibleTypes = new [] { typeof(string) })]
        string UserIdentityUserName { get; set; }
        /// <summary>
        /// If true and the start task fails on a compute node, the Batch service retries the start task up to its maximum retry count
        /// (maxTaskRetryCount). If the task has still not completed successfully after all retries, then the Batch service marks
        /// the compute node unusable, and will not schedule tasks to it. This condition can be detected via the node state and scheduling
        /// error detail. If false, the Batch service will not wait for the start task to complete. In this case, other tasks can
        /// start executing on the compute node while the start task is still running; and even if the start task fails, new tasks
        /// will continue to be scheduled on the node. The default is true.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.Batch.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If true and the start task fails on a compute node, the Batch service retries the start task up to its maximum retry count (maxTaskRetryCount). If the task has still not completed successfully after all retries, then the Batch service marks the compute node unusable, and will not schedule tasks to it. This condition can be detected via the node state and scheduling error detail. If false, the Batch service will not wait for the start task to complete. In this case, other tasks can start executing on the compute node while the start task is still running; and even if the start task fails, new tasks will continue to be scheduled on the node. The default is true.",
        SerializedName = @"waitForSuccess",
        PossibleTypes = new [] { typeof(bool) })]
        bool? WaitForSuccess { get; set; }

    }
    /// In some cases the start task may be re-run even though the node was not rebooted. Due to this, start tasks should be idempotent
    /// and exit gracefully if the setup they're performing has already been done. Special care should be taken to avoid start
    /// tasks which create breakaway process or install/launch services from the start task working directory, as this will block
    /// Batch from being able to re-run the start task.
    internal partial interface IStartTaskInternal

    {
        /// <summary>The default value is nonAdmin.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.ElevationLevel? AutoUserElevationLevel { get; set; }
        /// <summary>
        /// The default value is Pool. If the pool is running Windows a value of Task should be specified if stricter isolation between
        /// tasks is required. For example, if the task mutates the registry in a way which could impact other tasks, or if certificates
        /// have been specified on the pool which should not be accessible by normal tasks but should be accessible by start tasks.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.AutoUserScope? AutoUserScope { get; set; }
        /// <summary>
        /// The command line does not run under a shell, and therefore cannot take advantage of shell features such as environment
        /// variable expansion. If you want to take advantage of such features, you should invoke the shell in the command line, for
        /// example using "cmd /c MyCommand" in Windows or "/bin/sh -c MyCommand" in Linux. Required if any other properties of the
        /// startTask are specified.
        /// </summary>
        string CommandLine { get; set; }
        /// <summary>
        /// When this is specified, all directories recursively below the AZ_BATCH_NODE_ROOT_DIR (the root of Azure Batch directories
        /// on the node) are mapped into the container, all task environment variables are mapped into the container, and the task
        /// command line is executed in the container.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.ITaskContainerSettings ContainerSetting { get; set; }
        /// <summary>
        /// These additional options are supplied as arguments to the "docker create" command, in addition to those controlled by
        /// the Batch Service.
        /// </summary>
        string ContainerSettingContainerRunOption { get; set; }
        /// <summary>
        /// This is the full image reference, as would be specified to "docker pull". If no tag is provided as part of the image name,
        /// the tag ":latest" is used as a default.
        /// </summary>
        string ContainerSettingImageName { get; set; }
        /// <summary>This setting can be omitted if was already provided at pool creation.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IContainerRegistry ContainerSettingRegistry { get; set; }
        /// <summary>
        /// A flag to indicate where the container task working directory is. The default is 'taskWorkingDirectory'.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Support.ContainerWorkingDirectory? ContainerSettingWorkingDirectory { get; set; }
        /// <summary>A list of environment variable settings for the start task.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IEnvironmentSetting[] EnvironmentSetting { get; set; }
        /// <summary>The ARM resource id of the user assigned identity.</summary>
        string IdentityReferenceResourceId { get; set; }
        /// <summary>
        /// The Batch service retries a task if its exit code is nonzero. Note that this value specifically controls the number of
        /// retries. The Batch service will try the task once, and may then retry up to this limit. For example, if the maximum retry
        /// count is 3, Batch tries the task up to 4 times (one initial try and 3 retries). If the maximum retry count is 0, the Batch
        /// service does not retry the task. If the maximum retry count is -1, the Batch service retries the task without limit, however
        /// this is not recommended for a start task or any task. The default value is 0 (no retries).
        /// </summary>
        int? MaxTaskRetryCount { get; set; }
        /// <summary>
        /// The reference to a user assigned identity associated with the Batch pool which a compute node will use.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IComputeNodeIdentityReference RegistryIdentityReference { get; set; }
        /// <summary>The password to log into the registry server.</summary>
        string RegistryPassword { get; set; }
        /// <summary>If omitted, the default is "docker.io".</summary>
        string RegistryServer { get; set; }
        /// <summary>The user name to log into the registry server.</summary>
        string RegistryUserName { get; set; }
        /// <summary>
        /// A list of files that the Batch service will download to the compute node before running the command line.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IResourceFile[] ResourceFile { get; set; }
        /// <summary>If omitted, the task runs as a non-administrative user unique to the task.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IUserIdentity UserIdentity { get; set; }
        /// <summary>
        /// The userName and autoUser properties are mutually exclusive; you must specify one but not both.
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.Batch.Models.Api202201.IAutoUserSpecification UserIdentityAutoUser { get; set; }
        /// <summary>
        /// The userName and autoUser properties are mutually exclusive; you must specify one but not both.
        /// </summary>
        string UserIdentityUserName { get; set; }
        /// <summary>
        /// If true and the start task fails on a compute node, the Batch service retries the start task up to its maximum retry count
        /// (maxTaskRetryCount). If the task has still not completed successfully after all retries, then the Batch service marks
        /// the compute node unusable, and will not schedule tasks to it. This condition can be detected via the node state and scheduling
        /// error detail. If false, the Batch service will not wait for the start task to complete. In this case, other tasks can
        /// start executing on the compute node while the start task is still running; and even if the start task fails, new tasks
        /// will continue to be scheduled on the node. The default is true.
        /// </summary>
        bool? WaitForSuccess { get; set; }

    }
}