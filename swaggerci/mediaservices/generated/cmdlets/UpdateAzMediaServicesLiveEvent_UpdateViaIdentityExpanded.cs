// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Cmdlets
{
    using static Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Extensions;
    using System;

    /// <summary>Updates settings on an existing live event.</summary>
    /// <remarks>
    /// [OpenAPI] Update=>PATCH:"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/mediaservices/{accountName}/liveEvents/{liveEventName}"
    /// </remarks>
    [global::System.Management.Automation.Cmdlet(global::System.Management.Automation.VerbsData.Update, @"AzMediaServicesLiveEvent_UpdateViaIdentityExpanded", SupportsShouldProcess = true)]
    [global::System.Management.Automation.OutputType(typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ILiveEvent))]
    [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Description(@"Updates settings on an existing live event.")]
    [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Generated]
    public partial class UpdateAzMediaServicesLiveEvent_UpdateViaIdentityExpanded : global::System.Management.Automation.PSCmdlet,
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener
    {
        /// <summary>A unique id generatd for the this cmdlet when it is instantiated.</summary>
        private string __correlationId = System.Guid.NewGuid().ToString();

        /// <summary>A copy of the Invocation Info (necessary to allow asJob to clone this cmdlet)</summary>
        private global::System.Management.Automation.InvocationInfo __invocationInfo;

        /// <summary>A unique id generatd for the this cmdlet when ProcessRecord() is called.</summary>
        private string __processRecordId;

        /// <summary>
        /// The <see cref="global::System.Threading.CancellationTokenSource" /> for this operation.
        /// </summary>
        private global::System.Threading.CancellationTokenSource _cancellationTokenSource = new global::System.Threading.CancellationTokenSource();

        /// <summary>The live event.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ILiveEvent _parametersBody = new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.LiveEvent();

        /// <summary>when specified, runs this cmdlet as a PowerShell job</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Run the command as a job")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter AsJob { get; set; }

        /// <summary>Wait for .NET debugger to attach</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Wait for .NET debugger to attach")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter Break { get; set; }

        /// <summary>The reference to the client API class.</summary>
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.AzureMediaServices Client => Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Module.Instance.ClientAPI;

        /// <summary>The content of clientaccesspolicy.xml used by Silverlight.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The content of clientaccesspolicy.xml used by Silverlight.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The content of clientaccesspolicy.xml used by Silverlight.",
        SerializedName = @"clientAccessPolicy",
        PossibleTypes = new [] { typeof(string) })]
        public string CrossSiteAccessPolicyClientAccessPolicy { get => _parametersBody.CrossSiteAccessPolicyClientAccessPolicy ?? null; set => _parametersBody.CrossSiteAccessPolicyClientAccessPolicy = value; }

        /// <summary>The content of crossdomain.xml used by Silverlight.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The content of crossdomain.xml used by Silverlight.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The content of crossdomain.xml used by Silverlight.",
        SerializedName = @"crossDomainPolicy",
        PossibleTypes = new [] { typeof(string) })]
        public string CrossSiteAccessPolicyCrossDomainPolicy { get => _parametersBody.CrossSiteAccessPolicyCrossDomainPolicy ?? null; set => _parametersBody.CrossSiteAccessPolicyCrossDomainPolicy = value; }

        /// <summary>
        /// The credentials, account, tenant, and subscription used for communication with Azure
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The credentials, account, tenant, and subscription used for communication with Azure.")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::System.Management.Automation.Alias("AzureRMContext", "AzureCredential")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Azure)]
        public global::System.Management.Automation.PSObject DefaultProfile { get; set; }

        /// <summary>A description for the live event.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "A description for the live event.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A description for the live event.",
        SerializedName = @"description",
        PossibleTypes = new [] { typeof(string) })]
        public string Description { get => _parametersBody.Description ?? null; set => _parametersBody.Description = value; }

        /// <summary>
        /// Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks
        /// of an encoding live event. For example, use PT2S to indicate 2 seconds. For the video track it also defines the key frame
        /// interval, or the length of a GoP (group of pictures). If this value is not set for an encoding live event, the fragment
        /// duration defaults to 2 seconds. The value cannot be set for pass-through live events.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use PT2S to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures). If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for the video and audio tracks of an encoding live event. For example, use PT2S to indicate 2 seconds. For the video track it also defines the key frame interval, or the length of a GoP (group of pictures). If this value is not set for an encoding live event, the fragment duration defaults to 2 seconds. The value cannot be set for pass-through live events.",
        SerializedName = @"keyFrameInterval",
        PossibleTypes = new [] { typeof(global::System.TimeSpan) })]
        public global::System.TimeSpan EncodingKeyFrameInterval { get => _parametersBody.EncodingKeyFrameInterval ?? default(global::System.TimeSpan); set => _parametersBody.EncodingKeyFrameInterval = value; }

        /// <summary>
        /// The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot
        /// be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType
        /// is set to Premium1080p, the default preset is ‘Default1080p’.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The optional encoding preset name, used when encodingType is not None. This value is specified at creation time and cannot be updated. If the encodingType is set to Standard, then the default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the default preset is ‘Default1080p’.",
        SerializedName = @"presetName",
        PossibleTypes = new [] { typeof(string) })]
        public string EncodingPresetName { get => _parametersBody.EncodingPresetName ?? null; set => _parametersBody.EncodingPresetName = value; }

        /// <summary>
        /// Specifies how the input video will be resized to fit the desired output resolution(s). Default is None
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies how the input video will be resized to fit the desired output resolution(s). Default is None")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies how the input video will be resized to fit the desired output resolution(s). Default is None",
        SerializedName = @"stretchMode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.StretchMode) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.StretchMode))]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.StretchMode EncodingStretchMode { get => _parametersBody.EncodingStretchMode ?? ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.StretchMode)""); set => _parametersBody.EncodingStretchMode = value; }

        /// <summary>
        /// Live event type. When encodingType is set to PassthroughBasic or PassthroughStandard, the service simply passes through
        /// the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder
        /// transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/linkid=2095101 for
        /// more information. This property cannot be modified after the live event is created.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Live event type. When encodingType is set to PassthroughBasic or PassthroughStandard, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/linkid=2095101 for more information. This property cannot be modified after the live event is created.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Live event type. When encodingType is set to PassthroughBasic or PassthroughStandard, the service simply passes through the incoming video and audio layer(s) to the output. When encodingType is set to Standard or Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers. See https://go.microsoft.com/fwlink/linkid=2095101 for more information. This property cannot be modified after the live event is created.",
        SerializedName = @"encodingType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventEncodingType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventEncodingType))]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventEncodingType EncodingType { get => _parametersBody.EncodingType ?? ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventEncodingType)""); set => _parametersBody.EncodingType = value; }

        /// <summary>
        /// When useStaticHostname is set to true, the hostnamePrefix specifies the first part of the hostname assigned to the live
        /// event preview and ingest endpoints. The final hostname would be a combination of this prefix, the media service account
        /// name and a short code for the Azure Media Services data center.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "When useStaticHostname is set to true, the hostnamePrefix specifies the first part of the hostname assigned to the live event preview and ingest endpoints. The final hostname would be a combination of this prefix, the media service account name and a short code for the Azure Media Services data center.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"When useStaticHostname is set to true, the hostnamePrefix specifies the first part of the hostname assigned to the live event preview and ingest endpoints. The final hostname would be a combination of this prefix, the media service account name and a short code for the Azure Media Services data center.",
        SerializedName = @"hostnamePrefix",
        PossibleTypes = new [] { typeof(string) })]
        public string HostnamePrefix { get => _parametersBody.HostnamePrefix ?? null; set => _parametersBody.HostnamePrefix = value; }

        /// <summary>SendAsync Pipeline Steps to be appended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be appended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Runtime)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.SendAsyncStep[] HttpPipelineAppend { get; set; }

        /// <summary>SendAsync Pipeline Steps to be prepended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be prepended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Runtime)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.SendAsyncStep[] HttpPipelinePrepend { get; set; }

        /// <summary>The IP allow list.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The IP allow list.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The IP allow list.",
        SerializedName = @"allow",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IIPRange) })]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IIPRange[] InputAccessControlIPAllow { get => _parametersBody.InputAccessControlIPAllow ?? null /* arrayOf */; set => _parametersBody.InputAccessControlIPAllow = value; }

        /// <summary>
        /// A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated. If
        /// omitted, the service will generate a unique value.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated. If omitted, the service will generate a unique value.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A UUID in string form to uniquely identify the stream. This can be specified at creation time but cannot be updated. If omitted, the service will generate a unique value.",
        SerializedName = @"accessToken",
        PossibleTypes = new [] { typeof(string) })]
        public string InputAccessToken { get => _parametersBody.InputAccessToken ?? null; set => _parametersBody.InputAccessToken = value; }

        /// <summary>The input endpoints for the live event.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The input endpoints for the live event.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The input endpoints for the live event.",
        SerializedName = @"endpoints",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ILiveEventEndpoint) })]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ILiveEventEndpoint[] InputEndpoint { get => _parametersBody.InputEndpoint ?? null /* arrayOf */; set => _parametersBody.InputEndpoint = value; }

        /// <summary>
        /// ISO 8601 time duration of the key frame interval duration of the input. This value sets the EXT-X-TARGETDURATION property
        /// in the HLS output. For example, use PT2S to indicate 2 seconds. Leave the value empty for encoding live events.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "ISO 8601 time duration of the key frame interval duration of the input. This value sets the EXT-X-TARGETDURATION property in the HLS output. For example, use PT2S to indicate 2 seconds. Leave the value empty for encoding live events.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"ISO 8601 time duration of the key frame interval duration of the input. This value sets the EXT-X-TARGETDURATION property in the HLS output. For example, use PT2S to indicate 2 seconds. Leave the value empty for encoding live events.",
        SerializedName = @"keyFrameIntervalDuration",
        PossibleTypes = new [] { typeof(string) })]
        public string InputKeyFrameIntervalDuration { get => _parametersBody.InputKeyFrameIntervalDuration ?? null; set => _parametersBody.InputKeyFrameIntervalDuration = value; }

        /// <summary>Backing field for <see cref="InputObject" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.IMediaServicesIdentity _inputObject;

        /// <summary>Identity Parameter</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "Identity Parameter", ValueFromPipeline = true)]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Path)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.IMediaServicesIdentity InputObject { get => this._inputObject; set => this._inputObject = value; }

        /// <summary>
        /// The input protocol for the live event. This is specified at creation time and cannot be updated.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The input protocol for the live event. This is specified at creation time and cannot be updated.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The input protocol for the live event. This is specified at creation time and cannot be updated.",
        SerializedName = @"streamingProtocol",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventInputProtocol) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventInputProtocol))]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventInputProtocol InputStreamingProtocol { get => _parametersBody.InputStreamingProtocol ?? ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.LiveEventInputProtocol)""); set => _parametersBody.InputStreamingProtocol = value; }

        /// <summary>Accessor for our copy of the InvocationInfo.</summary>
        public global::System.Management.Automation.InvocationInfo InvocationInformation { get => __invocationInfo = __invocationInfo ?? this.MyInvocation ; set { __invocationInfo = value; } }

        /// <summary>The geo-location where the resource lives</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The geo-location where the resource lives")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The geo-location where the resource lives",
        SerializedName = @"location",
        PossibleTypes = new [] { typeof(string) })]
        public string Location { get => _parametersBody.Location ?? null; set => _parametersBody.Location = value; }

        /// <summary>
        /// <see cref="Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener" /> cancellation delegate. Stops the cmdlet when called.
        /// </summary>
        global::System.Action Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener.Cancel => _cancellationTokenSource.Cancel;

        /// <summary><see cref="Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener" /> cancellation token.</summary>
        global::System.Threading.CancellationToken Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener.Token => _cancellationTokenSource.Token;

        /// <summary>
        /// when specified, will make the remote call, and return an AsyncOperationResponse, letting the remote operation continue
        /// asynchronously.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Run the command asynchronously")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter NoWait { get; set; }

        /// <summary>
        /// The instance of the <see cref="Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.HttpPipeline" /> that the remote call will use.
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.HttpPipeline Pipeline { get; set; }

        /// <summary>The IP allow list.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The IP allow list.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The IP allow list.",
        SerializedName = @"allow",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IIPRange) })]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IIPRange[] PreviewAccessControlIPAllow { get => _parametersBody.PreviewAccessControlIPAllow ?? null /* arrayOf */; set => _parametersBody.PreviewAccessControlIPAllow = value; }

        /// <summary>
        /// An alternative media identifier associated with the streaming locator created for the preview. This value is specified
        /// at creation time and cannot be updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate
        /// of the StreamingPolicy specified in the StreamingPolicyName field.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "An alternative media identifier associated with the streaming locator created for the preview. This value is specified at creation time and cannot be updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"An alternative media identifier associated with the streaming locator created for the preview. This value is specified at creation time and cannot be updated. The identifier can be used in the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the StreamingPolicyName field.",
        SerializedName = @"alternativeMediaId",
        PossibleTypes = new [] { typeof(string) })]
        public string PreviewAlternativeMediaId { get => _parametersBody.PreviewAlternativeMediaId ?? null; set => _parametersBody.PreviewAlternativeMediaId = value; }

        /// <summary>
        /// The endpoints for preview. Do not share the preview URL with the live event audience.
        /// </summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The endpoints for preview. Do not share the preview URL with the live event audience.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The endpoints for preview. Do not share the preview URL with the live event audience.",
        SerializedName = @"endpoints",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ILiveEventEndpoint) })]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ILiveEventEndpoint[] PreviewEndpoint { get => _parametersBody.PreviewEndpoint ?? null /* arrayOf */; set => _parametersBody.PreviewEndpoint = value; }

        /// <summary>
        /// The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview
        /// locator url before the event is created. If omitted, the service will generate a random identifier. This value cannot
        /// be updated once the live event is created.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. This value cannot be updated once the live event is created.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The identifier of the preview locator in Guid format. Specifying this at creation time allows the caller to know the preview locator url before the event is created. If omitted, the service will generate a random identifier. This value cannot be updated once the live event is created.",
        SerializedName = @"previewLocator",
        PossibleTypes = new [] { typeof(string) })]
        public string PreviewLocator { get => _parametersBody.PreviewLocator ?? null; set => _parametersBody.PreviewLocator = value; }

        /// <summary>
        /// The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of streaming policy used for the live event preview. This value is specified at creation time and cannot be updated.",
        SerializedName = @"streamingPolicyName",
        PossibleTypes = new [] { typeof(string) })]
        public string PreviewStreamingPolicyName { get => _parametersBody.PreviewStreamingPolicyName ?? null; set => _parametersBody.PreviewStreamingPolicyName = value; }

        /// <summary>The URI for the proxy server to use</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "The URI for the proxy server to use")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Runtime)]
        public global::System.Uri Proxy { get; set; }

        /// <summary>Credentials for a proxy server to use for the remote call</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Credentials for a proxy server to use for the remote call")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Runtime)]
        public global::System.Management.Automation.PSCredential ProxyCredential { get; set; }

        /// <summary>Use the default credentials for the proxy</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Use the default credentials for the proxy")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter ProxyUseDefaultCredentials { get; set; }

        /// <summary>
        /// The options to use for the LiveEvent. This value is specified at creation time and cannot be updated. The valid values
        /// for the array entry values are 'Default' and 'LowLatency'.
        /// </summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The options to use for the LiveEvent. This value is specified at creation time and cannot be updated. The valid values for the array entry values are 'Default' and 'LowLatency'.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The options to use for the LiveEvent. This value is specified at creation time and cannot be updated. The valid values for the array entry values are 'Default' and 'LowLatency'.",
        SerializedName = @"streamOptions",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.StreamOptionsFlag) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.StreamOptionsFlag))]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.StreamOptionsFlag[] StreamOption { get => _parametersBody.StreamOption ?? null /* arrayOf */; set => _parametersBody.StreamOption = value; }

        /// <summary>Resource tags.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ExportAs(typeof(global::System.Collections.Hashtable))]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Resource tags.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource tags.",
        SerializedName = @"tags",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ITrackedResourceTags) })]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ITrackedResourceTags Tag { get => _parametersBody.Tag ?? null /* object */; set => _parametersBody.Tag = value; }

        /// <summary>
        /// Live transcription settings for the live event. See https://go.microsoft.com/fwlink/linkid=2133742 for more information
        /// about the live transcription feature.
        /// </summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Live transcription settings for the live event. See https://go.microsoft.com/fwlink/linkid=2133742 for more information about the live transcription feature.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Live transcription settings for the live event. See https://go.microsoft.com/fwlink/linkid=2133742 for more information about the live transcription feature.",
        SerializedName = @"transcriptions",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ILiveEventTranscription) })]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ILiveEventTranscription[] Transcription { get => _parametersBody.Transcription ?? null /* arrayOf */; set => _parametersBody.Transcription = value; }

        /// <summary>
        /// Specifies whether a static hostname would be assigned to the live event preview and ingest endpoints. This value can only
        /// be updated if the live event is in Standby state
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies whether a static hostname would be assigned to the live event preview and ingest endpoints. This value can only be updated if the live event is in Standby state")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Category(global::Microsoft.Azure.PowerShell.Cmdlets.MediaServices.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether a static hostname would be assigned to the live event preview and ingest endpoints. This value can only be updated if the live event is in Standby state",
        SerializedName = @"useStaticHostname",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter UseStaticHostname { get => _parametersBody.UseStaticHostname ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.UseStaticHostname = value; }

        /// <summary>
        /// <c>overrideOnDefault</c> will be called before the regular onDefault has been processed, allowing customization of what
        /// happens on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IErrorResponse">Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IErrorResponse</see>
        /// from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onDefault method should be processed, or if the method should
        /// return immediately (set to true to skip further processing )</param>

        partial void overrideOnDefault(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IErrorResponse> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// <c>overrideOnOk</c> will be called before the regular onOk has been processed, allowing customization of what happens
        /// on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ILiveEvent">Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ILiveEvent</see>
        /// from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onOk method should be processed, or if the method should return
        /// immediately (set to true to skip further processing )</param>

        partial void overrideOnOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ILiveEvent> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// (overrides the default BeginProcessing method in global::System.Management.Automation.PSCmdlet)
        /// </summary>
        protected override void BeginProcessing()
        {
            var telemetryId = Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Module.Instance.GetTelemetryId.Invoke();
            if (telemetryId != "" && telemetryId != "internal")
            {
                __correlationId = telemetryId;
            }
            Module.Instance.SetProxyConfiguration(Proxy, ProxyCredential, ProxyUseDefaultCredentials);
            if (Break)
            {
                Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.AttachDebugger.Break();
            }
            ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Events.CmdletBeginProcessing).Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
        }

        /// <summary>Creates a duplicate instance of this cmdlet (via JSON serialization).</summary>
        /// <returns>
        /// a duplicate instance of UpdateAzMediaServicesLiveEvent_UpdateViaIdentityExpanded
        /// </returns>
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Cmdlets.UpdateAzMediaServicesLiveEvent_UpdateViaIdentityExpanded Clone()
        {
            var clone = new UpdateAzMediaServicesLiveEvent_UpdateViaIdentityExpanded();
            clone.__correlationId = this.__correlationId;
            clone.__processRecordId = this.__processRecordId;
            clone.DefaultProfile = this.DefaultProfile;
            clone.InvocationInformation = this.InvocationInformation;
            clone.Proxy = this.Proxy;
            clone.Pipeline = this.Pipeline;
            clone.AsJob = this.AsJob;
            clone.Break = this.Break;
            clone.ProxyCredential = this.ProxyCredential;
            clone.ProxyUseDefaultCredentials = this.ProxyUseDefaultCredentials;
            clone.HttpPipelinePrepend = this.HttpPipelinePrepend;
            clone.HttpPipelineAppend = this.HttpPipelineAppend;
            clone._parametersBody = this._parametersBody;
            return clone;
        }

        /// <summary>Performs clean-up after the command execution</summary>
        protected override void EndProcessing()
        {

        }

        /// <summary>Handles/Dispatches events during the call to the REST service.</summary>
        /// <param name="id">The message id</param>
        /// <param name="token">The message cancellation token. When this call is cancelled, this should be <c>true</c></param>
        /// <param name="messageData">Detailed message data for the message event.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the message is completed.
        /// </returns>
         async global::System.Threading.Tasks.Task Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener.Signal(string id, global::System.Threading.CancellationToken token, global::System.Func<Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.EventData> messageData)
        {
            using( NoSynchronizationContext )
            {
                if (token.IsCancellationRequested)
                {
                    return ;
                }

                switch ( id )
                {
                    case Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Events.Verbose:
                    {
                        WriteVerbose($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Events.Warning:
                    {
                        WriteWarning($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Events.Information:
                    {
                        // When an operation supports asjob, Information messages must go thru verbose.
                        WriteVerbose($"INFORMATION: {(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Events.Debug:
                    {
                        WriteDebug($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Events.Error:
                    {
                        WriteError(new global::System.Management.Automation.ErrorRecord( new global::System.Exception(messageData().Message), string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null ) );
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Events.DelayBeforePolling:
                    {
                        if (true == MyInvocation?.BoundParameters?.ContainsKey("NoWait"))
                        {
                            var data = messageData();
                            if (data.ResponseMessage is System.Net.Http.HttpResponseMessage response)
                            {
                                var asyncOperation = response.GetFirstHeader(@"Azure-AsyncOperation");
                                var location = response.GetFirstHeader(@"Location");
                                var uri = global::System.String.IsNullOrEmpty(asyncOperation) ? global::System.String.IsNullOrEmpty(location) ? response.RequestMessage.RequestUri.AbsoluteUri : location : asyncOperation;
                                WriteObject(new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.PowerShell.AsyncOperationResponse { Target = uri });
                                // do nothing more.
                                data.Cancel();
                                return;
                            }
                        }
                        break;
                    }
                }
                await Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Module.Instance.Signal(id, token, messageData, (i,t,m) => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Signal(i,t,()=> Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.EventDataConverter.ConvertFrom( m() ) as Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.EventData ), InvocationInformation, this.ParameterSetName, __correlationId, __processRecordId, null );
                if (token.IsCancellationRequested)
                {
                    return ;
                }
                WriteDebug($"{id}: {(messageData().Message ?? global::System.String.Empty)}");
            }
        }

        /// <summary>Performs execution of the command.</summary>
        protected override void ProcessRecord()
        {
            ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Events.CmdletProcessRecordStart).Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
            __processRecordId = System.Guid.NewGuid().ToString();
            try
            {
                // work
                if (ShouldProcess($"Call remote 'LiveEventsUpdate' operation"))
                {
                    if (true == MyInvocation?.BoundParameters?.ContainsKey("AsJob"))
                    {
                        var instance = this.Clone();
                        var job = new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.PowerShell.AsyncJob(instance, this.MyInvocation.Line, this.MyInvocation.MyCommand.Name, this._cancellationTokenSource.Token, this._cancellationTokenSource.Cancel);
                        JobRepository.Add(job);
                        var task = instance.ProcessRecordAsync();
                        job.Monitor(task);
                        WriteObject(job);
                    }
                    else
                    {
                        using( var asyncCommandRuntime = new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.PowerShell.AsyncCommandRuntime(this, ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Token) )
                        {
                            asyncCommandRuntime.Wait( ProcessRecordAsync(),((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Token);
                        }
                    }
                }
            }
            catch (global::System.AggregateException aggregateException)
            {
                // unroll the inner exceptions to get the root cause
                foreach( var innerException in aggregateException.Flatten().InnerExceptions )
                {
                    ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Events.CmdletException, $"{innerException.GetType().Name} - {innerException.Message} : {innerException.StackTrace}").Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    // Write exception out to error channel.
                    WriteError( new global::System.Management.Automation.ErrorRecord(innerException,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
                }
            }
            catch (global::System.Exception exception) when ((exception as System.Management.Automation.PipelineStoppedException)== null || (exception as System.Management.Automation.PipelineStoppedException).InnerException != null)
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Events.CmdletException, $"{exception.GetType().Name} - {exception.Message} : {exception.StackTrace}").Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                // Write exception out to error channel.
                WriteError( new global::System.Management.Automation.ErrorRecord(exception,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
            }
            finally
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Events.CmdletProcessRecordEnd).Wait();
            }
        }

        /// <summary>Performs execution of the command, working asynchronously if required.</summary>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        protected async global::System.Threading.Tasks.Task ProcessRecordAsync()
        {
            using( NoSynchronizationContext )
            {
                await ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Events.CmdletGetPipeline); if( ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                Pipeline = Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Module.Instance.CreatePipeline(InvocationInformation, __correlationId, __processRecordId, this.ParameterSetName);
                if (null != HttpPipelinePrepend)
                {
                    Pipeline.Prepend((this.CommandRuntime as Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelinePrepend) ?? HttpPipelinePrepend);
                }
                if (null != HttpPipelineAppend)
                {
                    Pipeline.Append((this.CommandRuntime as Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelineAppend) ?? HttpPipelineAppend);
                }
                // get the client instance
                try
                {
                    await ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Events.CmdletBeforeAPICall); if( ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    if (InputObject?.Id != null)
                    {
                        await this.Client.LiveEventsUpdateViaIdentity(InputObject.Id, _parametersBody, onOk, onDefault, this, Pipeline);
                    }
                    else
                    {
                        // try to call with PATH parameters from Input Object
                        if (null == InputObject.SubscriptionId)
                        {
                            ThrowTerminatingError( new global::System.Management.Automation.ErrorRecord(new global::System.Exception("InputObject has null value for InputObject.SubscriptionId"),string.Empty, global::System.Management.Automation.ErrorCategory.InvalidArgument, InputObject) );
                        }
                        if (null == InputObject.ResourceGroupName)
                        {
                            ThrowTerminatingError( new global::System.Management.Automation.ErrorRecord(new global::System.Exception("InputObject has null value for InputObject.ResourceGroupName"),string.Empty, global::System.Management.Automation.ErrorCategory.InvalidArgument, InputObject) );
                        }
                        if (null == InputObject.AccountName)
                        {
                            ThrowTerminatingError( new global::System.Management.Automation.ErrorRecord(new global::System.Exception("InputObject has null value for InputObject.AccountName"),string.Empty, global::System.Management.Automation.ErrorCategory.InvalidArgument, InputObject) );
                        }
                        if (null == InputObject.LiveEventName)
                        {
                            ThrowTerminatingError( new global::System.Management.Automation.ErrorRecord(new global::System.Exception("InputObject has null value for InputObject.LiveEventName"),string.Empty, global::System.Management.Automation.ErrorCategory.InvalidArgument, InputObject) );
                        }
                        await this.Client.LiveEventsUpdate(InputObject.SubscriptionId ?? null, InputObject.ResourceGroupName ?? null, InputObject.AccountName ?? null, InputObject.LiveEventName ?? null, _parametersBody, onOk, onDefault, this, Pipeline);
                    }
                    await ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Events.CmdletAfterAPICall); if( ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                }
                catch (Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.UndeclaredResponseException urexception)
                {
                    WriteError(new global::System.Management.Automation.ErrorRecord(urexception, urexception.StatusCode.ToString(), global::System.Management.Automation.ErrorCategory.InvalidOperation, new {  body=_parametersBody})
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(urexception.Message) { RecommendedAction = urexception.Action }
                    });
                }
                finally
                {
                    await ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Events.CmdletProcessRecordAsyncEnd);
                }
            }
        }

        /// <summary>Interrupts currently running code within the command.</summary>
        protected override void StopProcessing()
        {
            ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener)this).Cancel();
            base.StopProcessing();
        }

        /// <summary>
        /// Intializes a new instance of the <see cref="UpdateAzMediaServicesLiveEvent_UpdateViaIdentityExpanded" /> cmdlet class.
        /// </summary>
        public UpdateAzMediaServicesLiveEvent_UpdateViaIdentityExpanded()
        {

        }

        /// <summary>
        /// a delegate that is called when the remote service returns default (any response code not handled elsewhere).
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IErrorResponse">Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IErrorResponse</see>
        /// from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onDefault(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IErrorResponse> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnDefault(responseMessage, response, ref _returnNow);
                // if overrideOnDefault has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // Error Response : default
                var code = (await response)?.Code;
                var message = (await response)?.Message;
                if ((null == code || null == message))
                {
                    // Unrecognized Response. Create an error record based on what we have.
                    var ex = new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IErrorResponse>(responseMessage, await response);
                    WriteError( new global::System.Management.Automation.ErrorRecord(ex, ex.Code, global::System.Management.Automation.ErrorCategory.InvalidOperation, new { body=_parametersBody })
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(ex.Message) { RecommendedAction = ex.Action }
                    });
                }
                else
                {
                    WriteError( new global::System.Management.Automation.ErrorRecord(new global::System.Exception($"[{code}] : {message}"), code?.ToString(), global::System.Management.Automation.ErrorCategory.InvalidOperation, new { body=_parametersBody })
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(message) { RecommendedAction = global::System.String.Empty }
                    });
                }
            }
        }

        /// <summary>a delegate that is called when the remote service returns 200 (OK).</summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ILiveEvent">Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ILiveEvent</see>
        /// from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ILiveEvent> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnOk(responseMessage, response, ref _returnNow);
                // if overrideOnOk has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // onOk - response for 200 / application/json
                // (await response) // should be Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ILiveEvent
                WriteObject((await response));
            }
        }
    }
}