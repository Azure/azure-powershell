// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101
{
    using static Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Extensions;

    /// <summary>Class for envelope encryption scheme</summary>
    public partial class CommonEncryptionCenc :
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICommonEncryptionCenc,
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICommonEncryptionCencInternal
    {

        /// <summary>Backing field for <see cref="ClearTrack" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection[] _clearTrack;

        /// <summary>Representing which tracks should not be encrypted</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection[] ClearTrack { get => this._clearTrack; set => this._clearTrack = value; }

        /// <summary>Backing field for <see cref="ContentKey" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeys _contentKey;

        /// <summary>
        /// Representing default content key for each encryption scheme and separate content keys for specific tracks
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeys ContentKey { get => (this._contentKey = this._contentKey ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.StreamingPolicyContentKeys()); set => this._contentKey = value; }

        /// <summary>Representing tracks needs separate content key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey[] ContentKeyToTrackMapping { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeysInternal)ContentKey).KeyToTrackMapping; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeysInternal)ContentKey).KeyToTrackMapping = value ?? null /* arrayOf */; }

        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string DefaultKeyLabel { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeysInternal)ContentKey).DefaultKeyLabel; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeysInternal)ContentKey).DefaultKeyLabel = value ?? null; }

        /// <summary>Policy used by Default Key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string DefaultKeyPolicyName { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeysInternal)ContentKey).DefaultKeyPolicyName; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeysInternal)ContentKey).DefaultKeyPolicyName = value ?? null; }

        /// <summary>Backing field for <see cref="Drm" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICencDrmConfiguration _drm;

        /// <summary>Configuration of DRMs for CommonEncryptionCenc encryption scheme</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICencDrmConfiguration Drm { get => (this._drm = this._drm ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.CencDrmConfiguration()); set => this._drm = value; }

        /// <summary>Backing field for <see cref="EnabledProtocol" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocols _enabledProtocol;

        /// <summary>Representing supported protocols</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocols EnabledProtocol { get => (this._enabledProtocol = this._enabledProtocol ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.EnabledProtocols()); set => this._enabledProtocol = value; }

        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? EnabledProtocolDash { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocolsInternal)EnabledProtocol).Dash; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocolsInternal)EnabledProtocol).Dash = value ?? default(bool); }

        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? EnabledProtocolDownload { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocolsInternal)EnabledProtocol).Download; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocolsInternal)EnabledProtocol).Download = value ?? default(bool); }

        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? EnabledProtocolHl { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocolsInternal)EnabledProtocol).Hl; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocolsInternal)EnabledProtocol).Hl = value ?? default(bool); }

        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? EnabledProtocolSmoothStreaming { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocolsInternal)EnabledProtocol).SmoothStreaming; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocolsInternal)EnabledProtocol).SmoothStreaming = value ?? default(bool); }

        /// <summary>Internal Acessors for ContentKey</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeys Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICommonEncryptionCencInternal.ContentKey { get => (this._contentKey = this._contentKey ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.StreamingPolicyContentKeys()); set { {_contentKey = value;} } }

        /// <summary>Internal Acessors for ContentKeyDefaultKey</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IDefaultKey Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICommonEncryptionCencInternal.ContentKeyDefaultKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeysInternal)ContentKey).DefaultKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeysInternal)ContentKey).DefaultKey = value; }

        /// <summary>Internal Acessors for Drm</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICencDrmConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICommonEncryptionCencInternal.Drm { get => (this._drm = this._drm ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.CencDrmConfiguration()); set { {_drm = value;} } }

        /// <summary>Internal Acessors for DrmPlayReady</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPlayReadyConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICommonEncryptionCencInternal.DrmPlayReady { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICencDrmConfigurationInternal)Drm).PlayReady; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICencDrmConfigurationInternal)Drm).PlayReady = value; }

        /// <summary>Internal Acessors for DrmWidevine</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyWidevineConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICommonEncryptionCencInternal.DrmWidevine { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICencDrmConfigurationInternal)Drm).Widevine; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICencDrmConfigurationInternal)Drm).Widevine = value; }

        /// <summary>Internal Acessors for EnabledProtocol</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocols Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICommonEncryptionCencInternal.EnabledProtocol { get => (this._enabledProtocol = this._enabledProtocol ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.EnabledProtocols()); set { {_enabledProtocol = value;} } }

        /// <summary>Custom attributes for PlayReady</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string PlayReadyCustomAttribute { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICencDrmConfigurationInternal)Drm).PlayReadyCustomAttribute; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICencDrmConfigurationInternal)Drm).PlayReadyCustomAttribute = value ?? null; }

        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string PlayReadyCustomLicenseAcquisitionUrlTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICencDrmConfigurationInternal)Drm).PlayReadyCustomLicenseAcquisitionUrlTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICencDrmConfigurationInternal)Drm).PlayReadyCustomLicenseAcquisitionUrlTemplate = value ?? null; }

        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string WidevineCustomLicenseAcquisitionUrlTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICencDrmConfigurationInternal)Drm).WidevineCustomLicenseAcquisitionUrlTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICencDrmConfigurationInternal)Drm).WidevineCustomLicenseAcquisitionUrlTemplate = value ?? null; }

        /// <summary>Creates an new <see cref="CommonEncryptionCenc" /> instance.</summary>
        public CommonEncryptionCenc()
        {

        }
    }
    /// Class for envelope encryption scheme
    public partial interface ICommonEncryptionCenc :
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IJsonSerializable
    {
        /// <summary>Representing which tracks should not be encrypted</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Representing which tracks should not be encrypted",
        SerializedName = @"clearTracks",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection[] ClearTrack { get; set; }
        /// <summary>Representing tracks needs separate content key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Representing tracks needs separate content key",
        SerializedName = @"keyToTrackMappings",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey[] ContentKeyToTrackMapping { get; set; }
        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Label can be used to specify Content Key when creating a Streaming Locator",
        SerializedName = @"label",
        PossibleTypes = new [] { typeof(string) })]
        string DefaultKeyLabel { get; set; }
        /// <summary>Policy used by Default Key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Policy used by Default Key",
        SerializedName = @"policyName",
        PossibleTypes = new [] { typeof(string) })]
        string DefaultKeyPolicyName { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable DASH protocol or not",
        SerializedName = @"dash",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnabledProtocolDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable Download protocol or not",
        SerializedName = @"download",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnabledProtocolDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable HLS protocol or not",
        SerializedName = @"hls",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnabledProtocolHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable SmoothStreaming protocol or not",
        SerializedName = @"smoothStreaming",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnabledProtocolSmoothStreaming { get; set; }
        /// <summary>Custom attributes for PlayReady</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Custom attributes for PlayReady",
        SerializedName = @"playReadyCustomAttributes",
        PossibleTypes = new [] { typeof(string) })]
        string PlayReadyCustomAttribute { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.",
        SerializedName = @"customLicenseAcquisitionUrlTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string PlayReadyCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.",
        SerializedName = @"customLicenseAcquisitionUrlTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string WidevineCustomLicenseAcquisitionUrlTemplate { get; set; }

    }
    /// Class for envelope encryption scheme
    internal partial interface ICommonEncryptionCencInternal

    {
        /// <summary>Representing which tracks should not be encrypted</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection[] ClearTrack { get; set; }
        /// <summary>
        /// Representing default content key for each encryption scheme and separate content keys for specific tracks
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeys ContentKey { get; set; }
        /// <summary>Default content key for an encryption scheme</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IDefaultKey ContentKeyDefaultKey { get; set; }
        /// <summary>Representing tracks needs separate content key</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey[] ContentKeyToTrackMapping { get; set; }
        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        string DefaultKeyLabel { get; set; }
        /// <summary>Policy used by Default Key</summary>
        string DefaultKeyPolicyName { get; set; }
        /// <summary>Configuration of DRMs for CommonEncryptionCenc encryption scheme</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICencDrmConfiguration Drm { get; set; }
        /// <summary>PlayReady configurations</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPlayReadyConfiguration DrmPlayReady { get; set; }
        /// <summary>Widevine configurations</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyWidevineConfiguration DrmWidevine { get; set; }
        /// <summary>Representing supported protocols</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocols EnabledProtocol { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        bool? EnabledProtocolDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        bool? EnabledProtocolDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        bool? EnabledProtocolHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        bool? EnabledProtocolSmoothStreaming { get; set; }
        /// <summary>Custom attributes for PlayReady</summary>
        string PlayReadyCustomAttribute { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        string PlayReadyCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        string WidevineCustomLicenseAcquisitionUrlTemplate { get; set; }

    }
}