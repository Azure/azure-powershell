// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101
{
    using static Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Extensions;

    /// <summary>Class for EnvelopeEncryption encryption scheme</summary>
    public partial class EnvelopeEncryption :
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnvelopeEncryption,
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnvelopeEncryptionInternal
    {

        /// <summary>Backing field for <see cref="ClearTrack" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection[] _clearTrack;

        /// <summary>Representing which tracks should not be encrypted</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection[] ClearTrack { get => this._clearTrack; set => this._clearTrack = value; }

        /// <summary>Backing field for <see cref="ContentKey" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeys _contentKey;

        /// <summary>
        /// Representing default content key for each encryption scheme and separate content keys for specific tracks
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeys ContentKey { get => (this._contentKey = this._contentKey ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.StreamingPolicyContentKeys()); set => this._contentKey = value; }

        /// <summary>Representing tracks needs separate content key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey[] ContentKeyToTrackMapping { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeysInternal)ContentKey).KeyToTrackMapping; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeysInternal)ContentKey).KeyToTrackMapping = value ?? null /* arrayOf */; }

        /// <summary>Backing field for <see cref="CustomKeyAcquisitionUrlTemplate" /> property.</summary>
        private string _customKeyAcquisitionUrlTemplate;

        /// <summary>
        /// Template for the URL of the custom service delivering keys to end user players. Not required when using Azure Media Services
        /// for issuing keys. The template supports replaceable tokens that the service will update at runtime with the value specific
        /// to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId,
        /// and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        public string CustomKeyAcquisitionUrlTemplate { get => this._customKeyAcquisitionUrlTemplate; set => this._customKeyAcquisitionUrlTemplate = value; }

        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string DefaultKeyLabel { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeysInternal)ContentKey).DefaultKeyLabel; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeysInternal)ContentKey).DefaultKeyLabel = value ?? null; }

        /// <summary>Policy used by Default Key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string DefaultKeyPolicyName { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeysInternal)ContentKey).DefaultKeyPolicyName; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeysInternal)ContentKey).DefaultKeyPolicyName = value ?? null; }

        /// <summary>Backing field for <see cref="EnabledProtocol" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocols _enabledProtocol;

        /// <summary>Representing supported protocols</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocols EnabledProtocol { get => (this._enabledProtocol = this._enabledProtocol ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.EnabledProtocols()); set => this._enabledProtocol = value; }

        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? EnabledProtocolDash { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocolsInternal)EnabledProtocol).Dash; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocolsInternal)EnabledProtocol).Dash = value ?? default(bool); }

        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? EnabledProtocolDownload { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocolsInternal)EnabledProtocol).Download; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocolsInternal)EnabledProtocol).Download = value ?? default(bool); }

        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? EnabledProtocolHl { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocolsInternal)EnabledProtocol).Hl; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocolsInternal)EnabledProtocol).Hl = value ?? default(bool); }

        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? EnabledProtocolSmoothStreaming { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocolsInternal)EnabledProtocol).SmoothStreaming; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocolsInternal)EnabledProtocol).SmoothStreaming = value ?? default(bool); }

        /// <summary>Internal Acessors for ContentKey</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeys Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnvelopeEncryptionInternal.ContentKey { get => (this._contentKey = this._contentKey ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.StreamingPolicyContentKeys()); set { {_contentKey = value;} } }

        /// <summary>Internal Acessors for ContentKeyDefaultKey</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IDefaultKey Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnvelopeEncryptionInternal.ContentKeyDefaultKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeysInternal)ContentKey).DefaultKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeysInternal)ContentKey).DefaultKey = value; }

        /// <summary>Internal Acessors for EnabledProtocol</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocols Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnvelopeEncryptionInternal.EnabledProtocol { get => (this._enabledProtocol = this._enabledProtocol ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.EnabledProtocols()); set { {_enabledProtocol = value;} } }

        /// <summary>Creates an new <see cref="EnvelopeEncryption" /> instance.</summary>
        public EnvelopeEncryption()
        {

        }
    }
    /// Class for EnvelopeEncryption encryption scheme
    public partial interface IEnvelopeEncryption :
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IJsonSerializable
    {
        /// <summary>Representing which tracks should not be encrypted</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Representing which tracks should not be encrypted",
        SerializedName = @"clearTracks",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection[] ClearTrack { get; set; }
        /// <summary>Representing tracks needs separate content key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Representing tracks needs separate content key",
        SerializedName = @"keyToTrackMappings",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey[] ContentKeyToTrackMapping { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering keys to end user players. Not required when using Azure Media Services
        /// for issuing keys. The template supports replaceable tokens that the service will update at runtime with the value specific
        /// to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId,
        /// and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.",
        SerializedName = @"customKeyAcquisitionUrlTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string CustomKeyAcquisitionUrlTemplate { get; set; }
        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Label can be used to specify Content Key when creating a Streaming Locator",
        SerializedName = @"label",
        PossibleTypes = new [] { typeof(string) })]
        string DefaultKeyLabel { get; set; }
        /// <summary>Policy used by Default Key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Policy used by Default Key",
        SerializedName = @"policyName",
        PossibleTypes = new [] { typeof(string) })]
        string DefaultKeyPolicyName { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable DASH protocol or not",
        SerializedName = @"dash",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnabledProtocolDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable Download protocol or not",
        SerializedName = @"download",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnabledProtocolDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable HLS protocol or not",
        SerializedName = @"hls",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnabledProtocolHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable SmoothStreaming protocol or not",
        SerializedName = @"smoothStreaming",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnabledProtocolSmoothStreaming { get; set; }

    }
    /// Class for EnvelopeEncryption encryption scheme
    internal partial interface IEnvelopeEncryptionInternal

    {
        /// <summary>Representing which tracks should not be encrypted</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection[] ClearTrack { get; set; }
        /// <summary>
        /// Representing default content key for each encryption scheme and separate content keys for specific tracks
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeys ContentKey { get; set; }
        /// <summary>Default content key for an encryption scheme</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IDefaultKey ContentKeyDefaultKey { get; set; }
        /// <summary>Representing tracks needs separate content key</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey[] ContentKeyToTrackMapping { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering keys to end user players. Not required when using Azure Media Services
        /// for issuing keys. The template supports replaceable tokens that the service will update at runtime with the value specific
        /// to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId,
        /// and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
        /// </summary>
        string CustomKeyAcquisitionUrlTemplate { get; set; }
        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        string DefaultKeyLabel { get; set; }
        /// <summary>Policy used by Default Key</summary>
        string DefaultKeyPolicyName { get; set; }
        /// <summary>Representing supported protocols</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocols EnabledProtocol { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        bool? EnabledProtocolDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        bool? EnabledProtocolDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        bool? EnabledProtocolHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        bool? EnabledProtocolSmoothStreaming { get; set; }

    }
}