// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101
{
    using static Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Extensions;

    /// <summary>A Streaming Policy resource</summary>
    public partial class StreamingPolicy :
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicy,
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal,
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IValidates
    {
        /// <summary>
        /// Backing field for Inherited model <see cref= "Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IResource"
        /// />
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IResource __resource = new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.Resource();

        /// <summary>Representing which tracks should not be encrypted</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection[] CommonEncryptionCbcClearTrack { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcClearTrack; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcClearTrack = value ?? null /* arrayOf */; }

        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCbcsContentKeysDefaultKeyLabel { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsContentKeysDefaultKeyLabel; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsContentKeysDefaultKeyLabel = value ?? null; }

        /// <summary>Policy used by Default Key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCbcsContentKeysDefaultKeyPolicyName { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsContentKeysDefaultKeyPolicyName; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsContentKeysDefaultKeyPolicyName = value ?? null; }

        /// <summary>Representing tracks needs separate content key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey[] CommonEncryptionCbcsContentKeysKeyToTrackMapping { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsContentKeysKeyToTrackMapping; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsContentKeysKeyToTrackMapping = value ?? null /* arrayOf */; }

        /// <summary>Custom attributes for PlayReady</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCbcsDrmPlayReadyCustomAttribute { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsDrmPlayReadyCustomAttribute; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsDrmPlayReadyCustomAttribute = value ?? null; }

        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCbcsDrmPlayReadyCustomLicenseAcquisitionUrlTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsDrmPlayReadyCustomLicenseAcquisitionUrlTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsDrmPlayReadyCustomLicenseAcquisitionUrlTemplate = value ?? null; }

        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCbcsDrmWidevineCustomLicenseAcquisitionUrlTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsDrmWidevineCustomLicenseAcquisitionUrlTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsDrmWidevineCustomLicenseAcquisitionUrlTemplate = value ?? null; }

        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? CommonEncryptionCbcsEnabledProtocolsDash { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsEnabledProtocolsDash; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsEnabledProtocolsDash = value ?? default(bool); }

        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? CommonEncryptionCbcsEnabledProtocolsDownload { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsEnabledProtocolsDownload; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsEnabledProtocolsDownload = value ?? default(bool); }

        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? CommonEncryptionCbcsEnabledProtocolsHl { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsEnabledProtocolsHl; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsEnabledProtocolsHl = value ?? default(bool); }

        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? CommonEncryptionCbcsEnabledProtocolsSmoothStreaming { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsEnabledProtocolsSmoothStreaming; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsEnabledProtocolsSmoothStreaming = value ?? default(bool); }

        /// <summary>Representing which tracks should not be encrypted</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection[] CommonEncryptionCencClearTrack { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencClearTrack; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencClearTrack = value ?? null /* arrayOf */; }

        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCencContentKeysDefaultKeyLabel { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencContentKeysDefaultKeyLabel; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencContentKeysDefaultKeyLabel = value ?? null; }

        /// <summary>Policy used by Default Key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCencContentKeysDefaultKeyPolicyName { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencContentKeysDefaultKeyPolicyName; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencContentKeysDefaultKeyPolicyName = value ?? null; }

        /// <summary>Representing tracks needs separate content key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey[] CommonEncryptionCencContentKeysKeyToTrackMapping { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencContentKeysKeyToTrackMapping; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencContentKeysKeyToTrackMapping = value ?? null /* arrayOf */; }

        /// <summary>Custom attributes for PlayReady</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCencDrmPlayReadyCustomAttribute { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencDrmPlayReadyCustomAttribute; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencDrmPlayReadyCustomAttribute = value ?? null; }

        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCencDrmPlayReadyCustomLicenseAcquisitionUrlTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencDrmPlayReadyCustomLicenseAcquisitionUrlTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencDrmPlayReadyCustomLicenseAcquisitionUrlTemplate = value ?? null; }

        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string CommonEncryptionCencDrmWidevineCustomLicenseAcquisitionUrlTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencDrmWidevineCustomLicenseAcquisitionUrlTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencDrmWidevineCustomLicenseAcquisitionUrlTemplate = value ?? null; }

        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? CommonEncryptionCencEnabledProtocolsDash { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencEnabledProtocolsDash; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencEnabledProtocolsDash = value ?? default(bool); }

        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? CommonEncryptionCencEnabledProtocolsDownload { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencEnabledProtocolsDownload; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencEnabledProtocolsDownload = value ?? default(bool); }

        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? CommonEncryptionCencEnabledProtocolsHl { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencEnabledProtocolsHl; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencEnabledProtocolsHl = value ?? default(bool); }

        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? CommonEncryptionCencEnabledProtocolsSmoothStreaming { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencEnabledProtocolsSmoothStreaming; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencEnabledProtocolsSmoothStreaming = value ?? default(bool); }

        /// <summary>Creation time of Streaming Policy</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public global::System.DateTime? Created { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).Created; }

        /// <summary>Default ContentKey used by current Streaming Policy</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string DefaultContentKeyPolicyName { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).DefaultContentKeyPolicyName; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).DefaultContentKeyPolicyName = value ?? null; }

        /// <summary>Representing which tracks should not be encrypted</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection[] EnvelopeEncryptionClearTrack { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionClearTrack; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionClearTrack = value ?? null /* arrayOf */; }

        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string EnvelopeEncryptionContentKeysDefaultKeyLabel { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionContentKeysDefaultKeyLabel; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionContentKeysDefaultKeyLabel = value ?? null; }

        /// <summary>Policy used by Default Key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string EnvelopeEncryptionContentKeysDefaultKeyPolicyName { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionContentKeysDefaultKeyPolicyName; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionContentKeysDefaultKeyPolicyName = value ?? null; }

        /// <summary>Representing tracks needs separate content key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey[] EnvelopeEncryptionContentKeysKeyToTrackMapping { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionContentKeysKeyToTrackMapping; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionContentKeysKeyToTrackMapping = value ?? null /* arrayOf */; }

        /// <summary>
        /// Template for the URL of the custom service delivering keys to end user players. Not required when using Azure Media Services
        /// for issuing keys. The template supports replaceable tokens that the service will update at runtime with the value specific
        /// to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId,
        /// and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string EnvelopeEncryptionCustomKeyAcquisitionUrlTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionCustomKeyAcquisitionUrlTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionCustomKeyAcquisitionUrlTemplate = value ?? null; }

        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? EnvelopeEncryptionEnabledProtocolsDash { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionEnabledProtocolsDash; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionEnabledProtocolsDash = value ?? default(bool); }

        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? EnvelopeEncryptionEnabledProtocolsDownload { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionEnabledProtocolsDownload; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionEnabledProtocolsDownload = value ?? default(bool); }

        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? EnvelopeEncryptionEnabledProtocolsHl { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionEnabledProtocolsHl; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionEnabledProtocolsHl = value ?? default(bool); }

        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? EnvelopeEncryptionEnabledProtocolsSmoothStreaming { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionEnabledProtocolsSmoothStreaming; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionEnabledProtocolsSmoothStreaming = value ?? default(bool); }

        /// <summary>All license to be persistent or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? FairPlayAllowPersistentLicense { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).FairPlayAllowPersistentLicense; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).FairPlayAllowPersistentLicense = value ?? default(bool); }

        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string FairPlayCustomLicenseAcquisitionUrlTemplate { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).FairPlayCustomLicenseAcquisitionUrlTemplate; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).FairPlayCustomLicenseAcquisitionUrlTemplate = value ?? null; }

        /// <summary>
        /// Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inherited)]
        public string Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IResourceInternal)__resource).Id; }

        /// <summary>Internal Acessors for Id</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IResourceInternal.Id { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IResourceInternal)__resource).Id; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IResourceInternal)__resource).Id = value; }

        /// <summary>Internal Acessors for Name</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IResourceInternal.Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IResourceInternal)__resource).Name; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IResourceInternal)__resource).Name = value; }

        /// <summary>Internal Acessors for Type</summary>
        string Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IResourceInternal.Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IResourceInternal)__resource).Type; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IResourceInternal)__resource).Type = value; }

        /// <summary>Internal Acessors for CommonEncryptionCbc</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICommonEncryptionCbcs Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.CommonEncryptionCbc { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbc; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbc = value; }

        /// <summary>Internal Acessors for CommonEncryptionCbcContentKey</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeys Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.CommonEncryptionCbcContentKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcContentKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcContentKey = value; }

        /// <summary>Internal Acessors for CommonEncryptionCbcDrm</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICbcsDrmConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.CommonEncryptionCbcDrm { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcDrm; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcDrm = value; }

        /// <summary>Internal Acessors for CommonEncryptionCbcEnabledProtocol</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocols Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.CommonEncryptionCbcEnabledProtocol { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcEnabledProtocol; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcEnabledProtocol = value; }

        /// <summary>Internal Acessors for CommonEncryptionCbcsContentKeysDefaultKey</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IDefaultKey Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.CommonEncryptionCbcsContentKeysDefaultKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsContentKeysDefaultKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsContentKeysDefaultKey = value; }

        /// <summary>Internal Acessors for CommonEncryptionCbcsDrmPlayReady</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPlayReadyConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.CommonEncryptionCbcsDrmPlayReady { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsDrmPlayReady; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsDrmPlayReady = value; }

        /// <summary>Internal Acessors for CommonEncryptionCbcsDrmWidevine</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyWidevineConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.CommonEncryptionCbcsDrmWidevine { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsDrmWidevine; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCbcsDrmWidevine = value; }

        /// <summary>Internal Acessors for CommonEncryptionCenc</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICommonEncryptionCenc Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.CommonEncryptionCenc { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCenc; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCenc = value; }

        /// <summary>Internal Acessors for CommonEncryptionCencContentKey</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeys Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.CommonEncryptionCencContentKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencContentKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencContentKey = value; }

        /// <summary>Internal Acessors for CommonEncryptionCencContentKeysDefaultKey</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IDefaultKey Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.CommonEncryptionCencContentKeysDefaultKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencContentKeysDefaultKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencContentKeysDefaultKey = value; }

        /// <summary>Internal Acessors for CommonEncryptionCencDrm</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICencDrmConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.CommonEncryptionCencDrm { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencDrm; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencDrm = value; }

        /// <summary>Internal Acessors for CommonEncryptionCencDrmPlayReady</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPlayReadyConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.CommonEncryptionCencDrmPlayReady { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencDrmPlayReady; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencDrmPlayReady = value; }

        /// <summary>Internal Acessors for CommonEncryptionCencDrmWidevine</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyWidevineConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.CommonEncryptionCencDrmWidevine { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencDrmWidevine; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencDrmWidevine = value; }

        /// <summary>Internal Acessors for CommonEncryptionCencEnabledProtocol</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocols Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.CommonEncryptionCencEnabledProtocol { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencEnabledProtocol; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).CommonEncryptionCencEnabledProtocol = value; }

        /// <summary>Internal Acessors for Created</summary>
        global::System.DateTime? Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.Created { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).Created; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).Created = value; }

        /// <summary>Internal Acessors for DrmFairPlay</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyFairPlayConfiguration Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.DrmFairPlay { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).DrmFairPlay; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).DrmFairPlay = value; }

        /// <summary>Internal Acessors for EnvelopeEncryption</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnvelopeEncryption Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.EnvelopeEncryption { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryption; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryption = value; }

        /// <summary>Internal Acessors for EnvelopeEncryptionContentKey</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeys Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.EnvelopeEncryptionContentKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionContentKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionContentKey = value; }

        /// <summary>Internal Acessors for EnvelopeEncryptionContentKeysDefaultKey</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IDefaultKey Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.EnvelopeEncryptionContentKeysDefaultKey { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionContentKeysDefaultKey; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionContentKeysDefaultKey = value; }

        /// <summary>Internal Acessors for EnvelopeEncryptionEnabledProtocol</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocols Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.EnvelopeEncryptionEnabledProtocol { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionEnabledProtocol; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).EnvelopeEncryptionEnabledProtocol = value; }

        /// <summary>Internal Acessors for NoEncryption</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.INoEncryption Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.NoEncryption { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).NoEncryption; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).NoEncryption = value; }

        /// <summary>Internal Acessors for NoEncryptionEnabledProtocol</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocols Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.NoEncryptionEnabledProtocol { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).NoEncryptionEnabledProtocol; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).NoEncryptionEnabledProtocol = value; }

        /// <summary>Internal Acessors for Property</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyProperties Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.StreamingPolicyProperties()); set { {_property = value;} } }

        /// <summary>Internal Acessors for SystemData</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ISystemData Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyInternal.SystemData { get => (this._systemData = this._systemData ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.SystemData()); set { {_systemData = value;} } }

        /// <summary>The name of the resource</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inherited)]
        public string Name { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IResourceInternal)__resource).Name; }

        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? NoEncryptionEnabledProtocolsDash { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).NoEncryptionEnabledProtocolsDash; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).NoEncryptionEnabledProtocolsDash = value ?? default(bool); }

        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? NoEncryptionEnabledProtocolsDownload { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).NoEncryptionEnabledProtocolsDownload; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).NoEncryptionEnabledProtocolsDownload = value ?? default(bool); }

        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? NoEncryptionEnabledProtocolsHl { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).NoEncryptionEnabledProtocolsHl; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).NoEncryptionEnabledProtocolsHl = value ?? default(bool); }

        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public bool? NoEncryptionEnabledProtocolsSmoothStreaming { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).NoEncryptionEnabledProtocolsSmoothStreaming; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPropertiesInternal)Property).NoEncryptionEnabledProtocolsSmoothStreaming = value ?? default(bool); }

        /// <summary>Backing field for <see cref="Property" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyProperties _property;

        /// <summary>Class to specify properties of Streaming Policy</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyProperties Property { get => (this._property = this._property ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.StreamingPolicyProperties()); set => this._property = value; }

        /// <summary>Backing field for <see cref="SystemData" /> property.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ISystemData _systemData;

        /// <summary>The system metadata relating to this resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Owned)]
        internal Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ISystemData SystemData { get => (this._systemData = this._systemData ?? new Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.SystemData()); }

        /// <summary>The timestamp of resource creation (UTC).</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public global::System.DateTime? SystemDataCreatedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ISystemDataInternal)SystemData).CreatedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ISystemDataInternal)SystemData).CreatedAt = value ?? default(global::System.DateTime); }

        /// <summary>The identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string SystemDataCreatedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ISystemDataInternal)SystemData).CreatedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ISystemDataInternal)SystemData).CreatedBy = value ?? null; }

        /// <summary>The type of identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.CreatedByType? SystemDataCreatedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ISystemDataInternal)SystemData).CreatedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ISystemDataInternal)SystemData).CreatedByType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.CreatedByType)""); }

        /// <summary>The timestamp of resource last modification (UTC)</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public global::System.DateTime? SystemDataLastModifiedAt { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ISystemDataInternal)SystemData).LastModifiedAt; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ISystemDataInternal)SystemData).LastModifiedAt = value ?? default(global::System.DateTime); }

        /// <summary>The identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public string SystemDataLastModifiedBy { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ISystemDataInternal)SystemData).LastModifiedBy; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ISystemDataInternal)SystemData).LastModifiedBy = value ?? null; }

        /// <summary>The type of identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inlined)]
        public Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.CreatedByType? SystemDataLastModifiedByType { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ISystemDataInternal)SystemData).LastModifiedByType; set => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ISystemDataInternal)SystemData).LastModifiedByType = value ?? ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.CreatedByType)""); }

        /// <summary>
        /// The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Origin(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.PropertyOrigin.Inherited)]
        public string Type { get => ((Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IResourceInternal)__resource).Type; }

        /// <summary>Creates an new <see cref="StreamingPolicy" /> instance.</summary>
        public StreamingPolicy()
        {

        }

        /// <summary>Validates that this object meets the validation criteria.</summary>
        /// <param name="eventListener">an <see cref="Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener" /> instance that will receive validation
        /// events.</param>
        /// <returns>
        /// A <see cref = "global::System.Threading.Tasks.Task" /> that will be complete when validation is completed.
        /// </returns>
        public async global::System.Threading.Tasks.Task Validate(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IEventListener eventListener)
        {
            await eventListener.AssertNotNull(nameof(__resource), __resource);
            await eventListener.AssertObjectIsValid(nameof(__resource), __resource);
        }
    }
    /// A Streaming Policy resource
    public partial interface IStreamingPolicy :
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.IJsonSerializable,
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IResource
    {
        /// <summary>Representing which tracks should not be encrypted</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Representing which tracks should not be encrypted",
        SerializedName = @"clearTracks",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection[] CommonEncryptionCbcClearTrack { get; set; }
        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Label can be used to specify Content Key when creating a Streaming Locator",
        SerializedName = @"label",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCbcsContentKeysDefaultKeyLabel { get; set; }
        /// <summary>Policy used by Default Key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Policy used by Default Key",
        SerializedName = @"policyName",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCbcsContentKeysDefaultKeyPolicyName { get; set; }
        /// <summary>Representing tracks needs separate content key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Representing tracks needs separate content key",
        SerializedName = @"keyToTrackMappings",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey[] CommonEncryptionCbcsContentKeysKeyToTrackMapping { get; set; }
        /// <summary>Custom attributes for PlayReady</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Custom attributes for PlayReady",
        SerializedName = @"playReadyCustomAttributes",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCbcsDrmPlayReadyCustomAttribute { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.",
        SerializedName = @"customLicenseAcquisitionUrlTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCbcsDrmPlayReadyCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.",
        SerializedName = @"customLicenseAcquisitionUrlTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCbcsDrmWidevineCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable DASH protocol or not",
        SerializedName = @"dash",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CommonEncryptionCbcsEnabledProtocolsDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable Download protocol or not",
        SerializedName = @"download",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CommonEncryptionCbcsEnabledProtocolsDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable HLS protocol or not",
        SerializedName = @"hls",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CommonEncryptionCbcsEnabledProtocolsHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable SmoothStreaming protocol or not",
        SerializedName = @"smoothStreaming",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CommonEncryptionCbcsEnabledProtocolsSmoothStreaming { get; set; }
        /// <summary>Representing which tracks should not be encrypted</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Representing which tracks should not be encrypted",
        SerializedName = @"clearTracks",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection[] CommonEncryptionCencClearTrack { get; set; }
        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Label can be used to specify Content Key when creating a Streaming Locator",
        SerializedName = @"label",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCencContentKeysDefaultKeyLabel { get; set; }
        /// <summary>Policy used by Default Key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Policy used by Default Key",
        SerializedName = @"policyName",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCencContentKeysDefaultKeyPolicyName { get; set; }
        /// <summary>Representing tracks needs separate content key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Representing tracks needs separate content key",
        SerializedName = @"keyToTrackMappings",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey[] CommonEncryptionCencContentKeysKeyToTrackMapping { get; set; }
        /// <summary>Custom attributes for PlayReady</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Custom attributes for PlayReady",
        SerializedName = @"playReadyCustomAttributes",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCencDrmPlayReadyCustomAttribute { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.",
        SerializedName = @"customLicenseAcquisitionUrlTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCencDrmPlayReadyCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.",
        SerializedName = @"customLicenseAcquisitionUrlTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string CommonEncryptionCencDrmWidevineCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable DASH protocol or not",
        SerializedName = @"dash",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CommonEncryptionCencEnabledProtocolsDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable Download protocol or not",
        SerializedName = @"download",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CommonEncryptionCencEnabledProtocolsDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable HLS protocol or not",
        SerializedName = @"hls",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CommonEncryptionCencEnabledProtocolsHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable SmoothStreaming protocol or not",
        SerializedName = @"smoothStreaming",
        PossibleTypes = new [] { typeof(bool) })]
        bool? CommonEncryptionCencEnabledProtocolsSmoothStreaming { get; set; }
        /// <summary>Creation time of Streaming Policy</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = true,
        Description = @"Creation time of Streaming Policy",
        SerializedName = @"created",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? Created { get;  }
        /// <summary>Default ContentKey used by current Streaming Policy</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Default ContentKey used by current Streaming Policy",
        SerializedName = @"defaultContentKeyPolicyName",
        PossibleTypes = new [] { typeof(string) })]
        string DefaultContentKeyPolicyName { get; set; }
        /// <summary>Representing which tracks should not be encrypted</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Representing which tracks should not be encrypted",
        SerializedName = @"clearTracks",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection[] EnvelopeEncryptionClearTrack { get; set; }
        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Label can be used to specify Content Key when creating a Streaming Locator",
        SerializedName = @"label",
        PossibleTypes = new [] { typeof(string) })]
        string EnvelopeEncryptionContentKeysDefaultKeyLabel { get; set; }
        /// <summary>Policy used by Default Key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Policy used by Default Key",
        SerializedName = @"policyName",
        PossibleTypes = new [] { typeof(string) })]
        string EnvelopeEncryptionContentKeysDefaultKeyPolicyName { get; set; }
        /// <summary>Representing tracks needs separate content key</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Representing tracks needs separate content key",
        SerializedName = @"keyToTrackMappings",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey[] EnvelopeEncryptionContentKeysKeyToTrackMapping { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering keys to end user players. Not required when using Azure Media Services
        /// for issuing keys. The template supports replaceable tokens that the service will update at runtime with the value specific
        /// to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId,
        /// and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Template for the URL of the custom service delivering keys to end user players.  Not required when using Azure Media Services for issuing keys.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.",
        SerializedName = @"customKeyAcquisitionUrlTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string EnvelopeEncryptionCustomKeyAcquisitionUrlTemplate { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable DASH protocol or not",
        SerializedName = @"dash",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnvelopeEncryptionEnabledProtocolsDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable Download protocol or not",
        SerializedName = @"download",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnvelopeEncryptionEnabledProtocolsDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable HLS protocol or not",
        SerializedName = @"hls",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnvelopeEncryptionEnabledProtocolsHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable SmoothStreaming protocol or not",
        SerializedName = @"smoothStreaming",
        PossibleTypes = new [] { typeof(bool) })]
        bool? EnvelopeEncryptionEnabledProtocolsSmoothStreaming { get; set; }
        /// <summary>All license to be persistent or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"All license to be persistent or not",
        SerializedName = @"allowPersistentLicense",
        PossibleTypes = new [] { typeof(bool) })]
        bool? FairPlayAllowPersistentLicense { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Template for the URL of the custom service delivering licenses to end user players.  Not required when using Azure Media Services for issuing licenses.  The template supports replaceable tokens that the service will update at runtime with the value specific to the request.  The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.",
        SerializedName = @"customLicenseAcquisitionUrlTemplate",
        PossibleTypes = new [] { typeof(string) })]
        string FairPlayCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable DASH protocol or not",
        SerializedName = @"dash",
        PossibleTypes = new [] { typeof(bool) })]
        bool? NoEncryptionEnabledProtocolsDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable Download protocol or not",
        SerializedName = @"download",
        PossibleTypes = new [] { typeof(bool) })]
        bool? NoEncryptionEnabledProtocolsDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable HLS protocol or not",
        SerializedName = @"hls",
        PossibleTypes = new [] { typeof(bool) })]
        bool? NoEncryptionEnabledProtocolsHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enable SmoothStreaming protocol or not",
        SerializedName = @"smoothStreaming",
        PossibleTypes = new [] { typeof(bool) })]
        bool? NoEncryptionEnabledProtocolsSmoothStreaming { get; set; }
        /// <summary>The timestamp of resource creation (UTC).</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The timestamp of resource creation (UTC).",
        SerializedName = @"createdAt",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? SystemDataCreatedAt { get; set; }
        /// <summary>The identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The identity that created the resource.",
        SerializedName = @"createdBy",
        PossibleTypes = new [] { typeof(string) })]
        string SystemDataCreatedBy { get; set; }
        /// <summary>The type of identity that created the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The type of identity that created the resource.",
        SerializedName = @"createdByType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.CreatedByType) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.CreatedByType? SystemDataCreatedByType { get; set; }
        /// <summary>The timestamp of resource last modification (UTC)</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The timestamp of resource last modification (UTC)",
        SerializedName = @"lastModifiedAt",
        PossibleTypes = new [] { typeof(global::System.DateTime) })]
        global::System.DateTime? SystemDataLastModifiedAt { get; set; }
        /// <summary>The identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The identity that last modified the resource.",
        SerializedName = @"lastModifiedBy",
        PossibleTypes = new [] { typeof(string) })]
        string SystemDataLastModifiedBy { get; set; }
        /// <summary>The type of identity that last modified the resource.</summary>
        [Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The type of identity that last modified the resource.",
        SerializedName = @"lastModifiedByType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.CreatedByType) })]
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.CreatedByType? SystemDataLastModifiedByType { get; set; }

    }
    /// A Streaming Policy resource
    internal partial interface IStreamingPolicyInternal :
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.IResourceInternal
    {
        /// <summary>Configuration of CommonEncryptionCbcs</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICommonEncryptionCbcs CommonEncryptionCbc { get; set; }
        /// <summary>Representing which tracks should not be encrypted</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection[] CommonEncryptionCbcClearTrack { get; set; }
        /// <summary>
        /// Representing default content key for each encryption scheme and separate content keys for specific tracks
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeys CommonEncryptionCbcContentKey { get; set; }
        /// <summary>Configuration of DRMs for current encryption scheme</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICbcsDrmConfiguration CommonEncryptionCbcDrm { get; set; }
        /// <summary>Representing supported protocols</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocols CommonEncryptionCbcEnabledProtocol { get; set; }
        /// <summary>Default content key for an encryption scheme</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IDefaultKey CommonEncryptionCbcsContentKeysDefaultKey { get; set; }
        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        string CommonEncryptionCbcsContentKeysDefaultKeyLabel { get; set; }
        /// <summary>Policy used by Default Key</summary>
        string CommonEncryptionCbcsContentKeysDefaultKeyPolicyName { get; set; }
        /// <summary>Representing tracks needs separate content key</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey[] CommonEncryptionCbcsContentKeysKeyToTrackMapping { get; set; }
        /// <summary>PlayReady configurations</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPlayReadyConfiguration CommonEncryptionCbcsDrmPlayReady { get; set; }
        /// <summary>Custom attributes for PlayReady</summary>
        string CommonEncryptionCbcsDrmPlayReadyCustomAttribute { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        string CommonEncryptionCbcsDrmPlayReadyCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>Widevine configurations</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyWidevineConfiguration CommonEncryptionCbcsDrmWidevine { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        string CommonEncryptionCbcsDrmWidevineCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        bool? CommonEncryptionCbcsEnabledProtocolsDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        bool? CommonEncryptionCbcsEnabledProtocolsDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        bool? CommonEncryptionCbcsEnabledProtocolsHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        bool? CommonEncryptionCbcsEnabledProtocolsSmoothStreaming { get; set; }
        /// <summary>Configuration of CommonEncryptionCenc</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICommonEncryptionCenc CommonEncryptionCenc { get; set; }
        /// <summary>Representing which tracks should not be encrypted</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection[] CommonEncryptionCencClearTrack { get; set; }
        /// <summary>
        /// Representing default content key for each encryption scheme and separate content keys for specific tracks
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeys CommonEncryptionCencContentKey { get; set; }
        /// <summary>Default content key for an encryption scheme</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IDefaultKey CommonEncryptionCencContentKeysDefaultKey { get; set; }
        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        string CommonEncryptionCencContentKeysDefaultKeyLabel { get; set; }
        /// <summary>Policy used by Default Key</summary>
        string CommonEncryptionCencContentKeysDefaultKeyPolicyName { get; set; }
        /// <summary>Representing tracks needs separate content key</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey[] CommonEncryptionCencContentKeysKeyToTrackMapping { get; set; }
        /// <summary>Configuration of DRMs for CommonEncryptionCenc encryption scheme</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ICencDrmConfiguration CommonEncryptionCencDrm { get; set; }
        /// <summary>PlayReady configurations</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyPlayReadyConfiguration CommonEncryptionCencDrmPlayReady { get; set; }
        /// <summary>Custom attributes for PlayReady</summary>
        string CommonEncryptionCencDrmPlayReadyCustomAttribute { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        string CommonEncryptionCencDrmPlayReadyCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>Widevine configurations</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyWidevineConfiguration CommonEncryptionCencDrmWidevine { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        string CommonEncryptionCencDrmWidevineCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>Representing supported protocols</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocols CommonEncryptionCencEnabledProtocol { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        bool? CommonEncryptionCencEnabledProtocolsDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        bool? CommonEncryptionCencEnabledProtocolsDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        bool? CommonEncryptionCencEnabledProtocolsHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        bool? CommonEncryptionCencEnabledProtocolsSmoothStreaming { get; set; }
        /// <summary>Creation time of Streaming Policy</summary>
        global::System.DateTime? Created { get; set; }
        /// <summary>Default ContentKey used by current Streaming Policy</summary>
        string DefaultContentKeyPolicyName { get; set; }
        /// <summary>FairPlay configurations</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyFairPlayConfiguration DrmFairPlay { get; set; }
        /// <summary>Configuration of EnvelopeEncryption</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnvelopeEncryption EnvelopeEncryption { get; set; }
        /// <summary>Representing which tracks should not be encrypted</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.ITrackSelection[] EnvelopeEncryptionClearTrack { get; set; }
        /// <summary>
        /// Representing default content key for each encryption scheme and separate content keys for specific tracks
        /// </summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKeys EnvelopeEncryptionContentKey { get; set; }
        /// <summary>Default content key for an encryption scheme</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IDefaultKey EnvelopeEncryptionContentKeysDefaultKey { get; set; }
        /// <summary>Label can be used to specify Content Key when creating a Streaming Locator</summary>
        string EnvelopeEncryptionContentKeysDefaultKeyLabel { get; set; }
        /// <summary>Policy used by Default Key</summary>
        string EnvelopeEncryptionContentKeysDefaultKeyPolicyName { get; set; }
        /// <summary>Representing tracks needs separate content key</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyContentKey[] EnvelopeEncryptionContentKeysKeyToTrackMapping { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering keys to end user players. Not required when using Azure Media Services
        /// for issuing keys. The template supports replaceable tokens that the service will update at runtime with the value specific
        /// to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId,
        /// and {ContentKeyId}, which is replaced with the value of identifier of the key being requested.
        /// </summary>
        string EnvelopeEncryptionCustomKeyAcquisitionUrlTemplate { get; set; }
        /// <summary>Representing supported protocols</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocols EnvelopeEncryptionEnabledProtocol { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        bool? EnvelopeEncryptionEnabledProtocolsDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        bool? EnvelopeEncryptionEnabledProtocolsDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        bool? EnvelopeEncryptionEnabledProtocolsHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        bool? EnvelopeEncryptionEnabledProtocolsSmoothStreaming { get; set; }
        /// <summary>All license to be persistent or not</summary>
        bool? FairPlayAllowPersistentLicense { get; set; }
        /// <summary>
        /// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media
        /// Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the
        /// value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the
        /// value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of
        /// the key being requested.
        /// </summary>
        string FairPlayCustomLicenseAcquisitionUrlTemplate { get; set; }
        /// <summary>Configurations of NoEncryption</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.INoEncryption NoEncryption { get; set; }
        /// <summary>Representing supported protocols</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IEnabledProtocols NoEncryptionEnabledProtocol { get; set; }
        /// <summary>Enable DASH protocol or not</summary>
        bool? NoEncryptionEnabledProtocolsDash { get; set; }
        /// <summary>Enable Download protocol or not</summary>
        bool? NoEncryptionEnabledProtocolsDownload { get; set; }
        /// <summary>Enable HLS protocol or not</summary>
        bool? NoEncryptionEnabledProtocolsHl { get; set; }
        /// <summary>Enable SmoothStreaming protocol or not</summary>
        bool? NoEncryptionEnabledProtocolsSmoothStreaming { get; set; }
        /// <summary>Class to specify properties of Streaming Policy</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20211101.IStreamingPolicyProperties Property { get; set; }
        /// <summary>The system metadata relating to this resource.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Models.Api20.ISystemData SystemData { get; set; }
        /// <summary>The timestamp of resource creation (UTC).</summary>
        global::System.DateTime? SystemDataCreatedAt { get; set; }
        /// <summary>The identity that created the resource.</summary>
        string SystemDataCreatedBy { get; set; }
        /// <summary>The type of identity that created the resource.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.CreatedByType? SystemDataCreatedByType { get; set; }
        /// <summary>The timestamp of resource last modification (UTC)</summary>
        global::System.DateTime? SystemDataLastModifiedAt { get; set; }
        /// <summary>The identity that last modified the resource.</summary>
        string SystemDataLastModifiedBy { get; set; }
        /// <summary>The type of identity that last modified the resource.</summary>
        Microsoft.Azure.PowerShell.Cmdlets.MediaServices.Support.CreatedByType? SystemDataLastModifiedByType { get; set; }

    }
}