// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Cmdlets
{
    using static Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Extensions;
    using System;

    /// <summary>Creates or updates a managed cluster.</summary>
    /// <remarks>
    /// [OpenAPI] CreateOrUpdate=>PUT:"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}"
    /// </remarks>
    [global::System.Management.Automation.Cmdlet(global::System.Management.Automation.VerbsCommon.New, @"AzContainerServiceManagedCluster_CreateExpanded", SupportsShouldProcess = true)]
    [global::System.Management.Automation.OutputType(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedCluster))]
    [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Description(@"Creates or updates a managed cluster.")]
    [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Generated]
    public partial class NewAzContainerServiceManagedCluster_CreateExpanded : global::System.Management.Automation.PSCmdlet,
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener
    {
        /// <summary>A unique id generatd for the this cmdlet when it is instantiated.</summary>
        private string __correlationId = System.Guid.NewGuid().ToString();

        /// <summary>A copy of the Invocation Info (necessary to allow asJob to clone this cmdlet)</summary>
        private global::System.Management.Automation.InvocationInfo __invocationInfo;

        /// <summary>A unique id generatd for the this cmdlet when ProcessRecord() is called.</summary>
        private string __processRecordId;

        /// <summary>
        /// The <see cref="global::System.Threading.CancellationTokenSource" /> for this operation.
        /// </summary>
        private global::System.Threading.CancellationTokenSource _cancellationTokenSource = new global::System.Threading.CancellationTokenSource();

        /// <summary>Managed cluster.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedCluster _parametersBody = new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.ManagedCluster();

        /// <summary>The list of AAD group object IDs that will have admin role of the cluster.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The list of AAD group object IDs that will have admin role of the cluster.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The list of AAD group object IDs that will have admin role of the cluster.",
        SerializedName = @"adminGroupObjectIDs",
        PossibleTypes = new [] { typeof(string) })]
        public string[] AadProfileAdminGroupObjectID { get => _parametersBody.AadProfileAdminGroupObjectID ?? null /* arrayOf */; set => _parametersBody.AadProfileAdminGroupObjectID = value; }

        /// <summary>
        /// (DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "(DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"(DEPRECATED) The client AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.",
        SerializedName = @"clientAppID",
        PossibleTypes = new [] { typeof(string) })]
        public string AadProfileClientAppId { get => _parametersBody.AadProfileClientAppId ?? null; set => _parametersBody.AadProfileClientAppId = value; }

        /// <summary>Whether to enable Azure RBAC for Kubernetes authorization.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable Azure RBAC for Kubernetes authorization.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Azure RBAC for Kubernetes authorization.",
        SerializedName = @"enableAzureRBAC",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AadProfileEnableAzureRbac { get => _parametersBody.AadProfileEnableAzureRbac ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.AadProfileEnableAzureRbac = value; }

        /// <summary>Whether to enable managed AAD.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable managed AAD.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable managed AAD.",
        SerializedName = @"managed",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AadProfileManaged { get => _parametersBody.AadProfileManaged ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.AadProfileManaged = value; }

        /// <summary>
        /// (DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "(DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"(DEPRECATED) The server AAD application ID. Learn more at https://aka.ms/aks/aad-legacy.",
        SerializedName = @"serverAppID",
        PossibleTypes = new [] { typeof(string) })]
        public string AadProfileServerAppId { get => _parametersBody.AadProfileServerAppId ?? null; set => _parametersBody.AadProfileServerAppId = value; }

        /// <summary>
        /// (DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "(DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"(DEPRECATED) The server AAD application secret. Learn more at https://aka.ms/aks/aad-legacy.",
        SerializedName = @"serverAppSecret",
        PossibleTypes = new [] { typeof(string) })]
        public string AadProfileServerAppSecret { get => _parametersBody.AadProfileServerAppSecret ?? null; set => _parametersBody.AadProfileServerAppSecret = value; }

        /// <summary>
        /// The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The AAD tenant ID to use for authentication. If not specified, will use the tenant of the deployment subscription.",
        SerializedName = @"tenantID",
        PossibleTypes = new [] { typeof(string) })]
        public string AadProfileTenantId { get => _parametersBody.AadProfileTenantId ?? null; set => _parametersBody.AadProfileTenantId = value; }

        /// <summary>The profile of managed cluster add-on.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ExportAs(typeof(global::System.Collections.Hashtable))]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The profile of managed cluster add-on.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The profile of managed cluster add-on.",
        SerializedName = @"addonProfiles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedClusterPropertiesAddonProfiles) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedClusterPropertiesAddonProfiles AddonProfile { get => _parametersBody.AddonProfile ?? null /* object */; set => _parametersBody.AddonProfile = value; }

        /// <summary>The agent pool properties.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The agent pool properties.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The agent pool properties.",
        SerializedName = @"agentPoolProfiles",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedClusterAgentPoolProfile) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedClusterAgentPoolProfile[] AgentPoolProfile { get => _parametersBody.AgentPoolProfile ?? null /* arrayOf */; set => _parametersBody.AgentPoolProfile = value; }

        /// <summary>
        /// IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use
        /// Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see [API server authorized
        /// IP ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).
        /// </summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see [API server authorized IP ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"IP ranges are specified in CIDR format, e.g. 137.117.106.88/29. This feature is not compatible with clusters that use Public IP Per Node, or clusters that are using a Basic Load Balancer. For more information see [API server authorized IP ranges](https://docs.microsoft.com/azure/aks/api-server-authorized-ip-ranges).",
        SerializedName = @"authorizedIPRanges",
        PossibleTypes = new [] { typeof(string) })]
        public string[] ApiServerAccessProfileAuthorizedIPRange { get => _parametersBody.ApiServerAccessProfileAuthorizedIPRange ?? null /* arrayOf */; set => _parametersBody.ApiServerAccessProfileAuthorizedIPRange = value; }

        /// <summary>Whether to disable run command for the cluster or not.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to disable run command for the cluster or not.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to disable run command for the cluster or not.",
        SerializedName = @"disableRunCommand",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter ApiServerAccessProfileDisableRunCommand { get => _parametersBody.ApiServerAccessProfileDisableRunCommand ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.ApiServerAccessProfileDisableRunCommand = value; }

        /// <summary>
        /// For more details, see [Creating a private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "For more details, see [Creating a private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For more details, see [Creating a private AKS cluster](https://docs.microsoft.com/azure/aks/private-clusters).",
        SerializedName = @"enablePrivateCluster",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter ApiServerAccessProfileEnablePrivateCluster { get => _parametersBody.ApiServerAccessProfileEnablePrivateCluster ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.ApiServerAccessProfileEnablePrivateCluster = value; }

        /// <summary>Whether to create additional public FQDN for private cluster or not.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to create additional public FQDN for private cluster or not.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to create additional public FQDN for private cluster or not.",
        SerializedName = @"enablePrivateClusterPublicFQDN",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter ApiServerAccessProfileEnablePrivateClusterPublicFqdn { get => _parametersBody.ApiServerAccessProfileEnablePrivateClusterPublicFqdn ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.ApiServerAccessProfileEnablePrivateClusterPublicFqdn = value; }

        /// <summary>
        /// The default is System. For more details see [configure private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone).
        /// Allowed values are 'system' and 'none'.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is System. For more details see [configure private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone). Allowed values are 'system' and 'none'.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is System. For more details see [configure private DNS zone](https://docs.microsoft.com/azure/aks/private-clusters#configure-private-dns-zone). Allowed values are 'system' and 'none'.",
        SerializedName = @"privateDNSZone",
        PossibleTypes = new [] { typeof(string) })]
        public string ApiServerAccessProfilePrivateDnsZone { get => _parametersBody.ApiServerAccessProfilePrivateDnsZone ?? null; set => _parametersBody.ApiServerAccessProfilePrivateDnsZone = value; }

        /// <summary>when specified, runs this cmdlet as a PowerShell job</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Run the command as a job")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter AsJob { get; set; }

        /// <summary>Valid values are 'true' and 'false'</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Valid values are 'true' and 'false'")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Valid values are 'true' and 'false'",
        SerializedName = @"balance-similar-node-groups",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileBalanceSimilarNodeGroup { get => _parametersBody.AutoScalerProfileBalanceSimilarNodeGroup ?? null; set => _parametersBody.AutoScalerProfileBalanceSimilarNodeGroup = value; }

        /// <summary>
        /// If not specified, the default is 'random'. See [expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders)
        /// for more information.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "If not specified, the default is 'random'. See [expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders) for more information.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If not specified, the default is 'random'. See [expanders](https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-expanders) for more information.",
        SerializedName = @"expander",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Expander) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Expander))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Expander AutoScalerProfileExpander { get => _parametersBody.AutoScalerProfileExpander ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Expander)""); set => _parametersBody.AutoScalerProfileExpander = value; }

        /// <summary>The default is 10.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is 10.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is 10.",
        SerializedName = @"max-empty-bulk-delete",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileMaxEmptyBulkDelete { get => _parametersBody.AutoScalerProfileMaxEmptyBulkDelete ?? null; set => _parametersBody.AutoScalerProfileMaxEmptyBulkDelete = value; }

        /// <summary>The default is 600.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is 600.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is 600.",
        SerializedName = @"max-graceful-termination-sec",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileMaxGracefulTerminationSec { get => _parametersBody.AutoScalerProfileMaxGracefulTerminationSec ?? null; set => _parametersBody.AutoScalerProfileMaxGracefulTerminationSec = value; }

        /// <summary>
        /// The default is '15m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is '15m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '15m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"max-node-provision-time",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileMaxNodeProvisionTime { get => _parametersBody.AutoScalerProfileMaxNodeProvisionTime ?? null; set => _parametersBody.AutoScalerProfileMaxNodeProvisionTime = value; }

        /// <summary>The default is 45. The maximum is 100 and the minimum is 0.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is 45. The maximum is 100 and the minimum is 0.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is 45. The maximum is 100 and the minimum is 0.",
        SerializedName = @"max-total-unready-percentage",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileMaxTotalUnreadyPercentage { get => _parametersBody.AutoScalerProfileMaxTotalUnreadyPercentage ?? null; set => _parametersBody.AutoScalerProfileMaxTotalUnreadyPercentage = value; }

        /// <summary>
        /// For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all
        /// the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is '0s'. Values must be
        /// an integer followed by a unit ('s' for seconds, 'm' for minutes, 'h' for hours, etc).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is '0s'. Values must be an integer followed by a unit ('s' for seconds, 'm' for minutes, 'h' for hours, etc).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For scenarios like burst/batch scale where you don't want CA to act before the kubernetes scheduler could schedule all the pods, you can tell CA to ignore unscheduled pods before they're a certain age. The default is '0s'. Values must be an integer followed by a unit ('s' for seconds, 'm' for minutes, 'h' for hours, etc).",
        SerializedName = @"new-pod-scale-up-delay",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileNewPodScaleUpDelay { get => _parametersBody.AutoScalerProfileNewPodScaleUpDelay ?? null; set => _parametersBody.AutoScalerProfileNewPodScaleUpDelay = value; }

        /// <summary>This must be an integer. The default is 3.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This must be an integer. The default is 3.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This must be an integer. The default is 3.",
        SerializedName = @"ok-total-unready-count",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileOkTotalUnreadyCount { get => _parametersBody.AutoScalerProfileOkTotalUnreadyCount ?? null; set => _parametersBody.AutoScalerProfileOkTotalUnreadyCount = value; }

        /// <summary>
        /// The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-delay-after-add",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileScaleDownDelayAfterAdd { get => _parametersBody.AutoScalerProfileScaleDownDelayAfterAdd ?? null; set => _parametersBody.AutoScalerProfileScaleDownDelayAfterAdd = value; }

        /// <summary>
        /// The default is the scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m)
        /// is supported.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is the scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is the scan-interval. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-delay-after-delete",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileScaleDownDelayAfterDelete { get => _parametersBody.AutoScalerProfileScaleDownDelayAfterDelete ?? null; set => _parametersBody.AutoScalerProfileScaleDownDelayAfterDelete = value; }

        /// <summary>
        /// The default is '3m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is '3m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '3m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-delay-after-failure",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileScaleDownDelayAfterFailure { get => _parametersBody.AutoScalerProfileScaleDownDelayAfterFailure ?? null; set => _parametersBody.AutoScalerProfileScaleDownDelayAfterFailure = value; }

        /// <summary>
        /// The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '10m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-unneeded-time",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileScaleDownUnneededTime { get => _parametersBody.AutoScalerProfileScaleDownUnneededTime ?? null; set => _parametersBody.AutoScalerProfileScaleDownUnneededTime = value; }

        /// <summary>
        /// The default is '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '20m'. Values must be an integer followed by an 'm'. No unit of time other than minutes (m) is supported.",
        SerializedName = @"scale-down-unready-time",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileScaleDownUnreadyTime { get => _parametersBody.AutoScalerProfileScaleDownUnreadyTime ?? null; set => _parametersBody.AutoScalerProfileScaleDownUnreadyTime = value; }

        /// <summary>The default is '0.5'.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is '0.5'.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '0.5'.",
        SerializedName = @"scale-down-utilization-threshold",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileScaleDownUtilizationThreshold { get => _parametersBody.AutoScalerProfileScaleDownUtilizationThreshold ?? null; set => _parametersBody.AutoScalerProfileScaleDownUtilizationThreshold = value; }

        /// <summary>The default is '10'. Values must be an integer number of seconds.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is '10'. Values must be an integer number of seconds.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '10'. Values must be an integer number of seconds.",
        SerializedName = @"scan-interval",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileScanInterval { get => _parametersBody.AutoScalerProfileScanInterval ?? null; set => _parametersBody.AutoScalerProfileScanInterval = value; }

        /// <summary>The default is true.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is true.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is true.",
        SerializedName = @"skip-nodes-with-local-storage",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileSkipNodesWithLocalStorage { get => _parametersBody.AutoScalerProfileSkipNodesWithLocalStorage ?? null; set => _parametersBody.AutoScalerProfileSkipNodesWithLocalStorage = value; }

        /// <summary>The default is true.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is true.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is true.",
        SerializedName = @"skip-nodes-with-system-pods",
        PossibleTypes = new [] { typeof(string) })]
        public string AutoScalerProfileSkipNodesWithSystemPod { get => _parametersBody.AutoScalerProfileSkipNodesWithSystemPod ?? null; set => _parametersBody.AutoScalerProfileSkipNodesWithSystemPod = value; }

        /// <summary>
        /// For more information see [setting the AKS cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "For more information see [setting the AKS cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For more information see [setting the AKS cluster auto-upgrade channel](https://docs.microsoft.com/azure/aks/upgrade-cluster#set-auto-upgrade-channel).",
        SerializedName = @"upgradeChannel",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.UpgradeChannel) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.UpgradeChannel))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.UpgradeChannel AutoUpgradeProfileUpgradeChannel { get => _parametersBody.AutoUpgradeProfileUpgradeChannel ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.UpgradeChannel)""); set => _parametersBody.AutoUpgradeProfileUpgradeChannel = value; }

        /// <summary>Whether to enable Azure Key Vault key management service. The default is false.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable Azure Key Vault key management service. The default is false.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Azure Key Vault key management service. The default is false.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AzureKeyVaultKmEnabled { get => _parametersBody.AzureKeyVaultKmEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.AzureKeyVaultKmEnabled = value; }

        /// <summary>
        /// Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name)
        /// for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key
        /// identifier. When Azure Key Vault key management service is disabled, leave the field empty.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name) for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key identifier. When Azure Key Vault key management service is disabled, leave the field empty.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Identifier of Azure Key Vault key. See [key identifier format](https://docs.microsoft.com/en-us/azure/key-vault/general/about-keys-secrets-certificates#vault-name-and-object-name) for more details. When Azure Key Vault key management service is enabled, this field is required and must be a valid key identifier. When Azure Key Vault key management service is disabled, leave the field empty.",
        SerializedName = @"keyId",
        PossibleTypes = new [] { typeof(string) })]
        public string AzureKeyVaultKmKeyId { get => _parametersBody.AzureKeyVaultKmKeyId ?? null; set => _parametersBody.AzureKeyVaultKmKeyId = value; }

        /// <summary>
        /// Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public
        /// access from all networks. `Private` means the key vault disables public access and enables private link. The default value
        /// is `Public`.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link. The default value is `Public`.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Network access of key vault. The possible values are `Public` and `Private`. `Public` means the key vault allows public access from all networks. `Private` means the key vault disables public access and enables private link. The default value is `Public`.",
        SerializedName = @"keyVaultNetworkAccess",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes AzureKeyVaultKmKeyVaultNetworkAccess { get => _parametersBody.AzureKeyVaultKmKeyVaultNetworkAccess ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KeyVaultNetworkAccessTypes)""); set => _parametersBody.AzureKeyVaultKmKeyVaultNetworkAccess = value; }

        /// <summary>
        /// Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource
        /// ID. When keyVaultNetworkAccess is `Public`, leave the field empty.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource ID. When keyVaultNetworkAccess is `Public`, leave the field empty.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource ID of key vault. When keyVaultNetworkAccess is `Private`, this field is required and must be a valid resource ID. When keyVaultNetworkAccess is `Public`, leave the field empty.",
        SerializedName = @"keyVaultResourceId",
        PossibleTypes = new [] { typeof(string) })]
        public string AzureKeyVaultKmKeyVaultResourceId { get => _parametersBody.AzureKeyVaultKmKeyVaultResourceId ?? null; set => _parametersBody.AzureKeyVaultKmKeyVaultResourceId = value; }

        /// <summary>Whether to enable AzureBlob CSI Driver. The default value is false.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable AzureBlob CSI Driver. The default value is false.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable AzureBlob CSI Driver. The default value is false.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter BlobCsiDriverEnabled { get => _parametersBody.BlobCsiDriverEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.BlobCsiDriverEnabled = value; }

        /// <summary>Wait for .NET debugger to attach</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Wait for .NET debugger to attach")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter Break { get; set; }

        /// <summary>The reference to the client API class.</summary>
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ContainerServiceClient Client => Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Module.Instance.ClientAPI;

        /// <summary>
        /// The DefaultProfile parameter is not functional. Use the SubscriptionId parameter when available if executing the cmdlet
        /// against a different subscription
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The DefaultProfile parameter is not functional. Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::System.Management.Automation.Alias("AzureRMContext", "AzureCredential")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Azure)]
        public global::System.Management.Automation.PSObject DefaultProfile { get; set; }

        /// <summary>
        /// Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled,
        /// this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field
        /// empty.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled, this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field empty.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource ID of the Log Analytics workspace to be associated with Microsoft Defender. When Microsoft Defender is enabled, this field is required and must be a valid workspace resource ID. When Microsoft Defender is disabled, leave the field empty.",
        SerializedName = @"logAnalyticsWorkspaceResourceId",
        PossibleTypes = new [] { typeof(string) })]
        public string DefenderLogAnalyticsWorkspaceResourceId { get => _parametersBody.DefenderLogAnalyticsWorkspaceResourceId ?? null; set => _parametersBody.DefenderLogAnalyticsWorkspaceResourceId = value; }

        /// <summary>
        /// If set to true, getting static credentials will be disabled for this cluster. This must only be used on Managed Clusters
        /// that are AAD enabled. For more details see [disable local accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "If set to true, getting static credentials will be disabled for this cluster. This must only be used on Managed Clusters that are AAD enabled. For more details see [disable local accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If set to true, getting static credentials will be disabled for this cluster. This must only be used on Managed Clusters that are AAD enabled. For more details see [disable local accounts](https://docs.microsoft.com/azure/aks/managed-aad#disable-local-accounts-preview).",
        SerializedName = @"disableLocalAccounts",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter DisableLocalAccount { get => _parametersBody.DisableLocalAccount ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.DisableLocalAccount = value; }

        /// <summary>Whether to enable AzureDisk CSI Driver. The default value is true.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable AzureDisk CSI Driver. The default value is true.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable AzureDisk CSI Driver. The default value is true.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter DiskCsiDriverEnabled { get => _parametersBody.DiskCsiDriverEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.DiskCsiDriverEnabled = value; }

        /// <summary>
        /// This is of the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This is of the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This is of the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{encryptionSetName}'",
        SerializedName = @"diskEncryptionSetID",
        PossibleTypes = new [] { typeof(string) })]
        public string DiskEncryptionSetId { get => _parametersBody.DiskEncryptionSetId ?? null; set => _parametersBody.DiskEncryptionSetId = value; }

        /// <summary>This cannot be updated once the Managed Cluster has been created.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This cannot be updated once the Managed Cluster has been created.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This cannot be updated once the Managed Cluster has been created.",
        SerializedName = @"dnsPrefix",
        PossibleTypes = new [] { typeof(string) })]
        public string DnsPrefix { get => _parametersBody.DnsPrefix ?? null; set => _parametersBody.DnsPrefix = value; }

        /// <summary>
        /// (DEPRECATED) Whether to enable Kubernetes pod security policy (preview). PodSecurityPolicy was deprecated in Kubernetes
        /// v1.21, and removed from Kubernetes in v1.25. Learn more at https://aka.ms/k8s/psp and https://aka.ms/aks/psp.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "(DEPRECATED) Whether to enable Kubernetes pod security policy (preview). PodSecurityPolicy was deprecated in Kubernetes v1.21, and removed from Kubernetes in v1.25. Learn more at https://aka.ms/k8s/psp and https://aka.ms/aks/psp.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"(DEPRECATED) Whether to enable Kubernetes pod security policy (preview). PodSecurityPolicy was deprecated in Kubernetes v1.21, and removed from Kubernetes in v1.25. Learn more at https://aka.ms/k8s/psp and https://aka.ms/aks/psp.",
        SerializedName = @"enablePodSecurityPolicy",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter EnablePodSecurityPolicy { get => _parametersBody.EnablePodSecurityPolicy ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.EnablePodSecurityPolicy = value; }

        /// <summary>Whether to enable Kubernetes Role-Based Access Control.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable Kubernetes Role-Based Access Control.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Kubernetes Role-Based Access Control.",
        SerializedName = @"enableRBAC",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter EnableRbac { get => _parametersBody.EnableRbac ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.EnableRbac = value; }

        /// <summary>The name of the extended location.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The name of the extended location.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the extended location.",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        public string ExtendedLocationName { get => _parametersBody.ExtendedLocationName ?? null; set => _parametersBody.ExtendedLocationName = value; }

        /// <summary>The type of the extended location.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The type of the extended location.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The type of the extended location.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ExtendedLocationTypes) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ExtendedLocationTypes))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ExtendedLocationTypes ExtendedLocationType { get => _parametersBody.ExtendedLocationType ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ExtendedLocationTypes)""); set => _parametersBody.ExtendedLocationType = value; }

        /// <summary>Whether to enable AzureFile CSI Driver. The default value is true.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable AzureFile CSI Driver. The default value is true.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable AzureFile CSI Driver. The default value is true.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter FileCsiDriverEnabled { get => _parametersBody.FileCsiDriverEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.FileCsiDriverEnabled = value; }

        /// <summary>This cannot be updated once the Managed Cluster has been created.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This cannot be updated once the Managed Cluster has been created.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This cannot be updated once the Managed Cluster has been created.",
        SerializedName = @"fqdnSubdomain",
        PossibleTypes = new [] { typeof(string) })]
        public string FqdnSubdomain { get => _parametersBody.FqdnSubdomain ?? null; set => _parametersBody.FqdnSubdomain = value; }

        /// <summary>
        /// Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet
        /// which is used to create the managed cluster.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the DNS server for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.",
        SerializedName = @"dnsServer",
        PossibleTypes = new [] { typeof(string) })]
        public string GmsaProfileDnsServer { get => _parametersBody.GmsaProfileDnsServer ?? null; set => _parametersBody.GmsaProfileDnsServer = value; }

        /// <summary>Specifies whether to enable Windows gMSA in the managed cluster.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies whether to enable Windows gMSA in the managed cluster.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether to enable Windows gMSA in the managed cluster.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter GmsaProfileEnabled { get => _parametersBody.GmsaProfileEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.GmsaProfileEnabled = value; }

        /// <summary>
        /// Specifies the root domain name for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the
        /// vnet which is used to create the managed cluster.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the root domain name for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the root domain name for Windows gMSA. <br><br> Set it to empty if you have configured the DNS server in the vnet which is used to create the managed cluster.",
        SerializedName = @"rootDomainName",
        PossibleTypes = new [] { typeof(string) })]
        public string GmsaProfileRootDomainName { get => _parametersBody.GmsaProfileRootDomainName ?? null; set => _parametersBody.GmsaProfileRootDomainName = value; }

        /// <summary>SendAsync Pipeline Steps to be appended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be appended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.SendAsyncStep[] HttpPipelineAppend { get; set; }

        /// <summary>SendAsync Pipeline Steps to be prepended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be prepended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.SendAsyncStep[] HttpPipelinePrepend { get; set; }

        /// <summary>The HTTP proxy server endpoint to use.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The HTTP proxy server endpoint to use.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The HTTP proxy server endpoint to use.",
        SerializedName = @"httpProxy",
        PossibleTypes = new [] { typeof(string) })]
        public string HttpProxyConfigHttpProxy { get => _parametersBody.HttpProxyConfigHttpProxy ?? null; set => _parametersBody.HttpProxyConfigHttpProxy = value; }

        /// <summary>The HTTPS proxy server endpoint to use.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The HTTPS proxy server endpoint to use.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The HTTPS proxy server endpoint to use.",
        SerializedName = @"httpsProxy",
        PossibleTypes = new [] { typeof(string) })]
        public string HttpProxyConfigHttpsProxy { get => _parametersBody.HttpProxyConfigHttpsProxy ?? null; set => _parametersBody.HttpProxyConfigHttpsProxy = value; }

        /// <summary>The endpoints that should not go through proxy.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The endpoints that should not go through proxy.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The endpoints that should not go through proxy.",
        SerializedName = @"noProxy",
        PossibleTypes = new [] { typeof(string) })]
        public string[] HttpProxyConfigNoProxy { get => _parametersBody.HttpProxyConfigNoProxy ?? null /* arrayOf */; set => _parametersBody.HttpProxyConfigNoProxy = value; }

        /// <summary>Alternative CA cert to use for connecting to proxy servers.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Alternative CA cert to use for connecting to proxy servers.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Alternative CA cert to use for connecting to proxy servers.",
        SerializedName = @"trustedCa",
        PossibleTypes = new [] { typeof(string) })]
        public string HttpProxyConfigTrustedCa { get => _parametersBody.HttpProxyConfigTrustedCa ?? null; set => _parametersBody.HttpProxyConfigTrustedCa = value; }

        /// <summary>Identities associated with the cluster.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ExportAs(typeof(global::System.Collections.Hashtable))]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Identities associated with the cluster.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Identities associated with the cluster.",
        SerializedName = @"identityProfile",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedClusterPropertiesIdentityProfile) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedClusterPropertiesIdentityProfile IdentityProfile { get => _parametersBody.IdentityProfile ?? null /* object */; set => _parametersBody.IdentityProfile = value; }

        /// <summary>
        /// For more information see [use managed identities in AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "For more information see [use managed identities in AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For more information see [use managed identities in AKS](https://docs.microsoft.com/azure/aks/use-managed-identity).",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ResourceIdentityType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ResourceIdentityType))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ResourceIdentityType IdentityType { get => _parametersBody.IdentityType ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ResourceIdentityType)""); set => _parametersBody.IdentityType = value; }

        /// <summary>
        /// The keys must be ARM resource IDs in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ExportAs(typeof(global::System.Collections.Hashtable))]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The keys must be ARM resource IDs in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The keys must be ARM resource IDs in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.",
        SerializedName = @"userAssignedIdentities",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedClusterIdentityUserAssignedIdentities) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedClusterIdentityUserAssignedIdentities IdentityUserAssignedIdentity { get => _parametersBody.IdentityUserAssignedIdentity ?? null /* object */; set => _parametersBody.IdentityUserAssignedIdentity = value; }

        /// <summary>Whether to enable Image Cleaner on AKS cluster.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable Image Cleaner on AKS cluster.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Image Cleaner on AKS cluster.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter ImageCleanerEnabled { get => _parametersBody.ImageCleanerEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.ImageCleanerEnabled = value; }

        /// <summary>Image Cleaner scanning interval in hours.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Image Cleaner scanning interval in hours.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Image Cleaner scanning interval in hours.",
        SerializedName = @"intervalHours",
        PossibleTypes = new [] { typeof(int) })]
        public int ImageCleanerIntervalHour { get => _parametersBody.ImageCleanerIntervalHour ?? default(int); set => _parametersBody.ImageCleanerIntervalHour = value; }

        /// <summary>Accessor for our copy of the InvocationInfo.</summary>
        public global::System.Management.Automation.InvocationInfo InvocationInformation { get => __invocationInfo = __invocationInfo ?? this.MyInvocation ; set { __invocationInfo = value; } }

        /// <summary>Whether to enable KEDA.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable KEDA.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable KEDA.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter KedaEnabled { get => _parametersBody.KedaEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.KedaEnabled = value; }

        /// <summary>
        /// Comma-separated list of Kubernetes annotation keys that will be used in the resource's labels metric (Example: 'namespaces=[kubernetes.io/team,...],pods=[kubernetes.io/team],...').
        /// By default the metric contains only resource name and namespace labels.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Comma-separated list of Kubernetes annotation keys that will be used in the resource's labels metric (Example: 'namespaces=[kubernetes.io/team,...],pods=[kubernetes.io/team],...'). By default the metric contains only resource name and namespace labels.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Comma-separated list of Kubernetes annotation keys that will be used in the resource's labels metric (Example: 'namespaces=[kubernetes.io/team,...],pods=[kubernetes.io/team],...'). By default the metric contains only resource name and namespace labels.",
        SerializedName = @"metricAnnotationsAllowList",
        PossibleTypes = new [] { typeof(string) })]
        public string KubeStateMetricAnnotationsAllowList { get => _parametersBody.KubeStateMetricAnnotationsAllowList ?? null; set => _parametersBody.KubeStateMetricAnnotationsAllowList = value; }

        /// <summary>
        /// Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric (Example: 'namespaces=[k8s-label-1,k8s-label-n,...],pods=[app],...').
        /// By default the metric contains only resource name and namespace labels.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric (Example: 'namespaces=[k8s-label-1,k8s-label-n,...],pods=[app],...'). By default the metric contains only resource name and namespace labels.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Comma-separated list of additional Kubernetes label keys that will be used in the resource's labels metric (Example: 'namespaces=[k8s-label-1,k8s-label-n,...],pods=[app],...'). By default the metric contains only resource name and namespace labels.",
        SerializedName = @"metricLabelsAllowlist",
        PossibleTypes = new [] { typeof(string) })]
        public string KubeStateMetricLabelsAllowlist { get => _parametersBody.KubeStateMetricLabelsAllowlist ?? null; set => _parametersBody.KubeStateMetricLabelsAllowlist = value; }

        /// <summary>
        /// Both patch version <major.minor.patch> (e.g. 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor>
        /// is specified, the latest supported GA patch version is chosen automatically. Updating the cluster with the same <major.minor>
        /// once it has been created (e.g. 1.14.x -> 1.14) will not trigger an upgrade, even if a newer patch version is available.
        /// When you upgrade a supported AKS cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed
        /// sequentially by major version number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed,
        /// however 1.14.x -> 1.16.x is not allowed. See [upgrading an AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster)
        /// for more details.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Both patch version <major.minor.patch> (e.g. 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor> is specified, the latest supported GA patch version is chosen automatically. Updating the cluster with the same <major.minor> once it has been created (e.g. 1.14.x -> 1.14) will not trigger an upgrade, even if a newer patch version is available. When you upgrade a supported AKS cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed sequentially by major version number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed, however 1.14.x -> 1.16.x is not allowed. See [upgrading an AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster) for more details.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Both patch version <major.minor.patch> (e.g. 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor> is specified, the latest supported GA patch version is chosen automatically. Updating the cluster with the same <major.minor> once it has been created (e.g. 1.14.x -> 1.14) will not trigger an upgrade, even if a newer patch version is available. When you upgrade a supported AKS cluster, Kubernetes minor versions cannot be skipped. All upgrades must be performed sequentially by major version number. For example, upgrades between 1.14.x -> 1.15.x or 1.15.x -> 1.16.x are allowed, however 1.14.x -> 1.16.x is not allowed. See [upgrading an AKS cluster](https://docs.microsoft.com/azure/aks/upgrade-cluster) for more details.",
        SerializedName = @"kubernetesVersion",
        PossibleTypes = new [] { typeof(string) })]
        public string KubernetesVersion { get => _parametersBody.KubernetesVersion ?? null; set => _parametersBody.KubernetesVersion = value; }

        /// <summary>The administrator username to use for Linux VMs.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The administrator username to use for Linux VMs.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The administrator username to use for Linux VMs.",
        SerializedName = @"adminUsername",
        PossibleTypes = new [] { typeof(string) })]
        public string LinuxProfileAdminUsername { get => _parametersBody.LinuxProfileAdminUsername ?? null; set => _parametersBody.LinuxProfileAdminUsername = value; }

        /// <summary>The geo-location where the resource lives</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The geo-location where the resource lives")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The geo-location where the resource lives",
        SerializedName = @"location",
        PossibleTypes = new [] { typeof(string) })]
        public string Location { get => _parametersBody.Location ?? null; set => _parametersBody.Location = value; }

        /// <summary>
        /// Whether to enable or disable the Azure Managed Prometheus addon for Prometheus monitoring. See aka.ms/AzureManagedPrometheus-aks-enable
        /// for details on enabling and disabling.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable or disable the Azure Managed Prometheus addon for Prometheus monitoring. See aka.ms/AzureManagedPrometheus-aks-enable for details on enabling and disabling.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable or disable the Azure Managed Prometheus addon for Prometheus monitoring. See aka.ms/AzureManagedPrometheus-aks-enable for details on enabling and disabling.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter MetricEnabled { get => _parametersBody.MetricEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.MetricEnabled = value; }

        /// <summary>
        /// <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener" /> cancellation delegate. Stops the cmdlet when called.
        /// </summary>
        global::System.Action Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener.Cancel => _cancellationTokenSource.Cancel;

        /// <summary><see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener" /> cancellation token.</summary>
        global::System.Threading.CancellationToken Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener.Token => _cancellationTokenSource.Token;

        /// <summary>The network configuration profile.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The network configuration profile.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The network configuration profile.",
        SerializedName = @"networkProfile",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IContainerServiceNetworkProfile) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IContainerServiceNetworkProfile NetworkProfile { get => _parametersBody.NetworkProfile ?? null /* object */; set => _parametersBody.NetworkProfile = value; }

        /// <summary>
        /// when specified, will make the remote call, and return an AsyncOperationResponse, letting the remote operation continue
        /// asynchronously.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Run the command asynchronously")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter NoWait { get; set; }

        /// <summary>The name of the resource group containing agent pool nodes.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The name of the resource group containing agent pool nodes.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of the resource group containing agent pool nodes.",
        SerializedName = @"nodeResourceGroup",
        PossibleTypes = new [] { typeof(string) })]
        public string NodeResourceGroup { get => _parametersBody.NodeResourceGroup ?? null; set => _parametersBody.NodeResourceGroup = value; }

        /// <summary>Whether the OIDC issuer is enabled.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether the OIDC issuer is enabled.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether the OIDC issuer is enabled.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter OidcIssuerProfileEnabled { get => _parametersBody.OidcIssuerProfileEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.OidcIssuerProfileEnabled = value; }

        /// <summary>
        /// The instance of the <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.HttpPipeline" /> that the remote call will use.
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.HttpPipeline Pipeline { get; set; }

        /// <summary>
        /// Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing.
        /// See [using Kubenet network plugin with AAD Pod Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities)
        /// for more information.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing. See [using Kubenet network plugin with AAD Pod Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities) for more information.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Running in Kubenet is disabled by default due to the security related nature of AAD Pod Identity and the risks of IP spoofing. See [using Kubenet network plugin with AAD Pod Identity](https://docs.microsoft.com/azure/aks/use-azure-ad-pod-identity#using-kubenet-network-plugin-with-azure-active-directory-pod-managed-identities) for more information.",
        SerializedName = @"allowNetworkPluginKubenet",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter PodIdentityProfileAllowNetworkPluginKubenet { get => _parametersBody.PodIdentityProfileAllowNetworkPluginKubenet ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.PodIdentityProfileAllowNetworkPluginKubenet = value; }

        /// <summary>Whether the pod identity addon is enabled.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether the pod identity addon is enabled.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether the pod identity addon is enabled.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter PodIdentityProfileEnabled { get => _parametersBody.PodIdentityProfileEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.PodIdentityProfileEnabled = value; }

        /// <summary>The pod identities to use in the cluster.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The pod identities to use in the cluster.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The pod identities to use in the cluster.",
        SerializedName = @"userAssignedIdentities",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedClusterPodIdentity) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedClusterPodIdentity[] PodIdentityProfileUserAssignedIdentity { get => _parametersBody.PodIdentityProfileUserAssignedIdentity ?? null /* arrayOf */; set => _parametersBody.PodIdentityProfileUserAssignedIdentity = value; }

        /// <summary>The pod identity exceptions to allow.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The pod identity exceptions to allow.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The pod identity exceptions to allow.",
        SerializedName = @"userAssignedIdentityExceptions",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedClusterPodIdentityException) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedClusterPodIdentityException[] PodIdentityProfileUserAssignedIdentityException { get => _parametersBody.PodIdentityProfileUserAssignedIdentityException ?? null /* arrayOf */; set => _parametersBody.PodIdentityProfileUserAssignedIdentityException = value; }

        /// <summary>Private link resources associated with the cluster.</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Private link resources associated with the cluster.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Private link resources associated with the cluster.",
        SerializedName = @"privateLinkResources",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IPrivateLinkResource) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IPrivateLinkResource[] PrivateLinkResource { get => _parametersBody.PrivateLinkResource ?? null /* arrayOf */; set => _parametersBody.PrivateLinkResource = value; }

        /// <summary>The URI for the proxy server to use</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "The URI for the proxy server to use")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Uri Proxy { get; set; }

        /// <summary>Credentials for a proxy server to use for the remote call</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Credentials for a proxy server to use for the remote call")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Management.Automation.PSCredential ProxyCredential { get; set; }

        /// <summary>Use the default credentials for the proxy</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Use the default credentials for the proxy")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter ProxyUseDefaultCredentials { get; set; }

        /// <summary>Allow or deny public network access for AKS</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Allow or deny public network access for AKS")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Allow or deny public network access for AKS",
        SerializedName = @"publicNetworkAccess",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.PublicNetworkAccess) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.PublicNetworkAccess))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.PublicNetworkAccess PublicNetworkAccess { get => _parametersBody.PublicNetworkAccess ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.PublicNetworkAccess)""); set => _parametersBody.PublicNetworkAccess = value; }

        /// <summary>Backing field for <see cref="ResourceGroupName" /> property.</summary>
        private string _resourceGroupName;

        /// <summary>The name of the resource group. The name is case insensitive.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The name of the resource group. The name is case insensitive.")]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The name of the resource group. The name is case insensitive.",
        SerializedName = @"resourceGroupName",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Path)]
        public string ResourceGroupName { get => this._resourceGroupName; set => this._resourceGroupName = value; }

        /// <summary>Backing field for <see cref="ResourceName" /> property.</summary>
        private string _resourceName;

        /// <summary>The name of the managed cluster resource.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The name of the managed cluster resource.")]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The name of the managed cluster resource.",
        SerializedName = @"resourceName",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Path)]
        public string ResourceName { get => this._resourceName; set => this._resourceName = value; }

        /// <summary>Whether to enable Defender threat detection</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable Defender threat detection")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Defender threat detection",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter SecurityMonitoringEnabled { get => _parametersBody.SecurityMonitoringEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.SecurityMonitoringEnabled = value; }

        /// <summary>The ID for the service principal.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The ID for the service principal.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The ID for the service principal.",
        SerializedName = @"clientId",
        PossibleTypes = new [] { typeof(string) })]
        public string ServicePrincipalProfileClientId { get => _parametersBody.ServicePrincipalProfileClientId ?? null; set => _parametersBody.ServicePrincipalProfileClientId = value; }

        /// <summary>The secret password associated with the service principal in plain text.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The secret password associated with the service principal in plain text.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The secret password associated with the service principal in plain text.",
        SerializedName = @"secret",
        PossibleTypes = new [] { typeof(string) })]
        public string ServicePrincipalProfileSecret { get => _parametersBody.ServicePrincipalProfileSecret ?? null; set => _parametersBody.ServicePrincipalProfileSecret = value; }

        /// <summary>The name of a managed cluster SKU.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The name of a managed cluster SKU.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The name of a managed cluster SKU.",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ManagedClusterSkuName) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ManagedClusterSkuName))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ManagedClusterSkuName SkuName { get => _parametersBody.SkuName ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ManagedClusterSkuName)""); set => _parametersBody.SkuName = value; }

        /// <summary>
        /// If not specified, the default is 'Free'. See [AKS Pricing Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers)
        /// for more details.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "If not specified, the default is 'Free'. See [AKS Pricing Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers) for more details.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If not specified, the default is 'Free'. See [AKS Pricing Tier](https://learn.microsoft.com/azure/aks/free-standard-pricing-tiers) for more details.",
        SerializedName = @"tier",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ManagedClusterSkuTier) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ManagedClusterSkuTier))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ManagedClusterSkuTier SkuTier { get => _parametersBody.SkuTier ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ManagedClusterSkuTier)""); set => _parametersBody.SkuTier = value; }

        /// <summary>Whether to enable Snapshot Controller. The default value is true.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable Snapshot Controller. The default value is true.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable Snapshot Controller. The default value is true.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter SnapshotControllerEnabled { get => _parametersBody.SnapshotControllerEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.SnapshotControllerEnabled = value; }

        /// <summary>
        /// The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.
        /// </summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The list of SSH public keys used to authenticate with Linux-based VMs. A maximum of 1 key may be specified.",
        SerializedName = @"publicKeys",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IContainerServiceSshPublicKey) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IContainerServiceSshPublicKey[] SshPublicKey { get => _parametersBody.SshPublicKey ?? null /* arrayOf */; set => _parametersBody.SshPublicKey = value; }

        /// <summary>Backing field for <see cref="SubscriptionId" /> property.</summary>
        private string _subscriptionId;

        /// <summary>The ID of the target subscription.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The ID of the target subscription.")]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The ID of the target subscription.",
        SerializedName = @"subscriptionId",
        PossibleTypes = new [] { typeof(string) })]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.DefaultInfo(
        Name = @"",
        Description =@"",
        Script = @"(Get-AzContext).Subscription.Id")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Path)]
        public string SubscriptionId { get => this._subscriptionId; set => this._subscriptionId = value; }

        /// <summary>
        /// The support plan for the Managed Cluster. If unspecified, the default is 'KubernetesOfficial'.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The support plan for the Managed Cluster. If unspecified, the default is 'KubernetesOfficial'.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The support plan for the Managed Cluster. If unspecified, the default is 'KubernetesOfficial'.",
        SerializedName = @"supportPlan",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KubernetesSupportPlan) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KubernetesSupportPlan))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KubernetesSupportPlan SupportPlan { get => _parametersBody.SupportPlan ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KubernetesSupportPlan)""); set => _parametersBody.SupportPlan = value; }

        /// <summary>Resource tags.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ExportAs(typeof(global::System.Collections.Hashtable))]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Resource tags.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Resource tags.",
        SerializedName = @"tags",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api30.ITrackedResourceTags) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api30.ITrackedResourceTags Tag { get => _parametersBody.Tag ?? null /* object */; set => _parametersBody.Tag = value; }

        /// <summary>
        /// Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:**
        /// 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters
        /// <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:**
        /// "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:** 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\\W_]) <br><br> **Disallowed values:** \"abc@123\", \"P@$$w0rd\", \"P@ssw0rd\", \"P@ssword123\", \"Pa$$word\", \"pass@word1\", \"Password!\", \"Password1\", \"Password22\", \"iloveyou!\"")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the password of the administrator account. <br><br> **Minimum-length:** 8 characters <br><br> **Max-length:** 123 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:** ""abc@123"", ""P@$$w0rd"", ""P@ssw0rd"", ""P@ssword123"", ""Pa$$word"", ""pass@word1"", ""Password!"", ""Password1"", ""Password22"", ""iloveyou!""",
        SerializedName = @"adminPassword",
        PossibleTypes = new [] { typeof(string) })]
        public string WindowProfileAdminPassword { get => _parametersBody.WindowProfileAdminPassword ?? null; set => _parametersBody.WindowProfileAdminPassword = value; }

        /// <summary>
        /// Specifies the name of the administrator account. <br><br> **Restriction:** Cannot end in "." <br><br> **Disallowed values:**
        /// "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm",
        /// "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server", "sql", "support", "support_388945a0",
        /// "sys", "test2", "test3", "user4", "user5". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the name of the administrator account. <br><br> **Restriction:** Cannot end in \".\" <br><br> **Disallowed values:** \"administrator\", \"admin\", \"user\", \"user1\", \"test\", \"user2\", \"test1\", \"user3\", \"admin1\", \"1\", \"123\", \"a\", \"actuser\", \"adm\", \"admin2\", \"aspnet\", \"backup\", \"console\", \"david\", \"guest\", \"john\", \"owner\", \"root\", \"server\", \"sql\", \"support\", \"support_388945a0\", \"sys\", \"test2\", \"test3\", \"user4\", \"user5\". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the name of the administrator account. <br><br> **Restriction:** Cannot end in ""."" <br><br> **Disallowed values:** ""administrator"", ""admin"", ""user"", ""user1"", ""test"", ""user2"", ""test1"", ""user3"", ""admin1"", ""1"", ""123"", ""a"", ""actuser"", ""adm"", ""admin2"", ""aspnet"", ""backup"", ""console"", ""david"", ""guest"", ""john"", ""owner"", ""root"", ""server"", ""sql"", ""support"", ""support_388945a0"", ""sys"", ""test2"", ""test3"", ""user4"", ""user5"". <br><br> **Minimum-length:** 1 character <br><br> **Max-length:** 20 characters",
        SerializedName = @"adminUsername",
        PossibleTypes = new [] { typeof(string) })]
        public string WindowProfileAdminUsername { get => _parametersBody.WindowProfileAdminUsername ?? null; set => _parametersBody.WindowProfileAdminUsername = value; }

        /// <summary>
        /// For more details on CSI proxy, see the [CSI proxy GitHub repo](https://github.com/kubernetes-csi/csi-proxy).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "For more details on CSI proxy, see the [CSI proxy GitHub repo](https://github.com/kubernetes-csi/csi-proxy).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For more details on CSI proxy, see the [CSI proxy GitHub repo](https://github.com/kubernetes-csi/csi-proxy).",
        SerializedName = @"enableCSIProxy",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter WindowProfileEnableCsiProxy { get => _parametersBody.WindowProfileEnableCsiProxy ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.WindowProfileEnableCsiProxy = value; }

        /// <summary>
        /// The license type to use for Windows VMs. See [Azure Hybrid User Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/)
        /// for more details.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The license type to use for Windows VMs. See [Azure Hybrid User Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more details.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The license type to use for Windows VMs. See [Azure Hybrid User Benefits](https://azure.microsoft.com/pricing/hybrid-benefit/faq/) for more details.",
        SerializedName = @"licenseType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.LicenseType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.LicenseType))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.LicenseType WindowProfileLicenseType { get => _parametersBody.WindowProfileLicenseType ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.LicenseType)""); set => _parametersBody.WindowProfileLicenseType = value; }

        /// <summary>Whether to enable workload identity.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable workload identity.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable workload identity.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter WorkloadIdentityEnabled { get => _parametersBody.WorkloadIdentityEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.WorkloadIdentityEnabled = value; }

        /// <summary>
        /// <c>overrideOnDefault</c> will be called before the regular onDefault has been processed, allowing customization of what
        /// happens on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.ICloudError">Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.ICloudError</see>
        /// from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onDefault method should be processed, or if the method should
        /// return immediately (set to true to skip further processing )</param>

        partial void overrideOnDefault(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.ICloudError> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// <c>overrideOnOk</c> will be called before the regular onOk has been processed, allowing customization of what happens
        /// on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedCluster">Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedCluster</see>
        /// from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onOk method should be processed, or if the method should return
        /// immediately (set to true to skip further processing )</param>

        partial void overrideOnOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedCluster> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// (overrides the default BeginProcessing method in global::System.Management.Automation.PSCmdlet)
        /// </summary>
        protected override void BeginProcessing()
        {
            var telemetryId = Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Module.Instance.GetTelemetryId.Invoke();
            if (telemetryId != "" && telemetryId != "internal")
            {
                __correlationId = telemetryId;
            }
            Module.Instance.SetProxyConfiguration(Proxy, ProxyCredential, ProxyUseDefaultCredentials);
            if (Break)
            {
                Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.AttachDebugger.Break();
            }
            ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletBeginProcessing).Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
        }

        /// <summary>Creates a duplicate instance of this cmdlet (via JSON serialization).</summary>
        /// <returns>a duplicate instance of NewAzContainerServiceManagedCluster_CreateExpanded</returns>
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Cmdlets.NewAzContainerServiceManagedCluster_CreateExpanded Clone()
        {
            var clone = new NewAzContainerServiceManagedCluster_CreateExpanded();
            clone.__correlationId = this.__correlationId;
            clone.__processRecordId = this.__processRecordId;
            clone.DefaultProfile = this.DefaultProfile;
            clone.InvocationInformation = this.InvocationInformation;
            clone.Proxy = this.Proxy;
            clone.Pipeline = this.Pipeline;
            clone.AsJob = this.AsJob;
            clone.Break = this.Break;
            clone.ProxyCredential = this.ProxyCredential;
            clone.ProxyUseDefaultCredentials = this.ProxyUseDefaultCredentials;
            clone.HttpPipelinePrepend = this.HttpPipelinePrepend;
            clone.HttpPipelineAppend = this.HttpPipelineAppend;
            clone._parametersBody = this._parametersBody;
            clone.SubscriptionId = this.SubscriptionId;
            clone.ResourceGroupName = this.ResourceGroupName;
            clone.ResourceName = this.ResourceName;
            return clone;
        }

        /// <summary>Performs clean-up after the command execution</summary>
        protected override void EndProcessing()
        {

        }

        /// <summary>Handles/Dispatches events during the call to the REST service.</summary>
        /// <param name="id">The message id</param>
        /// <param name="token">The message cancellation token. When this call is cancelled, this should be <c>true</c></param>
        /// <param name="messageData">Detailed message data for the message event.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the message is completed.
        /// </returns>
         async global::System.Threading.Tasks.Task Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener.Signal(string id, global::System.Threading.CancellationToken token, global::System.Func<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.EventData> messageData)
        {
            using( NoSynchronizationContext )
            {
                if (token.IsCancellationRequested)
                {
                    return ;
                }

                switch ( id )
                {
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.Verbose:
                    {
                        WriteVerbose($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.Warning:
                    {
                        WriteWarning($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.Information:
                    {
                        // When an operation supports asjob, Information messages must go thru verbose.
                        WriteVerbose($"INFORMATION: {(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.Debug:
                    {
                        WriteDebug($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.Error:
                    {
                        WriteError(new global::System.Management.Automation.ErrorRecord( new global::System.Exception(messageData().Message), string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null ) );
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.DelayBeforePolling:
                    {
                        if (true == MyInvocation?.BoundParameters?.ContainsKey("NoWait"))
                        {
                            var data = messageData();
                            if (data.ResponseMessage is System.Net.Http.HttpResponseMessage response)
                            {
                                var asyncOperation = response.GetFirstHeader(@"Azure-AsyncOperation");
                                var location = response.GetFirstHeader(@"Location");
                                var uri = global::System.String.IsNullOrEmpty(asyncOperation) ? global::System.String.IsNullOrEmpty(location) ? response.RequestMessage.RequestUri.AbsoluteUri : location : asyncOperation;
                                WriteObject(new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.PowerShell.AsyncOperationResponse { Target = uri });
                                // do nothing more.
                                data.Cancel();
                                return;
                            }
                        }
                        break;
                    }
                }
                await Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Module.Instance.Signal(id, token, messageData, (i,t,m) => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(i,t,()=> Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.EventDataConverter.ConvertFrom( m() ) as Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.EventData ), InvocationInformation, this.ParameterSetName, __correlationId, __processRecordId, null );
                if (token.IsCancellationRequested)
                {
                    return ;
                }
                WriteDebug($"{id}: {(messageData().Message ?? global::System.String.Empty)}");
            }
        }

        /// <summary>
        /// Intializes a new instance of the <see cref="NewAzContainerServiceManagedCluster_CreateExpanded" /> cmdlet class.
        /// </summary>
        public NewAzContainerServiceManagedCluster_CreateExpanded()
        {

        }

        /// <summary>Performs execution of the command.</summary>
        protected override void ProcessRecord()
        {
            ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletProcessRecordStart).Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
            __processRecordId = System.Guid.NewGuid().ToString();
            try
            {
                // work
                if (ShouldProcess($"Call remote 'ManagedClustersCreateOrUpdate' operation"))
                {
                    if (true == MyInvocation?.BoundParameters?.ContainsKey("AsJob"))
                    {
                        var instance = this.Clone();
                        var job = new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.PowerShell.AsyncJob(instance, this.MyInvocation.Line, this.MyInvocation.MyCommand.Name, this._cancellationTokenSource.Token, this._cancellationTokenSource.Cancel);
                        JobRepository.Add(job);
                        var task = instance.ProcessRecordAsync();
                        job.Monitor(task);
                        WriteObject(job);
                    }
                    else
                    {
                        using( var asyncCommandRuntime = new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.PowerShell.AsyncCommandRuntime(this, ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token) )
                        {
                            asyncCommandRuntime.Wait( ProcessRecordAsync(),((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token);
                        }
                    }
                }
            }
            catch (global::System.AggregateException aggregateException)
            {
                // unroll the inner exceptions to get the root cause
                foreach( var innerException in aggregateException.Flatten().InnerExceptions )
                {
                    ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletException, $"{innerException.GetType().Name} - {innerException.Message} : {innerException.StackTrace}").Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    // Write exception out to error channel.
                    WriteError( new global::System.Management.Automation.ErrorRecord(innerException,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
                }
            }
            catch (global::System.Exception exception) when ((exception as System.Management.Automation.PipelineStoppedException)== null || (exception as System.Management.Automation.PipelineStoppedException).InnerException != null)
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletException, $"{exception.GetType().Name} - {exception.Message} : {exception.StackTrace}").Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                // Write exception out to error channel.
                WriteError( new global::System.Management.Automation.ErrorRecord(exception,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
            }
            finally
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletProcessRecordEnd).Wait();
            }
        }

        /// <summary>Performs execution of the command, working asynchronously if required.</summary>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        protected async global::System.Threading.Tasks.Task ProcessRecordAsync()
        {
            using( NoSynchronizationContext )
            {
                await ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletGetPipeline); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                Pipeline = Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Module.Instance.CreatePipeline(InvocationInformation, __correlationId, __processRecordId, this.ParameterSetName);
                if (null != HttpPipelinePrepend)
                {
                    Pipeline.Prepend((this.CommandRuntime as Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelinePrepend) ?? HttpPipelinePrepend);
                }
                if (null != HttpPipelineAppend)
                {
                    Pipeline.Append((this.CommandRuntime as Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelineAppend) ?? HttpPipelineAppend);
                }
                // get the client instance
                try
                {
                    await ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletBeforeAPICall); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    await this.Client.ManagedClustersCreateOrUpdate(SubscriptionId, ResourceGroupName, ResourceName, _parametersBody, onOk, onDefault, this, Pipeline);
                    await ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletAfterAPICall); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                }
                catch (Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.UndeclaredResponseException urexception)
                {
                    WriteError(new global::System.Management.Automation.ErrorRecord(urexception, urexception.StatusCode.ToString(), global::System.Management.Automation.ErrorCategory.InvalidOperation, new {  SubscriptionId=SubscriptionId,ResourceGroupName=ResourceGroupName,ResourceName=ResourceName,body=_parametersBody})
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(urexception.Message) { RecommendedAction = urexception.Action }
                    });
                }
                finally
                {
                    await ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletProcessRecordAsyncEnd);
                }
            }
        }

        /// <summary>Interrupts currently running code within the command.</summary>
        protected override void StopProcessing()
        {
            ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Cancel();
            base.StopProcessing();
        }

        /// <summary>
        /// a delegate that is called when the remote service returns default (any response code not handled elsewhere).
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.ICloudError">Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.ICloudError</see>
        /// from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onDefault(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.ICloudError> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnDefault(responseMessage, response, ref _returnNow);
                // if overrideOnDefault has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // Error Response : default
                var code = (await response)?.Code;
                var message = (await response)?.Message;
                if ((null == code || null == message))
                {
                    // Unrecognized Response. Create an error record based on what we have.
                    var ex = new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.ICloudError>(responseMessage, await response);
                    WriteError( new global::System.Management.Automation.ErrorRecord(ex, ex.Code, global::System.Management.Automation.ErrorCategory.InvalidOperation, new { SubscriptionId=SubscriptionId, ResourceGroupName=ResourceGroupName, ResourceName=ResourceName, body=_parametersBody })
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(ex.Message) { RecommendedAction = ex.Action }
                    });
                }
                else
                {
                    WriteError( new global::System.Management.Automation.ErrorRecord(new global::System.Exception($"[{code}] : {message}"), code?.ToString(), global::System.Management.Automation.ErrorCategory.InvalidOperation, new { SubscriptionId=SubscriptionId, ResourceGroupName=ResourceGroupName, ResourceName=ResourceName, body=_parametersBody })
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(message) { RecommendedAction = global::System.String.Empty }
                    });
                }
            }
        }

        /// <summary>a delegate that is called when the remote service returns 200 (OK).</summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedCluster">Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedCluster</see>
        /// from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedCluster> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnOk(responseMessage, response, ref _returnNow);
                // if overrideOnOk has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // onOk - response for 200 / application/json
                // (await response) // should be Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedCluster
                WriteObject((await response));
            }
        }
    }
}