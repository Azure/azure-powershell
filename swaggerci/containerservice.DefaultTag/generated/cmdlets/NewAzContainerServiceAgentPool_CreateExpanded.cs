// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Cmdlets
{
    using static Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Extensions;
    using System;

    /// <summary>Creates or updates an agent pool in the specified managed cluster.</summary>
    /// <remarks>
    /// [OpenAPI] CreateOrUpdate=>PUT:"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/managedClusters/{resourceName}/agentPools/{agentPoolName}"
    /// </remarks>
    [global::System.Management.Automation.Cmdlet(global::System.Management.Automation.VerbsCommon.New, @"AzContainerServiceAgentPool_CreateExpanded", SupportsShouldProcess = true)]
    [global::System.Management.Automation.OutputType(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IAgentPool))]
    [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Description(@"Creates or updates an agent pool in the specified managed cluster.")]
    [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Generated]
    public partial class NewAzContainerServiceAgentPool_CreateExpanded : global::System.Management.Automation.PSCmdlet,
        Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener
    {
        /// <summary>A unique id generatd for the this cmdlet when it is instantiated.</summary>
        private string __correlationId = System.Guid.NewGuid().ToString();

        /// <summary>A copy of the Invocation Info (necessary to allow asJob to clone this cmdlet)</summary>
        private global::System.Management.Automation.InvocationInfo __invocationInfo;

        /// <summary>A unique id generatd for the this cmdlet when ProcessRecord() is called.</summary>
        private string __processRecordId;

        /// <summary>
        /// The <see cref="global::System.Threading.CancellationTokenSource" /> for this operation.
        /// </summary>
        private global::System.Threading.CancellationTokenSource _cancellationTokenSource = new global::System.Threading.CancellationTokenSource();

        /// <summary>Agent Pool.</summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IAgentPool _parametersBody = new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.AgentPool();

        /// <summary>when specified, runs this cmdlet as a PowerShell job</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Run the command as a job")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter AsJob { get; set; }

        /// <summary>
        /// The list of Availability zones to use for nodes. This can only be specified if the AgentPoolType property is 'VirtualMachineScaleSets'.
        /// </summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The list of Availability zones to use for nodes. This can only be specified if the AgentPoolType property is 'VirtualMachineScaleSets'.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The list of Availability zones to use for nodes. This can only be specified if the AgentPoolType property is 'VirtualMachineScaleSets'.",
        SerializedName = @"availabilityZones",
        PossibleTypes = new [] { typeof(string) })]
        public string[] AvailabilityZone { get => _parametersBody.AvailabilityZone ?? null /* arrayOf */; set => _parametersBody.AvailabilityZone = value; }

        /// <summary>Wait for .NET debugger to attach</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Wait for .NET debugger to attach")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter Break { get; set; }

        /// <summary>The reference to the client API class.</summary>
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ContainerServiceClient Client => Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Module.Instance.ClientAPI;

        /// <summary>
        /// Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to 1000 (inclusive) for user
        /// pools and in the range of 1 to 1000 (inclusive) for system pools. The default value is 1.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to 1000 (inclusive) for user pools and in the range of 1 to 1000 (inclusive) for system pools. The default value is 1.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Number of agents (VMs) to host docker containers. Allowed values must be in the range of 0 to 1000 (inclusive) for user pools and in the range of 1 to 1000 (inclusive) for system pools. The default value is 1.",
        SerializedName = @"count",
        PossibleTypes = new [] { typeof(int) })]
        public int Count { get => _parametersBody.Count ?? default(int); set => _parametersBody.Count = value; }

        /// <summary>This is the ARM ID of the source object to be used to create the target object.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This is the ARM ID of the source object to be used to create the target object.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This is the ARM ID of the source object to be used to create the target object.",
        SerializedName = @"sourceResourceId",
        PossibleTypes = new [] { typeof(string) })]
        public string CreationDataSourceResourceId { get => _parametersBody.CreationDataSourceResourceId ?? null; set => _parametersBody.CreationDataSourceResourceId = value; }

        /// <summary>
        /// The DefaultProfile parameter is not functional. Use the SubscriptionId parameter when available if executing the cmdlet
        /// against a different subscription
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The DefaultProfile parameter is not functional. Use the SubscriptionId parameter when available if executing the cmdlet against a different subscription.")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::System.Management.Automation.Alias("AzureRMContext", "AzureCredential")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Azure)]
        public global::System.Management.Automation.PSObject DefaultProfile { get; set; }

        /// <summary>Whether to enable auto-scaler</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable auto-scaler")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable auto-scaler",
        SerializedName = @"enableAutoScaling",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter EnableAutoScaling { get => _parametersBody.EnableAutoScaling ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.EnableAutoScaling = value; }

        /// <summary>
        /// This is only supported on certain VM sizes and in certain Azure regions. For more information, see: https://docs.microsoft.com/azure/aks/enable-host-encryption
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This is only supported on certain VM sizes and in certain Azure regions. For more information, see: https://docs.microsoft.com/azure/aks/enable-host-encryption")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This is only supported on certain VM sizes and in certain Azure regions. For more information, see: https://docs.microsoft.com/azure/aks/enable-host-encryption",
        SerializedName = @"enableEncryptionAtHost",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter EnableEncryptionAtHost { get => _parametersBody.EnableEncryptionAtHost ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.EnableEncryptionAtHost = value; }

        /// <summary>
        /// See [Add a FIPS-enabled node pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#add-a-fips-enabled-node-pool-preview)
        /// for more details.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "See [Add a FIPS-enabled node pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#add-a-fips-enabled-node-pool-preview) for more details.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"See [Add a FIPS-enabled node pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#add-a-fips-enabled-node-pool-preview) for more details.",
        SerializedName = @"enableFIPS",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter EnableFips { get => _parametersBody.EnableFips ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.EnableFips = value; }

        /// <summary>
        /// Some scenarios may require nodes in a node pool to receive their own dedicated public IP addresses. A common scenario
        /// is for gaming workloads, where a console needs to make a direct connection to a cloud virtual machine to minimize hops.
        /// For more information see [assigning a public IP per node](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#assign-a-public-ip-per-node-for-your-node-pools).
        /// The default is false.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Some scenarios may require nodes in a node pool to receive their own dedicated public IP addresses. A common scenario is for gaming workloads, where a console needs to make a direct connection to a cloud virtual machine to minimize hops. For more information see [assigning a public IP per node](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#assign-a-public-ip-per-node-for-your-node-pools). The default is false.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Some scenarios may require nodes in a node pool to receive their own dedicated public IP addresses. A common scenario is for gaming workloads, where a console needs to make a direct connection to a cloud virtual machine to minimize hops. For more information see [assigning a public IP per node](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#assign-a-public-ip-per-node-for-your-node-pools). The default is false.",
        SerializedName = @"enableNodePublicIP",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter EnableNodePublicIP { get => _parametersBody.EnableNodePublicIP ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.EnableNodePublicIP = value; }

        /// <summary>Whether to enable UltraSSD</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Whether to enable UltraSSD")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Whether to enable UltraSSD",
        SerializedName = @"enableUltraSSD",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter EnableUltraSsd { get => _parametersBody.EnableUltraSsd ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.EnableUltraSsd = value; }

        /// <summary>
        /// GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"GPUInstanceProfile to be used to specify GPU MIG instance profile for supported GPU VM SKU.",
        SerializedName = @"gpuInstanceProfile",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.GpuInstanceProfile) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.GpuInstanceProfile))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.GpuInstanceProfile GpuInstanceProfile { get => _parametersBody.GpuInstanceProfile ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.GpuInstanceProfile)""); set => _parametersBody.GpuInstanceProfile = value; }

        /// <summary>
        /// This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}.
        /// For more information see [Azure dedicated hosts](https://docs.microsoft.com/azure/virtual-machines/dedicated-hosts).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}. For more information see [Azure dedicated hosts](https://docs.microsoft.com/azure/virtual-machines/dedicated-hosts).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/hostGroups/{hostGroupName}. For more information see [Azure dedicated hosts](https://docs.microsoft.com/azure/virtual-machines/dedicated-hosts).",
        SerializedName = @"hostGroupID",
        PossibleTypes = new [] { typeof(string) })]
        public string HostGroupId { get => _parametersBody.HostGroupId ?? null; set => _parametersBody.HostGroupId = value; }

        /// <summary>SendAsync Pipeline Steps to be appended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be appended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.SendAsyncStep[] HttpPipelineAppend { get; set; }

        /// <summary>SendAsync Pipeline Steps to be prepended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be prepended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.SendAsyncStep[] HttpPipelinePrepend { get; set; }

        /// <summary>Accessor for our copy of the InvocationInfo.</summary>
        public global::System.Management.Automation.InvocationInfo InvocationInformation { get => __invocationInfo = __invocationInfo ?? this.MyInvocation ; set { __invocationInfo = value; } }

        /// <summary>Allowed list of unsafe sysctls or unsafe sysctl patterns (ending in `*`).</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Allowed list of unsafe sysctls or unsafe sysctl patterns (ending in `*`).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Allowed list of unsafe sysctls or unsafe sysctl patterns (ending in `*`).",
        SerializedName = @"allowedUnsafeSysctls",
        PossibleTypes = new [] { typeof(string) })]
        public string[] KubeletConfigAllowedUnsafeSysctl { get => _parametersBody.KubeletConfigAllowedUnsafeSysctl ?? null /* arrayOf */; set => _parametersBody.KubeletConfigAllowedUnsafeSysctl = value; }

        /// <summary>
        /// The maximum number of container log files that can be present for a container. The number must be ≥ 2.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The maximum number of container log files that can be present for a container. The number must be ≥ 2.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The maximum number of container log files that can be present for a container. The number must be ≥ 2.",
        SerializedName = @"containerLogMaxFiles",
        PossibleTypes = new [] { typeof(int) })]
        public int KubeletConfigContainerLogMaxFile { get => _parametersBody.KubeletConfigContainerLogMaxFile ?? default(int); set => _parametersBody.KubeletConfigContainerLogMaxFile = value; }

        /// <summary>The maximum size (e.g. 10Mi) of container log file before it is rotated.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The maximum size (e.g. 10Mi) of container log file before it is rotated.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The maximum size (e.g. 10Mi) of container log file before it is rotated.",
        SerializedName = @"containerLogMaxSizeMB",
        PossibleTypes = new [] { typeof(int) })]
        public int KubeletConfigContainerLogMaxSizeMb { get => _parametersBody.KubeletConfigContainerLogMaxSizeMb ?? default(int); set => _parametersBody.KubeletConfigContainerLogMaxSizeMb = value; }

        /// <summary>The default is true.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is true.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is true.",
        SerializedName = @"cpuCfsQuota",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter KubeletConfigCpuCfsQuota { get => _parametersBody.KubeletConfigCpuCfsQuota ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.KubeletConfigCpuCfsQuota = value; }

        /// <summary>
        /// The default is '100ms.' Valid values are a sequence of decimal numbers with an optional fraction and a unit suffix. For
        /// example: '300ms', '2h45m'. Supported units are 'ns', 'us', 'ms', 's', 'm', and 'h'.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is '100ms.' Valid values are a sequence of decimal numbers with an optional fraction and a unit suffix. For example: '300ms', '2h45m'. Supported units are 'ns', 'us', 'ms', 's', 'm', and 'h'.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is '100ms.' Valid values are a sequence of decimal numbers with an optional fraction and a unit suffix. For example: '300ms', '2h45m'. Supported units are 'ns', 'us', 'ms', 's', 'm', and 'h'.",
        SerializedName = @"cpuCfsQuotaPeriod",
        PossibleTypes = new [] { typeof(string) })]
        public string KubeletConfigCpuCfsQuotaPeriod { get => _parametersBody.KubeletConfigCpuCfsQuotaPeriod ?? null; set => _parametersBody.KubeletConfigCpuCfsQuotaPeriod = value; }

        /// <summary>
        /// The default is 'none'. See [Kubernetes CPU management policies](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/#cpu-management-policies)
        /// for more information. Allowed values are 'none' and 'static'.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is 'none'. See [Kubernetes CPU management policies](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/#cpu-management-policies) for more information. Allowed values are 'none' and 'static'.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is 'none'. See [Kubernetes CPU management policies](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/#cpu-management-policies) for more information. Allowed values are 'none' and 'static'.",
        SerializedName = @"cpuManagerPolicy",
        PossibleTypes = new [] { typeof(string) })]
        public string KubeletConfigCpuManagerPolicy { get => _parametersBody.KubeletConfigCpuManagerPolicy ?? null; set => _parametersBody.KubeletConfigCpuManagerPolicy = value; }

        /// <summary>
        /// If set to true it will make the Kubelet fail to start if swap is enabled on the node.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "If set to true it will make the Kubelet fail to start if swap is enabled on the node.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If set to true it will make the Kubelet fail to start if swap is enabled on the node.",
        SerializedName = @"failSwapOn",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter KubeletConfigFailSwapOn { get => _parametersBody.KubeletConfigFailSwapOn ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.KubeletConfigFailSwapOn = value; }

        /// <summary>To disable image garbage collection, set to 100. The default is 85%</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "To disable image garbage collection, set to 100. The default is 85%")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"To disable image garbage collection, set to 100. The default is 85%",
        SerializedName = @"imageGcHighThreshold",
        PossibleTypes = new [] { typeof(int) })]
        public int KubeletConfigImageGcHighThreshold { get => _parametersBody.KubeletConfigImageGcHighThreshold ?? default(int); set => _parametersBody.KubeletConfigImageGcHighThreshold = value; }

        /// <summary>This cannot be set higher than imageGcHighThreshold. The default is 80%</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This cannot be set higher than imageGcHighThreshold. The default is 80%")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This cannot be set higher than imageGcHighThreshold. The default is 80%",
        SerializedName = @"imageGcLowThreshold",
        PossibleTypes = new [] { typeof(int) })]
        public int KubeletConfigImageGcLowThreshold { get => _parametersBody.KubeletConfigImageGcLowThreshold ?? default(int); set => _parametersBody.KubeletConfigImageGcLowThreshold = value; }

        /// <summary>The maximum number of processes per pod.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The maximum number of processes per pod.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The maximum number of processes per pod.",
        SerializedName = @"podMaxPids",
        PossibleTypes = new [] { typeof(int) })]
        public int KubeletConfigPodMaxPid { get => _parametersBody.KubeletConfigPodMaxPid ?? default(int); set => _parametersBody.KubeletConfigPodMaxPid = value; }

        /// <summary>
        /// For more information see [Kubernetes Topology Manager](https://kubernetes.io/docs/tasks/administer-cluster/topology-manager).
        /// The default is 'none'. Allowed values are 'none', 'best-effort', 'restricted', and 'single-numa-node'.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "For more information see [Kubernetes Topology Manager](https://kubernetes.io/docs/tasks/administer-cluster/topology-manager). The default is 'none'. Allowed values are 'none', 'best-effort', 'restricted', and 'single-numa-node'.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"For more information see [Kubernetes Topology Manager](https://kubernetes.io/docs/tasks/administer-cluster/topology-manager). The default is 'none'. Allowed values are 'none', 'best-effort', 'restricted', and 'single-numa-node'.",
        SerializedName = @"topologyManagerPolicy",
        PossibleTypes = new [] { typeof(string) })]
        public string KubeletConfigTopologyManagerPolicy { get => _parametersBody.KubeletConfigTopologyManagerPolicy ?? null; set => _parametersBody.KubeletConfigTopologyManagerPolicy = value; }

        /// <summary>
        /// Determines the placement of emptyDir volumes, container runtime data root, and Kubelet ephemeral storage.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Determines the placement of emptyDir volumes, container runtime data root, and Kubelet ephemeral storage.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Determines the placement of emptyDir volumes, container runtime data root, and Kubelet ephemeral storage.",
        SerializedName = @"kubeletDiskType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KubeletDiskType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KubeletDiskType))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KubeletDiskType KubeletDiskType { get => _parametersBody.KubeletDiskType ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.KubeletDiskType)""); set => _parametersBody.KubeletDiskType = value; }

        /// <summary>The size in MB of a swap file that will be created on each node.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The size in MB of a swap file that will be created on each node.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The size in MB of a swap file that will be created on each node.",
        SerializedName = @"swapFileSizeMB",
        PossibleTypes = new [] { typeof(int) })]
        public int LinuxOSConfigSwapFileSizeMb { get => _parametersBody.LinuxOSConfigSwapFileSizeMb ?? default(int); set => _parametersBody.LinuxOSConfigSwapFileSizeMb = value; }

        /// <summary>Sysctl settings for Linux agent nodes.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Sysctl settings for Linux agent nodes.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Sysctl settings for Linux agent nodes.",
        SerializedName = @"sysctls",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.ISysctlConfig) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.ISysctlConfig LinuxOSConfigSysctl { get => _parametersBody.LinuxOSConfigSysctl ?? null /* object */; set => _parametersBody.LinuxOSConfigSysctl = value; }

        /// <summary>
        /// Valid values are 'always', 'defer', 'defer+madvise', 'madvise' and 'never'. The default is 'madvise'. For more information
        /// see [Transparent Hugepages](https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html#admin-guide-transhuge).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Valid values are 'always', 'defer', 'defer+madvise', 'madvise' and 'never'. The default is 'madvise'. For more information see [Transparent Hugepages](https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html#admin-guide-transhuge).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Valid values are 'always', 'defer', 'defer+madvise', 'madvise' and 'never'. The default is 'madvise'. For more information see [Transparent Hugepages](https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html#admin-guide-transhuge).",
        SerializedName = @"transparentHugePageDefrag",
        PossibleTypes = new [] { typeof(string) })]
        public string LinuxOSConfigTransparentHugePageDefrag { get => _parametersBody.LinuxOSConfigTransparentHugePageDefrag ?? null; set => _parametersBody.LinuxOSConfigTransparentHugePageDefrag = value; }

        /// <summary>
        /// Valid values are 'always', 'madvise', and 'never'. The default is 'always'. For more information see [Transparent Hugepages](https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html#admin-guide-transhuge).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Valid values are 'always', 'madvise', and 'never'. The default is 'always'. For more information see [Transparent Hugepages](https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html#admin-guide-transhuge).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Valid values are 'always', 'madvise', and 'never'. The default is 'always'. For more information see [Transparent Hugepages](https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html#admin-guide-transhuge).",
        SerializedName = @"transparentHugePageEnabled",
        PossibleTypes = new [] { typeof(string) })]
        public string LinuxOSConfigTransparentHugePageEnabled { get => _parametersBody.LinuxOSConfigTransparentHugePageEnabled ?? null; set => _parametersBody.LinuxOSConfigTransparentHugePageEnabled = value; }

        /// <summary>The maximum number of nodes for auto-scaling</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The maximum number of nodes for auto-scaling")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The maximum number of nodes for auto-scaling",
        SerializedName = @"maxCount",
        PossibleTypes = new [] { typeof(int) })]
        public int MaxCount { get => _parametersBody.MaxCount ?? default(int); set => _parametersBody.MaxCount = value; }

        /// <summary>The maximum number of pods that can run on a node.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The maximum number of pods that can run on a node.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The maximum number of pods that can run on a node.",
        SerializedName = @"maxPods",
        PossibleTypes = new [] { typeof(int) })]
        public int MaxPod { get => _parametersBody.MaxPod ?? default(int); set => _parametersBody.MaxPod = value; }

        /// <summary>
        /// <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener" /> cancellation delegate. Stops the cmdlet when called.
        /// </summary>
        global::System.Action Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener.Cancel => _cancellationTokenSource.Cancel;

        /// <summary><see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener" /> cancellation token.</summary>
        global::System.Threading.CancellationToken Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener.Token => _cancellationTokenSource.Token;

        /// <summary>The minimum number of nodes for auto-scaling</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The minimum number of nodes for auto-scaling")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The minimum number of nodes for auto-scaling",
        SerializedName = @"minCount",
        PossibleTypes = new [] { typeof(int) })]
        public int MinCount { get => _parametersBody.MinCount ?? default(int); set => _parametersBody.MinCount = value; }

        /// <summary>
        /// A cluster must have at least one 'System' Agent Pool at all times. For additional information on agent pool restrictions
        /// and best practices, see: https://docs.microsoft.com/azure/aks/use-system-pools
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "A cluster must have at least one 'System' Agent Pool at all times. For additional information on agent pool restrictions and best practices, see: https://docs.microsoft.com/azure/aks/use-system-pools")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A cluster must have at least one 'System' Agent Pool at all times. For additional information on agent pool restrictions and best practices, see: https://docs.microsoft.com/azure/aks/use-system-pools",
        SerializedName = @"mode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.AgentPoolMode) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.AgentPoolMode))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.AgentPoolMode Mode { get => _parametersBody.Mode ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.AgentPoolMode)""); set => _parametersBody.Mode = value; }

        /// <summary>Backing field for <see cref="Name" /> property.</summary>
        private string _name;

        /// <summary>The name of the agent pool.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The name of the agent pool.")]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The name of the agent pool.",
        SerializedName = @"agentPoolName",
        PossibleTypes = new [] { typeof(string) })]
        [global::System.Management.Automation.Alias("AgentPoolName")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Path)]
        public string Name { get => this._name; set => this._name = value; }

        /// <summary>
        /// when specified, will make the remote call, and return an AsyncOperationResponse, letting the remote operation continue
        /// asynchronously.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Run the command asynchronously")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter NoWait { get; set; }

        /// <summary>The node labels to be persisted across all nodes in agent pool.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ExportAs(typeof(global::System.Collections.Hashtable))]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The node labels to be persisted across all nodes in agent pool.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The node labels to be persisted across all nodes in agent pool.",
        SerializedName = @"nodeLabels",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedClusterAgentPoolProfilePropertiesNodeLabels) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedClusterAgentPoolProfilePropertiesNodeLabels NodeLabel { get => _parametersBody.NodeLabel ?? null /* object */; set => _parametersBody.NodeLabel = value; }

        /// <summary>
        /// This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIPPrefixName}",
        SerializedName = @"nodePublicIPPrefixID",
        PossibleTypes = new [] { typeof(string) })]
        public string NodePublicIPPrefixId { get => _parametersBody.NodePublicIPPrefixId ?? null; set => _parametersBody.NodePublicIPPrefixId = value; }

        /// <summary>
        /// The taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule.
        /// </summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The taints added to new nodes during node pool create and scale. For example, key=value:NoSchedule.",
        SerializedName = @"nodeTaints",
        PossibleTypes = new [] { typeof(string) })]
        public string[] NodeTaint { get => _parametersBody.NodeTaint ?? null /* arrayOf */; set => _parametersBody.NodeTaint = value; }

        /// <summary>
        /// OS Disk Size in GB to be used to specify the disk size for every machine in the master/agent pool. If you specify 0, it
        /// will apply the default osDisk size according to the vmSize specified.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "OS Disk Size in GB to be used to specify the disk size for every machine in the master/agent pool. If you specify 0, it will apply the default osDisk size according to the vmSize specified.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"OS Disk Size in GB to be used to specify the disk size for every machine in the master/agent pool. If you specify 0, it will apply the default osDisk size according to the vmSize specified.",
        SerializedName = @"osDiskSizeGB",
        PossibleTypes = new [] { typeof(int) })]
        public int OSDiskSizeGb { get => _parametersBody.OSDiskSizeGb ?? default(int); set => _parametersBody.OSDiskSizeGb = value; }

        /// <summary>
        /// The default is 'Ephemeral' if the VM supports it and has a cache disk larger than the requested OSDiskSizeGB. Otherwise,
        /// defaults to 'Managed'. May not be changed after creation. For more information see [Ephemeral OS](https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The default is 'Ephemeral' if the VM supports it and has a cache disk larger than the requested OSDiskSizeGB. Otherwise, defaults to 'Managed'. May not be changed after creation. For more information see [Ephemeral OS](https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The default is 'Ephemeral' if the VM supports it and has a cache disk larger than the requested OSDiskSizeGB. Otherwise, defaults to 'Managed'. May not be changed after creation. For more information see [Ephemeral OS](https://docs.microsoft.com/azure/aks/cluster-configuration#ephemeral-os).",
        SerializedName = @"osDiskType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.OSDiskType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.OSDiskType))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.OSDiskType OSDiskType { get => _parametersBody.OSDiskType ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.OSDiskType)""); set => _parametersBody.OSDiskType = value; }

        /// <summary>
        /// Specifies the OS SKU used by the agent pool. The default is Ubuntu if OSType is Linux. The default is Windows2019 when
        /// Kubernetes <= 1.24 or Windows2022 when Kubernetes >= 1.25 if OSType is Windows.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the OS SKU used by the agent pool. The default is Ubuntu if OSType is Linux. The default is Windows2019 when Kubernetes <= 1.24 or Windows2022 when Kubernetes >= 1.25 if OSType is Windows.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the OS SKU used by the agent pool. The default is Ubuntu if OSType is Linux. The default is Windows2019 when Kubernetes <= 1.24 or Windows2022 when Kubernetes >= 1.25 if OSType is Windows.",
        SerializedName = @"osSKU",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Ossku) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Ossku))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Ossku OSSku { get => _parametersBody.OSSku ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Ossku)""); set => _parametersBody.OSSku = value; }

        /// <summary>The operating system type. The default is Linux.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The operating system type. The default is Linux.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The operating system type. The default is Linux.",
        SerializedName = @"osType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.OSType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.OSType))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.OSType OSType { get => _parametersBody.OSType ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.OSType)""); set => _parametersBody.OSType = value; }

        /// <summary>
        /// Both patch version <major.minor.patch> (e.g. 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor>
        /// is specified, the latest supported GA patch version is chosen automatically. Updating the cluster with the same <major.minor>
        /// once it has been created (e.g. 1.14.x -> 1.14) will not trigger an upgrade, even if a newer patch version is available.
        /// As a best practice, you should upgrade all node pools in an AKS cluster to the same Kubernetes version. The node pool
        /// version must have the same major version as the control plane. The node pool minor version must be within two minor versions
        /// of the control plane version. The node pool version cannot be greater than the control plane version. For more information
        /// see [upgrading a node pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#upgrade-a-node-pool).
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Both patch version <major.minor.patch> (e.g. 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor> is specified, the latest supported GA patch version is chosen automatically. Updating the cluster with the same <major.minor> once it has been created (e.g. 1.14.x -> 1.14) will not trigger an upgrade, even if a newer patch version is available. As a best practice, you should upgrade all node pools in an AKS cluster to the same Kubernetes version. The node pool version must have the same major version as the control plane. The node pool minor version must be within two minor versions of the control plane version. The node pool version cannot be greater than the control plane version. For more information see [upgrading a node pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#upgrade-a-node-pool).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Both patch version <major.minor.patch> (e.g. 1.20.13) and <major.minor> (e.g. 1.20) are supported. When <major.minor> is specified, the latest supported GA patch version is chosen automatically. Updating the cluster with the same <major.minor> once it has been created (e.g. 1.14.x -> 1.14) will not trigger an upgrade, even if a newer patch version is available. As a best practice, you should upgrade all node pools in an AKS cluster to the same Kubernetes version. The node pool version must have the same major version as the control plane. The node pool minor version must be within two minor versions of the control plane version. The node pool version cannot be greater than the control plane version. For more information see [upgrading a node pool](https://docs.microsoft.com/azure/aks/use-multiple-node-pools#upgrade-a-node-pool).",
        SerializedName = @"orchestratorVersion",
        PossibleTypes = new [] { typeof(string) })]
        public string OrchestratorVersion { get => _parametersBody.OrchestratorVersion ?? null; set => _parametersBody.OrchestratorVersion = value; }

        /// <summary>
        /// The instance of the <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.HttpPipeline" /> that the remote call will use.
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.HttpPipeline Pipeline { get; set; }

        /// <summary>
        /// If omitted, pod IPs are statically assigned on the node subnet (see vnetSubnetID for more details). This is of the form:
        /// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "If omitted, pod IPs are statically assigned on the node subnet (see vnetSubnetID for more details). This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If omitted, pod IPs are statically assigned on the node subnet (see vnetSubnetID for more details). This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}",
        SerializedName = @"podSubnetID",
        PossibleTypes = new [] { typeof(string) })]
        public string PodSubnetId { get => _parametersBody.PodSubnetId ?? null; set => _parametersBody.PodSubnetId = value; }

        /// <summary>Tells whether the cluster is Running or Stopped</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Tells whether the cluster is Running or Stopped")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Tells whether the cluster is Running or Stopped",
        SerializedName = @"code",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Code) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Code))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Code PowerStateCode { get => _parametersBody.PowerStateCode ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.Code)""); set => _parametersBody.PowerStateCode = value; }

        /// <summary>The type of Agent Pool.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The type of Agent Pool.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The type of Agent Pool.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.AgentPoolType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.AgentPoolType))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.AgentPoolType PropertiesType { get => _parametersBody.PropertiesType ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.AgentPoolType)""); set => _parametersBody.PropertiesType = value; }

        /// <summary>The ID for Proximity Placement Group.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The ID for Proximity Placement Group.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The ID for Proximity Placement Group.",
        SerializedName = @"proximityPlacementGroupID",
        PossibleTypes = new [] { typeof(string) })]
        public string ProximityPlacementGroupId { get => _parametersBody.ProximityPlacementGroupId ?? null; set => _parametersBody.ProximityPlacementGroupId = value; }

        /// <summary>The URI for the proxy server to use</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "The URI for the proxy server to use")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Uri Proxy { get; set; }

        /// <summary>Credentials for a proxy server to use for the remote call</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Credentials for a proxy server to use for the remote call")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Management.Automation.PSCredential ProxyCredential { get; set; }

        /// <summary>Use the default credentials for the proxy</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Use the default credentials for the proxy")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter ProxyUseDefaultCredentials { get; set; }

        /// <summary>Backing field for <see cref="ResourceGroupName" /> property.</summary>
        private string _resourceGroupName;

        /// <summary>The name of the resource group. The name is case insensitive.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The name of the resource group. The name is case insensitive.")]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The name of the resource group. The name is case insensitive.",
        SerializedName = @"resourceGroupName",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Path)]
        public string ResourceGroupName { get => this._resourceGroupName; set => this._resourceGroupName = value; }

        /// <summary>Backing field for <see cref="ResourceName" /> property.</summary>
        private string _resourceName;

        /// <summary>The name of the managed cluster resource.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The name of the managed cluster resource.")]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The name of the managed cluster resource.",
        SerializedName = @"resourceName",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Path)]
        public string ResourceName { get => this._resourceName; set => this._resourceName = value; }

        /// <summary>
        /// This also effects the cluster autoscaler behavior. If not specified, it defaults to Delete.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This also effects the cluster autoscaler behavior. If not specified, it defaults to Delete.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This also effects the cluster autoscaler behavior. If not specified, it defaults to Delete.",
        SerializedName = @"scaleDownMode",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ScaleDownMode) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ScaleDownMode))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ScaleDownMode ScaleDownMode { get => _parametersBody.ScaleDownMode ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ScaleDownMode)""); set => _parametersBody.ScaleDownMode = value; }

        /// <summary>
        /// This cannot be specified unless the scaleSetPriority is 'Spot'. If not specified, the default is 'Delete'.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This cannot be specified unless the scaleSetPriority is 'Spot'. If not specified, the default is 'Delete'.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This cannot be specified unless the scaleSetPriority is 'Spot'. If not specified, the default is 'Delete'.",
        SerializedName = @"scaleSetEvictionPolicy",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ScaleSetEvictionPolicy) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ScaleSetEvictionPolicy))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ScaleSetEvictionPolicy ScaleSetEvictionPolicy { get => _parametersBody.ScaleSetEvictionPolicy ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ScaleSetEvictionPolicy)""); set => _parametersBody.ScaleSetEvictionPolicy = value; }

        /// <summary>
        /// The Virtual Machine Scale Set priority. If not specified, the default is 'Regular'.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The Virtual Machine Scale Set priority. If not specified, the default is 'Regular'.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The Virtual Machine Scale Set priority. If not specified, the default is 'Regular'.",
        SerializedName = @"scaleSetPriority",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ScaleSetPriority) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ScaleSetPriority))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ScaleSetPriority ScaleSetPriority { get => _parametersBody.ScaleSetPriority ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.ScaleSetPriority)""); set => _parametersBody.ScaleSetPriority = value; }

        /// <summary>
        /// Possible values are any decimal value greater than zero or -1 which indicates the willingness to pay any on-demand price.
        /// For more details on spot pricing, see [spot VMs pricing](https://docs.microsoft.com/azure/virtual-machines/spot-vms#pricing)
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Possible values are any decimal value greater than zero or -1 which indicates the willingness to pay any on-demand price. For more details on spot pricing, see [spot VMs pricing](https://docs.microsoft.com/azure/virtual-machines/spot-vms#pricing)")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Possible values are any decimal value greater than zero or -1 which indicates the willingness to pay any on-demand price. For more details on spot pricing, see [spot VMs pricing](https://docs.microsoft.com/azure/virtual-machines/spot-vms#pricing)",
        SerializedName = @"spotMaxPrice",
        PossibleTypes = new [] { typeof(float) })]
        public float SpotMaxPrice { get => _parametersBody.SpotMaxPrice ?? default(float); set => _parametersBody.SpotMaxPrice = value; }

        /// <summary>Backing field for <see cref="SubscriptionId" /> property.</summary>
        private string _subscriptionId;

        /// <summary>The ID of the target subscription.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The ID of the target subscription.")]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The ID of the target subscription.",
        SerializedName = @"subscriptionId",
        PossibleTypes = new [] { typeof(string) })]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.DefaultInfo(
        Name = @"",
        Description =@"",
        Script = @"(Get-AzContext).Subscription.Id")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Path)]
        public string SubscriptionId { get => this._subscriptionId; set => this._subscriptionId = value; }

        /// <summary>The tags to be persisted on the agent pool virtual machine scale set.</summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ExportAs(typeof(global::System.Collections.Hashtable))]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The tags to be persisted on the agent pool virtual machine scale set.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The tags to be persisted on the agent pool virtual machine scale set.",
        SerializedName = @"tags",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedClusterAgentPoolProfilePropertiesTags) })]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IManagedClusterAgentPoolProfilePropertiesTags Tag { get => _parametersBody.Tag ?? null /* object */; set => _parametersBody.Tag = value; }

        /// <summary>
        /// This can either be set to an integer (e.g. '5') or a percentage (e.g. '50%'). If a percentage is specified, it is the
        /// percentage of the total agent pool size at the time of the upgrade. For percentages, fractional nodes are rounded up.
        /// If not specified, the default is 1. For more information, including best practices, see: https://docs.microsoft.com/azure/aks/upgrade-cluster#customize-node-surge-upgrade
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This can either be set to an integer (e.g. '5') or a percentage (e.g. '50%'). If a percentage is specified, it is the percentage of the total agent pool size at the time of the upgrade. For percentages, fractional nodes are rounded up. If not specified, the default is 1. For more information, including best practices, see: https://docs.microsoft.com/azure/aks/upgrade-cluster#customize-node-surge-upgrade")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This can either be set to an integer (e.g. '5') or a percentage (e.g. '50%'). If a percentage is specified, it is the percentage of the total agent pool size at the time of the upgrade. For percentages, fractional nodes are rounded up. If not specified, the default is 1. For more information, including best practices, see: https://docs.microsoft.com/azure/aks/upgrade-cluster#customize-node-surge-upgrade",
        SerializedName = @"maxSurge",
        PossibleTypes = new [] { typeof(string) })]
        public string UpgradeSettingMaxSurge { get => _parametersBody.UpgradeSettingMaxSurge ?? null; set => _parametersBody.UpgradeSettingMaxSurge = value; }

        /// <summary>
        /// VM size availability varies by region. If a node contains insufficient compute resources (memory, cpu, etc) pods might
        /// fail to run correctly. For more details on restricted VM sizes, see: https://docs.microsoft.com/azure/aks/quotas-skus-regions
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "VM size availability varies by region. If a node contains insufficient compute resources (memory, cpu, etc) pods might fail to run correctly. For more details on restricted VM sizes, see: https://docs.microsoft.com/azure/aks/quotas-skus-regions")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"VM size availability varies by region. If a node contains insufficient compute resources (memory, cpu, etc) pods might fail to run correctly. For more details on restricted VM sizes, see: https://docs.microsoft.com/azure/aks/quotas-skus-regions",
        SerializedName = @"vmSize",
        PossibleTypes = new [] { typeof(string) })]
        public string VMSize { get => _parametersBody.VMSize ?? null; set => _parametersBody.VMSize = value; }

        /// <summary>
        /// If this is not specified, a VNET and subnet will be generated and used. If no podSubnetID is specified, this applies to
        /// nodes and pods, otherwise it applies to just nodes. This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "If this is not specified, a VNET and subnet will be generated and used. If no podSubnetID is specified, this applies to nodes and pods, otherwise it applies to just nodes. This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"If this is not specified, a VNET and subnet will be generated and used. If no podSubnetID is specified, this applies to nodes and pods, otherwise it applies to just nodes. This is of the form: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}",
        SerializedName = @"vnetSubnetID",
        PossibleTypes = new [] { typeof(string) })]
        public string VnetSubnetId { get => _parametersBody.VnetSubnetId ?? null; set => _parametersBody.VnetSubnetId = value; }

        /// <summary>Determines the type of workload a node can run.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Determines the type of workload a node can run.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Category(global::Microsoft.Azure.PowerShell.Cmdlets.ContainerService.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Determines the type of workload a node can run.",
        SerializedName = @"workloadRuntime",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.WorkloadRuntime) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.WorkloadRuntime))]
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.WorkloadRuntime WorkloadRuntime { get => _parametersBody.WorkloadRuntime ?? ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Support.WorkloadRuntime)""); set => _parametersBody.WorkloadRuntime = value; }

        /// <summary>
        /// <c>overrideOnDefault</c> will be called before the regular onDefault has been processed, allowing customization of what
        /// happens on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.ICloudError">Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.ICloudError</see>
        /// from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onDefault method should be processed, or if the method should
        /// return immediately (set to true to skip further processing )</param>

        partial void overrideOnDefault(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.ICloudError> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// <c>overrideOnOk</c> will be called before the regular onOk has been processed, allowing customization of what happens
        /// on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IAgentPool">Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IAgentPool</see>
        /// from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onOk method should be processed, or if the method should return
        /// immediately (set to true to skip further processing )</param>

        partial void overrideOnOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IAgentPool> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// (overrides the default BeginProcessing method in global::System.Management.Automation.PSCmdlet)
        /// </summary>
        protected override void BeginProcessing()
        {
            var telemetryId = Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Module.Instance.GetTelemetryId.Invoke();
            if (telemetryId != "" && telemetryId != "internal")
            {
                __correlationId = telemetryId;
            }
            Module.Instance.SetProxyConfiguration(Proxy, ProxyCredential, ProxyUseDefaultCredentials);
            if (Break)
            {
                Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.AttachDebugger.Break();
            }
            ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletBeginProcessing).Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
        }

        /// <summary>Creates a duplicate instance of this cmdlet (via JSON serialization).</summary>
        /// <returns>a duplicate instance of NewAzContainerServiceAgentPool_CreateExpanded</returns>
        public Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Cmdlets.NewAzContainerServiceAgentPool_CreateExpanded Clone()
        {
            var clone = new NewAzContainerServiceAgentPool_CreateExpanded();
            clone.__correlationId = this.__correlationId;
            clone.__processRecordId = this.__processRecordId;
            clone.DefaultProfile = this.DefaultProfile;
            clone.InvocationInformation = this.InvocationInformation;
            clone.Proxy = this.Proxy;
            clone.Pipeline = this.Pipeline;
            clone.AsJob = this.AsJob;
            clone.Break = this.Break;
            clone.ProxyCredential = this.ProxyCredential;
            clone.ProxyUseDefaultCredentials = this.ProxyUseDefaultCredentials;
            clone.HttpPipelinePrepend = this.HttpPipelinePrepend;
            clone.HttpPipelineAppend = this.HttpPipelineAppend;
            clone._parametersBody = this._parametersBody;
            clone.SubscriptionId = this.SubscriptionId;
            clone.ResourceGroupName = this.ResourceGroupName;
            clone.ResourceName = this.ResourceName;
            clone.Name = this.Name;
            return clone;
        }

        /// <summary>Performs clean-up after the command execution</summary>
        protected override void EndProcessing()
        {

        }

        /// <summary>Handles/Dispatches events during the call to the REST service.</summary>
        /// <param name="id">The message id</param>
        /// <param name="token">The message cancellation token. When this call is cancelled, this should be <c>true</c></param>
        /// <param name="messageData">Detailed message data for the message event.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the message is completed.
        /// </returns>
         async global::System.Threading.Tasks.Task Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener.Signal(string id, global::System.Threading.CancellationToken token, global::System.Func<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.EventData> messageData)
        {
            using( NoSynchronizationContext )
            {
                if (token.IsCancellationRequested)
                {
                    return ;
                }

                switch ( id )
                {
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.Verbose:
                    {
                        WriteVerbose($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.Warning:
                    {
                        WriteWarning($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.Information:
                    {
                        // When an operation supports asjob, Information messages must go thru verbose.
                        WriteVerbose($"INFORMATION: {(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.Debug:
                    {
                        WriteDebug($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.Error:
                    {
                        WriteError(new global::System.Management.Automation.ErrorRecord( new global::System.Exception(messageData().Message), string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null ) );
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.DelayBeforePolling:
                    {
                        if (true == MyInvocation?.BoundParameters?.ContainsKey("NoWait"))
                        {
                            var data = messageData();
                            if (data.ResponseMessage is System.Net.Http.HttpResponseMessage response)
                            {
                                var asyncOperation = response.GetFirstHeader(@"Azure-AsyncOperation");
                                var location = response.GetFirstHeader(@"Location");
                                var uri = global::System.String.IsNullOrEmpty(asyncOperation) ? global::System.String.IsNullOrEmpty(location) ? response.RequestMessage.RequestUri.AbsoluteUri : location : asyncOperation;
                                WriteObject(new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.PowerShell.AsyncOperationResponse { Target = uri });
                                // do nothing more.
                                data.Cancel();
                                return;
                            }
                        }
                        break;
                    }
                }
                await Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Module.Instance.Signal(id, token, messageData, (i,t,m) => ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(i,t,()=> Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.EventDataConverter.ConvertFrom( m() ) as Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.EventData ), InvocationInformation, this.ParameterSetName, __correlationId, __processRecordId, null );
                if (token.IsCancellationRequested)
                {
                    return ;
                }
                WriteDebug($"{id}: {(messageData().Message ?? global::System.String.Empty)}");
            }
        }

        /// <summary>
        /// Intializes a new instance of the <see cref="NewAzContainerServiceAgentPool_CreateExpanded" /> cmdlet class.
        /// </summary>
        public NewAzContainerServiceAgentPool_CreateExpanded()
        {

        }

        /// <summary>Performs execution of the command.</summary>
        protected override void ProcessRecord()
        {
            ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletProcessRecordStart).Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
            __processRecordId = System.Guid.NewGuid().ToString();
            try
            {
                // work
                if (ShouldProcess($"Call remote 'AgentPoolsCreateOrUpdate' operation"))
                {
                    if (true == MyInvocation?.BoundParameters?.ContainsKey("AsJob"))
                    {
                        var instance = this.Clone();
                        var job = new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.PowerShell.AsyncJob(instance, this.MyInvocation.Line, this.MyInvocation.MyCommand.Name, this._cancellationTokenSource.Token, this._cancellationTokenSource.Cancel);
                        JobRepository.Add(job);
                        var task = instance.ProcessRecordAsync();
                        job.Monitor(task);
                        WriteObject(job);
                    }
                    else
                    {
                        using( var asyncCommandRuntime = new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.PowerShell.AsyncCommandRuntime(this, ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token) )
                        {
                            asyncCommandRuntime.Wait( ProcessRecordAsync(),((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token);
                        }
                    }
                }
            }
            catch (global::System.AggregateException aggregateException)
            {
                // unroll the inner exceptions to get the root cause
                foreach( var innerException in aggregateException.Flatten().InnerExceptions )
                {
                    ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletException, $"{innerException.GetType().Name} - {innerException.Message} : {innerException.StackTrace}").Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    // Write exception out to error channel.
                    WriteError( new global::System.Management.Automation.ErrorRecord(innerException,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
                }
            }
            catch (global::System.Exception exception) when ((exception as System.Management.Automation.PipelineStoppedException)== null || (exception as System.Management.Automation.PipelineStoppedException).InnerException != null)
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletException, $"{exception.GetType().Name} - {exception.Message} : {exception.StackTrace}").Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                // Write exception out to error channel.
                WriteError( new global::System.Management.Automation.ErrorRecord(exception,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
            }
            finally
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletProcessRecordEnd).Wait();
            }
        }

        /// <summary>Performs execution of the command, working asynchronously if required.</summary>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        protected async global::System.Threading.Tasks.Task ProcessRecordAsync()
        {
            using( NoSynchronizationContext )
            {
                await ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletGetPipeline); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                Pipeline = Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Module.Instance.CreatePipeline(InvocationInformation, __correlationId, __processRecordId, this.ParameterSetName);
                if (null != HttpPipelinePrepend)
                {
                    Pipeline.Prepend((this.CommandRuntime as Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelinePrepend) ?? HttpPipelinePrepend);
                }
                if (null != HttpPipelineAppend)
                {
                    Pipeline.Append((this.CommandRuntime as Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelineAppend) ?? HttpPipelineAppend);
                }
                // get the client instance
                try
                {
                    await ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletBeforeAPICall); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    await this.Client.AgentPoolsCreateOrUpdate(SubscriptionId, ResourceGroupName, ResourceName, Name, _parametersBody, onOk, onDefault, this, Pipeline);
                    await ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletAfterAPICall); if( ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                }
                catch (Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.UndeclaredResponseException urexception)
                {
                    WriteError(new global::System.Management.Automation.ErrorRecord(urexception, urexception.StatusCode.ToString(), global::System.Management.Automation.ErrorCategory.InvalidOperation, new {  SubscriptionId=SubscriptionId,ResourceGroupName=ResourceGroupName,ResourceName=ResourceName,Name=Name,body=_parametersBody})
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(urexception.Message) { RecommendedAction = urexception.Action }
                    });
                }
                finally
                {
                    await ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.Events.CmdletProcessRecordAsyncEnd);
                }
            }
        }

        /// <summary>Interrupts currently running code within the command.</summary>
        protected override void StopProcessing()
        {
            ((Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.IEventListener)this).Cancel();
            base.StopProcessing();
        }

        /// <summary>
        /// a delegate that is called when the remote service returns default (any response code not handled elsewhere).
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.ICloudError">Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.ICloudError</see>
        /// from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onDefault(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.ICloudError> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnDefault(responseMessage, response, ref _returnNow);
                // if overrideOnDefault has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // Error Response : default
                var code = (await response)?.Code;
                var message = (await response)?.Message;
                if ((null == code || null == message))
                {
                    // Unrecognized Response. Create an error record based on what we have.
                    var ex = new Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Runtime.RestException<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.ICloudError>(responseMessage, await response);
                    WriteError( new global::System.Management.Automation.ErrorRecord(ex, ex.Code, global::System.Management.Automation.ErrorCategory.InvalidOperation, new { SubscriptionId=SubscriptionId, ResourceGroupName=ResourceGroupName, ResourceName=ResourceName, Name=Name, body=_parametersBody })
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(ex.Message) { RecommendedAction = ex.Action }
                    });
                }
                else
                {
                    WriteError( new global::System.Management.Automation.ErrorRecord(new global::System.Exception($"[{code}] : {message}"), code?.ToString(), global::System.Management.Automation.ErrorCategory.InvalidOperation, new { SubscriptionId=SubscriptionId, ResourceGroupName=ResourceGroupName, ResourceName=ResourceName, Name=Name, body=_parametersBody })
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(message) { RecommendedAction = global::System.String.Empty }
                    });
                }
            }
        }

        /// <summary>a delegate that is called when the remote service returns 200 (OK).</summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IAgentPool">Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IAgentPool</see>
        /// from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IAgentPool> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnOk(responseMessage, response, ref _returnNow);
                // if overrideOnOk has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // onOk - response for 200 / application/json
                // (await response) // should be Microsoft.Azure.PowerShell.Cmdlets.ContainerService.Models.Api20230301.IAgentPool
                WriteObject((await response));
            }
        }
    }
}