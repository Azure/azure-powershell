// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

namespace Microsoft.Azure.PowerShell.Cmdlets.Storage.Cmdlets
{
    using static Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Extensions;
    using System;

    /// <summary>
    /// The update operation can be used to update the SKU, encryption, access tier, or tags for a storage account. It can also
    /// be used to map the account to a custom domain. Only one custom domain is supported per storage account; the replacement/change
    /// of custom domain is not supported. In order to replace an old custom domain, the old value must be cleared/unregistered
    /// before a new value can be set. The update of multiple properties is supported. This call does not change the storage keys
    /// for the account. If you want to change the storage account keys, use the regenerate keys operation. The location and name
    /// of the storage account cannot be changed after creation.
    /// </summary>
    /// <remarks>
    /// [OpenAPI] Update=>PATCH:"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}"
    /// </remarks>
    [global::System.Management.Automation.Cmdlet(global::System.Management.Automation.VerbsData.Update, @"AzStorageAccount_UpdateExpanded", SupportsShouldProcess = true)]
    [global::System.Management.Automation.OutputType(typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IStorageAccount))]
    [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Description(@"The update operation can be used to update the SKU, encryption, access tier, or tags for a storage account. It can also be used to map the account to a custom domain. Only one custom domain is supported per storage account; the replacement/change of custom domain is not supported. In order to replace an old custom domain, the old value must be cleared/unregistered before a new value can be set. The update of multiple properties is supported. This call does not change the storage keys for the account. If you want to change the storage account keys, use the regenerate keys operation. The location and name of the storage account cannot be changed after creation.")]
    [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Generated]
    public partial class UpdateAzStorageAccount_UpdateExpanded : global::System.Management.Automation.PSCmdlet,
        Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener
    {
        /// <summary>A unique id generatd for the this cmdlet when it is instantiated.</summary>
        private string __correlationId = System.Guid.NewGuid().ToString();

        /// <summary>A copy of the Invocation Info (necessary to allow asJob to clone this cmdlet)</summary>
        private global::System.Management.Automation.InvocationInfo __invocationInfo;

        /// <summary>A unique id generatd for the this cmdlet when ProcessRecord() is called.</summary>
        private string __processRecordId;

        /// <summary>
        /// The <see cref="global::System.Threading.CancellationTokenSource" /> for this operation.
        /// </summary>
        private global::System.Threading.CancellationTokenSource _cancellationTokenSource = new global::System.Threading.CancellationTokenSource();

        /// <summary>
        /// The parameters that can be provided when updating the storage account properties.
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IStorageAccountUpdateParameters _parametersBody = new Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.StorageAccountUpdateParameters();

        /// <summary>
        /// Required for storage accounts where kind = BlobStorage. The access tier is used for billing. The 'Premium' access tier
        /// is the default value for premium block blobs storage account type and it cannot be changed for the premium block blobs
        /// storage account type.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Required for storage accounts where kind = BlobStorage. The access tier is used for billing. The 'Premium' access tier is the default value for premium block blobs storage account type and it cannot be changed for the premium block blobs storage account type.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Required for storage accounts where kind = BlobStorage. The access tier is used for billing. The 'Premium' access tier is the default value for premium block blobs storage account type and it cannot be changed for the premium block blobs storage account type.",
        SerializedName = @"accessTier",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.AccessTier) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.AccessTier))]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.AccessTier AccessTier { get => _parametersBody.AccessTier ?? ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.AccessTier)""); set => _parametersBody.AccessTier = value; }

        /// <summary>Backing field for <see cref="AccountName" /> property.</summary>
        private string _accountName;

        /// <summary>
        /// The name of the storage account within the specified resource group. Storage account names must be between 3 and 24 characters
        /// in length and use numbers and lower-case letters only.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The name of the storage account within the specified resource group. Storage account names must be between 3 and 24 characters in length and use numbers and lower-case letters only.")]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The name of the storage account within the specified resource group. Storage account names must be between 3 and 24 characters in length and use numbers and lower-case letters only.",
        SerializedName = @"accountName",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Path)]
        public string AccountName { get => this._accountName; set => this._accountName = value; }

        /// <summary>Specifies the Active Directory account type for Azure Storage.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the Active Directory account type for Azure Storage.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the Active Directory account type for Azure Storage.",
        SerializedName = @"accountType",
        PossibleTypes = new [] { typeof(string) })]
        public string ActiveDirectoryPropertyAccountType { get => _parametersBody.ActiveDirectoryPropertyAccountType ?? null; set => _parametersBody.ActiveDirectoryPropertyAccountType = value; }

        /// <summary>Specifies the security identifier (SID) for Azure Storage.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the security identifier (SID) for Azure Storage.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the security identifier (SID) for Azure Storage.",
        SerializedName = @"azureStorageSid",
        PossibleTypes = new [] { typeof(string) })]
        public string ActiveDirectoryPropertyAzureStorageSid { get => _parametersBody.ActiveDirectoryPropertyAzureStorageSid ?? null; set => _parametersBody.ActiveDirectoryPropertyAzureStorageSid = value; }

        /// <summary>Specifies the domain GUID.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the domain GUID.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the domain GUID.",
        SerializedName = @"domainGuid",
        PossibleTypes = new [] { typeof(string) })]
        public string ActiveDirectoryPropertyDomainGuid { get => _parametersBody.ActiveDirectoryPropertyDomainGuid ?? null; set => _parametersBody.ActiveDirectoryPropertyDomainGuid = value; }

        /// <summary>Specifies the primary domain that the AD DNS server is authoritative for.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the primary domain that the AD DNS server is authoritative for.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the primary domain that the AD DNS server is authoritative for.",
        SerializedName = @"domainName",
        PossibleTypes = new [] { typeof(string) })]
        public string ActiveDirectoryPropertyDomainName { get => _parametersBody.ActiveDirectoryPropertyDomainName ?? null; set => _parametersBody.ActiveDirectoryPropertyDomainName = value; }

        /// <summary>Specifies the security identifier (SID).</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the security identifier (SID).")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the security identifier (SID).",
        SerializedName = @"domainSid",
        PossibleTypes = new [] { typeof(string) })]
        public string ActiveDirectoryPropertyDomainSid { get => _parametersBody.ActiveDirectoryPropertyDomainSid ?? null; set => _parametersBody.ActiveDirectoryPropertyDomainSid = value; }

        /// <summary>Specifies the Active Directory forest to get.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the Active Directory forest to get.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the Active Directory forest to get.",
        SerializedName = @"forestName",
        PossibleTypes = new [] { typeof(string) })]
        public string ActiveDirectoryPropertyForestName { get => _parametersBody.ActiveDirectoryPropertyForestName ?? null; set => _parametersBody.ActiveDirectoryPropertyForestName = value; }

        /// <summary>Specifies the NetBIOS domain name.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the NetBIOS domain name.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the NetBIOS domain name.",
        SerializedName = @"netBiosDomainName",
        PossibleTypes = new [] { typeof(string) })]
        public string ActiveDirectoryPropertyNetBiosDomainName { get => _parametersBody.ActiveDirectoryPropertyNetBiosDomainName ?? null; set => _parametersBody.ActiveDirectoryPropertyNetBiosDomainName = value; }

        /// <summary>Specifies the Active Directory SAMAccountName for Azure Storage.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the Active Directory SAMAccountName for Azure Storage.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the Active Directory SAMAccountName for Azure Storage.",
        SerializedName = @"samAccountName",
        PossibleTypes = new [] { typeof(string) })]
        public string ActiveDirectoryPropertySamAccountName { get => _parametersBody.ActiveDirectoryPropertySamAccountName ?? null; set => _parametersBody.ActiveDirectoryPropertySamAccountName = value; }

        /// <summary>
        /// Allow or disallow public access to all blobs or containers in the storage account. The default interpretation is true
        /// for this property.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Allow or disallow public access to all blobs or containers in the storage account. The default interpretation is true for this property.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Allow or disallow public access to all blobs or containers in the storage account. The default interpretation is true for this property.",
        SerializedName = @"allowBlobPublicAccess",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AllowBlobPublicAccess { get => _parametersBody.AllowBlobPublicAccess ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.AllowBlobPublicAccess = value; }

        /// <summary>
        /// Allow or disallow cross AAD tenant object replication. The default interpretation is true for this property.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Allow or disallow cross AAD tenant object replication. The default interpretation is true for this property.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Allow or disallow cross AAD tenant object replication. The default interpretation is true for this property.",
        SerializedName = @"allowCrossTenantReplication",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AllowCrossTenantReplication { get => _parametersBody.AllowCrossTenantReplication ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.AllowCrossTenantReplication = value; }

        /// <summary>
        /// Indicates whether the storage account permits requests to be authorized with the account access key via Shared Key. If
        /// false, then all requests, including shared access signatures, must be authorized with Azure Active Directory (Azure AD).
        /// The default value is null, which is equivalent to true.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Indicates whether the storage account permits requests to be authorized with the account access key via Shared Key. If false, then all requests, including shared access signatures, must be authorized with Azure Active Directory (Azure AD). The default value is null, which is equivalent to true.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether the storage account permits requests to be authorized with the account access key via Shared Key. If false, then all requests, including shared access signatures, must be authorized with Azure Active Directory (Azure AD). The default value is null, which is equivalent to true.",
        SerializedName = @"allowSharedKeyAccess",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter AllowSharedKeyAccess { get => _parametersBody.AllowSharedKeyAccess ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.AllowSharedKeyAccess = value; }

        /// <summary>
        /// Restrict copy to and from Storage Accounts within an AAD tenant or with Private Links to the same VNet.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Restrict copy to and from Storage Accounts within an AAD tenant or with Private Links to the same VNet.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Restrict copy to and from Storage Accounts within an AAD tenant or with Private Links to the same VNet.",
        SerializedName = @"allowedCopyScope",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.AllowedCopyScope) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.AllowedCopyScope))]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.AllowedCopyScope AllowedCopyScope { get => _parametersBody.AllowedCopyScope ?? ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.AllowedCopyScope)""); set => _parametersBody.AllowedCopyScope = value; }

        /// <summary>
        /// Default share permission for users using Kerberos authentication if RBAC role is not assigned.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Default share permission for users using Kerberos authentication if RBAC role is not assigned.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Default share permission for users using Kerberos authentication if RBAC role is not assigned.",
        SerializedName = @"defaultSharePermission",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.DefaultSharePermission) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.DefaultSharePermission))]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.DefaultSharePermission AzureFileIdentityBasedAuthenticationDefaultSharePermission { get => _parametersBody.AzureFileIdentityBasedAuthenticationDefaultSharePermission ?? ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.DefaultSharePermission)""); set => _parametersBody.AzureFileIdentityBasedAuthenticationDefaultSharePermission = value; }

        /// <summary>Indicates the directory service used.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Indicates the directory service used.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates the directory service used.",
        SerializedName = @"directoryServiceOptions",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.DirectoryServiceOptions) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.DirectoryServiceOptions))]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.DirectoryServiceOptions AzureFileIdentityBasedAuthenticationDirectoryServiceOption { get => _parametersBody.AzureFileIdentityBasedAuthenticationDirectoryServiceOption ?? ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.DirectoryServiceOptions)""); set => _parametersBody.AzureFileIdentityBasedAuthenticationDirectoryServiceOption = value; }

        /// <summary>Wait for .NET debugger to attach</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Wait for .NET debugger to attach")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter Break { get; set; }

        /// <summary>The reference to the client API class.</summary>
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.StorageManagementClient Client => Microsoft.Azure.PowerShell.Cmdlets.Storage.Module.Instance.ClientAPI;

        /// <summary>
        /// Gets or sets the custom domain name assigned to the storage account. Name is the CNAME source.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Gets or sets the custom domain name assigned to the storage account. Name is the CNAME source.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets the custom domain name assigned to the storage account. Name is the CNAME source.",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(string) })]
        public string CustomDomainName { get => _parametersBody.CustomDomainName ?? null; set => _parametersBody.CustomDomainName = value; }

        /// <summary>
        /// Indicates whether indirect CName validation is enabled. Default value is false. This should only be set on updates.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Indicates whether indirect CName validation is enabled. Default value is false. This should only be set on updates.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Indicates whether indirect CName validation is enabled. Default value is false. This should only be set on updates.",
        SerializedName = @"useSubDomainName",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter CustomDomainUseSubDomainName { get => _parametersBody.CustomDomainUseSubDomainName ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.CustomDomainUseSubDomainName = value; }

        /// <summary>
        /// The credentials, account, tenant, and subscription used for communication with Azure
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The credentials, account, tenant, and subscription used for communication with Azure.")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::System.Management.Automation.Alias("AzureRMContext", "AzureCredential")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Azure)]
        public global::System.Management.Automation.PSObject DefaultProfile { get; set; }

        /// <summary>
        /// A boolean flag which indicates whether the default authentication is OAuth or not. The default interpretation is false
        /// for this property.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "A boolean flag which indicates whether the default authentication is OAuth or not. The default interpretation is false for this property.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A boolean flag which indicates whether the default authentication is OAuth or not. The default interpretation is false for this property.",
        SerializedName = @"defaultToOAuthAuthentication",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter DefaultToOAuthAuthentication { get => _parametersBody.DefaultToOAuthAuthentication ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.DefaultToOAuthAuthentication = value; }

        /// <summary>
        /// Allows you to specify the type of endpoint. Set this to AzureDNSZone to create a large number of accounts in a single
        /// subscription, which creates accounts in an Azure DNS Zone and the endpoint URL will have an alphanumeric DNS Zone identifier.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Allows you to specify the type of endpoint. Set this to AzureDNSZone to create a large number of accounts in a single subscription, which creates accounts in an Azure DNS Zone and the endpoint URL will have an alphanumeric DNS Zone identifier.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Allows you to specify the type of endpoint. Set this to AzureDNSZone to create a large number of accounts in a single subscription, which creates accounts in an Azure DNS Zone and the endpoint URL will have an alphanumeric DNS Zone identifier.",
        SerializedName = @"dnsEndpointType",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.DnsEndpointType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.DnsEndpointType))]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.DnsEndpointType DnsEndpointType { get => _parametersBody.DnsEndpointType ?? ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.DnsEndpointType)""); set => _parametersBody.DnsEndpointType = value; }

        /// <summary>Allows https traffic only to storage service if sets to true.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Allows https traffic only to storage service if sets to true.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Allows https traffic only to storage service if sets to true.",
        SerializedName = @"supportsHttpsTrafficOnly",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter EnableHttpsTrafficOnly { get => _parametersBody.EnableHttpsTrafficOnly ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.EnableHttpsTrafficOnly = value; }

        /// <summary>
        /// Not applicable. Azure Storage encryption at rest is enabled by default for all storage accounts and cannot be disabled.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Not applicable. Azure Storage encryption at rest is enabled by default for all storage accounts and cannot be disabled.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Not applicable. Azure Storage encryption at rest is enabled by default for all storage accounts and cannot be disabled.",
        SerializedName = @"encryption",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IEncryption) })]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IEncryption Encryption { get => _parametersBody.Encryption ?? null /* object */; set => _parametersBody.Encryption = value; }

        /// <summary>SendAsync Pipeline Steps to be appended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be appended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Runtime)]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.SendAsyncStep[] HttpPipelineAppend { get; set; }

        /// <summary>SendAsync Pipeline Steps to be prepended to the front of the pipeline</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "SendAsync Pipeline Steps to be prepended to the front of the pipeline")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Runtime)]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.SendAsyncStep[] HttpPipelinePrepend { get; set; }

        /// <summary>The identity type.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The identity type.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The identity type.",
        SerializedName = @"type",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.IdentityType) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.IdentityType))]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.IdentityType IdentityType { get => _parametersBody.IdentityType ?? ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.IdentityType)""); set => _parametersBody.IdentityType = value; }

        /// <summary>
        /// Gets or sets a list of key value pairs that describe the set of User Assigned identities that will be used with this storage
        /// account. The key is the ARM resource identifier of the identity. Only 1 User Assigned identity is permitted here.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ExportAs(typeof(global::System.Collections.Hashtable))]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Gets or sets a list of key value pairs that describe the set of User Assigned identities that will be used with this storage account. The key is the ARM resource identifier of the identity. Only 1 User Assigned identity is permitted here.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets a list of key value pairs that describe the set of User Assigned identities that will be used with this storage account. The key is the ARM resource identifier of the identity. Only 1 User Assigned identity is permitted here.",
        SerializedName = @"userAssignedIdentities",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IIdentityUserAssignedIdentities) })]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IIdentityUserAssignedIdentities IdentityUserAssignedIdentity { get => _parametersBody.IdentityUserAssignedIdentity ?? null /* object */; set => _parametersBody.IdentityUserAssignedIdentity = value; }

        /// <summary>
        /// This property can only be changed for disabled and unlocked time-based retention policies. When enabled, new blocks can
        /// be written to an append blob while maintaining immutability protection and compliance. Only new blocks can be added and
        /// any existing blocks cannot be modified or deleted.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "This property can only be changed for disabled and unlocked time-based retention policies. When enabled, new blocks can be written to an append blob while maintaining immutability protection and compliance. Only new blocks can be added and any existing blocks cannot be modified or deleted.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"This property can only be changed for disabled and unlocked time-based retention policies. When enabled, new blocks can be written to an append blob while maintaining immutability protection and compliance. Only new blocks can be added and any existing blocks cannot be modified or deleted.",
        SerializedName = @"allowProtectedAppendWrites",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter ImmutabilityPolicyAllowProtectedAppendWrite { get => _parametersBody.ImmutabilityPolicyAllowProtectedAppendWrite ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.ImmutabilityPolicyAllowProtectedAppendWrite = value; }

        /// <summary>
        /// The immutability period for the blobs in the container since the policy creation, in days.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The immutability period for the blobs in the container since the policy creation, in days.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The immutability period for the blobs in the container since the policy creation, in days.",
        SerializedName = @"immutabilityPeriodSinceCreationInDays",
        PossibleTypes = new [] { typeof(int) })]
        public int ImmutabilityPolicyImmutabilityPeriodSinceCreationInDay { get => _parametersBody.ImmutabilityPolicyImmutabilityPeriodSinceCreationInDay ?? default(int); set => _parametersBody.ImmutabilityPolicyImmutabilityPeriodSinceCreationInDay = value; }

        /// <summary>
        /// The ImmutabilityPolicy state defines the mode of the policy. Disabled state disables the policy, Unlocked state allows
        /// increase and decrease of immutability retention time and also allows toggling allowProtectedAppendWrites property, Locked
        /// state only allows the increase of the immutability retention time. A policy can only be created in a Disabled or Unlocked
        /// state and can be toggled between the two states. Only a policy in an Unlocked state can transition to a Locked state which
        /// cannot be reverted.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The ImmutabilityPolicy state defines the mode of the policy. Disabled state disables the policy, Unlocked state allows increase and decrease of immutability retention time and also allows toggling allowProtectedAppendWrites property, Locked state only allows the increase of the immutability retention time. A policy can only be created in a Disabled or Unlocked state and can be toggled between the two states. Only a policy in an Unlocked state can transition to a Locked state which cannot be reverted.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The ImmutabilityPolicy state defines the mode of the policy. Disabled state disables the policy, Unlocked state allows increase and decrease of immutability retention time and also allows toggling allowProtectedAppendWrites property, Locked state only allows the increase of the immutability retention time. A policy can only be created in a Disabled or Unlocked state and can be toggled between the two states. Only a policy in an Unlocked state can transition to a Locked state which cannot be reverted.",
        SerializedName = @"state",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.AccountImmutabilityPolicyState) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.AccountImmutabilityPolicyState))]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.AccountImmutabilityPolicyState ImmutabilityPolicyState { get => _parametersBody.ImmutabilityPolicyState ?? ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.AccountImmutabilityPolicyState)""); set => _parametersBody.ImmutabilityPolicyState = value; }

        /// <summary>
        /// A boolean flag which enables account-level immutability. All the containers under such an account have object-level immutability
        /// enabled by default.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "A boolean flag which enables account-level immutability. All the containers under such an account have object-level immutability enabled by default.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A boolean flag which enables account-level immutability. All the containers under such an account have object-level immutability enabled by default.",
        SerializedName = @"enabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter ImmutableStorageWithVersioningEnabled { get => _parametersBody.ImmutableStorageWithVersioningEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.ImmutableStorageWithVersioningEnabled = value; }

        /// <summary>Accessor for our copy of the InvocationInfo.</summary>
        public global::System.Management.Automation.InvocationInfo InvocationInformation { get => __invocationInfo = __invocationInfo ?? this.MyInvocation ; set { __invocationInfo = value; } }

        /// <summary>Enables local users feature, if set to true</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enables local users feature, if set to true")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enables local users feature, if set to true",
        SerializedName = @"isLocalUserEnabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter IsLocalUserEnabled { get => _parametersBody.IsLocalUserEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.IsLocalUserEnabled = value; }

        /// <summary>Enables Secure File Transfer Protocol, if set to true</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Enables Secure File Transfer Protocol, if set to true")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Enables Secure File Transfer Protocol, if set to true",
        SerializedName = @"isSftpEnabled",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter IsSftpEnabled { get => _parametersBody.IsSftpEnabled ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.IsSftpEnabled = value; }

        /// <summary>The key expiration period in days.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The key expiration period in days.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The key expiration period in days.",
        SerializedName = @"keyExpirationPeriodInDays",
        PossibleTypes = new [] { typeof(int) })]
        public int KeyPolicyKeyExpirationPeriodInDay { get => _parametersBody.KeyPolicyKeyExpirationPeriodInDay ?? default(int); set => _parametersBody.KeyPolicyKeyExpirationPeriodInDay = value; }

        /// <summary>
        /// Optional. Indicates the type of storage account. Currently only StorageV2 value supported by server.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Optional. Indicates the type of storage account. Currently only StorageV2 value supported by server.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Optional. Indicates the type of storage account. Currently only StorageV2 value supported by server.",
        SerializedName = @"kind",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.Kind) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.Kind))]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.Kind Kind { get => _parametersBody.Kind ?? ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.Kind)""); set => _parametersBody.Kind = value; }

        /// <summary>
        /// Allow large file shares if sets to Enabled. It cannot be disabled once it is enabled.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Allow large file shares if sets to Enabled. It cannot be disabled once it is enabled.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Allow large file shares if sets to Enabled. It cannot be disabled once it is enabled.",
        SerializedName = @"largeFileSharesState",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.LargeFileSharesState) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.LargeFileSharesState))]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.LargeFileSharesState LargeFileSharesState { get => _parametersBody.LargeFileSharesState ?? ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.LargeFileSharesState)""); set => _parametersBody.LargeFileSharesState = value; }

        /// <summary>
        /// <see cref="Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener" /> cancellation delegate. Stops the cmdlet when called.
        /// </summary>
        global::System.Action Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener.Cancel => _cancellationTokenSource.Cancel;

        /// <summary><see cref="Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener" /> cancellation token.</summary>
        global::System.Threading.CancellationToken Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener.Token => _cancellationTokenSource.Token;

        /// <summary>
        /// Set the minimum TLS version to be permitted on requests to storage. The default interpretation is TLS 1.0 for this property.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Set the minimum TLS version to be permitted on requests to storage. The default interpretation is TLS 1.0 for this property.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Set the minimum TLS version to be permitted on requests to storage. The default interpretation is TLS 1.0 for this property.",
        SerializedName = @"minimumTlsVersion",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.MinimumTlsVersion) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.MinimumTlsVersion))]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.MinimumTlsVersion MinimumTlsVersion { get => _parametersBody.MinimumTlsVersion ?? ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.MinimumTlsVersion)""); set => _parametersBody.MinimumTlsVersion = value; }

        /// <summary>
        /// Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Possible values are any combination of Logging|Metrics|AzureServices
        /// (For example, "Logging, Metrics"), or None to bypass none of those traffics.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Possible values are any combination of Logging|Metrics|AzureServices (For example, \"Logging, Metrics\"), or None to bypass none of those traffics.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Possible values are any combination of Logging|Metrics|AzureServices (For example, ""Logging, Metrics""), or None to bypass none of those traffics.",
        SerializedName = @"bypass",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.Bypass) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.Bypass))]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.Bypass NetworkRuleSetBypass { get => _parametersBody.NetworkRuleSetBypass ?? ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.Bypass)""); set => _parametersBody.NetworkRuleSetBypass = value; }

        /// <summary>Specifies the default action of allow or deny when no other rules match.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Specifies the default action of allow or deny when no other rules match.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Specifies the default action of allow or deny when no other rules match.",
        SerializedName = @"defaultAction",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.DefaultAction) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.DefaultAction))]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.DefaultAction NetworkRuleSetDefaultAction { get => _parametersBody.NetworkRuleSetDefaultAction ?? ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.DefaultAction)""); set => _parametersBody.NetworkRuleSetDefaultAction = value; }

        /// <summary>Sets the IP ACL rules</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Sets the IP ACL rules")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Sets the IP ACL rules",
        SerializedName = @"ipRules",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IIPRule) })]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IIPRule[] NetworkRuleSetIPRule { get => _parametersBody.NetworkRuleSetIPRule ?? null /* arrayOf */; set => _parametersBody.NetworkRuleSetIPRule = value; }

        /// <summary>Sets the resource access rules</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Sets the resource access rules")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Sets the resource access rules",
        SerializedName = @"resourceAccessRules",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IResourceAccessRule) })]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IResourceAccessRule[] NetworkRuleSetResourceAccessRule { get => _parametersBody.NetworkRuleSetResourceAccessRule ?? null /* arrayOf */; set => _parametersBody.NetworkRuleSetResourceAccessRule = value; }

        /// <summary>Sets the virtual network rules</summary>
        [global::System.Management.Automation.AllowEmptyCollection]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Sets the virtual network rules")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Sets the virtual network rules",
        SerializedName = @"virtualNetworkRules",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IVirtualNetworkRule) })]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IVirtualNetworkRule[] NetworkRuleSetVirtualNetworkRule { get => _parametersBody.NetworkRuleSetVirtualNetworkRule ?? null /* arrayOf */; set => _parametersBody.NetworkRuleSetVirtualNetworkRule = value; }

        /// <summary>
        /// The instance of the <see cref="Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.HttpPipeline" /> that the remote call will use.
        /// </summary>
        private Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.HttpPipeline Pipeline { get; set; }

        /// <summary>The URI for the proxy server to use</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "The URI for the proxy server to use")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Runtime)]
        public global::System.Uri Proxy { get; set; }

        /// <summary>Credentials for a proxy server to use for the remote call</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Credentials for a proxy server to use for the remote call")]
        [global::System.Management.Automation.ValidateNotNull]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Runtime)]
        public global::System.Management.Automation.PSCredential ProxyCredential { get; set; }

        /// <summary>Use the default credentials for the proxy</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, DontShow = true, HelpMessage = "Use the default credentials for the proxy")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Runtime)]
        public global::System.Management.Automation.SwitchParameter ProxyUseDefaultCredentials { get; set; }

        /// <summary>
        /// Allow or disallow public network access to Storage Account. Value is optional but if passed in, must be 'Enabled' or 'Disabled'.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Allow or disallow public network access to Storage Account. Value is optional but if passed in, must be 'Enabled' or 'Disabled'.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Allow or disallow public network access to Storage Account. Value is optional but if passed in, must be 'Enabled' or 'Disabled'.",
        SerializedName = @"publicNetworkAccess",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.PublicNetworkAccess) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.PublicNetworkAccess))]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.PublicNetworkAccess PublicNetworkAccess { get => _parametersBody.PublicNetworkAccess ?? ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.PublicNetworkAccess)""); set => _parametersBody.PublicNetworkAccess = value; }

        /// <summary>Backing field for <see cref="ResourceGroupName" /> property.</summary>
        private string _resourceGroupName;

        /// <summary>
        /// The name of the resource group within the user's subscription. The name is case insensitive.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The name of the resource group within the user's subscription. The name is case insensitive.")]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The name of the resource group within the user's subscription. The name is case insensitive.",
        SerializedName = @"resourceGroupName",
        PossibleTypes = new [] { typeof(string) })]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Path)]
        public string ResourceGroupName { get => this._resourceGroupName; set => this._resourceGroupName = value; }

        /// <summary>
        /// A boolean flag which indicates whether internet routing storage endpoints are to be published
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "A boolean flag which indicates whether internet routing storage endpoints are to be published")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A boolean flag which indicates whether internet routing storage endpoints are to be published",
        SerializedName = @"publishInternetEndpoints",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter RoutingPreferencePublishInternetEndpoint { get => _parametersBody.RoutingPreferencePublishInternetEndpoint ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.RoutingPreferencePublishInternetEndpoint = value; }

        /// <summary>
        /// A boolean flag which indicates whether microsoft routing storage endpoints are to be published
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "A boolean flag which indicates whether microsoft routing storage endpoints are to be published")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"A boolean flag which indicates whether microsoft routing storage endpoints are to be published",
        SerializedName = @"publishMicrosoftEndpoints",
        PossibleTypes = new [] { typeof(global::System.Management.Automation.SwitchParameter) })]
        public global::System.Management.Automation.SwitchParameter RoutingPreferencePublishMicrosoftEndpoint { get => _parametersBody.RoutingPreferencePublishMicrosoftEndpoint ?? default(global::System.Management.Automation.SwitchParameter); set => _parametersBody.RoutingPreferencePublishMicrosoftEndpoint = value; }

        /// <summary>Routing Choice defines the kind of network routing opted by the user.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Routing Choice defines the kind of network routing opted by the user.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Routing Choice defines the kind of network routing opted by the user.",
        SerializedName = @"routingChoice",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.RoutingChoice) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.RoutingChoice))]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.RoutingChoice RoutingPreferenceRoutingChoice { get => _parametersBody.RoutingPreferenceRoutingChoice ?? ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.RoutingChoice)""); set => _parametersBody.RoutingPreferenceRoutingChoice = value; }

        /// <summary>The SAS expiration period, DD.HH:MM:SS.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The SAS expiration period, DD.HH:MM:SS.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The SAS expiration period, DD.HH:MM:SS.",
        SerializedName = @"sasExpirationPeriod",
        PossibleTypes = new [] { typeof(string) })]
        public string SasPolicySasExpirationPeriod { get => _parametersBody.SasPolicySasExpirationPeriod ?? null; set => _parametersBody.SasPolicySasExpirationPeriod = value; }

        /// <summary>
        /// The SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called accountType.
        /// </summary>
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "The SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called accountType.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"The SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called accountType.",
        SerializedName = @"name",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.SkuName) })]
        [global::System.Management.Automation.ArgumentCompleter(typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.SkuName))]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.SkuName SkuName { get => _parametersBody.SkuName ?? ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Support.SkuName)""); set => _parametersBody.SkuName = value; }

        /// <summary>Backing field for <see cref="SubscriptionId" /> property.</summary>
        private string _subscriptionId;

        /// <summary>The ID of the target subscription.</summary>
        [global::System.Management.Automation.Parameter(Mandatory = true, HelpMessage = "The ID of the target subscription.")]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = true,
        ReadOnly = false,
        Description = @"The ID of the target subscription.",
        SerializedName = @"subscriptionId",
        PossibleTypes = new [] { typeof(string) })]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.DefaultInfo(
        Name = @"",
        Description =@"",
        Script = @"(Get-AzContext).Subscription.Id")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Path)]
        public string SubscriptionId { get => this._subscriptionId; set => this._subscriptionId = value; }

        /// <summary>
        /// Gets or sets a list of key value pairs that describe the resource. These tags can be used in viewing and grouping this
        /// resource (across resource groups). A maximum of 15 tags can be provided for a resource. Each tag must have a key no greater
        /// in length than 128 characters and a value no greater in length than 256 characters.
        /// </summary>
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ExportAs(typeof(global::System.Collections.Hashtable))]
        [global::System.Management.Automation.Parameter(Mandatory = false, HelpMessage = "Gets or sets a list of key value pairs that describe the resource. These tags can be used in viewing and grouping this resource (across resource groups). A maximum of 15 tags can be provided for a resource. Each tag must have a key no greater in length than 128 characters and a value no greater in length than 256 characters.")]
        [global::Microsoft.Azure.PowerShell.Cmdlets.Storage.Category(global::Microsoft.Azure.PowerShell.Cmdlets.Storage.ParameterCategory.Body)]
        [Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Info(
        Required = false,
        ReadOnly = false,
        Description = @"Gets or sets a list of key value pairs that describe the resource. These tags can be used in viewing and grouping this resource (across resource groups). A maximum of 15 tags can be provided for a resource. Each tag must have a key no greater in length than 128 characters and a value no greater in length than 256 characters.",
        SerializedName = @"tags",
        PossibleTypes = new [] { typeof(Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IStorageAccountUpdateParametersTags) })]
        public Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IStorageAccountUpdateParametersTags Tag { get => _parametersBody.Tag ?? null /* object */; set => _parametersBody.Tag = value; }

        /// <summary>
        /// <c>overrideOnOk</c> will be called before the regular onOk has been processed, allowing customization of what happens
        /// on that response. Implement this method in a partial class to enable this behavior
        /// </summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IStorageAccount"
        /// /> from the remote call</param>
        /// <param name="returnNow">/// Determines if the rest of the onOk method should be processed, or if the method should return
        /// immediately (set to true to skip further processing )</param>

        partial void overrideOnOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IStorageAccount> response, ref global::System.Threading.Tasks.Task<bool> returnNow);

        /// <summary>
        /// (overrides the default BeginProcessing method in global::System.Management.Automation.PSCmdlet)
        /// </summary>
        protected override void BeginProcessing()
        {
            var telemetryId = Microsoft.Azure.PowerShell.Cmdlets.Storage.Module.Instance.GetTelemetryId.Invoke();
            if (telemetryId != "" && telemetryId != "internal")
            {
                __correlationId = telemetryId;
            }
            Module.Instance.SetProxyConfiguration(Proxy, ProxyCredential, ProxyUseDefaultCredentials);
            if (Break)
            {
                Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.AttachDebugger.Break();
            }
            ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Events.CmdletBeginProcessing).Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
        }

        /// <summary>Performs clean-up after the command execution</summary>
        protected override void EndProcessing()
        {

        }

        /// <summary>Handles/Dispatches events during the call to the REST service.</summary>
        /// <param name="id">The message id</param>
        /// <param name="token">The message cancellation token. When this call is cancelled, this should be <c>true</c></param>
        /// <param name="messageData">Detailed message data for the message event.</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the message is completed.
        /// </returns>
         async global::System.Threading.Tasks.Task Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener.Signal(string id, global::System.Threading.CancellationToken token, global::System.Func<Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.EventData> messageData)
        {
            using( NoSynchronizationContext )
            {
                if (token.IsCancellationRequested)
                {
                    return ;
                }

                switch ( id )
                {
                    case Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Events.Verbose:
                    {
                        WriteVerbose($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Events.Warning:
                    {
                        WriteWarning($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Events.Information:
                    {
                        var data = messageData();
                        WriteInformation(data.Message, new string[]{});
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Events.Debug:
                    {
                        WriteDebug($"{(messageData().Message ?? global::System.String.Empty)}");
                        return ;
                    }
                    case Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Events.Error:
                    {
                        WriteError(new global::System.Management.Automation.ErrorRecord( new global::System.Exception(messageData().Message), string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null ) );
                        return ;
                    }
                }
                await Microsoft.Azure.PowerShell.Cmdlets.Storage.Module.Instance.Signal(id, token, messageData, (i,t,m) => ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Signal(i,t,()=> Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.EventDataConverter.ConvertFrom( m() ) as Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.EventData ), InvocationInformation, this.ParameterSetName, __correlationId, __processRecordId, null );
                if (token.IsCancellationRequested)
                {
                    return ;
                }
                WriteDebug($"{id}: {(messageData().Message ?? global::System.String.Empty)}");
            }
        }

        /// <summary>Performs execution of the command.</summary>
        protected override void ProcessRecord()
        {
            ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Events.CmdletProcessRecordStart).Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
            __processRecordId = System.Guid.NewGuid().ToString();
            try
            {
                // work
                if (ShouldProcess($"Call remote 'StorageAccountsUpdate' operation"))
                {
                    using( var asyncCommandRuntime = new Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.PowerShell.AsyncCommandRuntime(this, ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Token) )
                    {
                        asyncCommandRuntime.Wait( ProcessRecordAsync(),((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Token);
                    }
                }
            }
            catch (global::System.AggregateException aggregateException)
            {
                // unroll the inner exceptions to get the root cause
                foreach( var innerException in aggregateException.Flatten().InnerExceptions )
                {
                    ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Events.CmdletException, $"{innerException.GetType().Name} - {innerException.Message} : {innerException.StackTrace}").Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    // Write exception out to error channel.
                    WriteError( new global::System.Management.Automation.ErrorRecord(innerException,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
                }
            }
            catch (global::System.Exception exception) when ((exception as System.Management.Automation.PipelineStoppedException)== null || (exception as System.Management.Automation.PipelineStoppedException).InnerException != null)
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Events.CmdletException, $"{exception.GetType().Name} - {exception.Message} : {exception.StackTrace}").Wait(); if( ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                // Write exception out to error channel.
                WriteError( new global::System.Management.Automation.ErrorRecord(exception,string.Empty, global::System.Management.Automation.ErrorCategory.NotSpecified, null) );
            }
            finally
            {
                ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Events.CmdletProcessRecordEnd).Wait();
            }
        }

        /// <summary>Performs execution of the command, working asynchronously if required.</summary>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        protected async global::System.Threading.Tasks.Task ProcessRecordAsync()
        {
            using( NoSynchronizationContext )
            {
                await ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Events.CmdletGetPipeline); if( ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                Pipeline = Microsoft.Azure.PowerShell.Cmdlets.Storage.Module.Instance.CreatePipeline(InvocationInformation, __correlationId, __processRecordId, this.ParameterSetName);
                if (null != HttpPipelinePrepend)
                {
                    Pipeline.Prepend((this.CommandRuntime as Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelinePrepend) ?? HttpPipelinePrepend);
                }
                if (null != HttpPipelineAppend)
                {
                    Pipeline.Append((this.CommandRuntime as Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.PowerShell.IAsyncCommandRuntimeExtensions)?.Wrap(HttpPipelineAppend) ?? HttpPipelineAppend);
                }
                // get the client instance
                try
                {
                    await ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Events.CmdletBeforeAPICall); if( ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                    await this.Client.StorageAccountsUpdate(ResourceGroupName, AccountName, SubscriptionId, _parametersBody, onOk, this, Pipeline);
                    await ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Events.CmdletAfterAPICall); if( ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Token.IsCancellationRequested ) { return; }
                }
                catch (Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.UndeclaredResponseException urexception)
                {
                    WriteError(new global::System.Management.Automation.ErrorRecord(urexception, urexception.StatusCode.ToString(), global::System.Management.Automation.ErrorCategory.InvalidOperation, new {  ResourceGroupName=ResourceGroupName,AccountName=AccountName,SubscriptionId=SubscriptionId,body=_parametersBody})
                    {
                      ErrorDetails = new global::System.Management.Automation.ErrorDetails(urexception.Message) { RecommendedAction = urexception.Action }
                    });
                }
                finally
                {
                    await ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Signal(Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.Events.CmdletProcessRecordAsyncEnd);
                }
            }
        }

        /// <summary>Interrupts currently running code within the command.</summary>
        protected override void StopProcessing()
        {
            ((Microsoft.Azure.PowerShell.Cmdlets.Storage.Runtime.IEventListener)this).Cancel();
            base.StopProcessing();
        }

        /// <summary>
        /// Intializes a new instance of the <see cref="UpdateAzStorageAccount_UpdateExpanded" /> cmdlet class.
        /// </summary>
        public UpdateAzStorageAccount_UpdateExpanded()
        {

        }

        /// <summary>a delegate that is called when the remote service returns 200 (OK).</summary>
        /// <param name="responseMessage">the raw response message as an global::System.Net.Http.HttpResponseMessage.</param>
        /// <param name="response">the body result as a <see cref="Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IStorageAccount"
        /// /> from the remote call</param>
        /// <returns>
        /// A <see cref="global::System.Threading.Tasks.Task" /> that will be complete when handling of the method is completed.
        /// </returns>
        private async global::System.Threading.Tasks.Task onOk(global::System.Net.Http.HttpResponseMessage responseMessage, global::System.Threading.Tasks.Task<Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IStorageAccount> response)
        {
            using( NoSynchronizationContext )
            {
                var _returnNow = global::System.Threading.Tasks.Task<bool>.FromResult(false);
                overrideOnOk(responseMessage, response, ref _returnNow);
                // if overrideOnOk has returned true, then return right away.
                if ((null != _returnNow && await _returnNow))
                {
                    return ;
                }
                // onOk - response for 200 / application/json
                // (await response) // should be Microsoft.Azure.PowerShell.Cmdlets.Storage.Models.Api20210901.IStorageAccount
                WriteObject((await response));
            }
        }
    }
}